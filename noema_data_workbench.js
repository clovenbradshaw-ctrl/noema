/**
 * Noema - Data Workbench
 * Airtable-style data management with EO sync principles
 *
 * Core Concepts (Nine Rules-Compliant Hierarchy):
 * - Workspaces: Contextual boundaries (broadest horizon)
 * - Sets: Typed data collections with schema
 * - Lenses: Type-scoped subsets of Sets (with their own refined schemas)
 * - Views: Display configurations (Grid, Cards, Kanban, Timeline, Calendar, Graph)
 * - Focuses: Filtered/restricted views
 * - Exports: Immutable frozen captures (downloaded and recorded)
 *
 * EO Integration:
 * - All views are MEANT events (Rule 1: interpretations)
 * - All access mediated through horizons (Rule 4)
 * - Focuses can only restrict, never expand (Rule 5)
 * - Full provenance tracking for all changes (Rule 7)
 * - Views are superseded, never deleted (Rule 9)
 */

// ============================================================================
// Field Types
// ============================================================================

const FieldTypes = Object.freeze({
  TEXT: 'text',
  LONG_TEXT: 'longText',
  NUMBER: 'number',
  SELECT: 'select',
  MULTI_SELECT: 'multiSelect',
  DATE: 'date',
  CHECKBOX: 'checkbox',
  LINK: 'link',
  ATTACHMENT: 'attachment',
  URL: 'url',
  EMAIL: 'email',
  PHONE: 'phone',
  FORMULA: 'formula',
  ROLLUP: 'rollup',
  COUNT: 'count',
  AUTONUMBER: 'autonumber',
  JSON: 'json'
});

const FieldTypeIcons = {
  [FieldTypes.TEXT]: 'ph-text-aa',
  [FieldTypes.LONG_TEXT]: 'ph-text-align-left',
  [FieldTypes.NUMBER]: 'ph-hash',
  [FieldTypes.SELECT]: 'ph-list-bullets',
  [FieldTypes.MULTI_SELECT]: 'ph-list-checks',
  [FieldTypes.DATE]: 'ph-calendar',
  [FieldTypes.CHECKBOX]: 'ph-check-square',
  [FieldTypes.LINK]: 'ph-link',
  [FieldTypes.ATTACHMENT]: 'ph-paperclip',
  [FieldTypes.URL]: 'ph-globe',
  [FieldTypes.EMAIL]: 'ph-envelope',
  [FieldTypes.PHONE]: 'ph-phone',
  [FieldTypes.FORMULA]: 'ph-function',
  [FieldTypes.ROLLUP]: 'ph-sigma',
  [FieldTypes.COUNT]: 'ph-number-circle-one',
  [FieldTypes.AUTONUMBER]: 'ph-number-square-one',
  [FieldTypes.JSON]: 'ph-brackets-curly'
};

// Display names for field types (used for auto-naming new fields)
const FieldTypeDisplayNames = {
  [FieldTypes.TEXT]: 'Text',
  [FieldTypes.LONG_TEXT]: 'Long text',
  [FieldTypes.NUMBER]: 'Number',
  [FieldTypes.SELECT]: 'Select',
  [FieldTypes.MULTI_SELECT]: 'Multi-select',
  [FieldTypes.DATE]: 'Date',
  [FieldTypes.CHECKBOX]: 'Checkbox',
  [FieldTypes.LINK]: 'Link',
  [FieldTypes.ATTACHMENT]: 'Attachment',
  [FieldTypes.URL]: 'URL',
  [FieldTypes.EMAIL]: 'Email',
  [FieldTypes.PHONE]: 'Phone',
  [FieldTypes.FORMULA]: 'Formula',
  [FieldTypes.ROLLUP]: 'Rollup',
  [FieldTypes.COUNT]: 'Count',
  [FieldTypes.AUTONUMBER]: 'Autonumber',
  [FieldTypes.JSON]: 'JSON'
};

const SelectColors = ['blue', 'green', 'yellow', 'red', 'purple', 'pink', 'orange', 'gray'];

// ============================================================================
// Field Name Utilities
// ============================================================================

/**
 * Convert a display name to camelCase.
 * Used for creating formula-referenceable field names.
 *
 * Examples:
 *   "First Name" -> "firstName"
 *   "Total Sales Amount" -> "totalSalesAmount"
 *   "email" -> "email"
 *   "ID" -> "id"
 *   "SSN Number" -> "ssnNumber"
 *   "Due Date" -> "dueDate"
 *
 * @param {string} displayName - The display name to convert
 * @returns {string} - The camelCase version
 */
function toCamelCase(displayName) {
  if (!displayName || typeof displayName !== 'string') return '';

  // Split on spaces, hyphens, underscores, and camelCase boundaries
  const words = displayName
    .trim()
    .replace(/([a-z])([A-Z])/g, '$1 $2') // Split camelCase
    .replace(/[_\-]+/g, ' ')              // Replace underscores/hyphens with spaces
    .split(/\s+/)                          // Split on whitespace
    .filter(word => word.length > 0);

  if (words.length === 0) return '';

  // First word is lowercase, rest are title case
  return words.map((word, index) => {
    const lower = word.toLowerCase();
    if (index === 0) {
      return lower;
    }
    return lower.charAt(0).toUpperCase() + lower.slice(1);
  }).join('');
}

/**
 * Check if a field name is a single word (can be cited without brackets).
 *
 * @param {string} name - The field display name
 * @returns {boolean} - True if single word
 */
function isSingleWordFieldName(name) {
  if (!name || typeof name !== 'string') return false;
  return !/\s/.test(name.trim());
}

/**
 * Get the formula reference syntax for a field.
 *
 * Citation rules:
 * - Single word display names: can use the name directly without brackets
 * - Multi-word display names: require {brackets}
 * - CamelCase name: always works without brackets
 *
 * @param {Object} field - The field object
 * @returns {{ displayRef: string, camelRef: string, needsBrackets: boolean }}
 */
function getFieldReferenceSyntax(field) {
  if (!field || !field.name) return { displayRef: '', camelRef: '', needsBrackets: true };

  const name = field.name;
  const camelName = field.camelCaseName || toCamelCase(name);
  const needsBrackets = !isSingleWordFieldName(name);

  return {
    displayRef: needsBrackets ? `{${name}}` : name,
    camelRef: camelName,
    needsBrackets
  };
}

// Export for use in other modules
if (typeof window !== 'undefined') {
  window.toCamelCase = toCamelCase;
  window.isSingleWordFieldName = isSingleWordFieldName;
  window.getFieldReferenceSyntax = getFieldReferenceSyntax;
}

// ============================================================================
// TABLE RENDERING RULES - NEVER VIOLATE THESE
// ============================================================================
//
// RULE 1: Every field MUST have a valid numeric width (minimum 80px, default 200px)
//         - Invalid or undefined widths render as "undefinedpx" breaking layout
//         - Always use ensureValidField() before rendering
//
// RULE 2: Every cell MUST have a td element for every field in the header
//         - Missing cells break column alignment and borders
//         - Empty values should show placeholder content, not skip cells
//
// RULE 3: Every field MUST have a valid id, name, and type
//         - Missing id causes record.values lookup failures
//         - Missing type defaults to TEXT for safe fallback
//
// RULE 4: Table layout MUST be consistent
//         - Use table-layout: fixed for predictable widths
//         - Always set explicit widths on th elements
//         - All borders come from CSS, never inline styles
//
// RULE 5: Field IDs MUST be consistent between set.fields and record.values
//         - Every key in record.values must exist as a field.id in set.fields
//         - When merging/copying sets, ALWAYS remap record values to new field IDs
//         - Use _mergeSetsWithIdRemapping() for set merges, not _mergeSchemas() alone
//         - Use validateFieldIdConsistency() to check for mismatches
//
// ============================================================================

// Field default/minimum values
const FIELD_MIN_WIDTH = 80;
const FIELD_DEFAULT_WIDTH = 200;
const FIELD_DEFAULT_TYPE = 'text';

/**
 * Ensure a field has all required properties for rendering.
 * This is the single source of truth for field validation.
 * ALWAYS call this before rendering a field.
 *
 * @param {Object} field - The field to validate
 * @returns {Object} - A field with guaranteed valid properties
 */
function ensureValidField(field) {
  if (!field) return null;

  const name = field.name || 'Untitled';
  return {
    ...field,
    id: field.id || generateId(),
    name: name,
    // CamelCase version for formula references (always works without brackets)
    camelCaseName: field.camelCaseName || toCamelCase(name),
    type: field.type || FIELD_DEFAULT_TYPE,
    width: Math.max(FIELD_MIN_WIDTH, Number(field.width) || FIELD_DEFAULT_WIDTH),
    isPrimary: field.isPrimary || false,
    options: field.options || {}
  };
}

/**
 * Ensure all fields in an array are valid for rendering.
 *
 * @param {Array} fields - Array of fields to validate
 * @returns {Array} - Array of validated fields (invalid entries filtered out)
 */
function ensureValidFields(fields) {
  if (!Array.isArray(fields)) return [];
  return fields.map(ensureValidField).filter(Boolean);
}

/**
 * Ensure a record has values for all fields.
 * Missing field values are set to null (not undefined).
 *
 * @param {Object} record - The record to validate
 * @param {Array} fields - The fields that should have values
 * @returns {Object} - Record with guaranteed values object
 */
function ensureRecordValues(record, fields) {
  if (!record) return null;

  const values = { ...(record.values || {}) };

  // Ensure every field has a value entry (null is valid, undefined is not)
  for (const field of fields) {
    if (!(field.id in values)) {
      values[field.id] = null;
    }
  }

  return {
    ...record,
    values
  };
}

/**
 * Validate that field IDs in set.fields match keys in record.values (TABLE RULE 5).
 *
 * This function checks for consistency between field definitions and record values.
 * Call this to diagnose column alignment issues.
 *
 * @param {Object} set - The set to validate
 * @returns {{ isValid: boolean, issues: Array }} - Validation result with list of issues
 */
function validateFieldIdConsistency(set) {
  const issues = [];

  if (!set || !set.fields || !set.records) {
    return { isValid: true, issues };
  }

  const fieldIds = new Set(set.fields.map(f => f.id));
  const fieldNameById = new Map(set.fields.map(f => [f.id, f.name]));

  for (const record of set.records) {
    if (!record.values) continue;

    const recordValueKeys = Object.keys(record.values);

    // Check for record keys that don't match any field ID
    for (const key of recordValueKeys) {
      if (!fieldIds.has(key)) {
        issues.push({
          type: 'orphaned_value',
          recordId: record.id,
          fieldKey: key,
          value: record.values[key],
          message: `Record ${record.id} has value for field ID "${key}" which doesn't exist in set.fields`
        });
      }
    }

    // Check for fields that have no value in this record (warning, not error)
    for (const fieldId of fieldIds) {
      if (!(fieldId in record.values)) {
        // This is less severe - just means the record doesn't have a value for this field
        // The ensureRecordValues function should handle this at render time
      }
    }
  }

  // Log issues for debugging
  if (issues.length > 0) {
    console.warn(`[RULE 5 VIOLATION] Set "${set.name}" has ${issues.length} field ID consistency issues:`, issues);
  }

  return {
    isValid: issues.length === 0,
    issues
  };
}

/**
 * Attempt to repair field ID consistency issues in a set.
 *
 * This function tries to match orphaned record values to fields by name similarity
 * or position. Use with caution - data could be lost if matching fails.
 *
 * @param {Object} set - The set to repair
 * @returns {{ repaired: boolean, changes: Array }} - Repair result
 */
function repairFieldIdConsistency(set) {
  const changes = [];

  if (!set || !set.fields || !set.records) {
    return { repaired: false, changes };
  }

  const fieldIds = new Set(set.fields.map(f => f.id));
  const fieldByName = new Map(set.fields.map(f => [f.name.toLowerCase(), f]));

  for (const record of set.records) {
    if (!record.values) continue;

    const newValues = {};
    let hasChanges = false;

    for (const [key, value] of Object.entries(record.values)) {
      if (fieldIds.has(key)) {
        // Key is valid, keep it
        newValues[key] = value;
      } else {
        // Key doesn't match any field ID - try to find matching field by name
        // This handles cases where the key IS the field name (common mistake)
        const matchingField = fieldByName.get(key.toLowerCase());
        if (matchingField) {
          newValues[matchingField.id] = value;
          changes.push({
            recordId: record.id,
            oldKey: key,
            newKey: matchingField.id,
            fieldName: matchingField.name,
            value
          });
          hasChanges = true;
        } else {
          // No match found - drop the value (or could keep it with warning)
          changes.push({
            recordId: record.id,
            oldKey: key,
            newKey: null,
            fieldName: null,
            value,
            dropped: true
          });
          hasChanges = true;
        }
      }
    }

    if (hasChanges) {
      record.values = newValues;
    }
  }

  if (changes.length > 0) {
    console.log(`[RULE 5 REPAIR] Repaired ${changes.length} field ID issues in set "${set.name}":`, changes);
  }

  return {
    repaired: changes.length > 0,
    changes
  };
}

// ============================================================================
// Data Model
// ============================================================================

/**
 * Generate a unique ID
 */
function generateId() {
  return 'id_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
}

/**
 * Create a new Set (table/collection)
 *
 * Per CORE_ARCHITECTURE.md:
 * - A Set always binds to at least one Source
 * - Sets have typed schema with optional semantic bindings
 * - When created, auto-creates default Lens and View
 *
 * @param {string} name - Set name
 * @param {string} icon - Icon class
 * @param {Object} options - Additional options
 * @param {string} options.sourceId - Source ID for sourceBindings (optional for scratch sets)
 * @param {string} options.sourceType - 'file', 'api', 'scrape', or 'null'
 */
function createSet(name, icon = 'ph-table', options = {}) {
  const setId = generateId();
  const { sourceId = null, sourceType = 'null' } = options;

  return {
    id: setId,
    name,
    icon,
    // CORE_ARCHITECTURE.md: A Set always binds to at least one Source
    // sourceBindings: [{ sourceId: "src_001", mapping: "direct" }]
    sourceBindings: sourceId ? [{ sourceId, mapping: 'direct' }] : [],
    fields: [
      createField('Name', FieldTypes.TEXT, { isPrimary: true })
    ],
    records: [],
    views: [
      createView('All Records', 'table')
    ],
    lenses: [], // Lenses are sub-objects of sets, pivoted around a particular field
    // Display name field - defaults to first column if null
    displayNameFieldId: null,
    // Dataset provenance for tracking origin
    datasetProvenance: {
      origin: sourceType === 'null' ? 'scratch' : 'import',
      sourceType: sourceType
    },
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  };
}

/**
 * Create a new Lens (sub-object of a set pivoted around a field value)
 * Lenses filter records by a field value and can have their own views
 */
function createLens(name, setId, pivotFieldId, pivotValue, icon = 'ph-funnel') {
  return {
    id: generateId(),
    name,
    setId,
    icon,
    pivotFieldId,  // The field to pivot on
    pivotValue,    // The value to filter by
    views: [
      createView('All Records', 'table')
    ],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  };
}

/**
 * Create a new Field
 *
 * Per CORE_ARCHITECTURE.md:
 * - Fields can have semanticBinding to Definition terms for semantic grounding
 * - semanticBinding: { definitionId: string, termId: string|null }
 */
function createField(name, type, options = {}) {
  const field = {
    id: generateId(),
    name,
    // CamelCase version for formula references (always works without brackets)
    camelCaseName: toCamelCase(name),
    type,
    width: options.width || 200,
    isPrimary: options.isPrimary || false,
    // CORE_ARCHITECTURE.md: Optional semantic binding to Definition term
    // semanticBinding: { definitionId: "def_schema_org", termId: "Organization" }
    semanticBinding: options.semanticBinding || null,
    options: {}
  };

  // Type-specific options
  switch (type) {
    case FieldTypes.SELECT:
    case FieldTypes.MULTI_SELECT:
      field.options.choices = options.choices || [];
      break;
    case FieldTypes.NUMBER:
      field.options.precision = options.precision ?? 0;
      field.options.format = options.format || 'number'; // number, currency, percent
      break;
    case FieldTypes.DATE:
      field.options.includeTime = options.includeTime || false;
      field.options.dateFormat = options.dateFormat || 'local'; // local, friendly, us, european, iso
      field.options.timeFormat = options.timeFormat || '12h'; // 12h, 24h
      break;
    case FieldTypes.LINK:
      field.options.linkedSetId = options.linkedSetId || null;
      field.options.linkedViewId = options.linkedViewId || null; // Optional: link to a specific view within the set
      field.options.linkedFieldId = options.linkedFieldId || null; // Which field in target set to use for linking (null = primary field)
      field.options.allowMultiple = options.allowMultiple || false;
      // Edge data fields - allows storing data on the relationship itself
      // edgeFields is an array of field definitions: [{id, name, type, options}]
      field.options.edgeFields = options.edgeFields || [];
      // enableEdgeData indicates whether edge data is enabled (creates edge lens)
      field.options.enableEdgeData = options.enableEdgeData || false;
      break;
    case FieldTypes.ATTACHMENT:
      field.options.maxFiles = options.maxFiles || null; // null = unlimited
      break;
    case FieldTypes.PHONE:
      field.options.defaultCountry = options.defaultCountry || 'US';
      break;
    case FieldTypes.FORMULA:
      field.options.formula = options.formula || '';
      field.options.resultType = options.resultType || 'text'; // text, number, date, checkbox
      break;
    case FieldTypes.ROLLUP:
      field.options.linkedFieldId = options.linkedFieldId || null;
      field.options.rollupFieldId = options.rollupFieldId || null;
      field.options.aggregation = options.aggregation || 'SUM'; // SUM, AVG, MIN, MAX, COUNT, COUNTA, etc.
      break;
    case FieldTypes.COUNT:
      field.options.linkedFieldId = options.linkedFieldId || null;
      break;
    case FieldTypes.AUTONUMBER:
      field.options.prefix = options.prefix || '';
      field.options.startValue = options.startValue ?? 1;
      break;
    case FieldTypes.JSON:
      // displayMode: 'keyValue' (default) shows elegant key-value pairs
      // displayMode: 'raw' shows the raw JSON string
      field.options.displayMode = options.displayMode || 'keyValue';
      break;
  }

  return field;
}

/**
 * Create a new View
 * @param {string} name - View name
 * @param {string} type - View type (table, cards, kanban, calendar, graph)
 * @param {Object} config - View configuration
 * @param {Object} metadata - Optional metadata (recordType, recordCount, icon, etc.)
 */
function createView(name, type, config = {}, metadata = null) {
  const view = {
    id: generateId(),
    name,
    type, // table, cards, kanban, calendar, graph
    config: {
      filters: config.filters || [],
      sorts: config.sorts || [],
      groups: config.groups || [],
      hiddenFields: config.hiddenFields || [],
      fieldOrder: config.fieldOrder || [],
      // View-specific config
      ...config
    },
    createdAt: new Date().toISOString()
  };

  // Add metadata if provided (for record type views, etc.)
  if (metadata) {
    view.metadata = metadata;
  }

  return view;
}

/**
 * Create a new Record
 */
function createRecord(setId, values = {}) {
  return {
    id: generateId(),
    setId,
    values,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  };
}

// ============================================================================
// Data Workbench Class
// ============================================================================

class EODataWorkbench {
  constructor(container) {
    this.container = typeof container === 'string'
      ? document.getElementById(container)
      : container;

    // View Hierarchy (Nine Rules-Compliant)
    this.viewRegistry = null;

    // Legacy State (for backward compatibility)
    this.projects = []; // Projects are super objects containing sources, sets, definitions, exports
    this.sets = [];
    this.sources = []; // CRITICAL: Initialize sources array for imports
    this.definitions = []; // Definition schemas for columns/keys from URIs
    this.exports = []; // Immutable frozen captures (downloads and records)
    this.currentProjectId = null; // Track the currently selected project
    this.currentSetId = null;
    this.currentViewId = null;
    this.currentSourceId = null; // Track when viewing a source (GIVEN data)
    this.currentDefinitionId = null; // Track when viewing a definition (TERMS)
    this.currentExportId = null; // Track when viewing an export (SNAPSHOT)
    this.isViewingDefinitions = false; // Track when viewing definitions tab
    this.showingSetFields = false; // Track when showing set fields panel (like Airtable's "Manage Fields")
    this.showingSetDetail = false; // Track when showing set detail view (Input → Transformation → Output)
    this._previousLayerType = null; // Track previous layer type for detecting layer switches
    this._layerSwitchBannerTimeout = null; // Timer for auto-hiding layer switch banner
    this.lastViewPerSet = {}; // Remember last active view for each set
    this.expandedSets = {}; // Track which sets are expanded in sidebar
    this.expandedDefinitions = {}; // Track which definitions are expanded in sidebar
    this.currentSetTagFilter = null; // Filter sets by tag in header
    this.selectedRecords = new Set();
    this.editingCell = null;
    this.clipboard = null;

    // Undo/Redo Stack
    this.undoStack = [];
    this.redoStack = [];
    this.maxUndoStackSize = 50;

    // Hierarchy State
    this.currentWorkspaceId = null;
    this.currentLensId = null;
    this.currentFocusId = null;

    // UI References
    this.elements = {};

    // EO Integration
    this.eventBus = null;
    this.eoApp = null;

    // Formula Engine - Pipeline-based formula evaluation
    this.formulaEngine = null;
    this._initFormulaEngine();

    // Event handlers
    this._handlers = {};

    // Chunked loading state - Performance optimized
    this.displayedRecordCount = 0;
    this.initialBatchSize = 25; // Smaller initial batch for fast first paint
    this.recordBatchSize = 50; // Number of records to load per subsequent batch
    this.loadingThreshold = 20; // Show loading indicator when records exceed this

    // Lazy loading - defer loading records for non-current sets
    this._useLazyLoading = true;
    this._fullSetData = null;

    // View search state
    this.viewSearchTerm = '';

    // Calendar navigation state
    this.calendarDate = new Date();

    // Panel view modes (list vs table)
    this.projectsViewMode = 'list'; // 'list' or 'table'
    this.sourcesViewMode = 'list'; // 'list' or 'table'
    this.setsViewMode = 'list'; // 'list' or 'table'
    this.definitionsViewMode = 'list'; // 'list' or 'table'
    this.exportsViewMode = 'list'; // 'list' or 'table'

    // File Explorer state
    this.fileExplorerMode = false; // Whether file explorer is active
    this.fileExplorerViewMode = 'list'; // 'tree', 'list', 'grid'
    this.fileExplorerContentMode = 'sources'; // 'sources' or 'sets' - what type of items to show
    this.fileExplorerCurrentFolder = null; // Current folder ID (null = root)
    this.fileExplorerSelectedSource = null; // Currently selected source for preview
    this.fileExplorerSelectedSet = null; // Currently selected set for preview
    this.fileExplorerSearchTerm = ''; // Search filter
    this.fileExplorerActiveFilter = 'smart_all'; // Active smart folder or tag filter
    this.fileExplorerExpandedFolders = new Set(); // Track expanded folders in tree view
    this.fileExplorerSelectedSources = new Set(); // Track multi-selected sources for batch operations
    this.fileExplorerSelectedSets = new Set(); // Track multi-selected sets for batch operations
    this.collapsedTableGroups = new Set(); // Track collapsed groups in grouped table view

    // Browser-Style Tab Manager - Everything is a tab like Chrome
    this.browserTabs = []; // Array of all open tabs
    this.activeTabId = null; // Currently active tab

    // Panel Tabs - For set detail view (overview, fields, source tabs)
    this.panelTabs = [];
    this.activePanelTabId = null;
    this.tabHistory = []; // Navigation history for back/forward
    this.recentlyClosedTabs = []; // For "Reopen closed tab" feature (max 10)

    // Tab types - like Chrome's chrome://settings, chrome://history, etc.
    this.tabTypes = {
      // Content tabs (can have multiple instances)
      set: { singleton: false, icon: 'ph-table' },
      source: { singleton: false, icon: 'ph-file-csv' },
      view: { singleton: false, icon: 'ph-table' }, // Individual view tabs (keyed by setId + viewId)
      schema: { singleton: false, icon: 'ph-list-checks', label: 'Schema' }, // Schema/fields tab per set
      lens: { singleton: false, icon: 'ph-funnel', label: 'Lens' }, // Lens tabs

      // Singleton tabs (only one instance each, like chrome://settings)
      sources: { singleton: true, label: 'Sources', icon: 'ph-download-simple' },
      sets: { singleton: true, label: 'Sets', icon: 'ph-database' },
      definitions: { singleton: true, label: 'Definitions', icon: 'ph-book-open' },
      settings: { singleton: true, label: 'Settings', icon: 'ph-gear' },
      activity: { singleton: true, label: 'Activity', icon: 'ph-clock-counter-clockwise' },
      shortcuts: { singleton: true, label: 'Shortcuts', icon: 'ph-keyboard' },
      newTab: { singleton: true, label: 'New Tab', icon: 'ph-plus' }
    };

    // Panel tab types - for set detail view panels (overview, fields, source, etc.)
    this.panelTabTypes = {
      overview: { id: 'overview', label: 'Overview', icon: 'ph-chart-bar', singleton: true },
      source: { id: 'source', label: 'Source', icon: 'ph-file-csv', singleton: true },
      transforms: { id: 'transforms', label: 'Transforms', icon: 'ph-shuffle', singleton: true },
      definitions: { id: 'definitions', label: 'Definitions', icon: 'ph-book-open', singleton: true },
      exports: { id: 'exports', label: 'Exports', icon: 'ph-export', singleton: true },
      lenses: { id: 'lenses', label: 'Lenses', icon: 'ph-funnel', singleton: true },
      recordTypes: { id: 'recordTypes', label: 'Record Types', icon: 'ph-stack', singleton: true }
    };

    // Panel tab history for "reopen tab" feature
    this.panelTabHistory = [];
  }

  // --------------------------------------------------------------------------
  // Initialization
  // --------------------------------------------------------------------------

  async init(eoApp = null) {
    this.eoApp = eoApp;

    // Initialize View Hierarchy Registry
    this._initViewHierarchy();

    // Load persisted data (includes awaiting IndexedDB records - GIVEN before MEANT)
    await this._loadData();

    // Ensure sources array is initialized
    if (!Array.isArray(this.sources)) {
      this.sources = [];
    }

    // If no workspaces exist, create a default one
    if (this.viewRegistry.getAllWorkspaces().length === 0) {
      this._createDefaultWorkspace();
    }

    // If no sets exist, create a default one
    if (this.sets.length === 0) {
      this._createDefaultSet();
    }

    // Set current set and view
    if (!this.currentSetId && this.sets.length > 0) {
      this.currentSetId = this.sets[0].id;
      this.currentViewId = this.sets[0].views[0]?.id;
    }

    // Sync legacy sets with view registry
    this._syncSetsToRegistry();

    // Bind elements
    this._bindElements();

    // Attach event listeners
    this._attachEventListeners();

    // Add beforeunload handler to ensure data persists on page close/refresh
    this._setupPersistenceHandlers();

    // Initialize browser tab keyboard shortcuts
    this._initTabKeyboardShortcuts();

    // Initialize browser tabs - restore persisted tabs or create default
    if (this.browserTabs.length === 0) {
      if (this.sets.length > 0) {
        const firstSet = this.sets[0];
        this.openTab('set', {
          contentId: firstSet.id,
          title: firstSet.name,
          icon: firstSet.icon || 'ph-table'
        });
      } else {
        this.openTab('newTab');
      }
    } else {
      // Restore persisted tabs - sync state from active tab
      const activeTab = this.browserTabs.find(t => t.id === this.activeTabId);
      if (activeTab) {
        this._syncStateFromTab(activeTab);
      } else if (this.browserTabs.length > 0) {
        // If activeTabId is invalid, activate the first tab
        this.activeTabId = this.browserTabs[0].id;
        this._syncStateFromTab(this.browserTabs[0]);
      }
      this._renderBrowserTabBar();
      this._renderTabContent();
    }

    // Render sidebar
    this._renderSidebar();

    // Update tossed items badge
    this._updateTossedBadge();

    // Update status
    this._updateStatus();

    console.log('EO Data Workbench initialized with compliant view hierarchy');
    return this;
  }

  /**
   * Initialize the View Hierarchy Registry
   */
  _initViewHierarchy() {
    // Get or create the view registry
    if (typeof initViewRegistry === 'function') {
      this.viewRegistry = initViewRegistry(
        this.eoApp?.getGate?.() || null,
        this.eoApp?.eventStore || null
      );
    } else {
      // Fallback: create a simple registry
      this.viewRegistry = {
        workspaces: new Map(),
        sets: new Map(),
        lenses: new Map(),
        focuses: new Map(),
        exports: new Map(),
        activeWorkspaceId: null,
        getAllWorkspaces: () => [],
        getAllSets: () => [],
        createWorkspace: () => null,
        subscribe: () => () => {}
      };
    }

    // Subscribe to registry events
    this.viewRegistry.subscribe?.((eventType, data) => {
      this._handleRegistryEvent(eventType, data);
    });
  }

  // --------------------------------------------------------------------------
  // Browser Tab Manager - Chrome-like tab management
  // --------------------------------------------------------------------------

  /**
   * Open a new tab (like opening a new page in Chrome)
   * @param {string} type - Tab type (set, source, sources, definitions, settings, etc.)
   * @param {Object} options - Tab options (id for sets/sources, etc.)
   * @returns {Object} The opened tab
   */
  openTab(type, options = {}) {
    const tabType = this.tabTypes[type];
    if (!tabType) {
      console.warn(`Unknown tab type: ${type}`);
      return null;
    }

    // Check if we're currently on a newTab (to close it after opening the new tab)
    const currentTab = this.getActiveTab();
    const wasOnNewTab = currentTab?.type === 'newTab';
    const newTabIdToClose = wasOnNewTab ? currentTab.id : null;

    // For singleton tabs, check if already open and just activate it
    if (tabType.singleton) {
      const existingTab = this.browserTabs.find(t => t.type === type);
      if (existingTab) {
        this.activateTab(existingTab.id);
        // Close the newTab we were on (like browser behavior)
        if (newTabIdToClose) {
          this._removeNewTab(newTabIdToClose);
        }
        return existingTab;
      }
    }

    // For content tabs, check for existing tab with same content
    if (!tabType.singleton && options.contentId) {
      let existingTab = null;

      if (type === 'view') {
        // View tabs are keyed by setId + viewId
        existingTab = this.browserTabs.find(t =>
          t.type === type &&
          t.contentId === options.contentId &&
          t.viewState?.viewId === options.viewState?.viewId
        );
      } else if (type === 'lens') {
        // Lens tabs are keyed by setId + lensId
        existingTab = this.browserTabs.find(t =>
          t.type === type &&
          t.contentId === options.contentId &&
          t.viewState?.lensId === options.viewState?.lensId
        );
      } else if (type === 'schema') {
        // Schema tabs are keyed by setId only
        existingTab = this.browserTabs.find(t => t.type === type && t.contentId === options.contentId);
      } else {
        // Default: key by type and contentId
        existingTab = this.browserTabs.find(t => t.type === type && t.contentId === options.contentId);
      }

      if (existingTab) {
        // Update viewState for set tabs when re-opening (e.g., clicking set header to show dashboard)
        if (type === 'set' && options.viewState) {
          existingTab.viewState = options.viewState;
        }
        this.activateTab(existingTab.id);
        // Close the newTab we were on (like browser behavior)
        if (newTabIdToClose) {
          this._removeNewTab(newTabIdToClose);
        }
        return existingTab;
      }
    }

    // Create new tab
    const tab = {
      id: `tab-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      type: type,
      contentId: options.contentId || null, // For sets: setId, for sources: sourceId
      title: options.title || tabType.label || 'New Tab',
      icon: options.icon || tabType.icon,
      isPinned: options.isPinned || false,
      createdAt: Date.now(),
      // View-specific state
      viewState: options.viewState || {}
    };

    // Add to tabs array
    if (tab.isPinned) {
      // Pinned tabs go to the front
      const lastPinnedIndex = this.browserTabs.findLastIndex(t => t.isPinned);
      this.browserTabs.splice(lastPinnedIndex + 1, 0, tab);
    } else {
      this.browserTabs.push(tab);
    }

    // Activate the new tab
    this.activateTab(tab.id);

    // Close the newTab we were on (like browser behavior - new tab page gets replaced)
    if (newTabIdToClose) {
      this._removeNewTab(newTabIdToClose);
    }

    // Persist tab state
    this._saveData();

    return tab;
  }

  /**
   * Remove a newTab from browserTabs without going through closeTab
   * This is used when navigating away from the new tab page
   */
  _removeNewTab(tabId) {
    const tabIndex = this.browserTabs.findIndex(t => t.id === tabId);
    if (tabIndex !== -1) {
      this.browserTabs.splice(tabIndex, 1);
      // Re-render tab bar to reflect the removal
      this._renderBrowserTabBar();
    }
  }

  /**
   * Close a tab (like clicking X on a Chrome tab)
   * @param {string} tabId - ID of tab to close
   * @param {boolean} skipHistory - Don't add to recently closed
   */
  closeTab(tabId, skipHistory = false) {
    const tabIndex = this.browserTabs.findIndex(t => t.id === tabId);
    if (tabIndex === -1) return;

    const tab = this.browserTabs[tabIndex];

    // Can't close pinned tabs without unpinning first
    if (tab.isPinned) {
      console.warn('Cannot close pinned tab. Unpin first.');
      return;
    }

    // Add to recently closed for "reopen tab" feature
    if (!skipHistory) {
      this.recentlyClosedTabs.unshift({ ...tab, closedAt: Date.now() });
      if (this.recentlyClosedTabs.length > 10) {
        this.recentlyClosedTabs.pop();
      }
    }

    // Remove the tab
    this.browserTabs.splice(tabIndex, 1);

    // If we closed the active tab, activate another
    if (this.activeTabId === tabId) {
      if (this.browserTabs.length > 0) {
        // Activate tab to the right, or left if we closed the rightmost
        const newIndex = Math.min(tabIndex, this.browserTabs.length - 1);
        this.activateTab(this.browserTabs[newIndex].id);
      } else {
        // No tabs left, open new tab page
        this.openTab('newTab');
      }
    } else {
      // Just re-render the tab bar
      this._renderBrowserTabBar();
    }

    // Persist tab state
    this._saveData();
  }

  /**
   * Close all tabs except pinned ones
   */
  closeAllTabs() {
    const tabsToClose = this.browserTabs.filter(t => !t.isPinned);
    tabsToClose.forEach(tab => {
      this.closeTab(tab.id);
    });
  }

  /**
   * Close other tabs (keep only the specified tab and pinned tabs)
   */
  closeOtherTabs(keepTabId) {
    const tabsToClose = this.browserTabs.filter(t => t.id !== keepTabId && !t.isPinned);
    tabsToClose.forEach(tab => {
      this.closeTab(tab.id);
    });
  }

  /**
   * Close tabs to the right of specified tab
   */
  closeTabsToRight(tabId) {
    const tabIndex = this.browserTabs.findIndex(t => t.id === tabId);
    if (tabIndex === -1) return;

    const tabsToClose = this.browserTabs.slice(tabIndex + 1).filter(t => !t.isPinned);
    tabsToClose.forEach(tab => {
      this.closeTab(tab.id);
    });
  }

  /**
   * Activate/switch to a tab
   */
  activateTab(tabId) {
    const tab = this.browserTabs.find(t => t.id === tabId);
    if (!tab) return;

    // CRITICAL: Commit any pending cell edits before switching tabs
    // This prevents data loss when navigating between tabs
    if (this.editingCell) {
      this._endCellEdit();
    }

    // Save current tab to history
    if (this.activeTabId && this.activeTabId !== tabId) {
      this.tabHistory.push(this.activeTabId);
      if (this.tabHistory.length > 50) {
        this.tabHistory.shift();
      }
    }

    this.activeTabId = tabId;

    // Update internal state based on tab type
    this._syncStateFromTab(tab);

    // Render
    this._renderBrowserTabBar();
    this._renderTabContent();

    // Persist active tab state
    this._saveData();
  }

  /**
   * Reopen the last closed tab
   */
  reopenClosedTab() {
    if (this.recentlyClosedTabs.length === 0) return null;

    const closedTab = this.recentlyClosedTabs.shift();
    return this.openTab(closedTab.type, {
      contentId: closedTab.contentId,
      title: closedTab.title,
      icon: closedTab.icon,
      viewState: closedTab.viewState
    });
  }

  /**
   * Pin/unpin a tab
   */
  toggleTabPin(tabId) {
    const tab = this.browserTabs.find(t => t.id === tabId);
    if (!tab) return;

    tab.isPinned = !tab.isPinned;

    // Record activity for tab pin toggle
    this._recordActivity({
      action: 'update',
      entityType: 'workspace',
      name: tab.title || 'Tab',
      details: `${tab.isPinned ? 'Pinned' : 'Unpinned'} tab "${tab.title || 'Unnamed'}"`,
      canReverse: false
    });

    // Reorder: pinned tabs should be at the front
    this.browserTabs.sort((a, b) => {
      if (a.isPinned && !b.isPinned) return -1;
      if (!a.isPinned && b.isPinned) return 1;
      return 0;
    });

    this._renderBrowserTabBar();
  }

  /**
   * Move tab to a new position
   */
  moveTab(tabId, newIndex) {
    const currentIndex = this.browserTabs.findIndex(t => t.id === tabId);
    if (currentIndex === -1) return;

    const tab = this.browserTabs[currentIndex];

    // Don't allow moving unpinned tabs before pinned tabs
    const firstUnpinnedIndex = this.browserTabs.findIndex(t => !t.isPinned);
    if (!tab.isPinned && newIndex < firstUnpinnedIndex) {
      newIndex = firstUnpinnedIndex;
    }

    // Move the tab
    this.browserTabs.splice(currentIndex, 1);
    this.browserTabs.splice(newIndex, 0, tab);

    // Record activity for tab move
    this._recordActivity({
      action: 'update',
      entityType: 'workspace',
      name: tab.title || 'Tab',
      details: `Moved tab "${tab.title || 'Unnamed'}" to position ${newIndex + 1}`,
      canReverse: false
    });

    this._renderBrowserTabBar();
  }

  /**
   * Get the active tab
   */
  getActiveTab() {
    return this.browserTabs.find(t => t.id === this.activeTabId);
  }

  /**
   * Sync internal state from tab (for backward compatibility)
   */
  _syncStateFromTab(tab) {
    // Clear all "current" states
    this.currentSourceId = null;
    this.isViewingDefinitions = false;
    this.showingSetDetail = false;
    this.showingSetFields = false;

    switch (tab.type) {
      case 'set':
        this.currentSetId = tab.contentId;
        this.currentViewId = tab.viewState?.viewId || this.lastViewPerSet[tab.contentId];
        this.showingSetDetail = tab.viewState?.showDetail || false;
        this.showingSetFields = tab.viewState?.showFields || false;
        break;

      case 'view':
        // Individual view tab - set both setId and viewId
        this.currentSetId = tab.contentId;
        this.currentViewId = tab.viewState?.viewId;
        this.currentLensId = tab.viewState?.lensId || null;
        break;

      case 'schema':
        // Schema/fields tab for a set
        this.currentSetId = tab.contentId;
        this.showingSetFields = true;
        break;

      case 'lens':
        // Lens tab - set setId and lensId
        this.currentSetId = tab.contentId;
        this.currentLensId = tab.viewState?.lensId;
        this.currentViewId = tab.viewState?.viewId;
        break;

      case 'source':
        this.currentSourceId = tab.contentId;
        break;

      case 'sources':
        this.currentSourceId = 'sources-table';
        break;

      case 'definitions':
        this.isViewingDefinitions = true;
        break;

      case 'settings':
      case 'activity':
      case 'shortcuts':
      case 'newTab':
        // These don't need special state
        break;
    }
  }

  /**
   * Render the browser tab bar
   */
  _renderBrowserTabBar() {
    const container = this.elements.tabBarTabs;
    if (!container) return;

    const tabsHtml = this.browserTabs.map(tab => {
      const isActive = tab.id === this.activeTabId;
      const isPinned = tab.isPinned;

      return `
        <div class="browser-tab ${isActive ? 'active' : ''} ${isPinned ? 'pinned' : ''}"
             data-tab-id="${tab.id}"
             draggable="true">
          <div class="tab-icon">
            <i class="ph ${tab.icon}"></i>
          </div>
          ${!isPinned ? `<span class="tab-title">${this._escapeHtml(tab.title)}</span>` : ''}
          ${!isPinned ? `
            <button class="tab-close" data-tab-id="${tab.id}" title="Close tab">
              <i class="ph ph-x"></i>
            </button>
          ` : ''}
          ${isActive ? '<div class="tab-curve-right"></div>' : ''}
        </div>
      `;
    }).join('');

    container.innerHTML = tabsHtml;

    this._attachBrowserTabEventHandlers();
  }

  /**
   * Attach event handlers for browser tabs
   */
  _attachBrowserTabEventHandlers() {
    const container = this.elements.tabBarTabs;
    if (!container) return;

    // Tab clicks
    container.querySelectorAll('.browser-tab').forEach(tabEl => {
      const tabId = tabEl.dataset.tabId;

      // Left click to activate
      tabEl.addEventListener('click', (e) => {
        if (e.target.closest('.tab-close')) return;
        this.activateTab(tabId);
      });

      // Middle click to close
      tabEl.addEventListener('auxclick', (e) => {
        if (e.button === 1) {
          e.preventDefault();
          this.closeTab(tabId);
        }
      });

      // Right click context menu
      tabEl.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        this._showTabContextMenu(e, tabId);
      });

      // Drag and drop
      tabEl.addEventListener('dragstart', (e) => {
        e.dataTransfer.setData('text/plain', tabId);
        tabEl.classList.add('dragging');
      });

      tabEl.addEventListener('dragend', () => {
        tabEl.classList.remove('dragging');
        container.querySelectorAll('.browser-tab').forEach(t => {
          t.classList.remove('drag-over', 'drag-over-right');
        });
      });

      tabEl.addEventListener('dragover', (e) => {
        e.preventDefault();
        const draggingTab = container.querySelector('.dragging');
        if (draggingTab && draggingTab !== tabEl) {
          const rect = tabEl.getBoundingClientRect();
          const midpoint = rect.left + rect.width / 2;
          tabEl.classList.remove('drag-over', 'drag-over-right');
          if (e.clientX < midpoint) {
            tabEl.classList.add('drag-over');
          } else {
            tabEl.classList.add('drag-over-right');
          }
        }
      });

      tabEl.addEventListener('dragleave', () => {
        tabEl.classList.remove('drag-over', 'drag-over-right');
      });

      tabEl.addEventListener('drop', (e) => {
        e.preventDefault();
        const draggedTabId = e.dataTransfer.getData('text/plain');
        const targetIndex = this.browserTabs.findIndex(t => t.id === tabId);
        const rect = tabEl.getBoundingClientRect();
        const insertAfter = e.clientX >= rect.left + rect.width / 2;
        this.moveTab(draggedTabId, insertAfter ? targetIndex + 1 : targetIndex);
        tabEl.classList.remove('drag-over', 'drag-over-right');
      });
    });

    // Close button clicks
    container.querySelectorAll('.tab-close').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        this.closeTab(btn.dataset.tabId);
      });
    });
  }

  /**
   * Show context menu for a tab
   */
  _showTabContextMenu(e, tabId) {
    const tab = this.browserTabs.find(t => t.id === tabId);
    if (!tab) return;

    // Remove any existing context menu
    document.querySelectorAll('.tab-context-menu').forEach(m => m.remove());

    const menu = document.createElement('div');
    menu.className = 'tab-context-menu';
    menu.innerHTML = `
      <div class="context-menu-item" data-action="pin">
        <i class="ph ${tab.isPinned ? 'ph-push-pin-slash' : 'ph-push-pin'}"></i>
        ${tab.isPinned ? 'Unpin' : 'Pin'}
      </div>
      <div class="context-menu-item" data-action="duplicate">
        <i class="ph ph-copy"></i>
        Duplicate
      </div>
      <div class="context-menu-divider"></div>
      ${!tab.isPinned ? `
        <div class="context-menu-item" data-action="close">
          <i class="ph ph-x"></i>
          Close
        </div>
      ` : ''}
      <div class="context-menu-item" data-action="close-others">
        <i class="ph ph-x-square"></i>
        Close Others
      </div>
      <div class="context-menu-item" data-action="close-right">
        <i class="ph ph-arrow-right"></i>
        Close Tabs to the Right
      </div>
      <div class="context-menu-divider"></div>
      <div class="context-menu-item ${this.recentlyClosedTabs.length === 0 ? 'disabled' : ''}" data-action="reopen">
        <i class="ph ph-arrow-counter-clockwise"></i>
        Reopen Closed Tab
      </div>
    `;

    menu.style.position = 'fixed';
    menu.style.left = `${e.clientX}px`;
    menu.style.top = `${e.clientY}px`;
    menu.style.zIndex = '10000';

    document.body.appendChild(menu);

    // Handle menu actions
    menu.querySelectorAll('.context-menu-item:not(.disabled)').forEach(item => {
      item.addEventListener('click', () => {
        const action = item.dataset.action;
        switch (action) {
          case 'pin':
            this.toggleTabPin(tabId);
            break;
          case 'duplicate':
            this.openTab(tab.type, {
              contentId: tab.contentId,
              title: tab.title,
              icon: tab.icon,
              viewState: { ...tab.viewState }
            });
            break;
          case 'close':
            this.closeTab(tabId);
            break;
          case 'close-others':
            this.closeOtherTabs(tabId);
            break;
          case 'close-right':
            this.closeTabsToRight(tabId);
            break;
          case 'reopen':
            this.reopenClosedTab();
            break;
        }
        menu.remove();
      });
    });

    // Close menu on click outside
    setTimeout(() => {
      document.addEventListener('click', () => menu.remove(), { once: true });
    }, 0);
  }

  /**
   * Render the content for the active tab
   */
  _renderTabContent() {
    const tab = this.getActiveTab();
    if (!tab) {
      this._renderNewTabPage();
      return;
    }

    switch (tab.type) {
      case 'set':
        if (tab.viewState?.showDetail) {
          this._renderSetDetailView();
        } else if (tab.viewState?.showFields) {
          this._renderSetFieldsPanel();
        } else {
          this._renderView();
        }
        break;

      case 'view':
        // Individual view tab - render that specific view
        this._renderView();
        break;

      case 'schema':
        // Schema/fields tab - show the fields panel
        this._renderSetFieldsPanel();
        break;

      case 'lens':
        // Lens tab - render the lens view
        this._renderView();
        break;

      case 'source':
        this._renderSourceDetail();
        break;

      case 'sources':
        this._showSourcesTableView();
        break;

      case 'sets':
        this._showSetsTableView();
        break;

      case 'definitions':
        this._showDefinitionsTableView();
        break;

      case 'settings':
        this._renderSettingsTab();
        break;

      case 'activity':
        this._renderActivityTab();
        break;

      case 'shortcuts':
        this._renderShortcutsTab();
        break;

      case 'newTab':
        this._renderNewTabPage();
        break;

      default:
        this._renderNewTabPage();
    }
  }

  /**
   * Render a source detail view when a source tab is active
   * Gets the source from currentSourceId and renders it
   */
  async _renderSourceDetail() {
    const sourceId = this.currentSourceId;
    if (!sourceId) {
      console.warn('_renderSourceDetail: No currentSourceId set');
      this._renderNewTabPage();
      return;
    }

    const source = this.sources?.find(s => s.id === sourceId);
    if (!source) {
      console.warn('_renderSourceDetail: Source not found:', sourceId);
      this._renderNewTabPage();
      return;
    }

    // Ensure source records are loaded from IndexedDB if needed
    await this._ensureSourceRecords(source);

    // Render the source data view
    this._renderSourceDataView(source);

    // Update status bar with source record count
    this._updateSourceStatus(source);
  }

  /**
   * Render the New Tab page (like Chrome's new tab page)
   */
  _renderNewTabPage() {
    const content = this.elements.contentArea;
    if (!content) return;

    const recentSets = this.sets.slice(0, 8);
    const recentSources = (this.sources || []).slice(0, 4);

    content.innerHTML = `
      <div class="new-tab-page">
        <div class="new-tab-header">
          <h1>New Tab</h1>
        </div>

        <div class="new-tab-search">
          <div class="new-tab-search-box">
            <i class="ph ph-magnifying-glass"></i>
            <input type="text" placeholder="Search sets, sources, or type a command..." id="new-tab-search-input" />
          </div>
        </div>

        <div class="new-tab-shortcuts">
          <button class="new-tab-shortcut" data-action="sources">
            <div class="new-tab-shortcut-icon sources">
              <i class="ph ph-download-simple"></i>
            </div>
            <span>Sources</span>
          </button>
          <button class="new-tab-shortcut" data-action="definitions">
            <div class="new-tab-shortcut-icon definitions">
              <i class="ph ph-book-open"></i>
            </div>
            <span>Definitions</span>
          </button>
          <button class="new-tab-shortcut" data-action="settings">
            <div class="new-tab-shortcut-icon settings">
              <i class="ph ph-gear"></i>
            </div>
            <span>Settings</span>
          </button>
          <button class="new-tab-shortcut" data-action="activity">
            <div class="new-tab-shortcut-icon activity">
              <i class="ph ph-clock-counter-clockwise"></i>
            </div>
            <span>Activity</span>
          </button>
          <button class="new-tab-shortcut" data-action="shortcuts">
            <div class="new-tab-shortcut-icon shortcuts">
              <i class="ph ph-keyboard"></i>
            </div>
            <span>Shortcuts</span>
          </button>
          <button class="new-tab-shortcut" data-action="import">
            <div class="new-tab-shortcut-icon import">
              <i class="ph ph-plus"></i>
            </div>
            <span>Import</span>
          </button>
          <button class="new-tab-shortcut" data-action="new-view">
            <div class="new-tab-shortcut-icon new-view">
              <i class="ph ph-squares-four"></i>
            </div>
            <span>New View</span>
          </button>
        </div>

        ${recentSets.length > 0 ? `
          <div class="new-tab-section">
            <h2>Sets</h2>
            <div class="new-tab-grid">
              ${recentSets.map(set => `
                <button class="new-tab-item" data-action="open-set" data-set-id="${set.id}">
                  <div class="new-tab-item-icon">
                    <i class="${set.icon || 'ph ph-table'}"></i>
                  </div>
                  <div class="new-tab-item-info">
                    <div class="new-tab-item-title">${this._escapeHtml(set.name)}</div>
                    <div class="new-tab-item-meta">${(set.records || []).length} records</div>
                  </div>
                </button>
              `).join('')}
            </div>
          </div>
        ` : ''}

        ${this.recentlyClosedTabs.length > 0 ? `
          <div class="new-tab-section">
            <h2>Recently Closed</h2>
            <div class="new-tab-list">
              ${this.recentlyClosedTabs.slice(0, 5).map(tab => `
                <button class="new-tab-closed-item" data-tab-index="${this.recentlyClosedTabs.indexOf(tab)}">
                  <i class="ph ${tab.icon}"></i>
                  <span>${this._escapeHtml(tab.title)}</span>
                  <small>${this._formatRelativeTime(tab.closedAt)}</small>
                </button>
              `).join('')}
            </div>
          </div>
        ` : ''}
      </div>
    `;

    // Attach event handlers
    content.querySelectorAll('.new-tab-shortcut').forEach(btn => {
      btn.addEventListener('click', () => {
        const action = btn.dataset.action;
        switch (action) {
          case 'sources':
            this.openTab('sources');
            break;
          case 'definitions':
            this.openTab('definitions');
            break;
          case 'settings':
            this.openTab('settings');
            break;
          case 'activity':
            this.openTab('activity');
            break;
          case 'shortcuts':
            this.openTab('shortcuts');
            break;
          case 'import':
            this._showImportDialog();
            break;
          case 'new-view':
            this._showNewViewFromNewTab();
            break;
        }
      });
    });

    content.querySelectorAll('[data-action="open-set"]').forEach(btn => {
      btn.addEventListener('click', () => {
        const setId = btn.dataset.setId;
        const set = this.sets.find(s => s.id === setId);
        if (set) {
          this.openTab('set', {
            contentId: setId,
            title: set.name,
            icon: set.icon || 'ph-table'
          });
        }
      });
    });

    content.querySelectorAll('.new-tab-closed-item').forEach(btn => {
      btn.addEventListener('click', () => {
        this.reopenClosedTab();
      });
    });

    // Focus search input
    const searchInput = document.getElementById('new-tab-search-input');
    if (searchInput) {
      searchInput.focus();
      searchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          // TODO: Implement search
        }
      });
    }
  }

  /**
   * Render Settings tab content
   */
  _renderSettingsTab() {
    const content = this.elements.contentArea;
    if (!content) return;

    content.innerHTML = `
      <div class="settings-page">
        <div class="settings-header">
          <h1><i class="ph ph-gear"></i> Settings</h1>
        </div>
        <div class="settings-content">
          <div class="settings-section">
            <h2>About</h2>
            <div class="settings-about">
              <p><strong>Noema</strong></p>
              <p>Version 1.0.0</p>
              <p class="settings-about-desc">A data workbench for organizing and transforming your data.</p>
            </div>
          </div>
        </div>
      </div>
    `;
  }

  /**
   * Render Activity tab content
   */
  _renderActivityTab() {
    const content = this.elements.contentArea;
    if (!content) return;

    // Collect all activities
    const allActivities = this._collectAllActivities();

    content.innerHTML = `
      <div class="activity-simple-container">
        <div class="activity-toolbar">
          <span class="activity-count-text">${allActivities.length} ${allActivities.length === 1 ? 'activity' : 'activities'}</span>
          <div class="activity-toolbar-filters">
            <select id="activity-tab-filter-type" class="activity-toolbar-select">
              <option value="all">All types</option>
              <option value="source">Sources</option>
              <option value="set">Sets</option>
              <option value="view">Views</option>
              <option value="field">Fields</option>
              <option value="record">Records</option>
              <option value="lens">Lenses</option>
            </select>
            <select id="activity-tab-filter-action" class="activity-toolbar-select">
              <option value="all">All actions</option>
              <option value="create">Created</option>
              <option value="update">Updated</option>
              <option value="delete">Deleted</option>
              <option value="restore">Restored</option>
            </select>
          </div>
        </div>
        <div class="activity-simple-content" id="activity-tab-content">
          ${this._renderActivityTabTableView(allActivities)}
        </div>
      </div>
    `;

    // Attach event listeners
    this._attachActivityTabListeners();
  }

  _renderActivityTabTableView(activities) {
    if (activities.length === 0) {
      return `
        <div class="activity-empty-simple">
          No activity recorded
        </div>
      `;
    }

    const rows = activities.slice(0, 100).map(activity => {
      const timeAgo = this._formatTimeAgo(activity.timestamp);
      const actionBadge = this._getActivityActionBadge(activity.action);
      const typeBadge = this._getActivityTypeBadge(activity.entityType);
      const canUndo = activity.canReverse && activity.reverseData;

      return `
        <tr data-activity-id="${activity.id}">
          <td>${timeAgo}</td>
          <td>${actionBadge}</td>
          <td>${typeBadge}</td>
          <td>${this._escapeHtml(activity.name || 'Untitled')}</td>
          <td class="activity-details-cell">${this._escapeHtml(activity.details || '')}</td>
          <td>${canUndo ? `<button class="activity-undo-btn" data-activity-id="${activity.id}">Undo</button>` : ''}</td>
        </tr>
      `;
    }).join('');

    return `
      <table class="activity-simple-table">
        <thead>
          <tr>
            <th>Time</th>
            <th>Action</th>
            <th>Type</th>
            <th>Name</th>
            <th>Details</th>
            <th></th>
          </tr>
        </thead>
        <tbody id="activity-tab-table-body">
          ${rows}
        </tbody>
      </table>
    `;
  }

  _renderActivityTabJsonView(activities) {
    if (activities.length === 0) {
      return `
        <div class="activity-empty-state">
          <i class="ph ph-clock-counter-clockwise"></i>
          <h3>No recent activity</h3>
          <p>Your recent actions will appear here</p>
        </div>
      `;
    }

    // Clean up activities for JSON display (remove circular refs and functions)
    const cleanActivities = activities.slice(0, 100).map(activity => {
      const clean = { ...activity };
      // Remove reverseData for cleaner display (it can contain large objects)
      if (clean.reverseData) {
        clean.reverseData = { type: clean.reverseData.type, '...': 'data omitted for display' };
      }
      return clean;
    });

    const jsonString = JSON.stringify(cleanActivities, null, 2);

    return `
      <div class="activity-json-view">
        <div class="activity-json-toolbar">
          <button class="activity-json-copy-btn" title="Copy to clipboard">
            <i class="ph ph-copy"></i> Copy JSON
          </button>
          <span class="activity-json-info">${activities.length} activities (showing up to 100)</span>
        </div>
        <pre class="activity-json-content"><code>${this._escapeHtml(jsonString)}</code></pre>
      </div>
    `;
  }

  _attachActivityTabListeners() {
    const content = this.elements.contentArea;
    if (!content) return;

    // Filter listeners
    const typeFilter = content.querySelector('#activity-tab-filter-type');
    const actionFilter = content.querySelector('#activity-tab-filter-action');

    const applyFilters = () => {
      const typeValue = typeFilter?.value || 'all';
      const actionValue = actionFilter?.value || 'all';

      let filtered = this._collectAllActivities();
      if (typeValue !== 'all') {
        filtered = filtered.filter(a => a.entityType === typeValue);
      }
      if (actionValue !== 'all') {
        filtered = filtered.filter(a => a.action === actionValue);
      }

      // Update count
      const countEl = content.querySelector('.activity-count-text');
      if (countEl) {
        countEl.textContent = `${filtered.length} ${filtered.length === 1 ? 'activity' : 'activities'}`;
      }

      // Update content
      const contentArea = content.querySelector('#activity-tab-content');
      if (contentArea) {
        contentArea.innerHTML = this._renderActivityTabTableView(filtered);
        this._attachActivityTabContentListeners();
      }
    };

    typeFilter?.addEventListener('change', applyFilters);
    actionFilter?.addEventListener('change', applyFilters);

    // Attach content-specific listeners
    this._attachActivityTabContentListeners();
  }

  _attachActivityTabContentListeners() {
    const content = this.elements.contentArea;
    if (!content) return;

    // Undo button listeners
    content.querySelectorAll('.activity-undo-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const activityId = btn.dataset.activityId;
        this._reverseActivity(activityId);
        this._renderActivityTab(); // Re-render after undo
      });
    });
  }

  /**
   * Render Shortcuts tab content
   */
  _renderShortcutsTab() {
    const content = this.elements.contentArea;
    if (!content) return;

    content.innerHTML = `
      <div class="shortcuts-page">
        <div class="shortcuts-header">
          <h1><i class="ph ph-keyboard"></i> Keyboard Shortcuts</h1>
        </div>
        <div class="shortcuts-content">
          <div class="shortcuts-section">
            <h2>Tabs</h2>
            <div class="shortcut-item">
              <span class="shortcut-desc">New tab</span>
              <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>T</kbd></span>
            </div>
            <div class="shortcut-item">
              <span class="shortcut-desc">Close tab</span>
              <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>W</kbd></span>
            </div>
            <div class="shortcut-item">
              <span class="shortcut-desc">Reopen closed tab</span>
              <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>T</kbd></span>
            </div>
            <div class="shortcut-item">
              <span class="shortcut-desc">Next tab</span>
              <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>Tab</kbd></span>
            </div>
            <div class="shortcut-item">
              <span class="shortcut-desc">Previous tab</span>
              <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Tab</kbd></span>
            </div>
            <div class="shortcut-item">
              <span class="shortcut-desc">Go to tab 1-9</span>
              <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>1-9</kbd></span>
            </div>
          </div>

          <div class="shortcuts-section">
            <h2>Navigation</h2>
            <div class="shortcut-item">
              <span class="shortcut-desc">Search</span>
              <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>K</kbd></span>
            </div>
            <div class="shortcut-item">
              <span class="shortcut-desc">Go to Sources</span>
              <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>S</kbd></span>
            </div>
            <div class="shortcut-item">
              <span class="shortcut-desc">Go to Definitions</span>
              <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>D</kbd></span>
            </div>
          </div>

          <div class="shortcuts-section">
            <h2>Records</h2>
            <div class="shortcut-item">
              <span class="shortcut-desc">Add new record</span>
              <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>N</kbd></span>
            </div>
            <div class="shortcut-item">
              <span class="shortcut-desc">Duplicate selected</span>
              <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>D</kbd></span>
            </div>
            <div class="shortcut-item">
              <span class="shortcut-desc">Delete selected</span>
              <span class="shortcut-keys"><kbd>Delete</kbd></span>
            </div>
            <div class="shortcut-item">
              <span class="shortcut-desc">Select all</span>
              <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>A</kbd></span>
            </div>
          </div>

          <div class="shortcuts-section">
            <h2>Editing</h2>
            <div class="shortcut-item">
              <span class="shortcut-desc">Undo</span>
              <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>Z</kbd></span>
            </div>
            <div class="shortcut-item">
              <span class="shortcut-desc">Redo</span>
              <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Z</kbd></span>
            </div>
            <div class="shortcut-item">
              <span class="shortcut-desc">Copy</span>
              <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>C</kbd></span>
            </div>
            <div class="shortcut-item">
              <span class="shortcut-desc">Paste</span>
              <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>V</kbd></span>
            </div>
          </div>
        </div>
      </div>
    `;
  }

  /**
   * Initialize keyboard shortcuts for tabs
   */
  _initTabKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
      // Skip shortcuts when typing in input fields
      if (e.target.closest('input, textarea, [contenteditable="true"]')) {
        return;
      }

      // Ctrl+T: New tab
      if (e.ctrlKey && e.key === 't') {
        e.preventDefault();
        this.openTab('newTab');
      }

      // Ctrl+W: Close current tab
      if (e.ctrlKey && e.key === 'w') {
        e.preventDefault();
        if (this.activeTabId) {
          this.closeTab(this.activeTabId);
        }
      }

      // Ctrl+Shift+T: Reopen closed tab
      if (e.ctrlKey && e.shiftKey && e.key === 'T') {
        e.preventDefault();
        this.reopenClosedTab();
      }

      // Ctrl+Tab: Next tab
      if (e.ctrlKey && e.key === 'Tab') {
        e.preventDefault();
        const currentIndex = this.browserTabs.findIndex(t => t.id === this.activeTabId);
        const nextIndex = e.shiftKey
          ? (currentIndex - 1 + this.browserTabs.length) % this.browserTabs.length
          : (currentIndex + 1) % this.browserTabs.length;
        if (this.browserTabs[nextIndex]) {
          this.activateTab(this.browserTabs[nextIndex].id);
        }
      }

      // Ctrl+1-9: Go to tab N
      if (e.ctrlKey && e.key >= '1' && e.key <= '9') {
        e.preventDefault();
        const index = parseInt(e.key) - 1;
        if (this.browserTabs[index]) {
          this.activateTab(this.browserTabs[index].id);
        }
      }
    });
  }

  /**
   * Create the default workspace
   */
  _createDefaultWorkspace() {
    if (!this.viewRegistry.createWorkspace) return;

    try {
      const workspace = this.viewRegistry.createWorkspace({
        name: 'My Workspace',
        description: 'Default workspace for organizing data',
        icon: 'ph-folder-simple',
        horizon: {
          timeRange: null,
          actors: [],
          entityTypes: []
        }
      }, ['system_init']);

      this.currentWorkspaceId = workspace.id;
      this.viewRegistry.activeWorkspaceId = workspace.id;
    } catch (e) {
      console.warn('Failed to create default workspace:', e);
    }
  }

  /**
   * Sync legacy sets with the view registry
   */
  _syncSetsToRegistry() {
    if (!this.viewRegistry.createSet) return;

    for (const set of this.sets) {
      // Check if set already exists in registry
      if (!this.viewRegistry.sets.has(set.id)) {
        try {
          // Create set in registry with schema
          const registrySet = this.viewRegistry.createSet({
            id: set.id,
            name: set.name,
            icon: set.icon,
            schema: { fields: set.fields },
            records: set.records
          }, this.currentWorkspaceId, ['system_init']);

          // Create lenses for each view
          for (const view of set.views || []) {
            const lens = this.viewRegistry.createLens({
              id: view.id,
              name: view.name,
              lensType: this._mapViewTypeToLensType(view.type),
              config: view.config || {}
            }, set.id);
          }
        } catch (e) {
          console.warn('Failed to sync set to registry:', e);
        }
      }
    }
  }

  /**
   * Map legacy view type to lens type
   */
  _mapViewTypeToLensType(viewType) {
    const mapping = {
      'table': 'grid',
      'cards': 'cards',
      'kanban': 'kanban',
      'calendar': 'calendar',
      'graph': 'graph',
      'timeline': 'timeline'
    };
    return mapping[viewType] || 'grid';
  }

  /**
   * Handle events from the view registry
   */
  _handleRegistryEvent(eventType, data) {
    switch (eventType) {
      case 'workspace_activated':
        this.currentWorkspaceId = data?.id;
        this._renderSidebar();
        break;
      case 'set_activated':
        this.currentSetId = data?.id;
        this._renderView();
        break;
      case 'lens_activated':
        this.currentLensId = data?.id;
        this._renderView();
        break;
      case 'focus_activated':
        this.currentFocusId = data?.id;
        this._renderView();
        break;
      case 'export_created':
        this._showNotification('Export created: ' + data.name);
        break;
    }
  }

  _createDefaultSet() {
    // EO-LAKE PRINCIPLE: SETs exist on the interpretation layer.
    // No real data exists in SETs - it all references data that originates in source.
    // Even sample/demo data must have a backing source.

    const timestamp = new Date().toISOString();

    // Create a "Sample" project to hold the sample data
    // This is created directly without UI side effects during initialization
    const sampleProject = {
      id: 'proj_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 9),
      name: 'Sample',
      description: 'Sample project with demo data',
      icon: 'ph-flask',
      color: '#8B5CF6', // Purple color for sample
      sourceIds: [],
      setIds: [],
      definitionIds: [],
      exportIds: [],
      settings: {
        isDefault: false // Not the default project
      },
      createdAt: timestamp,
      updatedAt: timestamp,
      status: 'active',
      isSample: true, // Flag to identify sample data - can only be cleared via Clear Sample Data
      getItemCount() {
        return (this.sourceIds?.length || 0) + (this.setIds?.length || 0) +
               (this.definitionIds?.length || 0) + (this.exportIds?.length || 0);
      }
    };
    if (!this.projects) this.projects = [];
    this.projects.push(sampleProject);

    // Initialize sourceStore if needed
    if (!this.sourceStore) {
      this._initSourceStore();
    }

    // Create type field with choices (for different record subtypes)
    const typeChoices = [
      { id: generateId(), name: 'Task', color: 'blue' },
      { id: generateId(), name: 'Bug', color: 'red' },
      { id: generateId(), name: 'Feature Request', color: 'green' }
    ];

    // Create status field with choices
    const statusChoices = [
      { id: generateId(), name: 'Backlog', color: 'gray' },
      { id: generateId(), name: 'In Progress', color: 'blue' },
      { id: generateId(), name: 'Review', color: 'yellow' },
      { id: generateId(), name: 'Complete', color: 'green' }
    ];

    // Create priority field with choices
    const priorityChoices = [
      { id: generateId(), name: 'Low', color: 'gray' },
      { id: generateId(), name: 'Medium', color: 'yellow' },
      { id: generateId(), name: 'High', color: 'orange' },
      { id: generateId(), name: 'Urgent', color: 'red' }
    ];

    // Create severity field with choices (for Bugs)
    const severityChoices = [
      { id: generateId(), name: 'Minor', color: 'gray' },
      { id: generateId(), name: 'Major', color: 'orange' },
      { id: generateId(), name: 'Critical', color: 'red' },
      { id: generateId(), name: 'Blocker', color: 'purple' }
    ];

    // Create business value field with choices (for Feature Requests)
    const businessValueChoices = [
      { id: generateId(), name: 'Nice to Have', color: 'gray' },
      { id: generateId(), name: 'Important', color: 'blue' },
      { id: generateId(), name: 'Critical', color: 'orange' },
      { id: generateId(), name: 'Must Have', color: 'red' }
    ];

    // Helper to get date string offset from today
    const getDate = (daysOffset) => {
      const date = new Date();
      date.setDate(date.getDate() + daysOffset);
      return date.toISOString().split('T')[0];
    };

    // Sample project data with different subtypes - this is the GIVEN data that will live in the source
    // Each subtype has common fields (Name, Type, Status, Priority, Notes) plus type-specific fields
    const projectData = [
      // === TASKS (4 records) ===
      {
        Name: 'User authentication system',
        Type: typeChoices[0].name, // Task
        Status: statusChoices[2].name, // Review
        Priority: priorityChoices[2].name, // High
        'Due Date': getDate(3),
        'Estimate (hrs)': 16,
        Assignee: 'Alice Chen',
        Completed: false,
        Notes: 'Implement OAuth2 with Google and GitHub providers. Include password reset flow.'
      },
      {
        Name: 'Dashboard redesign implementation',
        Type: typeChoices[0].name, // Task
        Status: statusChoices[1].name, // In Progress
        Priority: priorityChoices[1].name, // Medium
        'Due Date': getDate(7),
        'Estimate (hrs)': 24,
        Assignee: 'Bob Martinez',
        Completed: false,
        Notes: 'Implement new layout with improved data visualization. Focus on mobile responsiveness.'
      },
      {
        Name: 'Database migration to PostgreSQL 16',
        Type: typeChoices[0].name, // Task
        Status: statusChoices[0].name, // Backlog
        Priority: priorityChoices[1].name, // Medium
        'Due Date': getDate(21),
        'Estimate (hrs)': 20,
        Assignee: 'Carol Wu',
        Completed: false,
        Notes: 'Migrate from PostgreSQL 12 to 16. Plan for zero-downtime deployment.'
      },
      {
        Name: 'API documentation update',
        Type: typeChoices[0].name, // Task
        Status: statusChoices[3].name, // Complete
        Priority: priorityChoices[0].name, // Low
        'Due Date': getDate(-2),
        'Estimate (hrs)': 8,
        Assignee: 'David Kim',
        Completed: true,
        Notes: 'OpenAPI spec and usage examples for all public endpoints.'
      },
      // === BUGS (3 records) ===
      {
        Name: 'Login fails on Safari browser',
        Type: typeChoices[1].name, // Bug
        Status: statusChoices[1].name, // In Progress
        Priority: priorityChoices[2].name, // High
        Severity: severityChoices[2].name, // Critical
        'Reported By': 'QA Team',
        'Affected Version': '2.3.1',
        'Steps to Reproduce': '1. Open Safari 17+\n2. Navigate to login page\n3. Enter valid credentials\n4. Click Login button\n5. Page hangs indefinitely',
        Notes: 'Appears to be related to the new session handling code.'
      },
      {
        Name: 'Dashboard charts not rendering on mobile',
        Type: typeChoices[1].name, // Bug
        Status: statusChoices[0].name, // Backlog
        Priority: priorityChoices[1].name, // Medium
        Severity: severityChoices[1].name, // Major
        'Reported By': 'Customer Support',
        'Affected Version': '2.3.0',
        'Steps to Reproduce': '1. Open app on mobile device\n2. Navigate to dashboard\n3. Charts show blank area',
        Notes: 'Affects iOS and Android. Desktop works fine.'
      },
      {
        Name: 'Export CSV truncates long text fields',
        Type: typeChoices[1].name, // Bug
        Status: statusChoices[2].name, // Review
        Priority: priorityChoices[0].name, // Low
        Severity: severityChoices[0].name, // Minor
        'Reported By': 'Alice Chen',
        'Affected Version': '2.2.5',
        'Steps to Reproduce': '1. Create record with notes > 500 chars\n2. Export to CSV\n3. Open CSV, text is cut off',
        Notes: 'Workaround: use JSON export instead.'
      },
      // === FEATURE REQUESTS (3 records) ===
      {
        Name: 'Dark mode support',
        Type: typeChoices[2].name, // Feature Request
        Status: statusChoices[1].name, // In Progress
        Priority: priorityChoices[2].name, // High
        'Business Value': businessValueChoices[2].name, // Critical
        'Requested By': 'Marketing Team',
        'Target Release': 'v3.0',
        Notes: 'Users have been requesting dark mode. Should follow system preferences by default.'
      },
      {
        Name: 'Bulk import from Excel',
        Type: typeChoices[2].name, // Feature Request
        Status: statusChoices[0].name, // Backlog
        Priority: priorityChoices[1].name, // Medium
        'Business Value': businessValueChoices[1].name, // Important
        'Requested By': 'Enterprise Sales',
        'Target Release': 'v3.1',
        Notes: 'Large customers need to import thousands of records from Excel. Current CSV import is too slow.'
      },
      {
        Name: 'Two-factor authentication',
        Type: typeChoices[2].name, // Feature Request
        Status: statusChoices[2].name, // Review
        Priority: priorityChoices[3].name, // Urgent
        'Business Value': businessValueChoices[3].name, // Must Have
        'Requested By': 'Security Team',
        'Target Release': 'v2.5',
        Notes: 'Required for SOC2 compliance. Support TOTP and SMS options.'
      }
    ];

    // Step 1: Create the backing SOURCE (GIVEN layer) with sample data
    const sourceId = generateId();
    const sourceFields = [
      // Common fields (all types)
      { name: 'Name', type: 'text' },
      { name: 'Type', type: 'text' },
      { name: 'Status', type: 'text' },
      { name: 'Priority', type: 'text' },
      { name: 'Notes', type: 'text' },
      // Task-specific fields
      { name: 'Due Date', type: 'date' },
      { name: 'Estimate (hrs)', type: 'number' },
      { name: 'Assignee', type: 'text' },
      { name: 'Completed', type: 'boolean' },
      // Bug-specific fields
      { name: 'Severity', type: 'text' },
      { name: 'Reported By', type: 'text' },
      { name: 'Affected Version', type: 'text' },
      { name: 'Steps to Reproduce', type: 'text' },
      // Feature Request-specific fields
      { name: 'Business Value', type: 'text' },
      { name: 'Requested By', type: 'text' },
      { name: 'Target Release', type: 'text' }
    ];

    const source = {
      id: sourceId,
      name: 'Projects (source)',
      type: 'source',
      origin: 'sample', // Sample data origin
      records: projectData, // Raw GIVEN data lives here
      recordCount: projectData.length,
      schema: {
        fields: sourceFields,
        inferenceDecisions: null
      },
      // Multi-record type analysis - this source contains different record types
      multiRecordAnalysis: {
        typeField: 'Type',
        types: [
          { value: 'Task', count: 4, specificFields: ['Due Date', 'Estimate (hrs)', 'Assignee', 'Completed'] },
          { value: 'Bug', count: 3, specificFields: ['Severity', 'Reported By', 'Affected Version', 'Steps to Reproduce'] },
          { value: 'Feature Request', count: 3, specificFields: ['Business Value', 'Requested By', 'Target Release'] }
        ],
        commonFields: ['Name', 'Type', 'Status', 'Priority', 'Notes'],
        divergenceScore: 0.65 // High divergence - many type-specific fields
      },
      fileIdentity: {
        originalFilename: null,
        contentHash: null,
        rawSize: null,
        encoding: 'utf-8',
        mimeType: 'application/json'
      },
      provenance: {
        identity_kind: 'sample',
        identity_scope: 'composite',
        designation_operator: 'rec',
        designation_mechanism: 'sample_data_creation',
        asserting_agent: 'system',
        authority_class: 'system',
        boundary_type: '+1',
        boundary_basis: 'set',
        container_id: 'Projects',
        container_stability: 'stable',
        containment_level: 'root',
        jurisdiction_present: false,
        temporal_mode: '0',
        temporal_justification: 'sample data for demonstration',
        fixation_event: 'default set initialization',
        validity_window: 'indefinite',
        reassessment_required: false
      },
      derivedSetIds: [],
      status: 'active',
      isSample: true, // Flag to identify sample data - can only be cleared via Clear Sample Data
      importedAt: timestamp,
      createdAt: timestamp
    };

    // Add source to sourceStore and sources array
    this.sourceStore.sources.set(sourceId, source);
    if (!this.sources) this.sources = [];
    this.sources.push(source);

    // Step 2: Create the SET (MEANT layer) that interprets the source
    const set = createSet('Projects');

    // Create fields with choices - these are the INTERPRETED field definitions
    // Common fields
    const typeField = createField('Type', FieldTypes.SELECT, { choices: typeChoices });
    const statusField = createField('Status', FieldTypes.SELECT, { choices: statusChoices });
    const priorityField = createField('Priority', FieldTypes.SELECT, { choices: priorityChoices });
    const notesField = createField('Notes', FieldTypes.LONG_TEXT);

    // Task-specific fields
    const dueDateField = createField('Due Date', FieldTypes.DATE);
    const estimateField = createField('Estimate (hrs)', FieldTypes.NUMBER, { precision: 1 });
    const assigneeField = createField('Assignee', FieldTypes.TEXT);
    const completedField = createField('Completed', FieldTypes.CHECKBOX);

    // Bug-specific fields
    const severityField = createField('Severity', FieldTypes.SELECT, { choices: severityChoices });
    const reportedByField = createField('Reported By', FieldTypes.TEXT);
    const affectedVersionField = createField('Affected Version', FieldTypes.TEXT);
    const stepsToReproduceField = createField('Steps to Reproduce', FieldTypes.LONG_TEXT);

    // Feature Request-specific fields
    const businessValueField = createField('Business Value', FieldTypes.SELECT, { choices: businessValueChoices });
    const requestedByField = createField('Requested By', FieldTypes.TEXT);
    const targetReleaseField = createField('Target Release', FieldTypes.TEXT);

    // Add sourceColumn mapping to each field for grounding
    const nameField = set.fields[0];
    nameField.sourceColumn = 'Name';
    typeField.sourceColumn = 'Type';
    statusField.sourceColumn = 'Status';
    priorityField.sourceColumn = 'Priority';
    notesField.sourceColumn = 'Notes';
    dueDateField.sourceColumn = 'Due Date';
    estimateField.sourceColumn = 'Estimate (hrs)';
    assigneeField.sourceColumn = 'Assignee';
    completedField.sourceColumn = 'Completed';
    severityField.sourceColumn = 'Severity';
    reportedByField.sourceColumn = 'Reported By';
    affectedVersionField.sourceColumn = 'Affected Version';
    stepsToReproduceField.sourceColumn = 'Steps to Reproduce';
    businessValueField.sourceColumn = 'Business Value';
    requestedByField.sourceColumn = 'Requested By';
    targetReleaseField.sourceColumn = 'Target Release';

    set.fields.push(
      typeField,
      statusField,
      priorityField,
      notesField,
      // Task-specific
      dueDateField,
      estimateField,
      assigneeField,
      completedField,
      // Bug-specific
      severityField,
      reportedByField,
      affectedVersionField,
      stepsToReproduceField,
      // Feature Request-specific
      businessValueField,
      requestedByField,
      targetReleaseField
    );

    // Helper to find choice ID by name
    const findChoiceId = (choices, name) => {
      const choice = choices.find(c => c.name === name);
      return choice ? choice.id : null;
    };

    // Step 3: Create records that REFERENCE source data (not duplicate it)
    projectData.forEach((project, index) => {
      const values = {
        // Common fields
        [nameField.id]: project.Name,
        [typeField.id]: findChoiceId(typeChoices, project.Type),
        [statusField.id]: findChoiceId(statusChoices, project.Status),
        [priorityField.id]: findChoiceId(priorityChoices, project.Priority),
        [notesField.id]: project.Notes,
        // Task-specific fields (may be undefined for other types)
        [dueDateField.id]: project['Due Date'] || null,
        [estimateField.id]: project['Estimate (hrs)'] || null,
        [assigneeField.id]: project.Assignee || null,
        [completedField.id]: project.Completed ?? null,
        // Bug-specific fields
        [severityField.id]: findChoiceId(severityChoices, project.Severity),
        [reportedByField.id]: project['Reported By'] || null,
        [affectedVersionField.id]: project['Affected Version'] || null,
        [stepsToReproduceField.id]: project['Steps to Reproduce'] || null,
        // Feature Request-specific fields
        [businessValueField.id]: findChoiceId(businessValueChoices, project['Business Value']),
        [requestedByField.id]: project['Requested By'] || null,
        [targetReleaseField.id]: project['Target Release'] || null
      };
      const record = createRecord(set.id, values);
      // Link record back to source via _sourceIndex
      record._sourceIndex = index;
      record._sourceId = sourceId;
      set.records.push(record);
    });

    // Step 4: Set up derivation and provenance linking set to source
    set.derivation = {
      strategy: 'direct',
      parentSourceId: sourceId,
      constraint: {
        selectedFields: sourceFields.map(f => f.name),
        filters: []
      },
      derivedBy: 'system',
      derivedAt: timestamp
    };

    set.datasetProvenance = {
      originalFilename: null,
      importedAt: timestamp,
      sourceId: sourceId,
      origin: 'sample',
      provenance: source.provenance
    };

    // Mark set as sample data - can only be cleared via Clear Sample Data
    set.isSample = true;

    // Step 5: Create record type views (lenses) for each subtype
    // Each lens filters to a specific type and shows only relevant fields

    // Define hidden fields for each lens (fields not relevant to that type)
    const taskHiddenFields = [severityField.id, reportedByField.id, affectedVersionField.id, stepsToReproduceField.id, businessValueField.id, requestedByField.id, targetReleaseField.id];
    const bugHiddenFields = [dueDateField.id, estimateField.id, assigneeField.id, completedField.id, businessValueField.id, requestedByField.id, targetReleaseField.id];
    const featureHiddenFields = [dueDateField.id, estimateField.id, assigneeField.id, completedField.id, severityField.id, reportedByField.id, affectedVersionField.id, stepsToReproduceField.id];

    // Tasks lens with multiple views
    set.views.push(createView('Tasks', 'table', {
      filters: [{ fieldId: typeField.id, operator: 'is', filterValue: findChoiceId(typeChoices, 'Task'), enabled: true }],
      hiddenFields: taskHiddenFields
    }, {
      recordType: 'Task',
      recordCount: 4,
      isRecordTypeView: true,
      icon: 'ph-check-square'
    }));

    set.views.push(createView('Tasks - Kanban', 'kanban', {
      filters: [{ fieldId: typeField.id, operator: 'is', filterValue: findChoiceId(typeChoices, 'Task'), enabled: true }],
      hiddenFields: taskHiddenFields,
      groupByFieldId: statusField.id
    }, {
      recordType: 'Task',
      recordCount: 4,
      isRecordTypeView: true,
      icon: 'ph-check-square'
    }));

    set.views.push(createView('Tasks - Calendar', 'calendar', {
      filters: [{ fieldId: typeField.id, operator: 'is', filterValue: findChoiceId(typeChoices, 'Task'), enabled: true }],
      hiddenFields: taskHiddenFields,
      dateFieldId: dueDateField.id
    }, {
      recordType: 'Task',
      recordCount: 4,
      isRecordTypeView: true,
      icon: 'ph-check-square'
    }));

    // Bugs lens with multiple views
    set.views.push(createView('Bugs', 'table', {
      filters: [{ fieldId: typeField.id, operator: 'is', filterValue: findChoiceId(typeChoices, 'Bug'), enabled: true }],
      hiddenFields: bugHiddenFields
    }, {
      recordType: 'Bug',
      recordCount: 3,
      isRecordTypeView: true,
      icon: 'ph-bug'
    }));

    set.views.push(createView('Bugs - By Severity', 'kanban', {
      filters: [{ fieldId: typeField.id, operator: 'is', filterValue: findChoiceId(typeChoices, 'Bug'), enabled: true }],
      hiddenFields: bugHiddenFields,
      groupByFieldId: severityField.id
    }, {
      recordType: 'Bug',
      recordCount: 3,
      isRecordTypeView: true,
      icon: 'ph-bug'
    }));

    set.views.push(createView('Bugs - Cards', 'cards', {
      filters: [{ fieldId: typeField.id, operator: 'is', filterValue: findChoiceId(typeChoices, 'Bug'), enabled: true }],
      hiddenFields: bugHiddenFields,
      cardTitleField: nameField.id
    }, {
      recordType: 'Bug',
      recordCount: 3,
      isRecordTypeView: true,
      icon: 'ph-bug'
    }));

    // Feature Requests lens with multiple views
    set.views.push(createView('Features', 'table', {
      filters: [{ fieldId: typeField.id, operator: 'is', filterValue: findChoiceId(typeChoices, 'Feature Request'), enabled: true }],
      hiddenFields: featureHiddenFields
    }, {
      recordType: 'Feature Request',
      recordCount: 3,
      isRecordTypeView: true,
      icon: 'ph-lightbulb'
    }));

    set.views.push(createView('Features - By Value', 'kanban', {
      filters: [{ fieldId: typeField.id, operator: 'is', filterValue: findChoiceId(typeChoices, 'Feature Request'), enabled: true }],
      hiddenFields: featureHiddenFields,
      groupByFieldId: businessValueField.id
    }, {
      recordType: 'Feature Request',
      recordCount: 3,
      isRecordTypeView: true,
      icon: 'ph-lightbulb'
    }));

    set.views.push(createView('Features - Cards', 'cards', {
      filters: [{ fieldId: typeField.id, operator: 'is', filterValue: findChoiceId(typeChoices, 'Feature Request'), enabled: true }],
      hiddenFields: featureHiddenFields,
      cardTitleField: nameField.id
    }, {
      recordType: 'Feature Request',
      recordCount: 3,
      isRecordTypeView: true,
      icon: 'ph-lightbulb'
    }));

    // Add a global Kanban view for status-based workflow (all types)
    set.views.push(createView('All - Kanban', 'kanban', {
      groupByFieldId: statusField.id
    }));

    // Register set with source
    source.derivedSetIds.push(set.id);

    this.sets.push(set);

    // Associate source and set with the Sample project
    sampleProject.sourceIds.push(sourceId);
    sampleProject.setIds.push(set.id);

    // Select the sample project so user is always in a project context
    this.currentProjectId = sampleProject.id;

    // Trigger auto-import key definition suggestions for sample data
    this._triggerKeySuggestions(source);

    this._saveData();
  }

  /**
   * Trigger key definition suggestions for a source
   * Updated to support new "keys in definitions by default" workflow
   *
   * @param {Object} source - Source object with schema
   * @param {DefinitionSource[]} stubDefinitions - Optional stub definitions from import
   * @private
   */
  _triggerKeySuggestions(source, stubDefinitions = null) {
    if (!source || !window.EOKeySuggestions) return;

    // NEW: If stub definitions provided, use the new definition population workflow
    if (stubDefinitions && stubDefinitions.length > 0) {
      const {
        addStubDefinitionsForPopulation,
        injectDefinitionPopulationStyles
      } = window.EOKeySuggestions;

      if (addStubDefinitionsForPopulation) {
        injectDefinitionPopulationStyles();
        addStubDefinitionsForPopulation(stubDefinitions, {
          showPanel: false,
          workbench: this
        });

        // Show notification for definitions needing population
        setTimeout(() => {
          this._showDefinitionPopulationNotification(stubDefinitions.length, source.id);
        }, 1000);
        return;
      }
    }

    // LEGACY: Fall back to old suggestion workflow
    const { autoImportSuggestions, injectKeySuggestionStyles } = window.EOKeySuggestions;

    // Inject styles
    injectKeySuggestionStyles();

    // Generate suggestions asynchronously
    setTimeout(async () => {
      try {
        const suggestions = await autoImportSuggestions(source, {
          showPanel: false, // Don't auto-show, we'll show via notification
          workbench: this
        });

        if (suggestions && suggestions.length > 0) {
          // Show notification banner after a brief delay
          setTimeout(() => {
            this._showKeySuggestionNotification(suggestions.length, source.id);
          }, 1000);
        }
      } catch (error) {
        console.warn('Key suggestion generation failed:', error);
      }
    }, 500);
  }

  /**
   * Show notification for definitions needing population
   * @param {number} count - Number of stub definitions
   * @param {string} sourceId - Source ID
   * @private
   */
  _showDefinitionPopulationNotification(count, sourceId) {
    if (!window.EOKeySuggestions || count === 0) return;

    const { getDefinitionPopulationStore } = window.EOKeySuggestions;
    const store = getDefinitionPopulationStore?.();
    const withSuggestions = store?.getDefinitionsWithSuggestionsCount() || 0;

    // Create notification banner
    const banner = document.createElement('div');
    banner.className = 'definition-population-banner';
    banner.innerHTML = `
      <div class="banner-icon">
        <i class="ph ph-book-open"></i>
      </div>
      <div class="banner-content">
        <strong>${count} new definitions created</strong>
        <span>${withSuggestions > 0 ?
          `${withSuggestions} have API suggestions ready` :
          'Click to populate with definitions'}</span>
      </div>
      <button class="btn btn-sm btn-primary">
        <i class="ph ph-pencil"></i>
        Populate Definitions
      </button>
      <button class="btn-icon banner-close">
        <i class="ph ph-x"></i>
      </button>
    `;

    // Style the banner
    banner.style.cssText = `
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
      border: 1px solid #f59e0b;
      border-radius: 8px;
      margin: 8px 16px;
      animation: slideIn 0.3s ease;
    `;

    // Handle click to show panel
    const openBtn = banner.querySelector('.btn-primary');
    openBtn.addEventListener('click', () => {
      this._showDefinitionPopulationPanel(sourceId);
      banner.remove();
    });

    // Handle close
    const closeBtn = banner.querySelector('.banner-close');
    closeBtn.addEventListener('click', () => {
      banner.classList.add('fade-out');
      setTimeout(() => banner.remove(), 300);
    });

    // Insert at top of content area
    const contentArea = document.getElementById('content-area');
    if (contentArea) {
      const existingBanner = contentArea.querySelector('.definition-population-banner');
      if (existingBanner) existingBanner.remove();
      contentArea.insertBefore(banner, contentArea.firstChild);
    }
  }

  /**
   * Show the definition population panel
   * @param {string} sourceId - Optional source ID to focus on
   */
  _showDefinitionPopulationPanel(sourceId = null) {
    if (!window.EOKeySuggestions) return;

    const {
      initDefinitionPopulationPanel,
      injectDefinitionPopulationStyles
    } = window.EOKeySuggestions;

    if (!initDefinitionPopulationPanel) {
      // Fall back to suggestion panel
      this._showKeySuggestionPanel(sourceId);
      return;
    }

    // Inject styles
    injectDefinitionPopulationStyles();

    // Show the overlay
    const overlay = this._getOrCreatePanelOverlay();
    overlay.classList.add('visible');

    // Initialize panel with container
    const panelContainer = overlay.querySelector('.panel-container');
    const panel = initDefinitionPopulationPanel({
      container: panelContainer,
      workbench: this
    });

    panel.show(sourceId);
  }

  /**
   * Lookup definition from external APIs
   * Opens the definition detail view with API lookup mode enabled
   * @param {string} definitionId - The definition ID to lookup
   */
  _lookupDefinitionFromAPIs(definitionId) {
    const definition = this.definitions.find(d => d.id === definitionId);
    if (!definition) return;

    // Get the term to search for
    const searchTerm = definition.term?.label || definition.term?.term || definition.name;
    if (!searchTerm) {
      this._showToast('Cannot lookup: no term name found', 'error');
      return;
    }

    // Show loading state
    this._showToast(`Looking up "${searchTerm}" in external sources...`, 'info');

    // If DefinitionAPI is available, trigger search
    if (window.DefinitionAPI) {
      window.DefinitionAPI.searchAll(searchTerm, { limit: 10 })
        .then(results => {
          // Store results as apiSuggestions on the definition
          if (results && results.length > 0) {
            definition.apiSuggestions = results;
            this._saveDefinitions();
            this._showToast(`Found ${results.length} suggestion(s) for "${searchTerm}"`, 'success');
            // Open definition detail to show/select from suggestions
            this._showDefinitionDetail(definitionId);
          } else {
            this._showToast(`No results found for "${searchTerm}"`, 'warning');
            // Still open detail so user can manually define
            this._showDefinitionDetail(definitionId);
          }
        })
        .catch(err => {
          console.error('Definition API lookup error:', err);
          this._showToast('API lookup failed. Opening definition for manual entry.', 'warning');
          this._showDefinitionDetail(definitionId);
        });
    } else {
      // Fall back to opening the definition detail
      this._showDefinitionDetail(definitionId);
    }
  }

  /**
   * Show notification for pending key suggestions
   * @param {number} count - Number of pending suggestions
   * @param {string} sourceId - Source ID
   * @private
   */
  _showKeySuggestionNotification(count, sourceId) {
    if (!window.EOKeySuggestions || count === 0) return;

    const { createSuggestionBanner } = window.EOKeySuggestions;

    const banner = createSuggestionBanner(count, () => {
      this._showKeySuggestionPanel(sourceId);
    });

    if (banner) {
      // Insert banner at top of content area
      const contentArea = document.getElementById('content-area');
      if (contentArea) {
        const existingBanner = contentArea.querySelector('.suggestion-banner');
        if (existingBanner) existingBanner.remove();
        contentArea.insertBefore(banner, contentArea.firstChild);
      }
    }
  }

  /**
   * Show the key suggestion panel
   * @param {string} sourceId - Optional source ID to focus on
   */
  _showKeySuggestionPanel(sourceId = null) {
    if (!window.EOKeySuggestions) return;

    const { initKeySuggestionPanel, injectKeySuggestionStyles } = window.EOKeySuggestions;

    // Inject styles
    injectKeySuggestionStyles();

    // Show the overlay
    const overlay = document.getElementById('key-suggestion-overlay');
    const container = document.getElementById('key-suggestion-container');

    if (overlay && container) {
      overlay.style.display = 'flex';

      // Initialize the panel
      const panel = initKeySuggestionPanel({
        container: container,
        workbench: this
      });

      // Override the hide method to also hide the overlay
      const originalHide = panel.hide.bind(panel);
      panel.hide = () => {
        originalHide();
        overlay.style.display = 'none';

        // Remove any suggestion banners
        const banner = document.querySelector('.suggestion-banner');
        if (banner) banner.remove();
      };

      panel.show(sourceId);

      // Close on overlay click (outside the panel)
      overlay.onclick = (e) => {
        if (e.target === overlay) {
          panel.hide();
        }
      };
    }
  }

  _bindElements() {
    this.elements = {
      sidebar: document.getElementById('app-sidebar'),
      setsNav: document.getElementById('sets-nav'),
      contentArea: document.getElementById('content-area'),
      detailPanel: document.getElementById('detail-panel'),
      modal: document.getElementById('modal-overlay'),
      contextMenu: document.getElementById('context-menu'),
      fieldTypePicker: document.getElementById('field-type-picker'),
      recordCount: document.getElementById('record-count'),
      selectedCount: document.getElementById('selected-count'),
      currentSetName: document.getElementById('current-set-name'),
      currentViewName: document.getElementById('current-view-name'),
      // Tab bar elements
      tabBar: document.getElementById('tab-bar'),
      tabBarTabs: document.getElementById('tab-bar-tabs'),
      newTabBtn: document.getElementById('new-tab-btn'),
      tabListBtn: document.getElementById('tab-list-btn'),
      tabScrollLeft: document.getElementById('tab-scroll-left'),
      tabScrollRight: document.getElementById('tab-scroll-right')
    };

    // Tab management state
    this.tossedItems = []; // Items that have been tossed (not deleted, just out of view)
    this.maxTossedItems = 10;
    this.tabListDropdownOpen = false;
    this.tabContextMenuOpen = false;

    // Activity stream - complete history of all actions
    this.activityLog = []; // Array of activity objects for the activity stream
    this.maxActivityLogSize = 500;

    // Pick Up state - for grabbing data from various sources
    this.pickedUp = null; // Currently picked up item { type, data, source }
  }

  _attachEventListeners() {
    // View switcher
    document.querySelectorAll('.view-switch-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const viewType = btn.dataset.view;
        this._switchViewType(viewType);
      });
    });

    // New project button
    document.getElementById('btn-new-project')?.addEventListener('click', () => {
      this._showNewProjectModal();
    });

    // New set button
    document.getElementById('btn-new-set')?.addEventListener('click', () => {
      this._showNewSetModal();
    });

    // Import data button
    document.getElementById('btn-import-data')?.addEventListener('click', () => {
      this._showImportModal();
    });

    // Definition panel buttons
    document.getElementById('btn-new-definition')?.addEventListener('click', () => {
      this._showImportDefinitionModal();
    });

    document.getElementById('btn-import-definition-uri')?.addEventListener('click', () => {
      this._showImportDefinitionModal();
    });

    // Consolidated "New" action button and dropdown
    this._initNewActionDropdown();

    // File Explorer button
    document.getElementById('btn-file-explorer')?.addEventListener('click', () => {
      this._showFileExplorer();
    });

    // Explorer buttons for each panel
    document.getElementById('btn-sets-explorer')?.addEventListener('click', () => {
      this._showSetsTableView();
    });

    document.getElementById('btn-definitions-explorer')?.addEventListener('click', () => {
      this._showDefinitionsExplorer();
    });

    document.getElementById('btn-exports-explorer')?.addEventListener('click', () => {
      this._showExportsExplorer();
    });

    // Panel title click handlers - clicking panel names opens explorer views
    // Projects panel title click - show projects explorer
    const projectsPanel = document.querySelector('.projects-panel .nav-panel-title');
    projectsPanel?.addEventListener('click', () => {
      this._showProjectsExplorer();
    });

    // Sources panel title click - show file explorer
    const sourcesPanel = document.querySelector('.sources-panel .nav-panel-title');
    sourcesPanel?.addEventListener('click', () => {
      this._showFileExplorer();
    });

    // Definitions panel title click - show definitions explorer
    const definitionsPanel = document.querySelector('.definitions-panel .nav-panel-title');
    definitionsPanel?.addEventListener('click', () => {
      this._showDefinitionsExplorer();
    });

    // Sets panel title click - show sets table view
    const setsPanel = document.querySelector('.sets-panel .nav-panel-title');
    setsPanel?.addEventListener('click', () => {
      this._showSetsTableView();
    });

    // New export button
    document.getElementById('btn-new-export')?.addEventListener('click', () => {
      this._showNewExportModal();
    });

    // New view button
    document.getElementById('btn-new-view')?.addEventListener('click', () => {
      this._showNewViewModal();
    });

    // Sidebar collapse
    document.getElementById('sidebar-collapse')?.addEventListener('click', () => {
      this.elements.sidebar.classList.toggle('collapsed');
    });

    // Detail panel close
    document.getElementById('detail-panel-close')?.addEventListener('click', () => {
      this._closeDetailPanel();
    });

    // Pipeline panel events
    document.getElementById('pipeline-panel-close')?.addEventListener('click', () => {
      this._closePipelinePanel();
    });
    document.getElementById('pipeline-run-btn')?.addEventListener('click', () => {
      this._runPipeline();
    });
    document.getElementById('pipeline-add-step-btn')?.addEventListener('click', () => {
      this._showAddStepModal();
    });
    document.getElementById('pipeline-add-first-step')?.addEventListener('click', () => {
      this._showAddStepModal();
    });
    document.getElementById('pipeline-history-btn')?.addEventListener('click', () => {
      this._showPipelineHistory();
    });

    // Pipeline view toggle (list vs canvas)
    this._pipelineViewMode = 'list';
    document.getElementById('pipeline-view-toggle')?.addEventListener('click', (e) => {
      const btn = e.target.closest('.toggle-btn');
      if (!btn) return;
      const view = btn.dataset.view;
      if (view && view !== this._pipelineViewMode) {
        this._pipelineViewMode = view;
        document.querySelectorAll('#pipeline-view-toggle .toggle-btn').forEach(b => {
          b.classList.toggle('active', b.dataset.view === view);
        });
        this._renderPipelinePanel();
      }
    });

    // Modal close handlers
    document.getElementById('modal-close')?.addEventListener('click', () => this._closeModal());
    document.getElementById('modal-cancel')?.addEventListener('click', () => this._closeModal());
    document.getElementById('modal-overlay')?.addEventListener('click', (e) => {
      if (e.target === e.currentTarget) this._closeModal();
    });

    // Global keyboard shortcuts
    document.addEventListener('keydown', (e) => this._handleKeyDown(e));

    // Global click to close menus
    document.addEventListener('click', (e) => {
      // Global fallback handler for add record buttons
      // This catches clicks that might not bubble through the table's delegated handler
      const addRecordElement = e.target.closest('#add-row-btn, #add-row-cell, #add-first-record, .add-row-cell');
      if (addRecordElement) {
        e.preventDefault();
        e.stopPropagation();
        const record = this.addRecord();
        if (record) {
          this._showRecordDetail(record.id);
        }
        return;
      }

      if (!e.target.closest('.context-menu')) {
        this.elements.contextMenu?.classList.remove('active');
      }
      if (!e.target.closest('.field-type-picker') && !e.target.closest('.col-add') && !e.target.closest('.context-menu') && !e.target.closest('#fields-panel-add-field') && !e.target.closest('#fields-panel-empty-add')) {
        this.elements.fieldTypePicker?.classList.remove('active');
      }
      // Close New action dropdown when clicking outside
      if (!e.target.closest('.sidebar-new-action')) {
        const dropdown = document.getElementById('new-action-dropdown');
        if (dropdown) dropdown.style.display = 'none';
      }
    });

    // Mobile menu
    document.getElementById('mobile-menu-btn')?.addEventListener('click', () => {
      this._toggleMobileSidebar();
    });

    // Mobile panel backdrop - close panels when clicking backdrop
    document.getElementById('mobile-panel-backdrop')?.addEventListener('click', () => {
      this._closeMobilePanels();
    });

    // Mobile swipe gestures
    this._initMobileSwipeGestures();

    // Import button
    document.getElementById('btn-import')?.addEventListener('click', () => {
      if (typeof showImportModal === 'function') {
        showImportModal();
      }
    });

    // Export button (Rule 9: downloads and records)
    document.getElementById('btn-export')?.addEventListener('click', () => this._showNewExportModal());

    // New workspace button
    document.getElementById('btn-new-workspace')?.addEventListener('click', () => this._showNewWorkspaceModal());

    // Keyboard shortcuts modal
    document.getElementById('nav-keyboard-shortcuts')?.addEventListener('click', () => this._showKeyboardShortcuts());
    document.getElementById('shortcuts-modal-close')?.addEventListener('click', () => this._hideKeyboardShortcuts());
    document.getElementById('shortcuts-modal')?.addEventListener('click', (e) => {
      if (e.target.id === 'shortcuts-modal') this._hideKeyboardShortcuts();
    });

    // Sidebar footer collapse toggle
    document.getElementById('sidebar-footer-toggle')?.addEventListener('click', () => {
      const sidebarFooter = document.querySelector('.sidebar-footer');
      if (sidebarFooter) {
        sidebarFooter.classList.toggle('collapsed');
        // Save state to localStorage
        localStorage.setItem('sidebarFooterCollapsed', sidebarFooter.classList.contains('collapsed'));
      }
    });

    // Restore sidebar footer collapse state from localStorage
    const sidebarFooterCollapsed = localStorage.getItem('sidebarFooterCollapsed');
    if (sidebarFooterCollapsed === 'true') {
      document.querySelector('.sidebar-footer')?.classList.add('collapsed');
    }

    // Tossed items panel
    document.getElementById('nav-tossed-items')?.addEventListener('click', () => this._showTossedPanel());
    document.getElementById('tossed-panel-close')?.addEventListener('click', () => this._hideTossedPanel());
    document.getElementById('tossed-panel-done')?.addEventListener('click', () => this._hideTossedPanel());
    document.getElementById('tossed-clear-all')?.addEventListener('click', () => this._clearAllTossedItems());

    // Activity stream - opens as a tab
    document.getElementById('nav-activity-stream')?.addEventListener('click', () => this.openTab('activity'));
    // Keep panel close handlers for backwards compatibility
    document.getElementById('activity-panel-close')?.addEventListener('click', () => this._hideActivityPanel());
    document.getElementById('activity-panel-done')?.addEventListener('click', () => this._hideActivityPanel());
    document.getElementById('activity-filter-type')?.addEventListener('change', () => this._renderActivityPanel());
    document.getElementById('activity-filter-action')?.addEventListener('change', () => this._renderActivityPanel());

    // Sync panel
    document.getElementById('nav-sync')?.addEventListener('click', () => this._showSyncPanel());
    document.getElementById('sync-panel-close')?.addEventListener('click', () => this._hideSyncPanel());
    document.getElementById('sync-panel-cancel')?.addEventListener('click', () => this._hideSyncPanel());
    document.getElementById('sync-panel-save')?.addEventListener('click', () => this._saveSyncConfig());
    document.getElementById('sync-test-connection')?.addEventListener('click', () => this._testSyncConnection());
    document.getElementById('sync-now')?.addEventListener('click', () => this._triggerSync());
    document.getElementById('sync-token-toggle')?.addEventListener('click', () => this._toggleSyncTokenVisibility());
    document.getElementById('sync-enabled')?.addEventListener('change', () => this._updateSyncNowButton());

    // Bulk actions toolbar
    document.getElementById('bulk-duplicate')?.addEventListener('click', () => this._bulkDuplicate());
    document.getElementById('bulk-export')?.addEventListener('click', () => this._bulkExport());
    document.getElementById('bulk-delete')?.addEventListener('click', () => this._bulkDelete());
    // Use event delegation for close button to handle clicks on icon child element
    const closeBtn = document.getElementById('bulk-actions-close');
    if (closeBtn) {
      closeBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        this._clearSelection();
        this._showToast('Selection cleared', 'info');
      });
      // Also handle clicks on the icon inside the button
      closeBtn.addEventListener('mousedown', (e) => {
        e.preventDefault();
      });
    }

    // Add global fallback handler for bulk actions close button
    // This catches clicks that might not be handled by the direct handler
    document.addEventListener('click', (e) => {
      const closeTarget = e.target.closest('#bulk-actions-close, .bulk-actions-close');
      if (closeTarget) {
        e.preventDefault();
        e.stopPropagation();
        this._clearSelection();
        this._showToast('Selection cleared', 'info');
      }
    }, { capture: true });

    // Filter/Focus panel - Focus button opens the filter panel for creating focused views (Rule 5)
    document.getElementById('btn-filter')?.addEventListener('click', () => this._toggleFilterPanel());
    document.getElementById('filter-panel-close')?.addEventListener('click', () => this._hideFilterPanel());
    document.getElementById('add-filter-btn')?.addEventListener('click', () => this._addFilterRow());
    document.getElementById('filter-apply')?.addEventListener('click', () => this._applyFilters());
    document.getElementById('filter-clear')?.addEventListener('click', () => this._clearFilters());

    // Sort panel
    document.getElementById('btn-sort')?.addEventListener('click', () => this._toggleSortPanel());
    document.getElementById('sort-panel-close')?.addEventListener('click', () => this._hideSortPanel());
    document.getElementById('add-sort-btn')?.addEventListener('click', () => this._addSortRow());
    document.getElementById('sort-apply')?.addEventListener('click', () => this._applySorts());
    document.getElementById('sort-clear')?.addEventListener('click', () => this._clearSorts());

    // Fields/Schema panel (visibility & reordering)
    document.getElementById('btn-fields')?.addEventListener('click', () => this._toggleFieldsPanel());
    document.getElementById('fields-panel-close')?.addEventListener('click', () => this._hideFieldsPanel());
    document.getElementById('fields-show-all')?.addEventListener('click', () => this._showAllFields());
    document.getElementById('fields-hide-all')?.addEventListener('click', () => this._hideAllFields());
    document.getElementById('fields-apply')?.addEventListener('click', () => this._hideFieldsPanel());

    // Schema tabs (Structure vs Meaning)
    document.querySelectorAll('.schema-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        const tabName = tab.dataset.tab;
        // Update active tab
        document.querySelectorAll('.schema-tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        // Show/hide content
        document.getElementById('schema-structure-content')?.classList.toggle('hidden', tabName !== 'structure');
        document.getElementById('schema-meaning-content')?.classList.toggle('hidden', tabName !== 'meaning');
        // Render meaning tab content if needed
        if (tabName === 'meaning') {
          this._renderSchemaMeaningTab();
        }
      });
    });

    // Tab toolbar buttons
    document.getElementById('btn-filter-dropdown')?.addEventListener('click', () => {
      this._toggleFilterPanel();
    });
    document.getElementById('btn-sort-dropdown')?.addEventListener('click', () => {
      this._toggleSortPanel();
    });
    document.getElementById('btn-fields-dropdown')?.addEventListener('click', () => {
      this._toggleFieldsPanel();
    });
    document.getElementById('btn-pipeline-dropdown')?.addEventListener('click', () => {
      this._togglePipelinePanel();
    });
    document.getElementById('btn-import-dropdown')?.addEventListener('click', () => {
      if (typeof showImportModal === 'function') {
        showImportModal();
      }
    });
    document.getElementById('btn-export-dropdown')?.addEventListener('click', () => {
      this._showNewExportModal();
    });

    // Close dropdowns when clicking outside
    document.addEventListener('click', (e) => {
      const tagSelector = document.getElementById('set-tag-selector');
      if (tagSelector && !tagSelector.contains(e.target)) {
        this._hideSetTagDropdown();
      }
    });

    // Set tag selector
    document.getElementById('set-tag-btn')?.addEventListener('click', (e) => {
      e.stopPropagation();
      this._toggleSetTagDropdown();
    });

    // Note: Global search is handled by eo_app.js handleGlobalSearch() which supports
    // prefix-based search (@fields, #sets, /views, ?sources, >commands, !provenance)
    // The DataWorkbench _handleSearch is kept as a fallback for internal search needs
    // but does not need to be attached to the global-search input

    // Tab bar event listeners
    this._attachTabBarListeners();
  }

  /**
   * Attach tab bar event listeners
   */
  _attachTabBarListeners() {
    // New tab button
    this.elements.newTabBtn?.addEventListener('click', () => this._createNewTab());

    // Tab list dropdown button
    this.elements.tabListBtn?.addEventListener('click', (e) => {
      e.stopPropagation();
      this._toggleTabListDropdown();
    });

    // Tab scroll buttons
    this.elements.tabScrollLeft?.addEventListener('click', () => this._scrollTabs('left'));
    this.elements.tabScrollRight?.addEventListener('click', () => this._scrollTabs('right'));

    // Check for tab overflow on resize
    window.addEventListener('resize', () => this._checkTabOverflow());

    // Close dropdowns when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.tab-list-dropdown') && !e.target.closest('#tab-list-btn')) {
        this._closeTabListDropdown();
      }
      if (!e.target.closest('.tab-context-menu')) {
        this._closeTabContextMenu();
      }
    });

    // CRITICAL: Ensure data is saved before page unload
    // This prevents data loss during page refresh
    window.addEventListener('beforeunload', (e) => {
      // Commit any pending cell edits
      if (this.editingCell) {
        this._endCellEdit();
      }

      // Trigger a final synchronous save attempt
      // Note: async saves may not complete, but localStorage save should work
      try {
        // Force synchronous save to localStorage at minimum
        const quickSave = {
          sets: this.sets?.map(s => ({ ...s })) || [],
          currentSetId: this.currentSetId,
          currentViewId: this.currentViewId,
          browserTabs: this.browserTabs || [],
          activeTabId: this.activeTabId,
          _lastSave: new Date().toISOString()
        };
        // Only save if we have data to prevent overwriting with empty state
        if (this.sets?.length > 0 || this.browserTabs?.length > 0) {
          localStorage.setItem('eo_lake_backup', JSON.stringify(quickSave));
        }
      } catch (err) {
        console.warn('Failed to create backup on unload:', err);
      }
    });
  }

  // --------------------------------------------------------------------------
  // Persistence Event Handlers
  // --------------------------------------------------------------------------

  /**
   * Setup persistence handlers to ensure data survives page refresh/close
   */
  _setupPersistenceHandlers() {
    // Track pending save state
    this._pendingSave = null;
    this._lastSaveTime = null;

    // beforeunload - ensure data is saved before page closes
    window.addEventListener('beforeunload', (e) => {
      // Always do a sync save on page close to ensure data persists
      // This handles the case where async save hasn't completed yet
      this._saveDataSync();
    });

    // visibilitychange - save when tab becomes hidden (user switches tabs or minimizes)
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        // When tab is hidden, ensure data is saved
        this._saveDataSync();
      }
    });

    // pagehide - additional handler for mobile Safari and some browsers
    window.addEventListener('pagehide', () => {
      this._saveDataSync();
    });

    console.log('[Persistence] Event handlers registered');
  }

  // --------------------------------------------------------------------------
  // Data Persistence
  // --------------------------------------------------------------------------

  async _loadData() {
    try {
      const data = localStorage.getItem('eo_lake_data');

      // Check for backup data - this helps recover from interrupted saves
      const backupData = localStorage.getItem('eo_lake_backup');
      if (backupData && !data) {
        // Main data was lost but backup exists - try to recover
        console.log('[Recovery] Main data missing, attempting recovery from backup...');
        try {
          const backup = JSON.parse(backupData);
          if (backup.sets?.length > 0) {
            this.sets = backup.sets || [];
            this.currentSetId = backup.currentSetId;
            this.currentViewId = backup.currentViewId;
            this.browserTabs = backup.browserTabs || [];
            this.activeTabId = backup.activeTabId;
            console.log('[Recovery] Recovered data from backup:', {
              sets: this.sets.length,
              tabs: this.browserTabs.length
            });
            // Clear backup after successful recovery
            localStorage.removeItem('eo_lake_backup');
            // Still need to load IndexedDB records for recovered data
            await this._loadRecordsFromIndexedDBOnStartup();
            return; // Skip normal loading since we recovered
          }
        } catch (backupErr) {
          console.warn('[Recovery] Failed to parse backup:', backupErr);
        }
      }

      if (data) {
        const parsed = JSON.parse(data);

        // Clear old backup if main data is intact
        if (backupData) {
          localStorage.removeItem('eo_lake_backup');
        }

        // Load projects (super objects containing sources, sets, definitions, exports)
        this.projects = (parsed.projects || []).map(p => ({
          ...p,
          // Restore helper method
          getItemCount() {
            return (this.sourceIds?.length || 0) + (this.setIds?.length || 0) +
                   (this.definitionIds?.length || 0) + (this.exportIds?.length || 0);
          }
        }));
        this.currentProjectId = parsed.currentProjectId || null;

        // Load sources (CRITICAL for import functionality)
        this.sources = parsed.sources || [];

        // Load definitions (schema definitions from URIs)
        this.definitions = parsed.definitions || [];

        // Load exports (immutable frozen captures)
        this.exports = parsed.exports || [];

        // Performance: Use lazy loading for set records
        // Only load metadata initially, defer record loading
        if (this._useLazyLoading && parsed.sets?.length > 1) {
          this.sets = parsed.sets.map(set => ({
            ...set,
            records: [], // Defer loading records
            _recordsLoaded: false,
            _recordCount: set.records?.length || 0
          }));
          this._fullSetData = parsed.sets; // Store full data for lazy loading
        } else {
          this.sets = parsed.sets || [];
        }

        this.currentSetId = parsed.currentSetId;
        this.currentViewId = parsed.currentViewId;
        this.lastViewPerSet = parsed.lastViewPerSet || {};

        // Load tossed items (for trash bin / recovery)
        this.tossedItems = parsed.tossedItems || [];

        // Load activity log (for activity stream)
        this.activityLog = parsed.activityLog || [];

        // Load browser tabs (persistent tabs feature)
        this.browserTabs = parsed.browserTabs || [];
        this.activeTabId = parsed.activeTabId || null;
        this.recentlyClosedTabs = parsed.recentlyClosedTabs || [];

        // Load records for current set immediately if using lazy loading
        if (this._useLazyLoading && this.currentSetId) {
          this._loadSetRecords(this.currentSetId);
        }

        // CRITICAL: Load records from IndexedDB for current set/sources that have _recordsInIndexedDB flag
        // This ensures data persists across page refresh
        // EO principle: GIVEN (records) must be present before MEANT (views) can render
        await this._loadRecordsFromIndexedDBOnStartup();

        // Migration: Validate all fields to ensure proper rendering (TABLE RULES 1, 3 & 5)
        // This fixes any legacy data that might have missing width, type, or other properties
        this.sets.forEach(set => {
          // TABLE RULES 1 & 3: Ensure valid field properties
          if (set.fields) {
            set.fields = set.fields.map(field => ensureValidField(field));
          }

          // Migration: Ensure displayNameFieldId property exists (defaults to null for first column fallback)
          if (set.displayNameFieldId === undefined) {
            set.displayNameFieldId = null;
          }

          // TABLE RULE 5: Validate and auto-repair field ID consistency
          // This catches issues from legacy data or corrupted imports
          const validation = validateFieldIdConsistency(set);
          if (!validation.isValid) {
            console.warn(`[RULE 5] Set "${set.name}" has field ID mismatches. Attempting auto-repair...`);
            const repair = repairFieldIdConsistency(set);
            if (repair.repaired) {
              console.log(`[RULE 5] Auto-repaired ${repair.changes.length} field ID issues in set "${set.name}"`);
            }
          }
        });

        // Initialize Definitions Set and sync existing definitions
        this._initializeDefinitionsSet();
      }
    } catch (e) {
      console.error('Failed to load data:', e);
    }
  }

  /**
   * Initialize the Definitions Set infrastructure
   * Creates the system Definitions Set and syncs existing definitions to it
   */
  _initializeDefinitionsSet() {
    try {
      const DefinitionsSetManager = typeof window !== 'undefined' &&
        window.EO?.DefinitionsSetManager;
      const DisambiguationEngine = typeof window !== 'undefined' &&
        window.EO?.DisambiguationEngine;

      if (!DefinitionsSetManager) {
        console.log('DefinitionsSetManager not available yet');
        return;
      }

      // Create manager instance
      this._definitionsSetManager = new DefinitionsSetManager(this);

      // Ensure the Definitions Set exists
      const defSet = this._definitionsSetManager.ensureDefinitionsSet();
      console.log('Definitions Set initialized:', defSet.id, 'with', defSet.records?.length || 0, 'records');

      // Sync existing workbench.definitions to the Definitions Set
      if (this.definitions?.length > 0) {
        const syncResult = this._definitionsSetManager.syncDefinitionsArrayToSet();
        console.log('Synced definitions to Definitions Set:', syncResult);
      }

      // Initialize disambiguation engine
      if (DisambiguationEngine) {
        this._disambiguationEngine = new DisambiguationEngine(this._definitionsSetManager);
        this._disambiguationEngine.initialize();
        console.log('Disambiguation engine initialized');
      }

      // Complete any pending definition links for sets
      const completePendingDefinitionLinks = window.EO?.completePendingDefinitionLinks;
      if (completePendingDefinitionLinks) {
        for (const set of this.sets || []) {
          const hasPendingLinks = set.fields?.some(f => f.pendingDefinitionLink);
          if (hasPendingLinks) {
            completePendingDefinitionLinks(set.id, this);
          }
        }
      }
    } catch (err) {
      console.warn('Failed to initialize Definitions Set:', err);
    }
  }

  /**
   * Get the Definitions Set Manager
   */
  getDefinitionsSetManager() {
    if (!this._definitionsSetManager) {
      this._initializeDefinitionsSet();
    }
    return this._definitionsSetManager;
  }

  /**
   * Get the Disambiguation Engine
   */
  getDisambiguationEngine() {
    if (!this._disambiguationEngine) {
      this._initializeDefinitionsSet();
    }
    return this._disambiguationEngine;
  }

  /**
   * Show disambiguation UI for a field
   * @param {string} setId - The set containing the field
   * @param {string} fieldId - The field ID or name
   * @param {Object} options - Options for the disambiguation panel
   */
  showFieldDisambiguation(setId, fieldId, options = {}) {
    const DisambiguationPanel = typeof window !== 'undefined' &&
      window.EO?.DisambiguationPanel;

    if (!DisambiguationPanel) {
      console.warn('DisambiguationPanel not available');
      return;
    }

    const set = this.sets?.find(s => s.id === setId);
    const field = set?.fields?.find(f => f.id === fieldId || f.name === fieldId);

    if (!field) {
      console.warn('Field not found:', fieldId);
      return;
    }

    // Get disambiguation status
    const engine = this.getDisambiguationEngine();
    const status = engine?.checkDisambiguation(field.name);

    // Get context from sibling fields
    const siblingFields = set.fields
      ?.filter(f => f.name !== field.name)
      ?.map(f => f.name) || [];

    // Get sample values
    const sampleValues = set.records
      ?.slice(0, 10)
      ?.map(r => r.values?.[field.id] || r.values?.[field.name])
      ?.filter(v => v != null) || [];

    // Resolve with context
    const resolution = engine?.resolveWithContext(field.name, {
      siblingFields,
      domain: set.domain || options.domain,
      sampleValues
    });

    // Create modal container
    const modal = document.createElement('div');
    modal.className = 'disambiguation-modal';
    modal.innerHTML = `
      <div class="disambiguation-modal-overlay"></div>
      <div class="disambiguation-modal-content"></div>
    `;
    document.body.appendChild(modal);

    // Create the panel
    const panel = new DisambiguationPanel({
      container: modal.querySelector('.disambiguation-modal-content'),
      term: field.name,
      candidates: resolution?.alternatives ? [resolution.bestMatch, ...resolution.alternatives] : status?.candidates || [],
      context: { siblingFields, domain: set.domain, sampleValues },
      bestMatch: resolution?.bestMatch,
      confidence: resolution?.confidence || 0,
      reasoning: resolution?.reasoning,
      onSelect: (definitionId, decision) => {
        // Link the field to the selected definition
        const manager = this.getDefinitionsSetManager();
        manager?.linkFieldToDefinition(setId, fieldId, definitionId, {
          method: decision.method,
          alternatives: decision.alternatives,
          context: decision.context
        });

        // Record the disambiguation decision
        engine?.recordDisambiguationDecision(definitionId, decision);

        // Save and refresh
        this._saveData();
        this._renderSetsNav();

        modal.remove();
        this._showNotification(`Linked "${field.name}" to definition`, 'success');
      },
      onCreateNew: (newDef) => {
        // Create new definition in Definitions Set
        const manager = this.getDefinitionsSetManager();
        const record = manager?.createDefinitionRecord({
          term: { term: newDef.term, label: newDef.label },
          status: 'complete',
          discoveredFrom: { fieldName: field.name, sourceId: set.id }
        });

        if (record) {
          // Set context signature
          if (newDef.contextSignature) {
            engine?.setContextSignature(record.id, newDef.contextSignature);
          }

          // Link the field
          manager?.linkFieldToDefinition(setId, fieldId, record.id, {
            method: 'user_creation'
          });

          // Save and refresh
          this._saveData();
          this._renderSetsNav();
        }

        modal.remove();
        this._showNotification(`Created and linked definition for "${field.name}"`, 'success');
      },
      onCancel: () => {
        modal.remove();
      }
    });
    panel.render();

    // Close on overlay click
    modal.querySelector('.disambiguation-modal-overlay')?.addEventListener('click', () => {
      modal.remove();
    });
  }

  /**
   * Lazy load records for a specific set
   * Performance: Defers record loading until set is accessed
   */
  _loadSetRecords(setId) {
    // First check for IndexedDB storage (takes priority over legacy lazy loading)
    const set = this.sets.find(s => s.id === setId);
    // Use undefined check specifically - empty array means already loaded (no records in IndexedDB)
    if (set && set._recordsInIndexedDB && set.records === undefined) {
      // Load from IndexedDB asynchronously and re-render when done
      this._ensureSetRecords(set).then(() => {
        this._renderView();
      });
      return;
    }

    // Legacy lazy loading from _fullSetData
    if (!this._fullSetData) return;

    const fullSet = this._fullSetData.find(s => s.id === setId);

    if (set && fullSet && !set._recordsLoaded) {
      set.records = fullSet.records || [];
      set._recordsLoaded = true;
    }
  }

  /**
   * CRITICAL: Load records from IndexedDB on startup for all sets/sources with _recordsInIndexedDB flag
   * This prevents data loss on page refresh by ensuring IndexedDB data is loaded before rendering
   */
  async _loadRecordsFromIndexedDBOnStartup() {
    const storage = typeof eoStorage !== 'undefined' ? eoStorage : null;
    if (!storage) return;

    // Track loading promises for current set (priority) and all other items
    const loadingPromises = [];

    // Priority 1: Load current set records first (user sees this immediately)
    if (this.currentSetId) {
      const currentSet = this.sets.find(s => s.id === this.currentSetId);
      // Check for undefined specifically - empty array means already loaded (no records in IndexedDB)
      if (currentSet && currentSet._recordsInIndexedDB && currentSet.records === undefined) {
        console.log(`[IndexedDB] Loading current set records: ${currentSet.name}`);
        loadingPromises.push(
          this._ensureSetRecords(currentSet).then(() => {
            console.log(`[IndexedDB] Loaded ${currentSet.records?.length || 0} records for current set`);
            // Re-render immediately after current set loads
            this._renderView();
          })
        );
      }
    }

    // Priority 2: Load all other sets with _recordsInIndexedDB flag (background)
    for (const set of this.sets) {
      // Check for undefined specifically - empty array means already loaded (no records in IndexedDB)
      if (set.id !== this.currentSetId && set._recordsInIndexedDB && set.records === undefined) {
        loadingPromises.push(
          this._ensureSetRecords(set).then(() => {
            console.log(`[IndexedDB] Background loaded ${set.records?.length || 0} records for set: ${set.name}`);
          })
        );
      }
    }

    // Priority 3: Load all sources with _recordsInIndexedDB flag
    for (const source of (this.sources || [])) {
      // Check for undefined specifically - empty array means already loaded (no records in IndexedDB)
      if (source._recordsInIndexedDB && source.records === undefined) {
        loadingPromises.push(
          this._ensureSourceRecords(source).then(() => {
            console.log(`[IndexedDB] Loaded ${source.records?.length || 0} records for source: ${source.name}`);
          })
        );
      }
    }

    // Wait for all to complete
    if (loadingPromises.length > 0) {
      try {
        await Promise.all(loadingPromises);
        console.log(`[IndexedDB] Completed loading ${loadingPromises.length} items from IndexedDB`);
      } catch (error) {
        console.error('[IndexedDB] Error loading records on startup:', error);
      }
    }
  }

  _saveData() {
    // Use hybrid storage: metadata in localStorage, records in IndexedDB
    // Track pending save for beforeunload handler
    this._pendingSave = this._saveDataHybrid();
    return this._pendingSave;
  }

  /**
   * Synchronous save fallback - saves metadata to localStorage immediately
   * Used by beforeunload to ensure data persists even if async save is pending
   */
  _saveDataSync() {
    try {
      // Serialize projects (strip helper methods)
      const projectsToSave = (this.projects || []).map(p => {
        const { getItemCount, ...cleanProject } = p;
        return cleanProject;
      });

      // For sync save, include records inline (skip IndexedDB)
      const sourcesToSave = (this.sources || []).map(source => {
        const sourceData = { ...source };
        // Keep records inline for sync save to ensure persistence
        return sourceData;
      });

      const setsToSave = (this.sets || []).map(set => {
        // For virtual sets, don't include records
        if (set.isVirtual || set.derivation?.operator === 'relational_merge') {
          const { records, ...setMetadata } = set;
          setMetadata.isVirtual = true;
          setMetadata.recordCount = set.recordCount || null;
          return setMetadata;
        }
        // Keep records inline for sync save
        const { _recordsLoaded, _recordCount, ...setData } = set;
        return setData;
      });

      const dataToSave = {
        projects: projectsToSave,
        currentProjectId: this.currentProjectId,
        sources: sourcesToSave,
        definitions: this.definitions || [],
        exports: this.exports || [],
        sets: setsToSave,
        currentSetId: this.currentSetId,
        currentViewId: this.currentViewId,
        lastViewPerSet: this.lastViewPerSet,
        tossedItems: (this.tossedItems || []).slice(0, 50), // Limit for quota
        activityLog: (this.activityLog || []).slice(0, 50), // Limit for quota
        browserTabs: this.browserTabs || [],
        activeTabId: this.activeTabId,
        recentlyClosedTabs: [],
        _storageVersion: 2,
        _syncSave: true // Mark as sync save
      };

      localStorage.setItem('eo_lake_data', JSON.stringify(dataToSave));
      console.log('[Persistence] Sync save completed');
    } catch (e) {
      console.error('[Persistence] Sync save failed:', e);
    }
  }

  /**
   * Hybrid save: stores metadata in localStorage, large record data in IndexedDB
   * This solves the localStorage quota issue for large datasets
   */
  async _saveDataHybrid() {
    // Initialize IndexedDB storage if available
    const storage = typeof eoStorage !== 'undefined' ? eoStorage : null;

    // Serialize projects (strip helper methods)
    const projectsToSave = (this.projects || []).map(p => {
      const { getItemCount, ...cleanProject } = p;
      return cleanProject;
    });

    // Prepare sources for localStorage - strip records, store in IndexedDB
    const sourcesToSave = await this._prepareSourcesForSave(storage);

    // Prepare sets for localStorage - strip records from non-virtual sets
    const setsToSave = await this._prepareSetsForSave(storage);

    // Prepare data with configurable trimming levels for quota management
    const prepareDataForSave = (trimLevel = 0) => {
      // Progressive trimming based on level:
      // 0: No trimming (metadata only - records already in IndexedDB)
      // 1: Reduce activity log to 100, clear recently closed tabs
      // 2: Reduce activity log to 50, clear tossed items older than 1 day
      // 3: Reduce activity log to 20, clear all tossed items
      // 4: Clear activity log entirely, minimal data only

      let activityLogToSave = this.activityLog || [];
      let tossedItemsToSave = this.tossedItems || [];
      let recentlyClosedToSave = this.recentlyClosedTabs || [];

      if (trimLevel >= 1) {
        activityLogToSave = activityLogToSave.slice(0, 100);
        recentlyClosedToSave = [];
      }
      if (trimLevel >= 2) {
        activityLogToSave = activityLogToSave.slice(0, 50);
        const oneDayAgo = Date.now() - (24 * 60 * 60 * 1000);
        tossedItemsToSave = tossedItemsToSave.filter(item =>
          item.tossedAt && new Date(item.tossedAt).getTime() > oneDayAgo
        );
      }
      if (trimLevel >= 3) {
        activityLogToSave = activityLogToSave.slice(0, 20);
        tossedItemsToSave = [];
      }
      if (trimLevel >= 4) {
        activityLogToSave = [];
      }

      return {
        projects: projectsToSave,
        currentProjectId: this.currentProjectId,
        sources: sourcesToSave,
        definitions: this.definitions || [],
        exports: this.exports || [],
        sets: setsToSave,
        currentSetId: this.currentSetId,
        currentViewId: this.currentViewId,
        lastViewPerSet: this.lastViewPerSet,
        tossedItems: tossedItemsToSave,
        activityLog: activityLogToSave,
        browserTabs: this.browserTabs || [],
        activeTabId: this.activeTabId,
        recentlyClosedTabs: recentlyClosedToSave,
        _storageVersion: 2, // Mark as hybrid storage format
        _hasIndexedDB: !!storage
      };
    };

    // Try saving with progressive data trimming on quota errors
    let lastError = null;
    for (let trimLevel = 0; trimLevel <= 4; trimLevel++) {
      try {
        const dataToSave = prepareDataForSave(trimLevel);
        localStorage.setItem('eo_lake_data', JSON.stringify(dataToSave));

        // If we had to trim data, update our in-memory state to match
        if (trimLevel > 0) {
          if (trimLevel >= 1) {
            this.activityLog = dataToSave.activityLog;
            this.recentlyClosedTabs = dataToSave.recentlyClosedTabs;
          }
          if (trimLevel >= 2) {
            this.tossedItems = dataToSave.tossedItems;
          }
          // Show warning to user that data was trimmed
          this._showStorageWarning(trimLevel);
        }

        // Also create EO events if connected
        if (this.eoApp) {
          this._createEOEvent('data_saved', { timestamp: new Date().toISOString() });
        }

        // Update last saved time
        const lastSaved = document.querySelector('#last-saved span:last-child');
        if (lastSaved) {
          lastSaved.textContent = trimLevel > 0 ? 'Just now (trimmed)' : 'Just now';
        }
        return; // Success
      } catch (e) {
        lastError = e;
        if (e.name !== 'QuotaExceededError') {
          // Non-quota error, don't retry
          console.error('Failed to save data:', e);
          return;
        }
        // QuotaExceededError: try next trim level
      }
    }

    // All trim levels failed
    console.error('Failed to save data after all trim attempts:', lastError);
    this._showStorageError();
  }

  /**
   * Prepare sources for localStorage save - strips records and stores them in IndexedDB
   */
  async _prepareSourcesForSave(storage) {
    const sources = this.sources || [];
    const sourcesToSave = [];

    for (const source of sources) {
      // Create a copy without records for localStorage
      const { records, ...sourceMetadata } = source;

      // Store record count for reference
      sourceMetadata.recordCount = records?.length || source.recordCount || 0;
      sourceMetadata._recordsInIndexedDB = !!storage;

      // Store records in IndexedDB if available and source has records
      if (storage && records && records.length > 0) {
        try {
          await storage.storeSourceRecords(source.id, records);
        } catch (e) {
          console.warn(`Failed to store source records in IndexedDB for ${source.id}:`, e);
          // Fall back to storing inline if IndexedDB fails
          sourceMetadata.records = records;
          sourceMetadata._recordsInIndexedDB = false;
        }
      } else if (!storage && records) {
        // No IndexedDB, must store inline (legacy mode)
        sourceMetadata.records = records;
      }

      sourcesToSave.push(sourceMetadata);
    }

    return sourcesToSave;
  }

  /**
   * Prepare sets for localStorage save - handles virtual sets and strips records
   */
  async _prepareSetsForSave(storage) {
    // When using lazy loading, merge loaded records back into full set data
    let sets = this.sets;
    if (this._useLazyLoading && this._fullSetData) {
      sets = this._fullSetData.map(fullSet => {
        const loadedSet = this.sets.find(s => s.id === fullSet.id);
        if (loadedSet && loadedSet._recordsLoaded) {
          const { _recordsLoaded, _recordCount, ...cleanSet } = loadedSet;
          return cleanSet;
        }
        return fullSet;
      });
      this._fullSetData = sets;
    }

    const setsToSave = [];

    for (const set of sets) {
      // Virtual sets (merged sets) don't need record storage - they compute on demand
      if (set.isVirtual || set.derivation?.operator === 'relational_merge') {
        const { records, ...setMetadata } = set;
        setMetadata.isVirtual = true;
        setMetadata.recordCount = set.recordCount || null; // May be computed later
        setsToSave.push(setMetadata);
        continue;
      }

      // Non-virtual sets - store records in IndexedDB if available
      const { records, _recordsLoaded, _recordCount, ...setMetadata } = set;
      setMetadata.recordCount = records?.length || set.recordCount || 0;
      setMetadata._recordsInIndexedDB = !!storage;

      if (storage && records && records.length > 0) {
        try {
          await storage.storeSetRecords(set.id, records);
        } catch (e) {
          console.warn(`Failed to store set records in IndexedDB for ${set.id}:`, e);
          setMetadata.records = records;
          setMetadata._recordsInIndexedDB = false;
        }
      } else if (!storage && records) {
        setMetadata.records = records;
      }

      setsToSave.push(setMetadata);
    }

    return setsToSave;
  }

  _showStorageWarning(trimLevel) {
    // Avoid showing too many warnings
    if (this._lastStorageWarning && Date.now() - this._lastStorageWarning < 30000) {
      return;
    }
    this._lastStorageWarning = Date.now();

    const messages = [
      '',
      'Storage space low. Cleared recently closed tabs and trimmed activity history.',
      'Storage space very low. Cleared old tossed items.',
      'Storage space critical. Cleared all tossed items.',
      'Storage space exhausted. Cleared all activity history.'
    ];

    console.warn('Storage warning:', messages[trimLevel]);

    // Show visual notification
    this._showNotification(messages[trimLevel], 'warning');
  }

  _showStorageError() {
    // Avoid showing too many errors
    if (this._lastStorageError && Date.now() - this._lastStorageError < 60000) {
      return;
    }
    this._lastStorageError = Date.now();

    console.error('Storage quota exceeded. Unable to save data. Consider exporting your data or clearing browser storage.');
    this._showNotification('Storage full. Unable to save. Please export your data or clear browser storage.', 'error');
  }

  _showNotification(message, type = 'info') {
    // Create notification element if it doesn't exist
    let notification = document.getElementById('eo-storage-notification');
    if (!notification) {
      notification = document.createElement('div');
      notification.id = 'eo-storage-notification';
      notification.style.cssText = `
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 12px 20px;
        border-radius: 8px;
        font-size: 14px;
        z-index: 10000;
        max-width: 400px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        transition: opacity 0.3s ease;
      `;
      document.body.appendChild(notification);
    }

    // Style based on type
    if (type === 'error') {
      notification.style.backgroundColor = '#fee2e2';
      notification.style.color = '#991b1b';
      notification.style.border = '1px solid #fecaca';
    } else if (type === 'warning') {
      notification.style.backgroundColor = '#fef3c7';
      notification.style.color = '#92400e';
      notification.style.border = '1px solid #fde68a';
    } else {
      notification.style.backgroundColor = '#dbeafe';
      notification.style.color = '#1e40af';
      notification.style.border = '1px solid #bfdbfe';
    }

    notification.textContent = message;
    notification.style.display = 'block';
    notification.style.opacity = '1';

    // Auto-hide after delay
    clearTimeout(this._notificationTimeout);
    this._notificationTimeout = setTimeout(() => {
      notification.style.opacity = '0';
      setTimeout(() => {
        notification.style.display = 'none';
      }, 300);
    }, type === 'error' ? 10000 : 5000);
  }

  // --------------------------------------------------------------------------
  // Getters
  // --------------------------------------------------------------------------

  getCurrentSet() {
    return this.sets.find(s => s.id === this.currentSetId);
  }

  getCurrentView() {
    const set = this.getCurrentSet();
    // If a lens is selected, check lens views first
    if (this.currentLensId) {
      const lens = set?.lenses?.find(l => l.id === this.currentLensId);
      const lensView = lens?.views?.find(v => v.id === this.currentViewId);
      if (lensView) return lensView;
    }
    return set?.views.find(v => v.id === this.currentViewId);
  }

  getCurrentLens() {
    const set = this.getCurrentSet();
    return set?.lenses?.find(l => l.id === this.currentLensId);
  }

  /**
   * Get the current workspace name
   */
  _getCurrentWorkspaceName() {
    const workspace = this.viewRegistry?.getWorkspace?.(this.currentWorkspaceId);
    return workspace?.name || 'Workspace';
  }

  /**
   * Get the current project name for display in tab headers
   */
  _getCurrentProjectName() {
    if (!this.currentProjectId) return '';
    const project = this.projects.find(p => p.id === this.currentProjectId);
    return project?.name || 'Project';
  }

  /**
   * Get a record by its ID from the current set
   */
  _getRecordById(recordId) {
    const set = this.getCurrentSet();
    return set?.records?.find(r => r.id === recordId);
  }

  /**
   * Ensure a set has its records loaded/computed
   * Handles virtual sets (lazy merge computation) and IndexedDB storage
   */
  async _ensureSetRecords(set) {
    if (!set) return [];

    // Check if this is a virtual merged set that needs computation
    if (set.isVirtual || (set.derivation?.operator === 'relational_merge' && (!set.records || set.records.length === 0))) {
      return this._computeVirtualSetRecords(set);
    }

    // Check if records need to be loaded from IndexedDB
    // Use undefined check specifically - empty array means already loaded (no records in IndexedDB)
    if (set._recordsInIndexedDB && set.records === undefined) {
      return this._loadSetRecordsFromIndexedDB(set);
    }

    // Records are already available inline
    return set.records || [];
  }

  /**
   * Compute records for a virtual (merged) set
   */
  async _computeVirtualSetRecords(set) {
    const derivation = set.derivation;
    if (!derivation || derivation.operator !== 'relational_merge') {
      return set.records || [];
    }

    // Show loading indicator
    this._showToast('Computing merged data...', 'info');

    try {
      // Get the merge engine
      const engine = typeof mergeEngine !== 'undefined' ? mergeEngine : new MergeEngine();

      // Function to get source records by ID
      const getSourceRecords = async (sourceId) => {
        const source = this.sources?.find(s => String(s.id) === String(sourceId));
        if (!source) {
          throw new Error(`Source not found: ${sourceId}`);
        }

        // Check if records are in IndexedDB
        // Use undefined check specifically - empty array means already loaded (no records in IndexedDB)
        if (source._recordsInIndexedDB && source.records === undefined) {
          return this._loadSourceRecordsFromIndexedDB(source);
        }

        return source.records || [];
      };

      // Compute the merge
      const result = await engine.computeMerge(set, getSourceRecords);

      if (!result.success) {
        this._showToast(`Merge computation failed: ${result.error}`, 'error');
        return [];
      }

      // Cache the computed records on the set object
      set.records = result.records;
      set.recordCount = result.totalCount;
      set._computedAt = new Date().toISOString();

      // Also cache in IndexedDB for faster subsequent access
      const storage = typeof eoStorage !== 'undefined' ? eoStorage : null;
      if (storage) {
        await storage.storeMergeResult(set.id, result);
      }

      this._showToast(`Computed ${result.totalCount} merged records`, 'success');
      return result.records;

    } catch (error) {
      console.error('Failed to compute virtual set records:', error);
      this._showToast(`Error computing merge: ${error.message}`, 'error');
      return [];
    }
  }

  /**
   * Load set records from IndexedDB
   */
  async _loadSetRecordsFromIndexedDB(set) {
    const storage = typeof eoStorage !== 'undefined' ? eoStorage : null;
    if (!storage) {
      return set.records || [];
    }

    try {
      // First check if there's a cached merge result
      if (set.isVirtual) {
        const cached = await storage.getMergeResult(set.id);
        if (cached) {
          set.records = cached.records;
          set.recordCount = cached.totalCount;
          return cached.records;
        }
      }

      // Load from set_records store
      const records = await storage.getSetRecords(set.id);
      set.records = records;
      return records;
    } catch (error) {
      console.error('Failed to load set records from IndexedDB:', error);
      return set.records || [];
    }
  }

  /**
   * Load source records from IndexedDB
   */
  async _loadSourceRecordsFromIndexedDB(source) {
    const storage = typeof eoStorage !== 'undefined' ? eoStorage : null;
    if (!storage) {
      return source.records || [];
    }

    try {
      const records = await storage.getSourceRecords(source.id);
      source.records = records;
      return records;
    } catch (error) {
      console.error('Failed to load source records from IndexedDB:', error);
      return source.records || [];
    }
  }

  /**
   * Ensure a source has its records loaded from IndexedDB if needed
   * Similar to _ensureSetRecords but for sources
   */
  async _ensureSourceRecords(source) {
    if (!source) return [];

    // Check if records need to be loaded from IndexedDB
    // Use undefined check specifically - empty array means already loaded (no records in IndexedDB)
    if (source._recordsInIndexedDB && source.records === undefined) {
      return this._loadSourceRecordsFromIndexedDB(source);
    }

    // Records are already available inline
    return source.records || [];
  }

  getFilteredRecords() {
    const set = this.getCurrentSet();
    const view = this.getCurrentView();
    if (!set) return [];

    // Safety check: If records are in IndexedDB but not loaded, trigger async load
    // This should rarely happen if _loadRecordsFromIndexedDBOnStartup and _selectSet work correctly
    // Use undefined check specifically - empty array means already loaded (no records in IndexedDB)
    if (set._recordsInIndexedDB && set.records === undefined) {
      console.warn('[DATA INTEGRITY] Records in IndexedDB not yet loaded - triggering background load');
      this._ensureSetRecords(set).then(() => {
        // Re-render once records are loaded
        this._renderView();
      });
      // Return empty for now, will be populated after async load
      return [];
    }

    // For virtual sets, records may need to be computed asynchronously
    // Use cached records if available, otherwise return empty and trigger async load
    let records = [...(set.records || [])];

    // Apply lens filter if a lens is selected
    const lens = this.getCurrentLens();
    if (lens && lens.pivotFieldId !== undefined) {
      records = records.filter(r => {
        const val = r.values?.[lens.pivotFieldId];
        if (Array.isArray(val)) {
          return val.includes(lens.pivotValue);
        }
        return val === lens.pivotValue;
      });
    }

    // Apply filters (only enabled filters)
    if (view?.config.filters?.length > 0) {
      records = records.filter(record => {
        return view.config.filters.every(filter => {
          // Skip disabled filters
          if (filter.enabled === false) return true;
          const value = record.values[filter.fieldId];
          return this._matchesFilter(value, filter);
        });
      });
    }

    // Apply sorts
    if (view?.config.sorts?.length > 0) {
      records.sort((a, b) => {
        for (const sort of view.config.sorts) {
          const aVal = a.values[sort.fieldId];
          const bVal = b.values[sort.fieldId];
          const cmp = this._compareValues(aVal, bVal);
          if (cmp !== 0) return sort.direction === 'asc' ? cmp : -cmp;
        }
        return 0;
      });
    }

    return records;
  }

  _matchesFilter(value, filter) {
    const { operator, filterValue } = filter;
    switch (operator) {
      case 'is': return value === filterValue;
      case 'isNot': return value !== filterValue;
      case 'contains': return String(value || '').toLowerCase().includes(String(filterValue).toLowerCase());
      case 'doesNotContain': return !String(value || '').toLowerCase().includes(String(filterValue).toLowerCase());
      case 'isEmpty': return value == null || value === '';
      case 'isNotEmpty': return value != null && value !== '';
      case 'greaterThan': return Number(value) > Number(filterValue);
      case 'lessThan': return Number(value) < Number(filterValue);
      default: return true;
    }
  }

  _compareValues(a, b) {
    if (a == null && b == null) return 0;
    if (a == null) return -1;
    if (b == null) return 1;
    if (typeof a === 'string') return a.localeCompare(b);
    return a < b ? -1 : a > b ? 1 : 0;
  }

  // --------------------------------------------------------------------------
  // View Search
  // --------------------------------------------------------------------------

  /**
   * Handle view search input
   * Debounces the search to avoid excessive re-renders
   */
  _handleViewSearch(term) {
    // Clear any existing debounce timer
    if (this._searchDebounceTimer) {
      clearTimeout(this._searchDebounceTimer);
    }

    // Debounce the search
    this._searchDebounceTimer = setTimeout(() => {
      this.viewSearchTerm = term.trim();
      this._renderView();
    }, 150);
  }

  /**
   * Clear the view search
   */
  _clearViewSearch() {
    this.viewSearchTerm = '';
    this._renderView();
  }

  /**
   * Check if a record matches the current search term
   * Searches across all field values
   */
  _recordMatchesSearch(record, searchTerm, fields) {
    if (!searchTerm) return { matches: true, matchedFields: [] };

    const term = searchTerm.toLowerCase();
    const matchedFields = [];

    for (const field of fields) {
      const value = record.values[field.id];
      if (value == null) continue;

      let stringValue = '';

      // Handle different field types
      switch (field.type) {
        case FieldTypes.SELECT:
          const choice = field.options?.choices?.find(c => c.id === value);
          stringValue = choice?.name || '';
          break;
        case FieldTypes.MULTI_SELECT:
          if (Array.isArray(value)) {
            stringValue = value.map(v => {
              const choice = field.options?.choices?.find(c => c.id === v);
              return choice?.name || '';
            }).join(' ');
          }
          break;
        case FieldTypes.CHECKBOX:
          stringValue = value ? 'yes true checked' : 'no false unchecked';
          break;
        case FieldTypes.JSON:
          stringValue = typeof value === 'string' ? value : JSON.stringify(value);
          break;
        case FieldTypes.LINK:
          // For link fields, try to get linked record names
          if (Array.isArray(value)) {
            const linkedSet = this.sets.find(s => s.id === field.options?.linkedSetId);
            if (linkedSet) {
              // Use linkedFieldId if set, otherwise fall back to primary field
              const displayField = field.options?.linkedFieldId
                ? linkedSet.fields.find(f => f.id === field.options.linkedFieldId)
                : (linkedSet.fields.find(f => f.isPrimary) || linkedSet.fields[0]);
              stringValue = value.map(id => {
                const linkedRecord = linkedSet.records.find(r => r.id === id);
                return linkedRecord?.values[displayField?.id] || '';
              }).join(' ');
            }
          }
          break;
        default:
          stringValue = String(value);
      }

      if (stringValue.toLowerCase().includes(term)) {
        matchedFields.push(field.id);
      }
    }

    return {
      matches: matchedFields.length > 0,
      matchedFields
    };
  }

  /**
   * Get records filtered by the current search term
   * Returns records with matched field information for highlighting
   */
  getSearchFilteredRecords() {
    const set = this.getCurrentSet();
    const baseRecords = this.getFilteredRecords();

    if (!this.viewSearchTerm || !set) {
      return baseRecords.map(r => ({ record: r, matchedFields: [] }));
    }

    const fields = set.fields || [];
    const results = [];

    for (const record of baseRecords) {
      const { matches, matchedFields } = this._recordMatchesSearch(record, this.viewSearchTerm, fields);
      if (matches) {
        results.push({ record, matchedFields });
      }
    }

    return results;
  }

  /**
   * Highlight matching text in a string
   * Returns HTML with <mark> tags around matched portions
   */
  _highlightText(text, searchTerm) {
    if (!searchTerm || !text) return this._escapeHtml(String(text || ''));

    const escapedText = this._escapeHtml(String(text));
    const term = searchTerm.toLowerCase();
    const lowerText = String(text).toLowerCase();

    // Find all occurrences
    const parts = [];
    let lastIndex = 0;

    let index = lowerText.indexOf(term);
    while (index !== -1) {
      // Add text before match
      if (index > lastIndex) {
        parts.push(this._escapeHtml(String(text).substring(lastIndex, index)));
      }
      // Add highlighted match
      parts.push(`<mark class="search-highlight">${this._escapeHtml(String(text).substring(index, index + term.length))}</mark>`);
      lastIndex = index + term.length;
      index = lowerText.indexOf(term, lastIndex);
    }

    // Add remaining text
    if (lastIndex < text.length) {
      parts.push(this._escapeHtml(String(text).substring(lastIndex)));
    }

    return parts.join('');
  }

  // --------------------------------------------------------------------------
  // Sidebar Rendering
  // --------------------------------------------------------------------------

  _renderSidebar() {
    // Project-centric navigation: All content nested under each Project
    // Structure: Project → Sources (GIVEN) / Sets (SCHEMA) / Definitions (MEANT) / Exports (GIVEN)
    // This makes the SOURCE→SET→VIEW chain obvious and reduces confusion
    this._renderProjectsNavNested();
    // Update tab bar (view disclosure removed - views in sidebar only)
    this._renderTabBar();
  }

  /**
   * Progressive Disclosure: Update collapsible panel states
   * Auto-collapses empty Definitions and Exports panels
   * Expands panels when they have content or user manually expands
   */
  _updateCollapsiblePanels() {
    // Initialize panel expansion state if not exists
    if (!this.panelExpansionState) {
      this.panelExpansionState = {
        definitions: false,  // false = collapsed by default
        exports: null        // null = auto (collapsed when empty)
      };
    }

    // Get counts
    const definitionsCount = (this.definitions || []).filter(d => d.status !== 'archived').length;
    const exportsCount = (this.exports || []).length;

    // Update definitions panel
    const definitionsPanel = document.querySelector('.definitions-panel');
    if (definitionsPanel) {
      definitionsPanel.setAttribute('data-collapsible', 'true');
      const isExpanded = this.panelExpansionState.definitions === true;
      definitionsPanel.classList.toggle('collapsed', !isExpanded);
      definitionsPanel.classList.toggle('expanded', isExpanded);

      // Update count badge
      const countBadge = document.getElementById('definitions-count-badge');
      if (countBadge) {
        countBadge.textContent = definitionsCount;
        countBadge.style.display = definitionsCount > 0 || !isExpanded ? '' : 'none';
      }
    }

    // Update exports panel
    const exportsPanel = document.querySelector('.exports-panel');
    if (exportsPanel) {
      exportsPanel.setAttribute('data-collapsible', 'true');
      const isExpanded = this.panelExpansionState.exports === true ||
                        (this.panelExpansionState.exports === null && exportsCount > 0);
      exportsPanel.classList.toggle('collapsed', !isExpanded);
      exportsPanel.classList.toggle('expanded', isExpanded);

      // Update count badge
      const countBadge = document.getElementById('exports-count-badge');
      if (countBadge) {
        countBadge.textContent = exportsCount;
        countBadge.style.display = exportsCount > 0 || !isExpanded ? '' : 'none';
      }
    }

    // Attach click handlers for collapsible headers (once)
    this._attachCollapsiblePanelHandlers();
  }

  /**
   * Attach click handlers to collapsible panel headers
   */
  _attachCollapsiblePanelHandlers() {
    // Only attach once
    if (this._collapsibleHandlersAttached) return;
    this._collapsibleHandlersAttached = true;

    // Definitions panel header click
    const definitionsHeader = document.querySelector('.definitions-panel .nav-panel-header');
    if (definitionsHeader) {
      definitionsHeader.addEventListener('click', (e) => {
        // Don't toggle if clicking on action buttons
        if (e.target.closest('.nav-panel-actions')) return;

        const panel = definitionsHeader.closest('.nav-panel');
        const isCurrentlyExpanded = panel.classList.contains('expanded');

        // Toggle state - set explicit user preference
        this.panelExpansionState.definitions = !isCurrentlyExpanded;
        this._updateCollapsiblePanels();
      });
    }

    // Exports panel header click
    const exportsHeader = document.querySelector('.exports-panel .nav-panel-header');
    if (exportsHeader) {
      exportsHeader.addEventListener('click', (e) => {
        // Don't toggle if clicking on action buttons
        if (e.target.closest('.nav-panel-actions')) return;

        const panel = exportsHeader.closest('.nav-panel');
        const isCurrentlyExpanded = panel.classList.contains('expanded');

        // Toggle state - set explicit user preference
        this.panelExpansionState.exports = !isCurrentlyExpanded;
        this._updateCollapsiblePanels();
      });
    }
  }

  /**
   * Render View Disclosure Panel
   * Shows views for the current set prominently at the top when inside a set
   */
  _renderViewDisclosure() {
    const panel = document.getElementById('view-disclosure');
    const content = document.getElementById('view-disclosure-content');
    const setNameEl = document.getElementById('view-disclosure-set-name');
    const countEl = document.getElementById('view-disclosure-count');

    if (!panel || !content) return;

    const set = this.getCurrentSet();

    // Only show when we have a current set
    if (!set) {
      panel.style.display = 'none';
      return;
    }

    // Show the panel
    panel.style.display = 'block';

    // Update set name in title
    if (setNameEl) {
      setNameEl.textContent = `${set.name} Views`;
    }

    // Get views for current set
    const views = set.views || [];

    // Update count
    if (countEl) {
      countEl.textContent = `${views.length} view${views.length !== 1 ? 's' : ''}`;
    }

    // Render view items
    const viewIcons = {
      table: 'ph-table',
      cards: 'ph-cards',
      kanban: 'ph-kanban',
      calendar: 'ph-calendar-blank',
      graph: 'ph-graph',
      filesystem: 'ph-folder-open',
      timeline: 'ph-clock-countdown',
      pipeline: 'ph-cooking-pot',
      flow: 'ph-flow-arrow'
    };

    content.innerHTML = views.map(view => {
      const isActive = view.id === this.currentViewId;
      const icon = viewIcons[view.type] || 'ph-table';
      const epistemicBadge = this._getEpistemicStatusBadge(view);

      return `
        <div class="view-disclosure-item ${isActive ? 'active' : ''}"
             data-view-id="${view.id}"
             title="${view.type} view">
          <i class="ph ${icon}"></i>
          <span>${this._escapeHtml(view.name)}</span>
          <span class="view-disclosure-item-badge">${epistemicBadge}</span>
        </div>
      `;
    }).join('');

    // If no views, show prompt to create one
    if (views.length === 0) {
      content.innerHTML = `
        <div class="view-disclosure-empty">
          <span>No views yet. Click + to create one.</span>
        </div>
      `;
    }

    // Attach event handlers
    this._attachViewDisclosureHandlers();
  }

  /**
   * Attach event handlers for view disclosure panel
   */
  _attachViewDisclosureHandlers() {
    const panel = document.getElementById('view-disclosure');
    if (!panel) return;

    // Toggle collapse/expand
    const toggle = panel.querySelector('#view-disclosure-toggle');
    const header = panel.querySelector('.view-disclosure-header');

    // Header click toggles collapse
    header?.addEventListener('click', (e) => {
      // Don't toggle if clicking the add button
      if (e.target.closest('#view-disclosure-add')) return;
      panel.classList.toggle('collapsed');
      // Remember state
      localStorage.setItem('eo-view-disclosure-collapsed', panel.classList.contains('collapsed'));
    });

    // Restore collapse state
    const wasCollapsed = localStorage.getItem('eo-view-disclosure-collapsed') === 'true';
    if (wasCollapsed) {
      panel.classList.add('collapsed');
    }

    // View item clicks
    panel.querySelectorAll('.view-disclosure-item').forEach(item => {
      item.addEventListener('click', (e) => {
        e.stopPropagation();
        const viewId = item.dataset.viewId;
        if (viewId) {
          this._selectView(viewId);
        }
      });
    });

    // Add button
    const addBtn = panel.querySelector('#view-disclosure-add');
    addBtn?.addEventListener('click', (e) => {
      e.stopPropagation();
      this._showCreateViewModal();
    });
  }

  /**
   * Show modal to create a new view
   *
   * Views are configured with two dimensions:
   * - "Organize by" (Lens): How data is structured for understanding
   * - "Display as" (View): How the organized data is rendered
   *
   * The Lens is implicit infrastructure - users don't need to know
   * they're configuring a Lens, just that they're choosing how to
   * organize their data.
   */
  _showCreateViewModal() {
    const set = this.getCurrentSet();
    if (!set) {
      this._showToast('Please select a set first to create a new view', 'warning');
      return;
    }

    // Get fields that can be used for organization
    const fields = set?.fields || [];
    const selectFields = fields.filter(f => f.type === FieldTypes.SELECT || f.type === FieldTypes.MULTI_SELECT);
    const dateFields = fields.filter(f => f.type === FieldTypes.DATE);
    const linkFields = fields.filter(f => f.type === FieldTypes.LINK);

    // Build "Organize by" options
    const organizeOptions = [
      { value: 'none', label: 'None (flat list)', group: 'default' }
    ];

    // Add select fields for grouping
    selectFields.forEach(f => {
      organizeOptions.push({
        value: `field:${f.id}`,
        label: f.name,
        group: 'group',
        fieldType: 'select'
      });
    });

    // Add date fields for temporal organization
    dateFields.forEach(f => {
      organizeOptions.push({
        value: `date:${f.id}`,
        label: f.name,
        group: 'date',
        fieldType: 'date'
      });
    });

    // Add link fields for relationship/graph organization
    linkFields.forEach(f => {
      organizeOptions.push({
        value: `link:${f.id}`,
        label: f.name,
        group: 'relationship',
        fieldType: 'link'
      });
    });

    // Define all view types with descriptions (Airtable-style)
    const allViewTypes = [
      { value: 'table', icon: 'ph-table', label: 'Grid', desc: 'Rows and columns, like a spreadsheet' },
      { value: 'kanban', icon: 'ph-kanban', label: 'Kanban', desc: 'Stack cards by status or category' },
      { value: 'calendar', icon: 'ph-calendar-blank', label: 'Calendar', desc: 'Schedule by dates on a calendar' },
      { value: 'gallery', icon: 'ph-squares-four', label: 'Gallery', desc: 'Visual cards with images' },
      { value: 'timeline', icon: 'ph-chart-line-up', label: 'Timeline', desc: 'Events arranged over time' },
      { value: 'list', icon: 'ph-list-bullets', label: 'List', desc: 'Compact single-column list' },
      { value: 'gantt', icon: 'ph-chart-bar-horizontal', label: 'Gantt', desc: 'Project scheduling with dependencies' },
      { value: 'graph', icon: 'ph-graph', label: 'Graph', desc: 'Network of linked records' },
      { value: 'form', icon: 'ph-clipboard-text', label: 'Form', desc: 'Collect data with a shareable form' }
    ];

    const html = `
      <div class="create-view-form">
        <div class="form-group">
          <label for="view-name" class="form-label">View name</label>
          <input type="text" id="view-name" class="form-input" placeholder="My View" value="New View">
        </div>

        <div class="form-group">
          <label class="form-label">View type</label>
          <div class="view-type-grid" id="view-type-grid">
            ${allViewTypes.map((vt, idx) => `
              <div class="view-type-card ${idx === 0 ? 'selected' : ''}" data-value="${vt.value}">
                <div class="view-type-card-icon">
                  <i class="ph ${vt.icon}"></i>
                </div>
                <div class="view-type-card-label">${vt.label}</div>
                <div class="view-type-card-desc">${vt.desc}</div>
              </div>
            `).join('')}
          </div>
          <input type="hidden" id="view-display" value="table">
        </div>

        <div class="form-group">
          <label for="view-organize" class="form-label">Organize by</label>
          <select id="view-organize" class="form-select">
            <optgroup label="Default">
              <option value="none">None (flat list)</option>
            </optgroup>
            ${selectFields.length > 0 ? `
              <optgroup label="Group by field">
                ${selectFields.map(f => `<option value="field:${f.id}">${this._escapeHtml(f.name)}</option>`).join('')}
              </optgroup>
            ` : ''}
            ${dateFields.length > 0 ? `
              <optgroup label="By date">
                ${dateFields.map(f => `<option value="date:${f.id}">${this._escapeHtml(f.name)}</option>`).join('')}
              </optgroup>
            ` : ''}
            ${linkFields.length > 0 ? `
              <optgroup label="By relationship">
                ${linkFields.map(f => `<option value="link:${f.id}">${this._escapeHtml(f.name)}</option>`).join('')}
              </optgroup>
            ` : ''}
          </select>
          <span class="form-hint">How should records be structured?</span>
        </div>
      </div>
    `;

    this._showModal('Create New View', html, () => {
      const name = document.getElementById('view-name')?.value || 'New View';
      const organizeBy = document.getElementById('view-organize')?.value || 'none';
      const displayAs = document.getElementById('view-display')?.value || 'table';
      this._createNewViewWithLens(name, organizeBy, displayAs);
    });

    // Handle view type card selection
    setTimeout(() => {
      const viewTypeGrid = document.getElementById('view-type-grid');
      const displayInput = document.getElementById('view-display');

      if (viewTypeGrid && displayInput) {
        viewTypeGrid.querySelectorAll('.view-type-card').forEach(card => {
          card.addEventListener('click', () => {
            // Update selection
            viewTypeGrid.querySelectorAll('.view-type-card').forEach(c => {
              c.classList.remove('selected');
            });
            card.classList.add('selected');
            displayInput.value = card.dataset.value;
          });
        });
      }
    }, 0);
  }

  /**
   * Create a new view with lens configuration
   *
   * @param {string} name - View name
   * @param {string} organizeBy - Organization type (e.g., 'none', 'field:fld_123', 'date:fld_456')
   * @param {string} displayAs - Display type (e.g., 'table', 'kanban', 'calendar')
   */
  _createNewViewWithLens(name, organizeBy, displayAs) {
    const set = this.getCurrentSet();
    if (!set) {
      this._showToast('Please select a set first to create a new view', 'warning');
      return;
    }

    // Ensure views array exists
    if (!set.views) {
      set.views = [];
    }

    // Parse organize by value
    const [organizeType, fieldId] = organizeBy.includes(':')
      ? organizeBy.split(':')
      : [organizeBy, null];

    // Build view config with lens information embedded
    const viewConfig = {
      filters: [],
      sorts: [],
      groups: [],
      hiddenFields: [],
      fieldOrder: []
    };

    // Configure based on organization type
    if (organizeType === 'field' && fieldId) {
      viewConfig.groupByFieldId = fieldId;
    } else if (organizeType === 'date' && fieldId) {
      viewConfig.dateFieldId = fieldId;
    } else if (organizeType === 'link' && fieldId) {
      viewConfig.linkFieldId = fieldId;
    }

    // Store lens metadata for future reference
    viewConfig.lens = {
      type: organizeType,
      fieldId: fieldId || null
    };

    const newView = createView(name, displayAs, viewConfig);
    set.views.push(newView);

    // Switch to the new view
    this.currentViewId = newView.id;
    this.lastViewPerSet[this.currentSetId] = newView.id;

    // Record activity for activity stream
    this._recordActivity({
      action: 'create',
      entityType: 'view',
      name: name,
      details: `${displayAs} view organized by ${organizeType === 'none' ? 'flat list' : organizeType} in "${set.name}"`
    });

    // Re-render
    this._renderSidebar();
    this._renderView();
    this._updateBreadcrumb();
    this._saveData();
  }

  /**
   * Create a new view for the current set
   */
  _createNewView(name, type) {
    const set = this.getCurrentSet();
    if (!set) {
      this._showToast('Please select a set first to create a new view', 'warning');
      return;
    }

    // Ensure views array exists
    if (!set.views) {
      set.views = [];
    }

    const newView = createView(name, type);
    set.views.push(newView);

    // Switch to the new view
    this.currentViewId = newView.id;
    this.lastViewPerSet[this.currentSetId] = newView.id;

    // Record activity for activity stream
    this._recordActivity({
      action: 'create',
      entityType: 'view',
      name: name,
      details: `${type} view in "${set.name}"`
    });

    // Re-render
    this._renderSidebar();
    this._renderView();
    this._updateBreadcrumb();
    this._saveData();
  }

  /**
   * Show dialog to create a new view from New Tab page
   * Allows user to select a set first, then create view with lens configuration
   */
  _showNewViewFromNewTab() {
    const sets = this._getProjectSets();

    if (sets.length === 0) {
      this._showToast('No sets available. Create a set first.', 'warning');
      return;
    }

    // Define all view types with descriptions (Airtable-style)
    const allViewTypes = [
      { value: 'table', icon: 'ph-table', label: 'Grid', desc: 'Rows and columns, like a spreadsheet' },
      { value: 'kanban', icon: 'ph-kanban', label: 'Kanban', desc: 'Stack cards by status or category' },
      { value: 'calendar', icon: 'ph-calendar-blank', label: 'Calendar', desc: 'Schedule by dates on a calendar' },
      { value: 'gallery', icon: 'ph-squares-four', label: 'Gallery', desc: 'Visual cards with images' },
      { value: 'timeline', icon: 'ph-chart-line-up', label: 'Timeline', desc: 'Events arranged over time' },
      { value: 'list', icon: 'ph-list-bullets', label: 'List', desc: 'Compact single-column list' },
      { value: 'gantt', icon: 'ph-chart-bar-horizontal', label: 'Gantt', desc: 'Project scheduling with dependencies' },
      { value: 'graph', icon: 'ph-graph', label: 'Graph', desc: 'Network of linked records' },
      { value: 'form', icon: 'ph-clipboard-text', label: 'Form', desc: 'Collect data with a shareable form' }
    ];

    const html = `
      <div class="create-view-form">
        <div class="form-group">
          <label for="view-set-select" class="form-label">Select set</label>
          <select id="view-set-select" class="form-select">
            ${sets.map(set => `
              <option value="${set.id}">${this._escapeHtml(set.name)} (${(set.records || []).length} records)</option>
            `).join('')}
          </select>
        </div>

        <div class="form-group">
          <label for="view-name" class="form-label">View name</label>
          <input type="text" id="view-name" class="form-input" placeholder="My View" value="New View">
        </div>

        <div class="form-group">
          <label class="form-label">View type</label>
          <div class="view-type-grid" id="view-type-grid">
            ${allViewTypes.map((vt, idx) => `
              <div class="view-type-card ${idx === 0 ? 'selected' : ''}" data-value="${vt.value}">
                <div class="view-type-card-icon">
                  <i class="ph ${vt.icon}"></i>
                </div>
                <div class="view-type-card-label">${vt.label}</div>
                <div class="view-type-card-desc">${vt.desc}</div>
              </div>
            `).join('')}
          </div>
          <input type="hidden" id="view-display" value="table">
        </div>

        <div class="form-group">
          <label for="view-organize" class="form-label">Organize by</label>
          <select id="view-organize" class="form-select">
            <option value="none">None (flat list)</option>
          </select>
          <span class="form-hint">How should records be structured?</span>
        </div>
      </div>
    `;

    this._showModal('Create New View', html, () => {
      const setId = document.getElementById('view-set-select')?.value;
      const name = document.getElementById('view-name')?.value || 'New View';
      const organizeBy = document.getElementById('view-organize')?.value || 'none';
      const displayAs = document.getElementById('view-display')?.value || 'table';

      const set = this.sets.find(s => s.id === setId);
      if (!set) {
        this._showToast('Please select a set', 'error');
        return;
      }

      // Ensure views array exists
      if (!set.views) {
        set.views = [];
      }

      // Parse organize by value
      const [organizeType, fieldId] = organizeBy.includes(':')
        ? organizeBy.split(':')
        : [organizeBy, null];

      // Build view config with lens information embedded
      const viewConfig = {
        filters: [],
        sorts: [],
        groups: [],
        hiddenFields: [],
        fieldOrder: []
      };

      // Configure based on organization type
      if (organizeType === 'field' && fieldId) {
        viewConfig.groupByFieldId = fieldId;
      } else if (organizeType === 'date' && fieldId) {
        viewConfig.dateFieldId = fieldId;
      } else if (organizeType === 'link' && fieldId) {
        viewConfig.linkFieldId = fieldId;
      }

      // Store lens metadata
      viewConfig.lens = {
        type: organizeType,
        fieldId: fieldId || null
      };

      const newView = createView(name, displayAs, viewConfig);
      set.views.push(newView);

      // Switch to the set and new view
      this.currentSetId = set.id;
      this.currentViewId = newView.id;
      this.lastViewPerSet[set.id] = newView.id;

      // Open the set tab with the new view
      this.openTab('set', {
        contentId: set.id,
        title: set.name,
        icon: set.icon || 'ph-table'
      });

      // Record activity
      this._recordActivity({
        action: 'create',
        entityType: 'view',
        name: name,
        details: `${displayAs} view organized by ${organizeType === 'none' ? 'flat list' : organizeType} in "${set.name}"`
      });

      this._renderSidebar();
      this._renderView();
      this._updateBreadcrumb();
      this._saveData();
      this._showToast(`Created "${name}" view in "${set.name}"`, 'success');
    });

    // Handle set selection change and view type card selection
    setTimeout(() => {
      const setSelect = document.getElementById('view-set-select');
      const organizeSelect = document.getElementById('view-organize');
      const viewTypeGrid = document.getElementById('view-type-grid');
      const displayInput = document.getElementById('view-display');

      const updateOrganizeOptions = () => {
        const setId = setSelect?.value;
        const set = this.sets.find(s => s.id === setId);
        if (!set || !organizeSelect) return;

        const fields = set?.fields || [];
        const selectFields = fields.filter(f => f.type === FieldTypes.SELECT || f.type === FieldTypes.MULTI_SELECT);
        const dateFields = fields.filter(f => f.type === FieldTypes.DATE);
        const linkFields = fields.filter(f => f.type === FieldTypes.LINK);

        let html = `
          <optgroup label="Default">
            <option value="none">None (flat list)</option>
          </optgroup>
        `;

        if (selectFields.length > 0) {
          html += `
            <optgroup label="Group by field">
              ${selectFields.map(f => `<option value="field:${f.id}">${this._escapeHtml(f.name)}</option>`).join('')}
            </optgroup>
          `;
        }

        if (dateFields.length > 0) {
          html += `
            <optgroup label="By date">
              ${dateFields.map(f => `<option value="date:${f.id}">${this._escapeHtml(f.name)}</option>`).join('')}
            </optgroup>
          `;
        }

        if (linkFields.length > 0) {
          html += `
            <optgroup label="By relationship">
              ${linkFields.map(f => `<option value="link:${f.id}">${this._escapeHtml(f.name)}</option>`).join('')}
            </optgroup>
          `;
        }

        organizeSelect.innerHTML = html;
      };

      // Handle view type card selection
      if (viewTypeGrid && displayInput) {
        viewTypeGrid.querySelectorAll('.view-type-card').forEach(card => {
          card.addEventListener('click', () => {
            // Update selection
            viewTypeGrid.querySelectorAll('.view-type-card').forEach(c => {
              c.classList.remove('selected');
            });
            card.classList.add('selected');
            displayInput.value = card.dataset.value;
          });
        });
      }

      // Initial update
      updateOrganizeOptions();

      // Update on set change
      setSelect?.addEventListener('change', updateOrganizeOptions);
    }, 0);
  }

  /**
   * Render Sets with nested Views in sidebar (Panel 2: Schema)
   * FIX #2: Sets show derivation strategy and operator badges
   * Sets are MEANT events - interpretive schema definitions
   * Views are disclosed under each set when expanded
   */
  _renderSetsNavFlat() {
    const container = document.getElementById('sets-nav');
    if (!container) return;

    // Filter sets by project first, then by tag
    let filteredSets = this._getProjectSets();
    const totalSets = this.sets.length;

    // Update panel header with project context
    this._updatePanelProjectContext('sets', filteredSets.length, totalSets);

    if (this.currentSetTagFilter) {
      filteredSets = filteredSets.filter(set =>
        set.tags && set.tags.includes(this.currentSetTagFilter)
      );
    }

    if (filteredSets.length === 0) {
      container.innerHTML = `
        <div class="nav-empty-state">
          <i class="ph ph-funnel"></i>
          <span>${this.currentSetTagFilter ? 'No sets with this tag' : 'No sets yet'}</span>
          <div class="empty-actions">
            <button class="btn-link" id="btn-create-from-import">Import & Create Set</button>
            <span class="empty-divider">or</span>
            <button class="btn-link btn-secondary" id="btn-create-empty-set">Create Empty</button>
          </div>
        </div>
      `;
      container.querySelector('#btn-create-from-import')?.addEventListener('click', () => {
        this._showImportModal();
      });
      container.querySelector('#btn-create-empty-set')?.addEventListener('click', () => {
        this._showOperatorFirstCreationModal();
      });
      return;
    }

    // View type icons mapping
    const viewTypeIcons = {
      'grid': 'ph-table',
      'table': 'ph-table',
      'cards': 'ph-cards',
      'kanban': 'ph-kanban',
      'calendar': 'ph-calendar-blank',
      'graph': 'ph-graph',
      'filesystem': 'ph-folder-open',
      'timeline': 'ph-clock-countdown',
      'pipeline': 'ph-cooking-pot',
      'flow': 'ph-flow-arrow'
    };

    // Don't show any set as active when viewing a source
    const isViewingSource = !!this.currentSourceId;

    container.innerHTML = filteredSets.map(set => {
      const recordCount = set.records?.length || 0;
      const fieldCount = set.fields?.length || 0;
      const isExpanded = this.expandedSets[set.id] || set.id === this.currentSetId;
      const isActiveSet = !isViewingSource && set.id === this.currentSetId;
      const views = set.views || [];

      // Determine derivation strategy for operator badge
      const derivation = this._getSetDerivationInfo(set);
      const operatorBadge = this._getOperatorBadgeHTML(derivation.operator);

      // Check stability level
      const stability = set.stabilityLevel || 'holon';
      const stabilityClass = `stability-${stability}`;

      // Render nested views
      const viewsHtml = views.map(view => {
        const isActiveView = view.id === this.currentViewId && isActiveSet;
        const isRecordTypeView = view.metadata?.isRecordTypeView || view.metadata?.recordType;
        // For record type views, use a distinct icon; otherwise use view type icon
        const viewIcon = isRecordTypeView
          ? 'ph-stack'
          : (view.metadata?.icon || viewTypeIcons[view.type] || 'ph-table');
        // Show record count for views with metadata (e.g., type-filtered views)
        const viewCount = view.metadata?.recordCount;
        const countHtml = viewCount !== undefined ? `<span class="view-item-count">${viewCount}</span>` : '';
        return `
          <div class="set-view-item ${isActiveView ? 'active' : ''} ${isRecordTypeView ? 'record-type-view' : 'regular-view'}"
               data-view-id="${view.id}"
               data-set-id="${set.id}"
               title="${this._escapeHtml(view.name)} (${view.type})${isRecordTypeView ? ' · Record Type' : ''}${viewCount !== undefined ? ` · ${viewCount} records` : ''}">
            <i class="ph ${viewIcon}"></i>
            <span>${this._escapeHtml(view.name)}</span>
            ${countHtml}
          </div>
        `;
      }).join('');

      // Schema item (Structure & Meaning) - renamed from "Fields"
      const isFieldsActive = isActiveSet && this.showingSetFields;
      const fieldsItem = `
        <div class="set-view-item set-fields-item ${isFieldsActive ? 'active' : ''}"
             data-set-id="${set.id}"
             data-action="fields"
             title="Schema: Structure (GIVEN) & Meaning (MEANT)">
          <i class="ph ph-blueprint"></i>
          <span>Schema</span>
          <span class="view-item-count">${fieldCount}</span>
        </div>
      `;

      // Render nested lenses (sub-objects of this set)
      const lenses = set.lenses || [];
      const lensesHtml = lenses.map(lens => {
        const isActiveLens = this.currentLensId === lens.id;
        const lensRecordCount = this._getLensRecordCount(set, lens);
        const isLensExpanded = this.expandedLenses?.[lens.id];

        // Render views within this lens
        const lensViewsHtml = (lens.views || []).map(view => {
          const isActiveView = view.id === this.currentViewId && isActiveLens;
          const viewIcon = viewTypeIcons[view.type] || 'ph-table';
          return `
            <div class="set-view-item lens-view-item ${isActiveView ? 'active' : ''}"
                 data-view-id="${view.id}"
                 data-lens-id="${lens.id}"
                 data-set-id="${set.id}"
                 title="${this._escapeHtml(view.name)} (${view.type})">
              <i class="ph ${viewIcon}"></i>
              <span>${this._escapeHtml(view.name)}</span>
            </div>
          `;
        }).join('');

        return `
          <div class="set-lens-container ${isLensExpanded ? 'expanded' : ''}" data-lens-id="${lens.id}" data-set-id="${set.id}">
            <div class="set-lens-header ${isActiveLens ? 'active' : ''}"
                 data-lens-id="${lens.id}"
                 data-set-id="${set.id}"
                 title="Lens: ${this._escapeHtml(lens.name)} · ${lensRecordCount} records">
              <div class="lens-expand-icon">
                <i class="ph ph-caret-right"></i>
              </div>
              <i class="ph ${lens.icon || 'ph-funnel'}"></i>
              <span>${this._escapeHtml(lens.name)}</span>
              <span class="lens-item-count">${lensRecordCount}</span>
            </div>
            <div class="lens-views-list">
              ${lensViewsHtml}
            </div>
          </div>
        `;
      }).join('');

      return `
        <div class="set-item-container ${isExpanded ? 'expanded' : ''} ${stabilityClass}" data-set-id="${set.id}">
          <div class="set-item-header ${isActiveSet && !this.showingSetFields ? 'active' : ''}"
               data-set-id="${set.id}"
               title="${derivation.description}\n${fieldCount} fields · ${recordCount} records">
            <div class="set-item-expand">
              <i class="ph ph-caret-right"></i>
            </div>
            ${operatorBadge}
            <i class="set-item-icon ${set.icon || 'ph ph-table'}"></i>
            <span class="set-item-name">${this._escapeHtml(set.name)}</span>
            <span class="set-item-count">${recordCount}</span>
            <div class="set-item-actions">
              <button class="set-item-action-btn add-view-btn" data-set-id="${set.id}" title="Add view">
                <i class="ph ph-plus"></i>
              </button>
            </div>
          </div>
          <div class="set-views-list">
            ${fieldsItem}
            ${lensesHtml}
            ${viewsHtml}
            <button class="set-add-view-btn" data-set-id="${set.id}">
              <i class="ph ph-plus"></i>
              <span>Add view</span>
            </button>
          </div>
        </div>
      `;
    }).join('');

    // Attach event handlers
    this._attachSetNavEventHandlers(container);
  }

  /**
   * Attach event handlers to set navigation items
   */
  _attachSetNavEventHandlers(container) {
    // Set header click - toggle expansion or open tab for default view
    container.querySelectorAll('.set-item-header').forEach(header => {
      header.addEventListener('click', (e) => {
        const setId = header.dataset.setId;
        const containerEl = header.closest('.set-item-container');

        // If clicking on expand arrow, just toggle expansion
        if (e.target.closest('.set-item-expand')) {
          this.expandedSets[setId] = !this.expandedSets[setId];
          containerEl?.classList.toggle('expanded');
          return;
        }

        // If clicking on add view button, show view picker
        if (e.target.closest('.add-view-btn')) {
          e.stopPropagation();
          this._showViewTypePicker(setId, e.target.closest('.add-view-btn'));
          return;
        }

        // Otherwise expand the set and open the dashboard
        this.expandedSets[setId] = true;
        containerEl?.classList.add('expanded');

        // Open set dashboard (detail panel showing set metadata, sources, etc.)
        this._selectSet(setId);
      });

      header.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        this._showSetContextMenu(e, header.dataset.setId);
      });
    });

    // View item click - open tab for view or schema
    container.querySelectorAll('.set-view-item').forEach(item => {
      item.addEventListener('click', (e) => {
        e.stopPropagation();
        const setId = item.dataset.setId;
        const viewId = item.dataset.viewId;
        const action = item.dataset.action;

        // Handle special "Fields/Schema" action - open schema tab
        if (action === 'fields') {
          this._openSchemaTab(setId);
          return;
        }

        // Otherwise open a tab for this view
        this._openViewTab(setId, viewId);
      });

      item.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        // Don't show context menu for Fields items
        if (item.dataset.action === 'fields') return;
        this._showViewContextMenu(e, item.dataset.viewId, item.dataset.setId);
      });
    });

    // Add view button click
    container.querySelectorAll('.set-add-view-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        this._showViewTypePicker(btn.dataset.setId, btn);
      });
    });

    // Lens header click - toggle expansion or open lens tab
    container.querySelectorAll('.set-lens-header').forEach(header => {
      header.addEventListener('click', (e) => {
        const lensId = header.dataset.lensId;
        const setId = header.dataset.setId;
        const containerEl = header.closest('.set-lens-container');

        // If clicking on expand arrow, just toggle expansion
        if (e.target.closest('.lens-expand-icon')) {
          if (!this.expandedLenses) this.expandedLenses = {};
          this.expandedLenses[lensId] = !this.expandedLenses[lensId];
          containerEl?.classList.toggle('expanded');
          return;
        }

        // Otherwise open lens tab
        if (!this.expandedLenses) this.expandedLenses = {};
        this.expandedLenses[lensId] = true;
        this._openLensTab(setId, lensId);
        this._renderSidebar();
      });
    });

    // Lens view item click - open view tab with lens context
    container.querySelectorAll('.lens-view-item').forEach(item => {
      item.addEventListener('click', (e) => {
        e.stopPropagation();
        const viewId = item.dataset.viewId;
        const lensId = item.dataset.lensId;
        const setId = item.dataset.setId;

        this._openViewTab(setId, viewId, lensId);
      });
    });
  }

  /**
   * Open a tab for a specific view
   */
  _openViewTab(setId, viewId, lensId = null) {
    const set = this.sets.find(s => s.id === setId);
    const view = set?.views?.find(v => v.id === viewId);
    if (!set || !view) return;

    // Get icon based on view type
    const viewIcons = {
      table: 'ph-table',
      cards: 'ph-cards',
      kanban: 'ph-kanban',
      calendar: 'ph-calendar-blank',
      graph: 'ph-graph',
      filesystem: 'ph-folder-open',
      timeline: 'ph-clock-countdown',
      pipeline: 'ph-cooking-pot',
      flow: 'ph-flow-arrow'
    };

    this.openTab('view', {
      contentId: setId,
      title: view.name,
      icon: viewIcons[view.type] || 'ph-table',
      viewState: {
        viewId: viewId,
        lensId: lensId
      }
    });

    // Track in lastViewPerSet
    this.lastViewPerSet[setId] = viewId;
    this._saveData();
  }

  /**
   * Open a schema/fields tab for a set
   */
  _openSchemaTab(setId) {
    const set = this.sets.find(s => s.id === setId);
    if (!set) return;

    this.openTab('schema', {
      contentId: setId,
      title: `${set.name} - Schema`,
      icon: 'ph-list-checks'
    });
  }

  /**
   * Open a lens tab
   */
  _openLensTab(setId, lensId) {
    const set = this.sets.find(s => s.id === setId);
    // TODO: Get lens from registry when lenses are properly implemented
    const lensName = 'All Records'; // Default lens name

    // Clear search when switching to a new lens
    this.viewSearchTerm = '';
    const searchInput = document.getElementById('view-search-input');
    if (searchInput) searchInput.value = '';

    // Get the first view to display
    const defaultViewId = set?.views?.[0]?.id;

    this.openTab('lens', {
      contentId: setId,
      title: `${set?.name || 'Set'} - ${lensName}`,
      icon: 'ph-funnel',
      viewState: {
        lensId: lensId,
        viewId: defaultViewId
      }
    });
  }

  /**
   * Show view type picker dropdown for adding new views
   */
  _showViewTypePicker(setId, anchor) {
    // Remove any existing picker
    document.querySelectorAll('.view-type-picker-popup').forEach(p => p.remove());

    const set = this.sets.find(s => s.id === setId);
    const hasRecords = set && set.records && set.records.length > 0;

    // View types for quick picker (simplified - no filesystem)
    // Filesystem was removed because it's actually a lens (hierarchical organization)
    // not a view type. Users can achieve hierarchy via the full Create View modal.
    const viewTypes = [
      { type: 'table', icon: 'ph-table', label: 'Table' },
      { type: 'cards', icon: 'ph-cards', label: 'Cards' },
      { type: 'kanban', icon: 'ph-kanban', label: 'Kanban' },
      { type: 'calendar', icon: 'ph-calendar-blank', label: 'Calendar' },
      { type: 'graph', icon: 'ph-graph', label: 'Graph' },
      { type: 'timeline', icon: 'ph-clock-countdown', label: 'Timeline' },
      { type: 'pipeline', icon: 'ph-cooking-pot', label: 'Pipeline' },
      { type: 'flow', icon: 'ph-flow-arrow', label: 'Data Flow' }
    ];

    const picker = document.createElement('div');
    picker.className = 'view-type-picker-popup';
    picker.style.cssText = `
      position: fixed;
      min-width: 160px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-primary);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-lg);
      z-index: 1000;
      padding: 4px;
    `;

    picker.innerHTML = viewTypes.map(vt => `
      <div class="view-type-option" data-type="${vt.type}" style="
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        font-size: 12px;
        color: var(--text-secondary);
        border-radius: var(--radius-sm);
        cursor: pointer;
      ">
        <i class="ph ${vt.icon}" style="font-size: 14px;"></i>
        <span>${vt.label}</span>
      </div>
    `).join('') + `
      <div style="height: 1px; background: var(--border-primary); margin: 4px 0;"></div>
      <div class="view-type-option from-column-option ${!hasRecords ? 'disabled' : ''}" data-type="from-column" style="
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        font-size: 12px;
        color: ${hasRecords ? 'var(--accent-primary)' : 'var(--text-tertiary)'};
        border-radius: var(--radius-sm);
        cursor: ${hasRecords ? 'pointer' : 'not-allowed'};
        opacity: ${hasRecords ? '1' : '0.6'};
      " ${!hasRecords ? 'title="Requires records in the set"' : ''}>
        <i class="ph ph-columns" style="font-size: 14px;"></i>
        <span>From column...</span>
      </div>
    `;

    // Position near anchor
    const rect = anchor.getBoundingClientRect();
    picker.style.left = `${rect.right + 4}px`;
    picker.style.top = `${rect.top}px`;

    document.body.appendChild(picker);

    // Add hover effects
    picker.querySelectorAll('.view-type-option').forEach(opt => {
      const isDisabled = opt.classList.contains('disabled');

      opt.addEventListener('mouseenter', () => {
        if (!isDisabled) {
          opt.style.background = 'var(--bg-hover)';
          if (!opt.classList.contains('from-column-option')) {
            opt.style.color = 'var(--text-primary)';
          }
        }
      });
      opt.addEventListener('mouseleave', () => {
        opt.style.background = 'transparent';
        if (!opt.classList.contains('from-column-option')) {
          opt.style.color = 'var(--text-secondary)';
        }
      });
      opt.addEventListener('click', () => {
        const type = opt.dataset.type;

        if (type === 'from-column') {
          if (!isDisabled) {
            picker.remove();
            this._showCreateViewsFromColumnModal(setId);
          }
          return;
        }

        const set = this.sets.find(s => s.id === setId);
        if (set) {
          const viewName = `${type.charAt(0).toUpperCase() + type.slice(1)} View`;
          const newView = createView(viewName, type);
          set.views.push(newView);

          // Select the set and new view
          this.currentSetId = setId;
          this.currentViewId = newView.id;
          this.lastViewPerSet[setId] = newView.id;
          this.expandedSets[setId] = true;

          this._renderSidebar();
          this._renderView();
          this._updateBreadcrumb();
          this._saveData();
        }
        picker.remove();
      });
    });

    // Close on outside click
    const closeHandler = (e) => {
      if (!picker.contains(e.target) && e.target !== anchor) {
        picker.remove();
        document.removeEventListener('click', closeHandler);
      }
    };
    setTimeout(() => document.addEventListener('click', closeHandler), 0);
  }

  /**
   * Show context menu for a view in the sidebar
   */
  _showViewContextMenu(e, viewId, setId) {
    const set = this.sets.find(s => s.id === setId);
    const view = set?.views.find(v => v.id === viewId);
    if (!view) return;

    const menuItems = [
      { label: 'Rename', icon: 'ph-pencil', action: () => this._renameView(viewId, setId) },
      { label: 'Duplicate', icon: 'ph-copy', action: () => this._duplicateView(viewId, setId) },
      { type: 'divider' },
      { label: 'Delete', icon: 'ph-trash', action: () => this._deleteView(viewId, setId), danger: true }
    ];

    this._showContextMenu(e.clientX, e.clientY, menuItems);
  }

  /**
   * Rename a view
   */
  _renameView(viewId, setId) {
    const set = this.sets.find(s => s.id === setId);
    const view = set?.views.find(v => v.id === viewId);
    if (!view) return;

    const html = `
      <div class="form-group">
        <label>View Name</label>
        <input type="text" id="rename-view-input" class="form-input" value="${this._escapeHtml(view.name)}">
      </div>
    `;

    this._showModal('Rename View', html, () => {
      const newName = document.getElementById('rename-view-input')?.value?.trim();
      if (newName && newName !== view.name) {
        const oldName = view.name;
        view.name = newName;

        // Record activity for the rename
        this._recordActivity({
          action: 'update',
          entityType: 'view',
          name: newName,
          details: `Renamed from "${oldName}" to "${newName}" in "${set.name}"`,
          canReverse: false
        });

        this._renderSidebar();
        this._updateBreadcrumb();
        this._saveData();
      }
    });

    setTimeout(() => {
      const input = document.getElementById('rename-view-input');
      input?.focus();
      input?.select();
    }, 50);
  }

  /**
   * Duplicate a view
   */
  _duplicateView(viewId, setId) {
    const set = this.sets.find(s => s.id === setId);
    const view = set?.views.find(v => v.id === viewId);
    if (!view) return;

    const dupView = createView(`${view.name} (Copy)`, view.type);
    dupView.config = JSON.parse(JSON.stringify(view.config || {}));
    set.views.push(dupView);

    // Record activity for the duplication
    this._recordActivity({
      action: 'create',
      entityType: 'view',
      name: dupView.name,
      details: `Duplicated from "${view.name}" in "${set.name}"`,
      canReverse: false
    });

    this._selectView(dupView.id);
    this._saveData();
  }

  // --------------------------------------------------------------------------
  // Column-Based View Creation
  // --------------------------------------------------------------------------

  /**
   * Get unique values for a specific column in a set
   * @param {Object} set - The set to analyze
   * @param {string} fieldId - The field ID to get unique values from
   * @returns {Array} Array of unique values sorted alphabetically
   */
  _getUniqueColumnValues(set, fieldId) {
    if (!set || !set.records || !fieldId) return [];

    const uniqueValues = new Set();

    for (const record of set.records) {
      const value = record.values?.[fieldId];
      // Include null/empty as a separate category if exists
      if (value !== undefined && value !== null && value !== '') {
        uniqueValues.add(String(value));
      }
    }

    return Array.from(uniqueValues).sort((a, b) =>
      String(a).toLowerCase().localeCompare(String(b).toLowerCase())
    );
  }

  /**
   * Show modal to create views based on column values
   * @param {string} setId - The set ID to create views for
   */
  _showCreateViewsFromColumnModal(setId) {
    const set = this.sets.find(s => s.id === setId);
    if (!set) return;

    const fields = set.fields || [];
    if (fields.length === 0) {
      this._showToast('No columns available in this set', 'warning');
      return;
    }

    // Get fields that are good candidates for grouping (text, select, etc.)
    const groupableFields = fields.filter(f =>
      ['text', 'select', 'multiSelect', 'number', 'checkbox'].includes(f.type)
    );

    if (groupableFields.length === 0) {
      this._showToast('No suitable columns for creating views', 'warning');
      return;
    }

    const viewTypes = [
      { type: 'table', icon: 'ph-table', label: 'Table' },
      { type: 'cards', icon: 'ph-cards', label: 'Cards' },
      { type: 'kanban', icon: 'ph-kanban', label: 'Kanban' },
      { type: 'calendar', icon: 'ph-calendar-blank', label: 'Calendar' }
    ];

    const html = `
      <div class="create-views-from-column-modal">
        <p class="modal-description">Create separate views for each unique value in a column. Each view will be filtered to show only records matching that value.</p>

        <div class="form-group">
          <label class="form-label">Select Column</label>
          <select id="column-select" class="form-input">
            <option value="">Choose a column...</option>
            ${groupableFields.map(f => `
              <option value="${f.id}">${this._escapeHtml(f.name)} (${f.type})</option>
            `).join('')}
          </select>
        </div>

        <div id="column-preview" class="column-preview" style="display: none;">
          <div class="preview-header">
            <span class="preview-title">Unique Values</span>
            <span id="value-count" class="preview-count">0 values</span>
          </div>
          <div id="value-list" class="value-list"></div>
        </div>

        <div class="form-group">
          <label class="form-label">View Type</label>
          <div class="view-type-selector">
            ${viewTypes.map((vt, i) => `
              <label class="view-type-radio ${i === 0 ? 'selected' : ''}">
                <input type="radio" name="view-type" value="${vt.type}" ${i === 0 ? 'checked' : ''}>
                <i class="ph ${vt.icon}"></i>
                <span>${vt.label}</span>
              </label>
            `).join('')}
          </div>
        </div>

        <div class="form-group">
          <label class="checkbox-label">
            <input type="checkbox" id="include-empty-view" checked>
            <span>Create "All" view (unfiltered)</span>
          </label>
        </div>
      </div>

      <style>
        .create-views-from-column-modal .modal-description {
          color: var(--text-secondary);
          font-size: 13px;
          margin-bottom: 16px;
          line-height: 1.5;
        }
        .create-views-from-column-modal .column-preview {
          background: var(--bg-tertiary);
          border: 1px solid var(--border-primary);
          border-radius: var(--radius-md);
          padding: 12px;
          margin: 12px 0;
          max-height: 200px;
          overflow-y: auto;
        }
        .create-views-from-column-modal .preview-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 8px;
        }
        .create-views-from-column-modal .preview-title {
          font-weight: 500;
          font-size: 12px;
          color: var(--text-secondary);
        }
        .create-views-from-column-modal .preview-count {
          font-size: 11px;
          color: var(--text-tertiary);
        }
        .create-views-from-column-modal .value-list {
          display: flex;
          flex-wrap: wrap;
          gap: 6px;
        }
        .create-views-from-column-modal .value-tag {
          background: var(--bg-secondary);
          border: 1px solid var(--border-primary);
          padding: 4px 8px;
          border-radius: var(--radius-sm);
          font-size: 12px;
          color: var(--text-primary);
        }
        .create-views-from-column-modal .value-tag.empty {
          font-style: italic;
          color: var(--text-tertiary);
        }
        .create-views-from-column-modal .view-type-selector {
          display: flex;
          gap: 8px;
          flex-wrap: wrap;
        }
        .create-views-from-column-modal .view-type-radio {
          display: flex;
          align-items: center;
          gap: 6px;
          padding: 8px 12px;
          background: var(--bg-tertiary);
          border: 1px solid var(--border-primary);
          border-radius: var(--radius-md);
          cursor: pointer;
          font-size: 12px;
          transition: all 0.15s ease;
        }
        .create-views-from-column-modal .view-type-radio:hover {
          background: var(--bg-hover);
        }
        .create-views-from-column-modal .view-type-radio.selected {
          background: var(--accent-bg);
          border-color: var(--accent-primary);
          color: var(--accent-primary);
        }
        .create-views-from-column-modal .view-type-radio input {
          display: none;
        }
        .create-views-from-column-modal .checkbox-label {
          display: flex;
          align-items: center;
          gap: 8px;
          font-size: 13px;
          cursor: pointer;
        }
        .create-views-from-column-modal .too-many-warning {
          color: var(--warning-color, #f59e0b);
          font-size: 12px;
          margin-top: 8px;
        }
      </style>
    `;

    this._showModal('Create Views from Column', html, () => {
      const fieldId = document.getElementById('column-select')?.value;
      const viewType = document.querySelector('input[name="view-type"]:checked')?.value || 'table';
      const includeAllView = document.getElementById('include-empty-view')?.checked;

      if (!fieldId) {
        this._showToast('Please select a column', 'warning');
        return;
      }

      this._createViewsFromColumn(setId, fieldId, viewType, includeAllView);
    }, { confirmText: 'Create Views' });

    // Set up event handlers after modal is shown
    setTimeout(() => {
      const columnSelect = document.getElementById('column-select');
      const previewDiv = document.getElementById('column-preview');
      const valueListDiv = document.getElementById('value-list');
      const valueCountSpan = document.getElementById('value-count');

      // View type radio selection
      document.querySelectorAll('.view-type-radio').forEach(radio => {
        radio.addEventListener('click', () => {
          document.querySelectorAll('.view-type-radio').forEach(r => r.classList.remove('selected'));
          radio.classList.add('selected');
          radio.querySelector('input').checked = true;
        });
      });

      // Column selection change handler
      columnSelect?.addEventListener('change', () => {
        const fieldId = columnSelect.value;
        if (!fieldId) {
          previewDiv.style.display = 'none';
          return;
        }

        const uniqueValues = this._getUniqueColumnValues(set, fieldId);
        previewDiv.style.display = 'block';
        valueCountSpan.textContent = `${uniqueValues.length} value${uniqueValues.length !== 1 ? 's' : ''}`;

        // Show warning if too many values
        const maxRecommended = 20;
        let warningHtml = '';
        if (uniqueValues.length > maxRecommended) {
          warningHtml = `<div class="too-many-warning">
            <i class="ph ph-warning"></i>
            This will create ${uniqueValues.length} views. Consider using a column with fewer unique values.
          </div>`;
        }

        // Show up to 30 values in preview
        const displayValues = uniqueValues.slice(0, 30);
        const remaining = uniqueValues.length - displayValues.length;

        valueListDiv.innerHTML = displayValues.map(v =>
          `<span class="value-tag">${this._escapeHtml(v)}</span>`
        ).join('') +
          (remaining > 0 ? `<span class="value-tag empty">+${remaining} more...</span>` : '') +
          warningHtml;
      });
    }, 0);
  }

  /**
   * Show modal to add a source to an existing set
   * @param {string} setId - The set ID to add source to
   */
  _showAddSourceToSetModal(setId) {
    const set = this.sets.find(s => s.id === setId);
    if (!set) {
      this._showToast('Set not found', 'error');
      return;
    }

    // Ensure we have the AddSourceToSetUI class available
    if (typeof AddSourceToSetUI === 'undefined') {
      this._showToast('Source merging feature not available', 'error');
      return;
    }

    // Create container for the modal if it doesn't exist
    let container = document.getElementById('add-source-to-set-container');
    if (!container) {
      container = document.createElement('div');
      container.id = 'add-source-to-set-container';
      document.body.appendChild(container);
    }

    // Create the UI instance
    const addSourceUI = new AddSourceToSetUI({
      sourceStore: this.sourceStore,
      sourceMerger: new SourceMerger({
        sourceStore: this.sourceStore,
        eventStore: this._getOrCreateEventStore()
      })
    });

    // Show the modal
    addSourceUI.show(container, set, {
      onComplete: (result) => {
        // Update the set with merged data
        const setIndex = this.sets.findIndex(s => s.id === setId);
        if (setIndex !== -1) {
          this.sets[setIndex] = result.set;
          this.currentDataset = result.set;

          // Refresh the UI
          this._renderSetsNavFlat();
          this._renderMainContent();

          // Show success toast
          const stats = result.stats;
          const message = stats.joinedRecords !== undefined
            ? `Joined ${stats.sourceRecords} records (${stats.joinedRecords} after ${stats.joinType} join)`
            : `Added ${stats.appendedRecords || stats.unionedRecords} records to set`;
          this._showToast(message, 'success');
        }
      },
      onCancel: () => {
        // Nothing to do on cancel
      }
    });
  }

  /**
   * Create views from unique column values
   * @param {string} setId - The set ID
   * @param {string} fieldId - The field ID to filter by
   * @param {string} viewType - The type of view to create
   * @param {boolean} includeAllView - Whether to create an "All" view
   */
  _createViewsFromColumn(setId, fieldId, viewType, includeAllView = true) {
    const set = this.sets.find(s => s.id === setId);
    if (!set) return;

    const field = set.fields?.find(f => f.id === fieldId);
    if (!field) return;

    const uniqueValues = this._getUniqueColumnValues(set, fieldId);

    if (uniqueValues.length === 0) {
      this._showToast('No values found in this column', 'warning');
      return;
    }

    // Create "All" view first if requested
    if (includeAllView) {
      const allView = createView(`All (by ${field.name})`, viewType, {
        // Store metadata about this being a column-based view group
        metadata: {
          columnBasedGroup: true,
          sourceFieldId: fieldId,
          sourceFieldName: field.name
        }
      });
      set.views.push(allView);
    }

    // Create a view for each unique value
    for (const value of uniqueValues) {
      const viewName = `${value}`;
      const newView = createView(viewName, viewType, {
        filters: [
          { fieldId, operator: 'is', filterValue: value }
        ],
        // Store metadata about the source column and value
        metadata: {
          columnBasedGroup: true,
          sourceFieldId: fieldId,
          sourceFieldName: field.name,
          filterValue: value,
          recordType: value // For special styling in sidebar
        }
      });

      // Count records matching this filter
      const matchingCount = set.records?.filter(r =>
        String(r.values?.[fieldId] || '') === String(value)
      ).length || 0;
      newView.metadata.recordCount = matchingCount;

      set.views.push(newView);
    }

    // Select the first new view (the "All" view if created, otherwise first filtered view)
    const firstNewView = includeAllView
      ? set.views[set.views.length - uniqueValues.length - 1]
      : set.views[set.views.length - uniqueValues.length];

    if (firstNewView) {
      this.currentSetId = setId;
      this.currentViewId = firstNewView.id;
      this.lastViewPerSet[setId] = firstNewView.id;
      this.expandedSets[setId] = true;
    }

    // Record activity for view creation from column
    const viewCount = includeAllView ? uniqueValues.length + 1 : uniqueValues.length;
    this._recordActivity({
      action: 'create',
      entityType: 'view',
      name: `${viewCount} views from ${field.name}`,
      details: `Created ${viewCount} view${viewCount !== 1 ? 's' : ''} from column "${field.name}" in "${set.name}"`,
      canReverse: false
    });

    this._renderSidebar();
    this._renderView();
    this._updateBreadcrumb();
    this._saveData();

    this._showToast(`Created ${viewCount} view${viewCount !== 1 ? 's' : ''} from "${field.name}"`, 'success');
  }

  /**
   * Delete (toss) a view - moves to tossed items for recovery
   */
  _deleteView(viewId, setId) {
    const set = this.sets.find(s => s.id === setId);
    if (!set) return;

    const viewIndex = set.views.findIndex(v => v.id === viewId);
    if (viewIndex === -1) return;

    // Don't delete if it's the last view
    if (set.views.length <= 1) {
      this._showToast('Cannot delete the last view', 'warning');
      return;
    }

    const view = set.views[viewIndex];

    // Add to tossed items (nothing is ever deleted per Rule 9)
    this.tossedItems.unshift({
      type: 'view',
      view: JSON.parse(JSON.stringify(view)), // Deep clone
      setId: setId,
      tossedAt: new Date().toISOString()
    });
    if (this.tossedItems.length > this.maxTossedItems) {
      this.tossedItems.pop();
    }

    // Record activity for the deletion
    this._recordActivity({
      action: 'delete',
      entityType: 'view',
      name: view.name,
      details: `Tossed ${view.type} view from "${set.name}"`,
      canReverse: true,
      reverseData: { type: 'restore_tossed', item: { type: 'view', view, setId } }
    });

    set.views.splice(viewIndex, 1);

    // If deleted view was active, switch to another
    if (this.currentViewId === viewId) {
      this.currentViewId = set.views[0].id;
      this.lastViewPerSet[setId] = this.currentViewId;
    }

    this._renderSidebar();
    this._renderView();
    this._updateBreadcrumb();
    this._saveData();
    this._updateTossedBadge();

    // Show undo toast with countdown
    this._showToast(`Tossed view "${view.name}"`, 'info', {
      countdown: 5000,
      action: {
        label: 'Undo',
        callback: () => {
          // Restore the view using _restoreTossedItem (which also records activity)
          const tossedIndex = this.tossedItems.findIndex(
            t => t.type === 'view' && t.view.id === view.id
          );
          if (tossedIndex !== -1) {
            this._restoreTossedItem(tossedIndex);
          }
        }
      }
    });
  }

  /**
   * Get derivation info for a set
   */
  _getSetDerivationInfo(set) {
    // Check for explicit derivation config
    if (set.derivation) {
      const strategy = set.derivation.strategy;
      const descriptions = {
        'seg': 'Filtered from parent (SEG operator)',
        'con': 'Joined from multiple sets (CON operator)',
        'alt': 'Transformed via rule (ALT operator)',
        'direct': 'Direct import from source'
      };
      return {
        operator: strategy.toUpperCase(),
        strategy: strategy,
        description: descriptions[strategy] || 'Lens'
      };
    }

    // Infer from provenance
    const prov = set.datasetProvenance;
    const sourceValue = this._getProvenanceValue(prov?.provenance?.source);
    if (prov && (prov.originalFilename || sourceValue)) {
      return {
        operator: 'INS',
        strategy: 'direct',
        description: `Imported from ${prov.originalFilename || sourceValue}`
      };
    }

    // Manual/empty set
    return {
      operator: 'INS',
      strategy: 'manual',
      description: 'Manually created set'
    };
  }

  /**
   * Get HTML for operator badge
   */
  _getOperatorBadgeHTML(operator) {
    const operators = {
      'SEG': { symbol: '｜', color: 'purple', title: 'Segmented (filtered)' },
      'CON': { symbol: '⋈', color: 'blue', title: 'Connected (joined)' },
      'ALT': { symbol: '∿', color: 'green', title: 'Alternated (transformed)' },
      'SYN': { symbol: '∨', color: 'orange', title: 'Synthesized (merged)' },
      'INS': { symbol: '△', color: 'gray', title: 'Instantiated (created)' }
    };

    const op = operators[operator] || operators['INS'];
    return `<span class="op-badge-mini op-${op.color}" title="${op.title}">${op.symbol}</span>`;
  }

  /**
   * Show operator-first creation modal
   * FIX #8: Ask HOW to transform, not WHAT to create
   */
  _showOperatorFirstCreationModal() {
    const intents = [
      { id: 'CREATE', icon: 'ph-magic-wand', label: 'Create (Wizard)', operator: 'NEW', description: 'Visual wizard to select, join, and filter data' },
      { id: 'SQL', icon: 'ph-terminal', label: 'Query with SQL', operator: 'SQL', description: 'Write SQL to select, filter, and transform data' },
      { id: 'FILTER', icon: 'ph-funnel', label: 'Filter existing data', operator: 'SEG', description: 'Create a subset by filtering records' },
      { id: 'RELATE', icon: 'ph-link', label: 'Relate things', operator: 'CON', description: 'Join records from multiple sets' },
      { id: 'SLICE', icon: 'ph-clock', label: 'Slice by time', operator: 'ALT', description: 'Create time-based partitions' },
      { id: 'COMBINE', icon: 'ph-stack', label: 'Combine perspectives', operator: 'SUP', description: 'Overlay multiple views' },
      { id: 'IMPORT', icon: 'ph-upload', label: 'Import new data', operator: 'INS', description: 'Import external data as source' },
      { id: 'EMPTY', icon: 'ph-plus-circle', label: 'Start empty', operator: 'INS', description: 'Create an empty set (manual entry)' }
    ];

    const html = `
      <div class="operator-creation-modal">
        <p class="creation-prompt">How do you want to create this set?</p>
        <div class="creation-intents">
          ${intents.map(intent => `
            <button class="creation-intent-btn" data-intent="${intent.id}">
              <i class="ph ${intent.icon}"></i>
              <div class="intent-content">
                <span class="intent-label">${intent.label}</span>
                <span class="intent-description">${intent.description}</span>
              </div>
              <span class="intent-operator" title="EO Operator">${intent.operator}</span>
            </button>
          `).join('')}
        </div>
      </div>
    `;

    this._showModal('Create New Set', html, null, { hideFooter: true });

    // Use event delegation on modal body for more reliable click handling
    const modalBody = document.getElementById('modal-body');
    if (modalBody) {
      const handleIntentClick = (e) => {
        const btn = e.target.closest('.creation-intent-btn');
        if (btn) {
          const intent = btn.dataset.intent;
          // Remove the event listener before closing to prevent memory leaks
          modalBody.removeEventListener('click', handleIntentClick);
          this._closeModal();
          this._handleCreationIntent(intent);
        }
      };
      modalBody.addEventListener('click', handleIntentClick);
    }
  }

  /**
   * Handle creation intent selection
   */
  _handleCreationIntent(intent) {
    switch (intent) {
      case 'CREATE':
        this._showSetJoinFilterCreator();
        break;
      case 'SQL':
        this._showSQLQueryModal();
        break;
      case 'FILTER':
        this._showFilterSetCreationFlow();
        break;
      case 'RELATE':
        this._showJoinBuilderUI();
        break;
      case 'SLICE':
        this._showTimeSliceCreationFlow();
        break;
      case 'COMBINE':
        this._showCombineViewFlow();
        break;
      case 'IMPORT':
        this._showImportModal();
        break;
      case 'EMPTY':
        this._createEmptySetWithWarning();
        break;
    }
  }

  /**
   * Show the SetJoinFilterCreator wizard for no-code set creation
   * Allows selecting multiple sources/sets, configuring joins, and filtering
   */
  _showSetJoinFilterCreator() {
    // Initialize source store if needed
    if (!this.sourceStore) {
      this._initSourceStore();
    }

    // Sync sources to sourceStore
    for (const source of (this.sources || [])) {
      if (!this.sourceStore.get(source.id)) {
        this.sourceStore.sources.set(source.id, source);
      }
    }

    // Create container for the wizard
    let container = document.getElementById('sjf-creator-container');
    if (!container) {
      container = document.createElement('div');
      container.id = 'sjf-creator-container';
      document.body.appendChild(container);
    }

    // Create and show the wizard
    const creator = new SetJoinFilterCreator({
      sourceStore: this.sourceStore,
      sets: this.sets
    });

    creator.show(container, {
      onComplete: (result) => {
        // Create the set from the wizard result
        this._createSetFromWizardResult(result);
      },
      onCancel: () => {
        // Nothing to do on cancel
      }
    });
  }

  /**
   * Create a set from the SetJoinFilterCreator wizard result
   */
  _createSetFromWizardResult(result) {
    const timestamp = new Date().toISOString();
    const setId = `set_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 6)}`;

    // Create fields with proper structure
    const fields = (result.fields || []).map(f => ({
      id: `fld_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 6)}`,
      name: f.name,
      type: f.type || 'TEXT',
      width: f.width || 150
    }));

    // Create records with proper structure
    const records = (result.records || []).map((rec, i) => ({
      id: rec.id || `rec_${Date.now().toString(36)}_${i}_${Math.random().toString(36).substring(2, 6)}`,
      setId: setId,
      values: rec.values || rec,
      createdAt: timestamp,
      updatedAt: timestamp
    }));

    // Create the set
    const newSet = {
      id: setId,
      name: result.name || 'Untitled Set',
      icon: 'ph-table',
      fields: fields,
      records: records,
      views: [{
        id: `view_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 6)}`,
        name: 'All Records',
        type: 'table',
        config: {}
      }],
      createdAt: timestamp,
      updatedAt: timestamp,
      derivation: result.derivation || null,
      datasetProvenance: {
        createdVia: 'SetJoinFilterCreator',
        sourceItems: result.derivation?.sourceItems || [],
        joinConfig: result.derivation?.joinConfig || null,
        filters: result.derivation?.filters || null
      }
    };

    // Add to sets and project
    this.sets.push(newSet);
    this._addSetToProject(newSet.id);
    this.currentSetId = newSet.id;
    this.currentViewId = newSet.views[0]?.id;
    this.lastViewPerSet[newSet.id] = this.currentViewId;

    // Record activity for activity stream
    this._recordActivity({
      action: 'create',
      entityType: 'set',
      name: newSet.name,
      details: `${records.length} records, ${fields.length} fields`
    });

    // Save and render
    this._saveData();
    this._renderSidebar();
    this._renderView();
    this._updateBreadcrumb();
    this._showToast(`Created set "${newSet.name}" with ${records.length} records`, 'success');
  }

  /**
   * Create empty set with ontology warning
   */
  _createEmptySetWithWarning() {
    this._showModal('Create Empty Set', `
      <div class="ontology-warning">
        <i class="ph ph-warning-circle"></i>
        <div>
          <strong>Ontology Notice</strong>
          <p>Empty sets violate EO's derivation principle. Sets should be born from constraint, not emptiness.</p>
          <p>Consider importing data or filtering from an existing set instead.</p>
        </div>
      </div>
      <div class="form-group" style="margin-top: 16px;">
        <label>Set Name</label>
        <input type="text" id="empty-set-name" class="form-input" placeholder="My Set" value="">
      </div>
    `, () => {
      const name = document.getElementById('empty-set-name')?.value?.trim() || 'New Set';
      const set = createSet(name);
      // Mark as manually created with warning
      set.derivation = {
        strategy: 'manual',
        constraint: { filters: [] },
        warning: 'Created empty - no derivation constraint'
      };
      this.sets.push(set);
      this._addSetToProject(set.id);

      // Record activity for the set creation
      this._recordActivity({
        action: 'create',
        entityType: 'set',
        name: name,
        details: 'Created empty set (manual)'
      });

      this._saveData();
      this._renderSidebar();
      this._selectSet(set.id);
      this._showToast('Set created (empty)', 'warning');
    });
  }

  /**
   * Show filter-based set creation flow
   */
  _showFilterSetCreationFlow() {
    if (this.sets.length === 0) {
      this._showToast('No sets to filter from. Import data first.', 'warning');
      return;
    }

    const html = `
      <div class="filter-creation-flow">
        <div class="form-group">
          <label>Filter from Set</label>
          <select id="filter-parent-set" class="form-select">
            ${this.sets.map(set => `
              <option value="${set.id}">${this._escapeHtml(set.name)} (${set.records?.length || 0} records)</option>
            `).join('')}
          </select>
        </div>
        <div class="form-group">
          <label>New Set Name</label>
          <input type="text" id="filter-set-name" class="form-input" placeholder="SEG: Filtered Records">
        </div>
        <p class="form-hint">You can define filter criteria after creating the set.</p>
      </div>
    `;

    this._showModal('Create Filtered Set (SEG)', html, () => {
      const parentId = document.getElementById('filter-parent-set')?.value;
      const name = document.getElementById('filter-set-name')?.value?.trim() || 'SEG: Filtered Set';
      const parentSet = this.sets.find(s => s.id === parentId);

      if (!parentSet) return;

      // Create derived set with SEG operator
      const set = createSet(name);
      set.fields = JSON.parse(JSON.stringify(parentSet.fields)); // Copy schema
      set.records = [...parentSet.records]; // Copy records (filter applied later)
      set.derivation = {
        strategy: 'seg',
        parentSetId: parentId,
        constraint: { filters: [] },
        derivedAt: new Date().toISOString()
      };

      this.sets.push(set);
      this._addSetToProject(set.id);

      // Record activity for the filtered set creation
      this._recordActivity({
        action: 'create',
        entityType: 'set',
        name: name,
        details: `Created filtered set from "${parentSet.name}"`
      });

      this._saveData();
      this._renderSidebar();
      this._selectSet(set.id);
      this._showToast('Filtered set created', 'success');
    });
  }

  /**
   * Show lens creation flow - creates a lens as a sub-object of the current set
   * Lenses pivot around a particular field value to show a subset of records
   */
  _showLensCreationFlow() {
    const currentSet = this.getCurrentSet();
    if (!currentSet) {
      this._showToast('Select a set first to create a lens', 'warning');
      return;
    }

    // Get select fields that can be used for pivoting
    const selectFields = (currentSet.fields || []).filter(f =>
      f.type === 'select' || f.type === 'multiselect' || f.type === 'text'
    );

    if (selectFields.length === 0) {
      this._showToast('No suitable fields found for creating a lens. Add a select or text field first.', 'warning');
      return;
    }

    // Build field options HTML
    const fieldOptionsHtml = selectFields.map(field => `
      <option value="${field.id}">${this._escapeHtml(field.name)} (${field.type})</option>
    `).join('');

    const html = `
      <div class="lens-creation-flow">
        <div class="form-group">
          <label>Lens Name</label>
          <input type="text" id="lens-name" class="form-input" placeholder="e.g., Bug Reports">
        </div>
        <div class="form-group">
          <label>Pivot Field</label>
          <select id="lens-pivot-field" class="form-select">
            ${fieldOptionsHtml}
          </select>
          <p class="form-hint">Select the field to filter records by</p>
        </div>
        <div class="form-group">
          <label>Pivot Value</label>
          <select id="lens-pivot-value" class="form-select">
            <option value="">-- Select a value --</option>
          </select>
          <p class="form-hint">Records with this value will be shown in the lens</p>
        </div>
      </div>
    `;

    this._showModal('Create Lens', html, () => {
      const name = document.getElementById('lens-name')?.value?.trim();
      const pivotFieldId = document.getElementById('lens-pivot-field')?.value;
      const pivotValue = document.getElementById('lens-pivot-value')?.value;

      if (!name) {
        this._showToast('Please enter a name for the lens', 'warning');
        return;
      }
      if (!pivotFieldId || !pivotValue) {
        this._showToast('Please select a pivot field and value', 'warning');
        return;
      }

      // Create the lens
      const lens = createLens(name, currentSet.id, pivotFieldId, pivotValue);

      // Initialize lenses array if needed
      if (!currentSet.lenses) {
        currentSet.lenses = [];
      }
      currentSet.lenses.push(lens);

      this._saveData();
      this._renderSidebar();
      this._showToast(`Lens "${name}" created`, 'success');
    });

    // Populate pivot values when field changes
    setTimeout(() => {
      const fieldSelect = document.getElementById('lens-pivot-field');
      const valueSelect = document.getElementById('lens-pivot-value');

      const updatePivotValues = () => {
        const fieldId = fieldSelect?.value;
        const field = currentSet.fields?.find(f => f.id === fieldId);

        if (!field || !valueSelect) return;

        // Get unique values for this field from records
        const values = new Set();
        (currentSet.records || []).forEach(r => {
          const val = r.values?.[fieldId];
          if (val !== null && val !== undefined && val !== '') {
            if (Array.isArray(val)) {
              val.forEach(v => values.add(v));
            } else {
              values.add(val);
            }
          }
        });

        // Also include options from select field config
        if (field.options?.options) {
          field.options.options.forEach(opt => {
            if (typeof opt === 'string') {
              values.add(opt);
            } else if (opt?.value) {
              values.add(opt.value);
            }
          });
        }

        // Build options
        valueSelect.innerHTML = '<option value="">-- Select a value --</option>' +
          Array.from(values).sort().map(v => `
            <option value="${this._escapeHtml(String(v))}">${this._escapeHtml(String(v))}</option>
          `).join('');
      };

      fieldSelect?.addEventListener('change', updatePivotValues);
      updatePivotValues(); // Initial population
    }, 0);
  }

  /**
   * Show join-based set creation flow
   */
  _showJoinSetCreationFlow() {
    if (this.sets.length < 2) {
      this._showToast('Need at least 2 sets to join.', 'warning');
      return;
    }

    const html = `
      <div class="join-creation-flow">
        <div class="form-group">
          <label>Select Sets to Join</label>
          <div class="checkbox-list">
            ${this.sets.map(set => `
              <label class="checkbox-item">
                <input type="checkbox" name="join-sets" value="${set.id}">
                <span>${this._escapeHtml(set.name)} (${set.records?.length || 0} records)</span>
              </label>
            `).join('')}
          </div>
        </div>
        <div class="form-group">
          <label>New Set Name</label>
          <input type="text" id="join-set-name" class="form-input" placeholder="CON: Combined Records">
        </div>
      </div>
    `;

    this._showModal('Create Joined Set (CON)', html, () => {
      const checkboxes = document.querySelectorAll('input[name="join-sets"]:checked');
      const setIds = Array.from(checkboxes).map(cb => cb.value);
      const name = document.getElementById('join-set-name')?.value?.trim() || 'CON: Joined Set';

      if (setIds.length < 2) {
        this._showToast('Select at least 2 sets to join', 'warning');
        return;
      }

      // Create derived set with CON operator
      const set = createSet(name);
      set.derivation = {
        strategy: 'con',
        joinSetIds: setIds,
        constraint: { joinCondition: null },
        derivedAt: new Date().toISOString()
      };

      // Merge schemas and records with proper field ID remapping
      const sourceSets = setIds.map(id => this.sets.find(s => s.id === id)).filter(Boolean);
      const { fields, records } = this._mergeSetsWithIdRemapping(sourceSets);
      set.fields = fields;
      set.records = records;

      this.sets.push(set);
      this._addSetToProject(set.id);
      this._saveData();
      this._renderSidebar();
      this._selectSet(set.id);
      this._showToast('Joined set created', 'success');
    });
  }

  /**
   * Merge schemas from multiple sets
   * Uses ensureValidField to guarantee all merged fields have proper width (TABLE RULE 1)
   *
   * IMPORTANT: This function only merges field schemas. If you need to merge records too,
   * use _mergeSetsWithIdRemapping() instead to ensure field IDs stay consistent with record values.
   */
  _mergeSchemas(sets) {
    const fieldMap = new Map();
    for (const set of sets) {
      for (const field of set.fields || []) {
        if (!fieldMap.has(field.name)) {
          // Ensure merged field has valid width and properties
          // KEEP the original field ID to maintain consistency with record values
          fieldMap.set(field.name, ensureValidField({ ...field }));
        }
      }
    }
    return Array.from(fieldMap.values());
  }

  /**
   * Merge multiple sets with proper field ID remapping.
   *
   * TABLE RULE 5: Field IDs must be consistent between set.fields and record.values.
   * When merging sets, records from different sources may use different field IDs
   * for fields with the same name. This function creates a unified schema and
   * remaps all record values to use the new consistent field IDs.
   *
   * @param {Array} sets - Array of sets to merge
   * @returns {{ fields: Array, records: Array }} - Merged fields and remapped records
   */
  _mergeSetsWithIdRemapping(sets) {
    // Step 1: Create unified field schema with new IDs
    // Map: field.name -> new unified field object
    const unifiedFieldMap = new Map();

    for (const set of sets) {
      for (const field of set.fields || []) {
        if (!unifiedFieldMap.has(field.name)) {
          // Create a new field with a fresh ID for the merged set
          unifiedFieldMap.set(field.name, ensureValidField({
            ...field,
            id: generateId()
          }));
        }
      }
    }

    const mergedFields = Array.from(unifiedFieldMap.values());

    // Step 2: Create mapping from source field IDs to unified field IDs
    // Map: old field ID -> new unified field ID
    const fieldIdRemapping = new Map();

    for (const set of sets) {
      for (const field of set.fields || []) {
        const unifiedField = unifiedFieldMap.get(field.name);
        if (unifiedField) {
          fieldIdRemapping.set(field.id, unifiedField.id);
        }
      }
    }

    // Step 3: Remap all records to use unified field IDs
    const mergedRecords = [];

    for (const set of sets) {
      for (const record of set.records || []) {
        // Create new record with remapped field IDs
        const newValues = {};
        for (const [oldFieldId, value] of Object.entries(record.values || {})) {
          const newFieldId = fieldIdRemapping.get(oldFieldId);
          if (newFieldId) {
            newValues[newFieldId] = value;
          }
          // Note: values for fields not in the merged schema are dropped
        }

        mergedRecords.push({
          ...record,
          id: generateId(), // New ID for merged record
          values: newValues
        });
      }
    }

    return { fields: mergedFields, records: mergedRecords };
  }

  /**
   * Show time slice creation flow (placeholder)
   */
  _showTimeSliceCreationFlow() {
    this._showToast('Time slice creation coming soon', 'info');
  }

  /**
   * Show combine view flow (placeholder)
   */
  _showCombineViewFlow() {
    this._showToast('Perspective combination coming soon', 'info');
  }

  /**
   * Show SQL Query modal for creating sets from SQL
   * EO-IR: Records the SQL query as derivation with full provenance
   */
  _showSQLQueryModal() {
    // Get available sources/sets for querying
    const sources = this.sets.map(set => ({
      id: set.id,
      name: set.name,
      recordCount: set.records?.length || 0,
      fields: set.fields?.map(f => f.name) || []
    }));

    if (sources.length === 0) {
      this._showToast('No data to query. Import data first.', 'warning');
      return;
    }

    const sourceList = sources.map(s =>
      `<code>${s.name}</code> (${s.recordCount} rows): ${s.fields.slice(0, 5).join(', ')}${s.fields.length > 5 ? '...' : ''}`
    ).join('<br>');

    const exampleQueries = [
      `SELECT * FROM ${sources[0].name}`,
      `SELECT * FROM ${sources[0].name} WHERE ${sources[0].fields[0] || 'field'} = 'value'`,
      `SELECT ${sources[0].fields.slice(0, 3).join(', ') || '*'} FROM ${sources[0].name} ORDER BY ${sources[0].fields[0] || 'field'} DESC LIMIT 100`,
      sources.length > 1 ? `SELECT * FROM ${sources[0].name} JOIN ${sources[1].name} ON ${sources[0].name}.id = ${sources[1].name}.id` : null
    ].filter(Boolean);

    const html = `
      <div class="sql-query-modal">
        <div class="form-group">
          <label class="form-label">Available Tables</label>
          <div class="sql-sources-list">
            ${sourceList}
          </div>
        </div>

        <div class="form-group">
          <label class="form-label">SQL Query</label>
          <textarea id="sql-query-input" class="form-textarea sql-editor" rows="6" placeholder="SELECT * FROM table WHERE condition...">${exampleQueries[0]}</textarea>
        </div>

        <div class="form-group">
          <label class="form-label">Quick Examples</label>
          <div class="sql-examples">
            ${exampleQueries.map((q, i) => `
              <button type="button" class="sql-example-btn" data-query="${this._escapeHtml(q)}">
                Example ${i + 1}
              </button>
            `).join('')}
          </div>
        </div>

        <div class="form-group">
          <button type="button" id="sql-preview-btn" class="btn btn-secondary">
            <i class="ph ph-play"></i> Preview Results
          </button>
        </div>

        <div id="sql-preview-results" class="sql-preview-results" style="display: none;">
          <div class="sql-preview-header">
            <span id="sql-preview-count">0 rows</span>
            <span id="sql-preview-time">0ms</span>
          </div>
          <div class="sql-preview-table-wrap">
            <table id="sql-preview-table">
              <thead id="sql-preview-thead"></thead>
              <tbody id="sql-preview-tbody"></tbody>
            </table>
          </div>
        </div>

        <div id="sql-pipeline-view" class="sql-pipeline-view" style="display: none;">
          <label class="form-label">EO-IR Pipeline (Provenance)</label>
          <div id="sql-pipeline-steps" class="pipeline-steps"></div>
        </div>

        <div class="form-group" style="margin-top: 16px;">
          <label class="form-label">New Set Name</label>
          <input type="text" id="sql-set-name" class="form-input" placeholder="SQL: Query Results">
        </div>

        <div class="form-group">
          <label class="form-label">Frame (Optional)</label>
          <input type="text" id="sql-frame-purpose" class="form-input" placeholder="Purpose of this query...">
          <textarea id="sql-frame-caveats" class="form-textarea" rows="2" placeholder="Known limitations or caveats..."></textarea>
        </div>
      </div>
    `;

    this._showModal('Create Set from SQL Query', html, () => {
      this._executeSQLAndCreateSet();
    }, { confirmText: '<i class="ph ph-database"></i> Create Set' });

    // Setup event handlers after modal is shown
    setTimeout(() => {
      // Example buttons
      document.querySelectorAll('.sql-example-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const query = btn.dataset.query;
          document.getElementById('sql-query-input').value = query;
        });
      });

      // Preview button
      document.getElementById('sql-preview-btn')?.addEventListener('click', () => {
        this._previewSQLQuery();
      });

      // Setup SQL autocomplete
      this._setupSQLAutocomplete(sources);

      // Focus the editor
      document.getElementById('sql-query-input')?.focus();
    }, 100);
  }

  /**
   * Setup SQL autocomplete for the query input
   */
  _setupSQLAutocomplete(sources) {
    const input = document.getElementById('sql-query-input');
    if (!input) return;

    // SQL keywords for autocomplete
    const sqlKeywords = [
      'SELECT', 'FROM', 'WHERE', 'AND', 'OR', 'NOT', 'IN', 'LIKE', 'BETWEEN',
      'ORDER BY', 'GROUP BY', 'HAVING', 'LIMIT', 'OFFSET', 'JOIN', 'LEFT JOIN',
      'RIGHT JOIN', 'INNER JOIN', 'OUTER JOIN', 'ON', 'AS', 'DISTINCT', 'COUNT',
      'SUM', 'AVG', 'MIN', 'MAX', 'CASE', 'WHEN', 'THEN', 'ELSE', 'END', 'NULL',
      'IS NULL', 'IS NOT NULL', 'ASC', 'DESC', 'UNION', 'EXCEPT', 'INTERSECT'
    ];

    // Build table and field suggestions
    const tableSuggestions = sources.map(s => s.name);
    const fieldSuggestions = [...new Set(sources.flatMap(s => s.fields))];
    const allSuggestions = [...sqlKeywords, ...tableSuggestions, ...fieldSuggestions];

    // Create autocomplete dropdown
    const dropdown = document.createElement('div');
    dropdown.className = 'sql-autocomplete-dropdown';
    dropdown.style.cssText = 'display:none;position:absolute;background:var(--surface-secondary);border:1px solid var(--border-primary);border-radius:6px;max-height:200px;overflow-y:auto;z-index:1000;box-shadow:0 4px 12px rgba(0,0,0,0.3);min-width:180px;';
    input.parentNode.style.position = 'relative';
    input.parentNode.appendChild(dropdown);

    let selectedIndex = -1;

    const showSuggestions = (suggestions, rect) => {
      if (suggestions.length === 0) {
        dropdown.style.display = 'none';
        return;
      }

      dropdown.innerHTML = suggestions.map((s, i) => {
        const isKeyword = sqlKeywords.includes(s);
        const isTable = tableSuggestions.includes(s);
        const icon = isKeyword ? 'ph-code' : (isTable ? 'ph-table' : 'ph-columns');
        const type = isKeyword ? 'keyword' : (isTable ? 'table' : 'field');
        return `<div class="sql-autocomplete-item${i === selectedIndex ? ' selected' : ''}" data-value="${s}" data-index="${i}" style="padding:6px 10px;cursor:pointer;display:flex;align-items:center;gap:8px;font-size:12px;">
          <i class="ph ${icon}" style="color:var(--text-muted);font-size:14px;"></i>
          <span style="flex:1;">${s}</span>
          <span style="color:var(--text-muted);font-size:10px;">${type}</span>
        </div>`;
      }).join('');
      dropdown.style.display = 'block';
      dropdown.style.top = `${input.offsetHeight + 4}px`;
      dropdown.style.left = '0';
    };

    const hideSuggestions = () => {
      dropdown.style.display = 'none';
      selectedIndex = -1;
    };

    const getCurrentWord = () => {
      const cursorPos = input.selectionStart;
      const text = input.value.substring(0, cursorPos);
      const match = text.match(/[\w.]+$/);
      return match ? match[0] : '';
    };

    const replaceCurrentWord = (replacement) => {
      const cursorPos = input.selectionStart;
      const text = input.value;
      const beforeCursor = text.substring(0, cursorPos);
      const afterCursor = text.substring(cursorPos);
      const match = beforeCursor.match(/[\w.]+$/);
      const wordStart = match ? cursorPos - match[0].length : cursorPos;
      input.value = text.substring(0, wordStart) + replacement + afterCursor;
      const newPos = wordStart + replacement.length;
      input.setSelectionRange(newPos, newPos);
      input.focus();
    };

    input.addEventListener('input', () => {
      const word = getCurrentWord();
      if (word.length >= 1) {
        const filtered = allSuggestions.filter(s =>
          s.toLowerCase().startsWith(word.toLowerCase())
        ).slice(0, 10);
        selectedIndex = -1;
        showSuggestions(filtered);
      } else {
        hideSuggestions();
      }
    });

    input.addEventListener('keydown', (e) => {
      if (dropdown.style.display === 'none') return;

      const items = dropdown.querySelectorAll('.sql-autocomplete-item');
      if (items.length === 0) return;

      if (e.key === 'ArrowDown') {
        e.preventDefault();
        selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
        items.forEach((item, i) => item.classList.toggle('selected', i === selectedIndex));
        items[selectedIndex]?.scrollIntoView({ block: 'nearest' });
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        selectedIndex = Math.max(selectedIndex - 1, 0);
        items.forEach((item, i) => item.classList.toggle('selected', i === selectedIndex));
        items[selectedIndex]?.scrollIntoView({ block: 'nearest' });
      } else if (e.key === 'Enter' || e.key === 'Tab') {
        if (selectedIndex >= 0 && items[selectedIndex]) {
          e.preventDefault();
          replaceCurrentWord(items[selectedIndex].dataset.value);
          hideSuggestions();
        }
      } else if (e.key === 'Escape') {
        hideSuggestions();
      }
    });

    dropdown.addEventListener('click', (e) => {
      const item = e.target.closest('.sql-autocomplete-item');
      if (item) {
        replaceCurrentWord(item.dataset.value);
        hideSuggestions();
      }
    });

    dropdown.addEventListener('mouseenter', (e) => {
      const item = e.target.closest('.sql-autocomplete-item');
      if (item) {
        const items = dropdown.querySelectorAll('.sql-autocomplete-item');
        items.forEach(i => i.classList.remove('selected'));
        item.classList.add('selected');
        selectedIndex = parseInt(item.dataset.index);
      }
    }, true);

    input.addEventListener('blur', () => {
      setTimeout(hideSuggestions, 150);
    });
  }

  /**
   * Preview SQL query results
   */
  _previewSQLQuery() {
    const sql = document.getElementById('sql-query-input')?.value?.trim();
    if (!sql) {
      this._showToast('Enter a SQL query', 'warning');
      return;
    }

    // Create data provider that maps set names to data
    const dataProvider = this._createSQLDataProvider();

    // Parse and execute
    const parser = new EOSQLParser();
    const parsed = parser.parse(sql);

    if (!parsed.success) {
      this._showToast(`SQL Error: ${parsed.error}`, 'error');
      return;
    }

    const executor = new EOSQLExecutor(dataProvider);
    const result = executor.execute(parsed.pipeline);

    // Show results
    const previewDiv = document.getElementById('sql-preview-results');
    const pipelineDiv = document.getElementById('sql-pipeline-view');
    previewDiv.style.display = 'block';
    pipelineDiv.style.display = 'block';

    document.getElementById('sql-preview-count').textContent = `${result.rows.length} rows`;
    document.getElementById('sql-preview-time').textContent = `${result.stats.executionTime}ms`;

    // Render preview table (first 50 rows)
    const thead = document.getElementById('sql-preview-thead');
    const tbody = document.getElementById('sql-preview-tbody');

    thead.innerHTML = `<tr>${result.columns.map(c => `<th>${this._escapeHtml(c)}</th>`).join('')}</tr>`;
    tbody.innerHTML = result.rows.slice(0, 50).map(row =>
      `<tr>${result.columns.map(c => `<td>${this._escapeHtml(String(row[c] ?? ''))}</td>`).join('')}</tr>`
    ).join('');

    if (result.rows.length > 50) {
      tbody.innerHTML += `<tr><td colspan="${result.columns.length}" style="text-align:center;color:var(--text-muted);">Showing 50 of ${result.rows.length} rows</td></tr>`;
    }

    // Render pipeline visualization
    this._renderSQLPipeline(parsed.pipeline, result.stats);
  }

  /**
   * Render EO-IR pipeline visualization
   */
  _renderSQLPipeline(pipeline, stats) {
    const stepsDiv = document.getElementById('sql-pipeline-steps');
    const operatorSymbols = {
      'SOURCE': '◉',
      'FILTER': '⊃',
      'SORT': '↕',
      'LIMIT': '⊤',
      'SELECT': '⊏',
      'GROUP': '⊞',
      'AGGREGATE': '∑',
      'JOIN': '⋈',
      'UNION': '∪'
    };

    const operatorColors = {
      'SOURCE': 'green',
      'FILTER': 'orange',
      'SORT': 'blue',
      'LIMIT': 'orange',
      'SELECT': 'purple',
      'GROUP': 'purple',
      'AGGREGATE': 'purple',
      'JOIN': 'blue',
      'UNION': 'blue'
    };

    stepsDiv.innerHTML = pipeline.map((step, i) => {
      const symbol = operatorSymbols[step.op] || '○';
      const color = operatorColors[step.op] || 'gray';
      const params = Object.entries(step.params || {})
        .map(([k, v]) => `<span class="param-key">${k}:</span> <span class="param-value">${JSON.stringify(v)}</span>`)
        .join(', ');

      const statInfo = stats.operationsExecuted?.[i];
      const reduction = statInfo ? ` (${statInfo.inputRows} → ${statInfo.outputRows})` : '';

      return `
        <div class="pipeline-step">
          <span class="pipeline-symbol" style="color: var(--${color}-500, #888)">${symbol}</span>
          <span class="pipeline-op">${step.op}</span>
          <span class="pipeline-params">${params}</span>
          <span class="pipeline-reduction">${reduction}</span>
        </div>
      `;
    }).join('<div class="pipeline-arrow">↓</div>');
  }

  /**
   * Create data provider for SQL executor
   */
  _createSQLDataProvider() {
    const sets = this.sets;
    return {
      getSourceData(sourceId) {
        // Find by ID or name
        const set = sets.find(s => s.id === sourceId || s.name === sourceId);
        if (!set) {
          console.warn(`Source not found: ${sourceId}`);
          return [];
        }
        // Convert records to plain objects with field names
        return (set.records || []).map(record => {
          const row = {};
          for (const field of set.fields || []) {
            row[field.name] = record.values?.[field.id] ?? record[field.name] ?? record[field.id];
          }
          return row;
        });
      },
      getSourceSchema(sourceId) {
        const set = sets.find(s => s.id === sourceId || s.name === sourceId);
        return set?.fields?.map(f => f.name) || [];
      }
    };
  }

  /**
   * Execute SQL and create a new Set with full EO-IR provenance
   *
   * Uses EOSQLSetBuilder to:
   * - Parse SQL to EO-IR pipeline
   * - Execute with provenance tracking
   * - Create EO-IR events (query_executed, set_defined, record_created)
   * - Store events in the event store for full traceability
   */
  _executeSQLAndCreateSet() {
    const sql = document.getElementById('sql-query-input')?.value?.trim();
    const setName = document.getElementById('sql-set-name')?.value?.trim() || 'SQL: Query Results';
    const purpose = document.getElementById('sql-frame-purpose')?.value?.trim();
    const caveatsText = document.getElementById('sql-frame-caveats')?.value?.trim();
    const caveats = caveatsText ? caveatsText.split('\n').filter(c => c.trim()) : [];

    if (!sql) {
      this._showToast('Enter a SQL query', 'warning');
      return;
    }

    // Get or create event store for EO-IR provenance
    const eventStore = this._getOrCreateEventStore();
    const dataProvider = this._createSQLDataProvider();

    // Use EOSQLSetBuilder for full EO-IR provenance tracking
    const setBuilder = new EOSQLSetBuilder(eventStore, dataProvider);

    let builderResult;
    try {
      builderResult = setBuilder.createSetFromSQL({
        sql,
        setName,
        actor: 'user',
        frame: {
          purpose: purpose || `Created from SQL: ${sql.substring(0, 50)}...`,
          epistemicStatus: 'preliminary',
          caveats
        }
      });
    } catch (error) {
      this._showToast(`SQL Error: ${error.message}`, 'error');
      return;
    }

    // Store all EO-IR events in the event store
    for (const event of builderResult.events) {
      eventStore.append(event);
    }

    // Convert SetConfig to workbench format with full provenance
    const setConfig = builderResult.set;
    const result = builderResult.result;

    // Create workbench-compatible fields from SetConfig fields
    // Use ensureValidField to guarantee width and required properties (TABLE RULE 1, 3)
    const fields = (setConfig.fields || []).map((field, index) => ensureValidField({
      id: field.id,
      name: field.name,
      type: this._mapEOFieldType(field.type),
      sourceColumn: field.sourceColumn,
      isPrimary: index === 0
    }));

    // Create records with values mapped to field IDs
    const records = result.rows.map((row, i) => {
      const values = {};
      fields.forEach(field => {
        values[field.id] = row[field.sourceColumn || field.name];
      });
      return {
        id: generateId(),
        values,
        _sourceRow: i
      };
    });

    // Determine the derivation strategy based on SQL operations
    const derivationStrategy = this._inferDerivationStrategy(builderResult.pipeline);

    const newSet = {
      id: setConfig.id,
      name: setName,
      fields,
      records,
      views: [{
        id: generateId(),
        name: 'All Records',
        type: 'table',
        filters: [],
        sorts: [],
        hiddenFields: []
      }],
      // Full EO-IR Derivation with proper strategy and event references
      derivation: {
        strategy: derivationStrategy,
        sql: sql,
        pipeline: builderResult.pipeline,
        sourceRefs: builderResult.events[0]?.payload?.sourceRefs || [],
        // Event IDs for provenance chain
        queryEventId: builderResult.events.find(e => e.category === 'query_executed')?.id,
        setEventId: builderResult.events.find(e => e.category === 'set_defined')?.id,
        recordEventIds: builderResult.events
          .filter(e => e.category === 'record_created')
          .map(e => e.id),
        frame: {
          purpose: purpose || `Created from SQL: ${sql.substring(0, 50)}...`,
          epistemicStatus: 'preliminary',
          methodology: 'SQL query execution',
          caveats
        },
        grounding: {
          // Reference to source sets/events
          references: (builderResult.events[0]?.grounding?.references || []).map(ref => ({
            eventId: ref.eventId,
            kind: ref.kind
          })),
          // The transformation pipeline
          derivation: {
            operators: builderResult.pipeline,
            frozenParams: { sql }
          }
        },
        derivedAt: new Date().toISOString(),
        derivedBy: 'user',
        stats: {
          inputSources: builderResult.events[0]?.payload?.sourceRefs?.length || 0,
          outputRows: result.rows.length,
          executionMs: result.stats.executionTime
        }
      },
      createdAt: new Date().toISOString()
    };

    this.sets.push(newSet);
    this._addSetToProject(newSet.id);
    this._saveData();
    this._renderSidebar();
    this._selectSet(newSet.id);

    // Log provenance for debugging
    console.log('SQL Set created with EO-IR provenance:', {
      setId: newSet.id,
      events: builderResult.events.length,
      queryEventId: newSet.derivation.queryEventId,
      setEventId: newSet.derivation.setEventId,
      recordEvents: newSet.derivation.recordEventIds?.length
    });

    this._showToast(`Set "${setName}" created with ${result.rows.length} records (${builderResult.events.length} EO-IR events)`, 'success');
  }

  /**
   * Get or create an event store for EO-IR provenance tracking
   */
  _getOrCreateEventStore() {
    // Try to get event store from eoApp
    if (this.eoApp?.eventStore) {
      return this.eoApp.eventStore;
    }

    // Try global event store
    if (typeof window !== 'undefined' && window.eoEventStore) {
      return window.eoEventStore;
    }

    // Create a simple in-memory event store
    if (!this._localEventStore) {
      this._localEventStore = {
        events: new Map(),
        append(event) {
          this.events.set(event.id, event);
          return event;
        },
        get(id) {
          return this.events.get(id);
        },
        getAll() {
          return Array.from(this.events.values());
        },
        getByCategory(category) {
          return Array.from(this.events.values()).filter(e => e.category === category);
        },
        getEntityHistory(entityId) {
          return Array.from(this.events.values()).filter(e =>
            e.payload?.id === entityId ||
            e.payload?.setId === entityId ||
            e.payload?.recordId === entityId
          );
        }
      };
    }
    return this._localEventStore;
  }

  /**
   * Infer derivation strategy from SQL pipeline operations
   * - SEG: filtering/segmentation (WHERE)
   * - CON: connection/joining (JOIN)
   * - ALT: alteration/transformation (aggregates, computed columns)
   */
  _inferDerivationStrategy(pipeline) {
    const ops = pipeline.map(p => p.op);

    // If there's a JOIN, it's a connection (CON)
    if (ops.includes('JOIN')) {
      return 'con';  // DerivationStrategy.CON
    }

    // If there are aggregates or GROUP BY, it's an alteration (ALT)
    if (ops.includes('AGGREGATE') || ops.includes('GROUP')) {
      return 'alt';  // DerivationStrategy.ALT
    }

    // If there's just filtering/selection, it's segmentation (SEG)
    if (ops.includes('FILTER') || ops.includes('SELECT') || ops.includes('LIMIT')) {
      return 'seg';  // DerivationStrategy.SEG
    }

    // Default to SEG for simple queries
    return 'seg';
  }

  /**
   * Map EO field types to workbench field types
   */
  _mapEOFieldType(eoType) {
    const typeMap = {
      'integer': 'number',
      'number': 'number',
      'text': 'text',
      'date': 'date',
      'boolean': 'checkbox',
      'string': 'text'
    };
    return typeMap[eoType] || 'text';
  }

  /**
   * Infer field type from sample values
   */
  _inferFieldTypeFromValues(values) {
    const sample = values.filter(v => v != null).slice(0, 100);
    if (sample.length === 0) return 'text';

    if (sample.every(v => !isNaN(parseFloat(v)) && isFinite(v))) {
      return sample.every(v => Number.isInteger(parseFloat(v))) ? 'number' : 'number';
    }

    const datePattern = /^\d{4}-\d{2}-\d{2}/;
    if (sample.every(v => datePattern.test(String(v)))) return 'date';

    const boolValues = ['true', 'false', 'yes', 'no', '1', '0'];
    if (sample.every(v => boolValues.includes(String(v).toLowerCase()))) return 'checkbox';

    return 'text';
  }

  /**
   * Get lenses for a workspace
   */
  _getLensesForWorkspace(workspaceId) {
    // Get sets for this workspace
    const sets = this.viewRegistry?.getSetsForWorkspace?.(workspaceId) || this.sets;
    const lenses = [];

    for (const set of sets) {
      const registrySet = this.viewRegistry?.sets?.get(set.id);
      if (registrySet) {
        const setLenses = this.viewRegistry?.getLensesForSet?.(set.id) || [];
        for (const lens of setLenses) {
          lenses.push({ ...lens, setName: set.name, setId: set.id });
        }
      } else if (set.views) {
        // Fallback to legacy views
        for (const view of set.views) {
          lenses.push({
            id: view.id,
            name: view.name,
            lensType: view.type,
            setName: set.name,
            setId: set.id
          });
        }
      }
    }

    return lenses;
  }

  /**
   * Render a lens item with nested focuses
   */
  _renderLensItem(lens) {
    const isActive = lens.id === this.currentLensId || lens.id === this.currentViewId;
    const viewIcons = {
      grid: 'ph-table', table: 'ph-table',
      cards: 'ph-cards',
      kanban: 'ph-kanban',
      calendar: 'ph-calendar-blank',
      graph: 'ph-graph',
      timeline: 'ph-clock-countdown',
      filesystem: 'ph-folder-open',
      pipeline: 'ph-cooking-pot',
      flow: 'ph-flow-arrow'
    };
    const icon = viewIcons[lens.lensType] || 'ph-table';

    // Get focuses for this lens
    const focuses = this.viewRegistry?.getFocusesForLens?.(lens.id) || [];
    const set = this.sets.find(s => s.id === lens.setId);
    const totalRecords = set?.records?.length || 0;

    let focusHtml = '';
    if (focuses.length > 0) {
      focusHtml = `
        <div class="focus-children">
          ${focuses.map(focus => {
            const focusRecords = this._getFilteredRecordCountForFocus(focus, set);
            return `
              <div class="focus-item ${focus.id === this.currentFocusId ? 'active' : ''}"
                   data-focus-id="${focus.id}">
                <i class="ph ph-funnel"></i>
                <span>${this._escapeHtml(focus.name)}</span>
                <span class="focus-restriction">${focusRecords}/${totalRecords}</span>
              </div>
            `;
          }).join('')}
        </div>
      `;
    }

    return `
      <div class="lens-group">
        <div class="lens-item ${isActive ? 'active' : ''}"
             data-lens-id="${lens.id}"
             data-set-id="${lens.setId}">
          <i class="ph ${icon}"></i>
          <span>${this._escapeHtml(lens.name)}</span>
          <span class="lens-set-name">${lens.setName ? `· ${this._escapeHtml(lens.setName)}` : ''}</span>
        </div>
        ${focusHtml}
      </div>
    `;
  }

  /**
   * Render a lens item from legacy view object
   */
  _renderLensItemFromView(view, set) {
    const isActive = view.id === this.currentViewId;
    const viewIcons = {
      table: 'ph-table',
      cards: 'ph-cards',
      kanban: 'ph-kanban',
      calendar: 'ph-calendar-blank',
      graph: 'ph-graph',
      filesystem: 'ph-folder-open',
      timeline: 'ph-clock-countdown',
      pipeline: 'ph-cooking-pot',
      flow: 'ph-flow-arrow'
    };
    const icon = viewIcons[view.type] || 'ph-table';

    return `
      <div class="lens-item ${isActive ? 'active' : ''}"
           data-view-id="${view.id}"
           data-set-id="${set.id}">
        <i class="ph ${icon}"></i>
        <span>${this._escapeHtml(view.name)}</span>
      </div>
    `;
  }

  /**
   * Attach event handlers for views hierarchy
   */
  _attachViewsHierarchyHandlers(container) {
    // Workspace toggle
    container.querySelectorAll('.workspace-header').forEach(header => {
      header.addEventListener('click', (e) => {
        const group = header.closest('.workspace-group');
        const workspaceId = group.dataset.workspaceId;
        group.classList.toggle('expanded');

        if (!this.expandedWorkspaces) this.expandedWorkspaces = new Set();
        if (group.classList.contains('expanded')) {
          this.expandedWorkspaces.add(workspaceId);
        } else {
          this.expandedWorkspaces.delete(workspaceId);
        }
      });
    });

    // Lens click
    container.querySelectorAll('.lens-item').forEach(item => {
      item.addEventListener('click', (e) => {
        e.stopPropagation();
        const lensId = item.dataset.lensId || item.dataset.viewId;
        const setId = item.dataset.setId;

        if (setId && setId !== this.currentSetId) {
          this._selectSet(setId);
        }
        if (lensId) {
          this._selectView(lensId);
        }
      });

      item.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        this._showViewContextMenu(e, item.dataset.lensId || item.dataset.viewId);
      });
    });

    // Focus click
    container.querySelectorAll('.focus-item').forEach(item => {
      item.addEventListener('click', (e) => {
        e.stopPropagation();
        this._selectFocus(item.dataset.focusId);
      });
    });

    // Empty hint click
    container.querySelector('#create-first-view')?.addEventListener('click', () => {
      this._showNewViewTypeMenu?.();
    });
  }

  /**
   * Render sources navigation (import hierarchy)
   * FIX #1: Sources panel shows ONLY true imports (GIVEN events)
   * Sets are NOT shown here - they belong in the Sets panel
   *
   * EO Principle: Sources are GIVEN (immutable external data)
   * Sets are MEANT (interpretive schema definitions)
   */
  // --------------------------------------------------------------------------
  // Projects Panel Rendering - Nested Structure
  // --------------------------------------------------------------------------

  /**
   * Render Projects navigation with nested content (Sources, Sets, Definitions, Exports)
   * This creates a hierarchical view where all content is organized under projects.
   * Each project expands to show its Sources (GIVEN), Sets (SCHEMA), Definitions (MEANT), Exports (GIVEN)
   */
  _renderProjectsNavNested() {
    const container = document.getElementById('projects-nav');
    if (!container) return;

    // Ensure data arrays exist
    if (!Array.isArray(this.projects)) this.projects = [];
    if (!Array.isArray(this.sources)) this.sources = [];
    if (!Array.isArray(this.sets)) this.sets = [];
    if (!Array.isArray(this.definitions)) this.definitions = [];
    if (!Array.isArray(this.exports)) this.exports = [];

    // Get all active projects
    const activeProjects = this.projects.filter(p => p.status !== 'archived');

    // Sort projects by creation date (newest first)
    const sortedProjects = activeProjects.sort((a, b) => {
      if (!a.createdAt) return 1;
      if (!b.createdAt) return -1;
      return new Date(b.createdAt) - new Date(a.createdAt);
    });

    // View type icons mapping
    const viewTypeIcons = {
      'grid': 'ph-table',
      'table': 'ph-table',
      'cards': 'ph-cards',
      'kanban': 'ph-kanban',
      'calendar': 'ph-calendar-blank',
      'graph': 'ph-graph',
      'filesystem': 'ph-folder-open',
      'timeline': 'ph-clock-countdown',
      'pipeline': 'ph-cooking-pot',
      'flow': 'ph-flow-arrow'
    };

    // Empty state - no projects yet
    if (sortedProjects.length === 0) {
      container.innerHTML = `
        <div class="nav-empty-state">
          <i class="ph ph-folder-simple-dashed"></i>
          <span>No projects yet</span>
          <button class="btn-link" id="btn-first-project">Create a project</button>
        </div>
      `;
      container.querySelector('#btn-first-project')?.addEventListener('click', () => {
        this._showNewProjectModal();
      });
      // Attach new project button handler
      this._attachNewProjectButtonHandler();
      return;
    }

    // Build HTML for projects with nested content
    let html = '';

    // "All Items" option to show everything without project filter
    const allSourcesCount = this.sources.filter(s => s.status !== 'archived').length;
    const allSetsCount = this.sets.filter(s => s.status !== 'archived').length;
    const allDefinitionsCount = this.definitions.filter(d => d.status !== 'archived').length;
    const allExportsCount = this.exports.length;
    const totalItemCount = allSourcesCount + allSetsCount + allDefinitionsCount + allExportsCount;

    html += `
      <div class="project-tree-item all-projects-item ${!this.currentProjectId ? 'active' : ''}"
           data-project-id="">
        <div class="project-tree-header">
          <i class="ph ph-stack project-icon"></i>
          <span class="project-name">All Items</span>
          <span class="project-item-count">${totalItemCount}</span>
        </div>
      </div>
    `;

    // Separate top-level projects from nested ones
    const topLevelProjects = sortedProjects.filter(p => !p.parentId);
    const projectsByParent = {};

    // Build a map of child projects by parent ID
    for (const project of sortedProjects) {
      if (project.parentId) {
        if (!projectsByParent[project.parentId]) {
          projectsByParent[project.parentId] = [];
        }
        projectsByParent[project.parentId].push(project);
      }
    }

    // Recursive function to render a project and its children
    const renderProjectTree = (project, depth = 0) => {
      const isActiveProject = this.currentProjectId === project.id;
      const isExpanded = this.expandedProjects?.[project.id] ?? isActiveProject;
      const childProjects = projectsByParent[project.id] || [];
      const hasChildren = childProjects.length > 0;

      // Get project's content
      const projectSources = this.sources.filter(s =>
        s.status !== 'archived' && project.sourceIds?.includes(s.id)
      );
      const projectSets = this.sets.filter(s =>
        s.status !== 'archived' && project.setIds?.includes(s.id)
      );
      const projectDefinitions = this.definitions.filter(d =>
        d.status !== 'archived' && project.definitionIds?.includes(d.id)
      );
      const projectExports = this.exports.filter(e => project.exportIds?.includes(e.id));

      const projectItemCount = projectSources.length + projectSets.length +
                               projectDefinitions.length + projectExports.length + childProjects.length;

      // Render nested Sources section
      const sourcesHtml = this._renderNestedSources(projectSources, project.id, viewTypeIcons);

      // Render nested Sets section
      const setsHtml = this._renderNestedSets(projectSets, project.id, viewTypeIcons);

      // Render nested Definitions section
      const definitionsHtml = this._renderNestedDefinitions(projectDefinitions, project.id, projectSets);

      // Render nested Exports section
      const exportsHtml = this._renderNestedExports(projectExports, project.id);

      // Check if this is a sample project
      const sampleBadge = project.isSample ? '<span class="sample-badge" title="Sample data - clear via Settings">Sample</span>' : '';

      // Recursively render child projects
      let childProjectsHtml = '';
      if (hasChildren) {
        childProjectsHtml = `
          <div class="project-section subprojects-section ${isExpanded ? 'expanded' : ''}"
               data-section="subprojects" data-project-id="${project.id}">
            <div class="project-section-header" data-section="subprojects" data-project-id="${project.id}">
              <i class="ph ph-caret-right section-expand-icon"></i>
              <i class="ph ph-folders section-icon"></i>
              <span class="section-title">Sub-projects</span>
              <span class="section-count">${childProjects.length}</span>
            </div>
            <div class="project-section-content subprojects-content">
              ${childProjects.map(child => renderProjectTree(child, depth + 1)).join('')}
            </div>
          </div>
        `;
      }

      const nestedClass = depth > 0 ? 'nested-project' : '';
      const indentStyle = depth > 0 ? `style="margin-left: ${depth * 8}px"` : '';

      return `
        <div class="project-tree-item ${isActiveProject ? 'active' : ''} ${isExpanded ? 'expanded' : ''} ${project.isSample ? 'sample-project' : ''} ${nestedClass}"
             data-project-id="${project.id}" data-depth="${depth}" ${indentStyle}>
          <div class="project-tree-header"
               data-project-id="${project.id}"
               title="${this._escapeHtml(project.description || project.name)}">
            <div class="project-expand-icon">
              <i class="ph ph-caret-right"></i>
            </div>
            <span class="project-color-dot" style="background-color: ${project.color || '#3B82F6'}"></span>
            <i class="ph ${project.icon || 'ph-folder-simple-dashed'} project-icon"></i>
            <span class="project-name">${this._escapeHtml(this._truncateName(project.name, 18 - depth * 2))}</span>
            ${sampleBadge}
            <span class="project-item-count">${projectItemCount}</span>
          </div>
          <div class="project-tree-content">
            ${childProjectsHtml}
            ${sourcesHtml}
            ${setsHtml}
            ${definitionsHtml}
            ${exportsHtml}
          </div>
        </div>
      `;
    };

    // Render top-level projects (those without parentId)
    for (const project of topLevelProjects) {
      html += renderProjectTree(project, 0);
    }

    // Add Archive section if there are archived items
    const archivedHtml = this._renderArchivedSection();
    html += archivedHtml;

    container.innerHTML = html;

    // Attach event handlers
    this._attachProjectsNavNestedHandlers(container);
    this._attachNewProjectButtonHandler();
  }

  /**
   * Render nested Sources section within a project
   */
  _renderNestedSources(sources, projectId, viewTypeIcons) {
    if (sources.length === 0) return '';

    const isExpanded = this.expandedProjectSections?.[`${projectId}-sources`] ?? true;

    const sourcesListHtml = sources.map(source => {
      const isActive = this.currentSourceId === source.id;
      const recordCount = source.data?.length || source.records?.length || 0;

      return `
        <div class="nested-nav-item source-nested-item ${isActive ? 'active' : ''}"
             data-source-id="${source.id}"
             data-project-id="${projectId}"
             title="${this._escapeHtml(source.name)}">
          <i class="ph ph-file-text"></i>
          <span class="nested-item-name">${this._escapeHtml(this._truncateName(source.name, 20))}</span>
          <span class="nested-item-count">${recordCount} rows</span>
          <span class="epistemic-mini-badge given-mini">GIVEN</span>
        </div>
      `;
    }).join('');

    return `
      <div class="project-section sources-section ${isExpanded ? 'expanded' : ''}"
           data-section="sources" data-project-id="${projectId}">
        <div class="project-section-header" data-section="sources" data-project-id="${projectId}">
          <i class="ph ph-caret-right section-expand-icon"></i>
          <i class="ph ph-download-simple section-icon"></i>
          <span class="section-title">Sources</span>
          <span class="section-badge given-badge">GIVEN</span>
          <span class="section-count">${sources.length}</span>
        </div>
        <div class="project-section-content">
          ${sourcesListHtml}
        </div>
      </div>
    `;
  }

  /**
   * Render nested Sets section within a project
   */
  _renderNestedSets(sets, projectId, viewTypeIcons) {
    if (sets.length === 0) return '';

    const isExpanded = this.expandedProjectSections?.[`${projectId}-sets`] ?? true;
    const isViewingSource = !!this.currentSourceId;

    const setsListHtml = sets.map(set => {
      const isActiveSet = !isViewingSource && set.id === this.currentSetId;
      const isSetExpanded = this.expandedSets[set.id] || set.id === this.currentSetId;
      const recordCount = set.records?.length || 0;
      const fieldCount = set.fields?.length || 0;
      const views = set.views || [];
      const lenses = set.lenses || [];

      // Calculate meaning coverage (fields with semantic bindings)
      const fieldsWithMeaning = (set.fields || []).filter(f =>
        f.definitionId || f.boundDefinitionId || f.semanticBinding?.definitionId
      ).length;
      const meaningCoverage = fieldCount > 0 ? Math.round((fieldsWithMeaning / fieldCount) * 100) : 0;
      const meaningStatus = meaningCoverage === 100 ? 'complete' : meaningCoverage >= 50 ? 'partial' : 'low';

      // Get derivation info
      const derivation = this._getSetDerivationInfo(set);
      const operatorBadge = this._getOperatorBadgeHTML(derivation.operator);

      // Render Schema item with Structure and Meaning subsections
      const isFieldsActive = isActiveSet && this.showingSetFields;
      const meaningBindingsList = (set.fields || [])
        .filter(f => f.definitionId || f.boundDefinitionId || f.semanticBinding?.definitionId)
        .slice(0, 3)
        .map(f => this._escapeHtml(f.name))
        .join(', ');
      const moreBindingsCount = Math.max(0, fieldsWithMeaning - 3);

      const schemaItem = `
        <div class="set-view-item set-fields-item ${isFieldsActive ? 'active' : ''}"
             data-set-id="${set.id}"
             data-action="fields"
             title="Schema: ${fieldCount} fields${fieldsWithMeaning > 0 ? `\nMeaning (Bindings): ${meaningBindingsList}${moreBindingsCount > 0 ? ` +${moreBindingsCount} more` : ''}` : ''}">
          <i class="ph ph-blueprint"></i>
          <div class="schema-item-content">
            <span class="schema-item-label">Schema</span>
            ${fieldsWithMeaning > 0 ? `<span class="schema-bindings-hint">${fieldsWithMeaning} bound</span>` : ''}
          </div>
          <span class="view-item-count">${fieldCount} fields</span>
        </div>
      `;

      // Render views
      const viewsHtml = views.map(view => {
        const isActiveView = view.id === this.currentViewId && isActiveSet;
        const viewIcon = viewTypeIcons[view.type] || 'ph-table';
        const viewCount = view.metadata?.recordCount;
        const countHtml = viewCount !== undefined ? `<span class="view-item-count">${viewCount}</span>` : '';

        return `
          <div class="set-view-item ${isActiveView ? 'active' : ''}"
               data-view-id="${view.id}"
               data-set-id="${set.id}"
               title="${this._escapeHtml(view.name)} (${view.type})">
            <i class="ph ${viewIcon}"></i>
            <span>${this._escapeHtml(view.name)}</span>
            ${countHtml}
          </div>
        `;
      }).join('');

      // Render lenses with human-readable names
      const lensesHtml = lenses.map(lens => {
        const isActiveLens = this.currentLensId === lens.id;
        const lensRecordCount = this._getLensRecordCount(set, lens);
        const isLensExpanded = this.expandedLenses?.[lens.id];

        // Generate human-readable lens name if it looks like an ID
        const displayName = this._getHumanReadableLensName(lens, set);

        const lensViewsHtml = (lens.views || []).map(view => {
          const isActiveView = view.id === this.currentViewId && isActiveLens;
          const viewIcon = viewTypeIcons[view.type] || 'ph-table';
          return `
            <div class="set-view-item lens-view-item ${isActiveView ? 'active' : ''}"
                 data-view-id="${view.id}"
                 data-lens-id="${lens.id}"
                 data-set-id="${set.id}">
              <i class="ph ${viewIcon}"></i>
              <span>${this._escapeHtml(view.name)}</span>
            </div>
          `;
        }).join('');

        return `
          <div class="set-lens-container ${isLensExpanded ? 'expanded' : ''}"
               data-lens-id="${lens.id}" data-set-id="${set.id}">
            <div class="set-lens-header ${isActiveLens ? 'active' : ''}"
                 data-lens-id="${lens.id}"
                 data-set-id="${set.id}"
                 title="Lens: ${this._escapeHtml(displayName)} · ${lensRecordCount} records">
              <div class="lens-expand-icon">
                <i class="ph ph-caret-right"></i>
              </div>
              <i class="ph ${lens.icon || 'ph-funnel'}"></i>
              <span>${this._escapeHtml(displayName)}</span>
              <span class="lens-item-count">${lensRecordCount}</span>
            </div>
            <div class="lens-views-list">
              ${lensViewsHtml}
            </div>
          </div>
        `;
      }).join('');

      // Generate meaning health indicator HTML
      const meaningHealthHtml = fieldCount > 0 ? `
        <span class="meaning-health-badge ${meaningStatus}"
              title="Meaning: ${fieldsWithMeaning} of ${fieldCount} fields have semantic definitions${meaningStatus === 'low' ? '. Consider adding definitions to make your data more reusable.' : ''}">
          <i class="ph ph-book-open"></i>
          ${fieldsWithMeaning}/${fieldCount}
        </span>
      ` : '';

      return `
        <div class="set-item-container nested-set ${isSetExpanded ? 'expanded' : ''}"
             data-set-id="${set.id}" data-project-id="${projectId}">
          <div class="set-item-header ${isActiveSet && !this.showingSetFields ? 'active' : ''}"
               data-set-id="${set.id}"
               title="${derivation.description}\n${fieldCount} fields · ${recordCount} records · Meaning: ${fieldsWithMeaning}/${fieldCount}">
            <div class="set-item-expand">
              <i class="ph ph-caret-right"></i>
            </div>
            ${operatorBadge}
            <i class="set-item-icon ${set.icon || 'ph ph-table'}"></i>
            <span class="set-item-name">${this._escapeHtml(set.name)}</span>
            ${meaningHealthHtml}
            <span class="set-item-count">${recordCount}</span>
            <span class="epistemic-mini-badge schema-mini">SCHEMA</span>
          </div>
          <div class="set-views-list">
            ${schemaItem}
            ${lensesHtml}
            ${viewsHtml}
          </div>
        </div>
      `;
    }).join('');

    return `
      <div class="project-section sets-section ${isExpanded ? 'expanded' : ''}"
           data-section="sets" data-project-id="${projectId}">
        <div class="project-section-header" data-section="sets" data-project-id="${projectId}">
          <i class="ph ph-caret-right section-expand-icon"></i>
          <i class="ph ph-database section-icon"></i>
          <span class="section-title">Sets</span>
          <span class="section-badge schema-badge">SCHEMA</span>
          <span class="section-count">${sets.length}</span>
        </div>
        <div class="project-section-content">
          ${setsListHtml}
        </div>
      </div>
    `;
  }

  /**
   * Render nested Definitions section within a project
   * Master-level definitions that work across all sets
   * Shows all keys/fields from all sets with their definition status
   */
  _renderNestedDefinitions(definitions, projectId, projectSets) {
    const isExpanded = this.expandedProjectSections?.[`${projectId}-definitions`] ?? true;

    // Collect ALL unique fields from ALL sets in this project
    const allFields = [];
    const fieldsByKey = new Map(); // key -> array of {setId, setName, field}

    for (const set of projectSets) {
      for (const field of (set.fields || [])) {
        const key = (field.name || '').toLowerCase().trim();
        if (!key) continue;

        if (!fieldsByKey.has(key)) {
          fieldsByKey.set(key, []);
        }
        fieldsByKey.get(key).push({
          setId: set.id,
          setName: set.name,
          field: field
        });
      }
    }

    // Build definition items from both existing definitions AND all discovered fields
    const definitionItems = [];
    const processedKeys = new Set();

    // First, add existing definitions
    for (const def of definitions) {
      const key = (def.term?.term || def.term?.label || '').toLowerCase().trim();
      processedKeys.add(key);

      const linkedFields = this._getDefinitionLinkedFields(def, projectSets);
      const allFieldsForKey = fieldsByKey.get(key) || [];

      definitionItems.push({
        id: def.id,
        term: def.term?.label || def.term?.term || 'Unnamed',
        termKey: def.term?.term || key,
        status: def.status || 'stub',
        authority: def.authority?.shortName || def.authority?.name || null,
        linkedFields: linkedFields,
        allFieldsForKey: allFieldsForKey,
        definition: def
      });
    }

    // Then, add stub entries for fields that don't have definitions yet
    for (const [key, fieldsForKey] of fieldsByKey) {
      if (processedKeys.has(key)) continue;

      // Create a virtual stub definition for this key
      const displayName = key
        .replace(/[_-]/g, ' ')
        .replace(/([a-z])([A-Z])/g, '$1 $2')
        .split(' ')
        .map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
        .join(' ');

      definitionItems.push({
        id: `stub_${key}`,
        term: displayName,
        termKey: key,
        status: 'stub',
        authority: null,
        linkedFields: [], // No bindings yet
        allFieldsForKey: fieldsForKey,
        definition: null
      });
    }

    // Sort: bound definitions first, then by term name
    definitionItems.sort((a, b) => {
      // Verified/complete first
      const statusOrder = { verified: 0, complete: 1, partial: 2, stub: 3, local_only: 4 };
      const aOrder = statusOrder[a.status] ?? 5;
      const bOrder = statusOrder[b.status] ?? 5;
      if (aOrder !== bOrder) return aOrder - bOrder;

      return a.term.localeCompare(b.term);
    });

    // Show empty state if no fields at all
    if (definitionItems.length === 0) {
      return '';
    }

    // Count bound vs unbound
    const boundCount = definitionItems.filter(d => d.status !== 'stub' && d.definition).length;
    const totalCount = definitionItems.length;

    // Render individual definition items
    const definitionsListHtml = definitionItems.map(item => {
      const isActive = this.currentDefinitionId === item.id;
      const isDefExpanded = this.expandedDefinitions?.[item.id] || isActive;
      const hasLinkedFields = item.allFieldsForKey.length > 0;

      // Status badge and icon based on definition status
      let statusIcon = 'ph-circle-dashed';
      let statusClass = 'stub';
      let statusTitle = 'No definition yet';

      switch (item.status) {
        case 'verified':
          statusIcon = 'ph-seal-check';
          statusClass = 'verified';
          statusTitle = 'Verified definition';
          break;
        case 'complete':
          statusIcon = 'ph-check-circle';
          statusClass = 'complete';
          statusTitle = 'Complete definition';
          break;
        case 'partial':
          statusIcon = 'ph-circle-half';
          statusClass = 'partial';
          statusTitle = 'Partial definition';
          break;
        case 'local_only':
          statusIcon = 'ph-house';
          statusClass = 'local';
          statusTitle = 'Local definition';
          break;
        default:
          statusIcon = 'ph-circle-dashed';
          statusClass = 'stub';
          statusTitle = 'No definition - click to define';
      }

      // Render linked fields/sets as nested items
      const linkedSetsHtml = item.allFieldsForKey.map(({ setId, setName, field }) => {
        const isBound = field.semanticBinding?.definitionId === item.id ||
                        field.definitionId === item.id ||
                        field.boundDefinitionId === item.id;
        return `
          <div class="definition-field-item ${isBound ? 'bound' : 'unbound'}"
               data-set-id="${setId}"
               data-field-id="${field.id}"
               data-definition-id="${item.id}"
               title="${this._escapeHtml(setName)}: ${this._escapeHtml(field.name)}${isBound ? ' (bound)' : ' (unbound)'}">
            <i class="ph ${isBound ? 'ph-link' : 'ph-link-break'}"></i>
            <span class="field-set-name">${this._escapeHtml(this._truncateName(setName, 12))}</span>
            <span class="field-name">${this._escapeHtml(field.name)}</span>
          </div>
        `;
      }).join('');

      return `
        <div class="definition-item-container ${isDefExpanded ? 'expanded' : ''}"
             data-definition-id="${item.id}" data-project-id="${projectId}">
          <div class="definition-item-header ${isActive ? 'active' : ''} ${statusClass}"
               data-definition-id="${item.id}"
               title="${statusTitle}${item.authority ? `\nAuthority: ${item.authority}` : ''}\nUsed in ${item.allFieldsForKey.length} field(s)">
            ${hasLinkedFields ? `
              <div class="definition-item-expand">
                <i class="ph ph-caret-right"></i>
              </div>
            ` : '<div class="definition-item-expand-spacer"></div>'}
            <i class="ph ${statusIcon} definition-status-icon"></i>
            <span class="definition-item-name">${this._escapeHtml(item.term)}</span>
            ${item.authority ? `<span class="definition-authority-badge">${this._escapeHtml(item.authority)}</span>` : ''}
            <span class="definition-item-count" title="${item.allFieldsForKey.length} field(s) across sets">${item.allFieldsForKey.length}</span>
            <span class="epistemic-mini-badge meant-mini">MEANT</span>
          </div>
          ${hasLinkedFields ? `
            <div class="definition-fields-list">
              ${linkedSetsHtml}
            </div>
          ` : ''}
        </div>
      `;
    }).join('');

    // Only show the section header without individual definition items in the sidebar dropdown
    return `
      <div class="project-section definitions-section"
           data-section="definitions" data-project-id="${projectId}">
        <div class="project-section-header" data-section="definitions" data-project-id="${projectId}">
          <i class="ph ph-book-open section-icon"></i>
          <span class="section-title">Definitions</span>
          <span class="section-badge meant-badge">MEANT</span>
          <span class="section-count" title="${boundCount} defined of ${totalCount} keys">${boundCount}/${totalCount}</span>
        </div>
      </div>
    `;
  }

  /**
   * Render nested Exports section within a project
   */
  _renderNestedExports(exports, projectId) {
    if (exports.length === 0) return '';

    const isExpanded = this.expandedProjectSections?.[`${projectId}-exports`] ?? false;

    const exportsListHtml = exports.map(exp => {
      const isActive = this.currentExportId === exp.id;
      const exportDate = exp.createdAt ? new Date(exp.createdAt).toLocaleDateString() : '';

      return `
        <div class="nested-nav-item export-nested-item ${isActive ? 'active' : ''}"
             data-export-id="${exp.id}"
             data-project-id="${projectId}"
             title="${this._escapeHtml(exp.name)} - ${exportDate}">
          <i class="ph ph-snowflake"></i>
          <span class="nested-item-name">${this._escapeHtml(this._truncateName(exp.name, 20))}</span>
          <span class="nested-item-date">${exportDate}</span>
          <span class="epistemic-mini-badge given-mini">GIVEN</span>
        </div>
      `;
    }).join('');

    return `
      <div class="project-section exports-section ${isExpanded ? 'expanded' : ''}"
           data-section="exports" data-project-id="${projectId}">
        <div class="project-section-header" data-section="exports" data-project-id="${projectId}">
          <i class="ph ph-caret-right section-expand-icon"></i>
          <i class="ph ph-export section-icon"></i>
          <span class="section-title">Exports</span>
          <span class="section-badge export-badge">GIVEN</span>
          <span class="section-count">${exports.length}</span>
        </div>
        <div class="project-section-content">
          ${exportsListHtml}
        </div>
      </div>
    `;
  }

  /**
   * Get human-readable lens name based on pivot field value
   * Converts opaque IDs like "id_mjuczjawettak" to "By Status" style names
   */
  _getHumanReadableLensName(lens, set) {
    // If the name doesn't look like an auto-generated ID, use it as-is
    if (lens.name && !lens.name.startsWith('id_') && lens.name.length < 30) {
      return lens.name;
    }

    // Try to generate a meaningful name from pivot field
    if (lens.pivotFieldId && lens.pivotValue) {
      const field = set.fields?.find(f => f.id === lens.pivotFieldId);
      if (field) {
        return `By ${field.name}: ${lens.pivotValue}`;
      }
    }

    // Fallback to original name
    return lens.name || 'Unnamed Lens';
  }

  /**
   * Find fields in sets that link to a given definition
   */
  _getDefinitionLinkedFields(definition, projectSets) {
    const linkedFields = [];

    for (const set of projectSets) {
      for (const field of (set.fields || [])) {
        // Check if field references this definition
        if (field.definitionId === definition.id ||
            field.boundDefinitionId === definition.id ||
            field.semanticBinding?.definitionId === definition.id) {
          linkedFields.push({
            setId: set.id,
            setName: set.name,
            fieldId: field.id,
            fieldName: field.name
          });
        }
      }
    }

    return linkedFields;
  }

  /**
   * Attach event handlers for new project button
   */
  _attachNewProjectButtonHandler() {
    document.getElementById('btn-new-project')?.addEventListener('click', () => {
      this._showNewProjectModal();
    });
  }

  /**
   * Attach event handlers for nested project navigation
   */
  _attachProjectsNavNestedHandlers(container) {
    // Initialize expansion state tracking
    if (!this.expandedProjects) this.expandedProjects = {};
    if (!this.expandedProjectSections) this.expandedProjectSections = {};

    // All Items option
    container.querySelector('.all-projects-item')?.addEventListener('click', () => {
      this._selectProject(null);
    });

    // Project headers (expand/collapse and select)
    container.querySelectorAll('.project-tree-header[data-project-id]').forEach(header => {
      header.addEventListener('click', (e) => {
        const projectId = header.dataset.projectId;
        if (!projectId) return; // Skip "All Items"

        // If clicking on expand arrow, just toggle expansion
        if (e.target.closest('.project-expand-icon')) {
          this.expandedProjects[projectId] = !this.expandedProjects[projectId];
          header.closest('.project-tree-item')?.classList.toggle('expanded');
          return;
        }

        // Otherwise select the project and expand it
        this.expandedProjects[projectId] = true;
        this._selectProject(projectId);
      });

      header.addEventListener('contextmenu', (e) => {
        const projectId = header.dataset.projectId;
        if (!projectId) return;
        e.preventDefault();
        this._showProjectContextMenu(e, projectId);
      });
    });

    // Section headers (Sources, Sets, Definitions, Exports)
    container.querySelectorAll('.project-section-header').forEach(header => {
      header.addEventListener('click', (e) => {
        e.stopPropagation();
        const section = header.dataset.section;
        const projectId = header.dataset.projectId;
        const key = `${projectId}-${section}`;

        // If clicking the expand arrow, just toggle expansion
        if (e.target.closest('.section-expand-icon')) {
          this.expandedProjectSections[key] = !this.expandedProjectSections[key];
          header.closest('.project-section')?.classList.toggle('expanded');
          return;
        }

        // Expand the section
        this.expandedProjectSections[key] = true;
        header.closest('.project-section')?.classList.add('expanded');

        // Open the appropriate dashboard tab for this section
        if (section === 'sources') {
          this.openTab('sources');
        } else if (section === 'sets') {
          this.openTab('sets');
        } else if (section === 'definitions') {
          this.openTab('definitions');
        }
      });
    });

    // Source items
    container.querySelectorAll('.source-nested-item').forEach(item => {
      item.addEventListener('click', (e) => {
        e.stopPropagation();
        const sourceId = item.dataset.sourceId;
        this._selectSource(sourceId);
      });

      item.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        e.stopPropagation();
        this._showSourceContextMenu(e, item.dataset.sourceId);
      });
    });

    // Set headers and views (reuse existing handlers)
    container.querySelectorAll('.set-item-header').forEach(header => {
      header.addEventListener('click', (e) => {
        e.stopPropagation();
        const setId = header.dataset.setId;
        const containerEl = header.closest('.set-item-container');

        // If clicking on expand arrow, just toggle expansion
        if (e.target.closest('.set-item-expand')) {
          this.expandedSets[setId] = !this.expandedSets[setId];
          containerEl?.classList.toggle('expanded');
          return;
        }

        // Otherwise expand the set and open the dashboard
        this.expandedSets[setId] = true;
        containerEl?.classList.add('expanded');

        // Open set dashboard (detail panel showing set metadata, sources, etc.)
        this._selectSet(setId);
      });

      header.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        e.stopPropagation();
        this._showSetContextMenu(e, header.dataset.setId);
      });
    });

    // View items
    container.querySelectorAll('.set-view-item').forEach(item => {
      item.addEventListener('click', (e) => {
        e.stopPropagation();
        const setId = item.dataset.setId;
        const viewId = item.dataset.viewId;
        const action = item.dataset.action;

        if (action === 'fields') {
          this._openSchemaTab(setId);
          return;
        }

        this._openViewTab(setId, viewId);
      });

      item.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (item.dataset.action === 'fields') return;
        this._showViewContextMenu(e, item.dataset.viewId, item.dataset.setId);
      });
    });

    // Lens headers
    container.querySelectorAll('.set-lens-header').forEach(header => {
      header.addEventListener('click', (e) => {
        e.stopPropagation();
        const lensId = header.dataset.lensId;
        const containerEl = header.closest('.set-lens-container');

        if (e.target.closest('.lens-expand-icon')) {
          if (!this.expandedLenses) this.expandedLenses = {};
          this.expandedLenses[lensId] = !this.expandedLenses[lensId];
          containerEl?.classList.toggle('expanded');
          return;
        }

        // Select the lens
        const setId = header.dataset.setId;
        if (!this.expandedLenses) this.expandedLenses = {};
        this.expandedLenses[lensId] = true;
        this._openLensTab(setId, lensId);
        this._renderSidebar();
      });

      header.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        e.stopPropagation();
        this._showLensContextMenu(e, header.dataset.lensId, header.dataset.setId);
      });
    });

    // Definition item headers (expand/collapse and select)
    container.querySelectorAll('.definition-item-header').forEach(header => {
      header.addEventListener('click', (e) => {
        e.stopPropagation();
        const definitionId = header.dataset.definitionId;
        const containerEl = header.closest('.definition-item-container');

        // If clicking on expand arrow, just toggle expansion
        if (e.target.closest('.definition-item-expand')) {
          if (!this.expandedDefinitions) this.expandedDefinitions = {};
          this.expandedDefinitions[definitionId] = !this.expandedDefinitions[definitionId];
          containerEl?.classList.toggle('expanded');
          return;
        }

        // Otherwise expand the definition and select it
        if (!this.expandedDefinitions) this.expandedDefinitions = {};
        this.expandedDefinitions[definitionId] = true;
        containerEl?.classList.add('expanded');

        // Select the definition - open definition detail/editor
        this.currentDefinitionId = definitionId;
        this._renderSidebar();

        // If it's a stub (virtual definition), prompt to create a real one
        if (definitionId.startsWith('stub_')) {
          const termKey = definitionId.replace('stub_', '');
          this._promptCreateDefinition(termKey);
        } else {
          // Open definition detail view
          this._showDefinitionDetail(definitionId);
        }
      });

      header.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        e.stopPropagation();
        this._showDefinitionContextMenu(e, header.dataset.definitionId);
      });
    });

    // Definition field items (clicking navigates to that field in the set)
    container.querySelectorAll('.definition-field-item').forEach(item => {
      item.addEventListener('click', (e) => {
        e.stopPropagation();
        const setId = item.dataset.setId;
        const fieldId = item.dataset.fieldId;
        const definitionId = item.dataset.definitionId;

        // Navigate to the set's schema view with this field highlighted
        this._openSchemaTab(setId, fieldId);
      });

      item.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const setId = item.dataset.setId;
        const fieldId = item.dataset.fieldId;
        const definitionId = item.dataset.definitionId;
        this._showFieldDefinitionContextMenu(e, setId, fieldId, definitionId);
      });
    });

    // Export items
    container.querySelectorAll('.export-nested-item').forEach(item => {
      item.addEventListener('click', (e) => {
        e.stopPropagation();
        const exportId = item.dataset.exportId;
        this._selectExport(exportId);
      });

      item.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        e.stopPropagation();
        this._showExportContextMenu(e, item.dataset.exportId);
      });
    });

    // Archive section handlers
    container.querySelectorAll('.archived-item').forEach(item => {
      item.addEventListener('click', (e) => {
        e.stopPropagation();
        const type = item.dataset.type;
        const id = item.dataset.id;

        // Show unarchive confirmation
        const name = item.querySelector('.archived-item-name')?.textContent || 'this item';
        if (confirm(`Restore "${name}" from archive?`)) {
          switch (type) {
            case 'project':
              this._unarchiveProject(id);
              break;
            case 'source':
              this._unarchiveSource(id);
              break;
            case 'set':
              this._unarchiveSet(id);
              break;
            case 'definition':
              this._unarchiveDefinition(id);
              break;
          }
        }
      });
    });

    // Archive section header toggle
    container.querySelector('.archive-section-header')?.addEventListener('click', (e) => {
      const section = e.target.closest('.archive-section');
      if (section) {
        const isExpanded = section.classList.contains('expanded');
        section.classList.toggle('expanded');
        this.archiveSectionExpanded = !isExpanded;
      }
    });
  }

  /**
   * Render the Archive section showing archived items
   */
  _renderArchivedSection() {
    // Count archived items
    const archivedProjects = this.projects?.filter(p => p.status === 'archived' && !p.isSample) || [];
    const archivedSources = this.sources?.filter(s => s.status === 'archived' && !s.isSample) || [];
    const archivedSets = this.sets?.filter(s => s.status === 'archived' && !s.isSample) || [];
    const archivedDefinitions = this.definitions?.filter(d => d.status === 'archived') || [];

    const totalArchived = archivedProjects.length + archivedSources.length + archivedSets.length + archivedDefinitions.length;

    if (totalArchived === 0) {
      return '';
    }

    const isExpanded = this.archiveSectionExpanded ?? false;

    let archivedItemsHtml = '';

    // Archived Projects
    for (const project of archivedProjects) {
      archivedItemsHtml += `
        <div class="archived-item" data-type="project" data-id="${project.id}" title="Click to restore">
          <i class="ph ph-folder-simple-dashed"></i>
          <span class="archived-item-name">${this._escapeHtml(project.name)}</span>
          <span class="archived-item-type">Project</span>
        </div>
      `;
    }

    // Archived Sources
    for (const source of archivedSources) {
      archivedItemsHtml += `
        <div class="archived-item" data-type="source" data-id="${source.id}" title="Click to restore">
          <i class="ph ph-file-text"></i>
          <span class="archived-item-name">${this._escapeHtml(source.name)}</span>
          <span class="archived-item-type">Source</span>
        </div>
      `;
    }

    // Archived Sets
    for (const set of archivedSets) {
      archivedItemsHtml += `
        <div class="archived-item" data-type="set" data-id="${set.id}" title="Click to restore">
          <i class="ph ph-table"></i>
          <span class="archived-item-name">${this._escapeHtml(set.name)}</span>
          <span class="archived-item-type">Set</span>
        </div>
      `;
    }

    // Archived Definitions
    for (const def of archivedDefinitions) {
      archivedItemsHtml += `
        <div class="archived-item" data-type="definition" data-id="${def.id}" title="Click to restore">
          <i class="ph ph-book-open-text"></i>
          <span class="archived-item-name">${this._escapeHtml(def.name)}</span>
          <span class="archived-item-type">Definition</span>
        </div>
      `;
    }

    return `
      <div class="archive-section ${isExpanded ? 'expanded' : ''}">
        <div class="archive-section-header">
          <i class="ph ph-caret-right section-expand-icon"></i>
          <i class="ph ph-archive"></i>
          <span>Archive</span>
          <span class="archive-count">${totalArchived}</span>
        </div>
        <div class="archive-section-content">
          ${archivedItemsHtml}
        </div>
      </div>
    `;
  }

  /**
   * Show context menu for lens (with rename option)
   */
  _showLensContextMenu(e, lensId, setId) {
    const set = this.sets.find(s => s.id === setId);
    const lens = set?.lenses?.find(l => l.id === lensId);
    if (!lens) return;

    const menuItems = [
      {
        label: 'Rename Lens',
        icon: 'ph-pencil-simple',
        action: () => this._renameLensInline(lensId, setId)
      },
      {
        label: 'Add View to Lens',
        icon: 'ph-plus',
        action: () => this._addViewToLens(lensId, setId)
      },
      { divider: true },
      {
        label: 'Delete Lens',
        icon: 'ph-trash',
        danger: true,
        action: () => this._deleteLens(lensId, setId)
      }
    ];

    this._showContextMenu(e, menuItems);
  }

  /**
   * Rename lens inline
   */
  _renameLensInline(lensId, setId) {
    const set = this.sets.find(s => s.id === setId);
    const lens = set?.lenses?.find(l => l.id === lensId);
    if (!lens) return;

    const currentName = this._getHumanReadableLensName(lens, set);
    const newName = prompt('Enter new lens name:', currentName);

    if (newName && newName.trim() && newName !== currentName) {
      const oldName = lens.name || currentName;
      lens.name = newName.trim();

      // Record activity for lens rename
      this._recordActivity({
        action: 'rename',
        entityType: 'lens',
        name: newName.trim(),
        details: `Renamed lens from "${oldName}" to "${newName.trim()}" in "${set.name}"`,
        canReverse: false
      });

      this._saveData();
      this._renderSidebar();
      this._showToast(`Lens renamed to "${newName}"`, 'success');
    }
  }

  /**
   * Delete a lens from a set
   */
  _deleteLens(lensId, setId) {
    const set = this.sets.find(s => s.id === setId);
    if (!set?.lenses) return;

    const lens = set.lenses.find(l => l.id === lensId);
    if (!lens) return;

    const lensName = lens.name || this._getHumanReadableLensName(lens, set);

    // Remove from lenses array
    set.lenses = set.lenses.filter(l => l.id !== lensId);

    // If this was the current lens, clear selection
    if (this.currentLensId === lensId) {
      this.currentLensId = null;
    }

    // Record activity for lens deletion
    this._recordActivity({
      action: 'delete',
      entityType: 'lens',
      name: lensName,
      details: `Deleted lens "${lensName}" from "${set.name}"`,
      canReverse: false
    });

    this._saveData();
    this._renderSidebar();
    this._showToast(`Lens "${lensName}" deleted`, 'success');
  }

  // --------------------------------------------------------------------------
  // Legacy Projects Panel Rendering (kept for compatibility)
  // --------------------------------------------------------------------------

  /**
   * Render Projects navigation panel (legacy - flat view)
   * Projects are super objects that contain Sources, Sets, Definitions, and Exports.
   * Definitions can be cited/referenced across projects.
   */
  _renderProjectsNav() {
    const container = document.getElementById('projects-nav');
    if (!container) return;

    // Ensure projects array exists
    if (!Array.isArray(this.projects)) {
      this.projects = [];
    }

    // Get all active projects
    const activeProjects = this.projects.filter(p => p.status !== 'archived');

    // Sort projects by creation date (newest first)
    const sortedProjects = activeProjects.sort((a, b) => {
      if (!a.createdAt) return 1;
      if (!b.createdAt) return -1;
      return new Date(b.createdAt) - new Date(a.createdAt);
    });

    // Empty state - no projects yet
    if (sortedProjects.length === 0) {
      container.innerHTML = `
        <div class="nav-empty-state">
          <i class="ph ph-folder-simple-dashed"></i>
          <span>No projects yet</span>
          <button class="btn-link" id="btn-first-project">Create a project</button>
        </div>
      `;
      container.querySelector('#btn-first-project')?.addEventListener('click', () => {
        this._showNewProjectModal();
      });
      return;
    }

    // Build HTML for projects
    let html = '';

    // "All Items" option to show everything without project filter
    html += `
      <div class="all-projects-item ${!this.currentProjectId ? 'active' : ''}" data-project-id="">
        <i class="ph ph-stack"></i>
        <span>All Items</span>
      </div>
    `;

    // Render each project
    for (const project of sortedProjects) {
      const isActive = this.currentProjectId === project.id;
      const itemCount = project.getItemCount ? project.getItemCount() :
        (project.sourceIds?.length || 0) + (project.setIds?.length || 0) +
        (project.definitionIds?.length || 0) + (project.exportIds?.length || 0);
      const createdDate = project.createdAt ? new Date(project.createdAt).toLocaleDateString() : '';

      html += `
        <div class="project-item ${isActive ? 'active' : ''}"
             data-project-id="${project.id}"
             title="${this._escapeHtml(project.description || project.name)}">
          <span class="project-color-dot" style="background-color: ${project.color || '#3B82F6'}"></span>
          <i class="ph ${project.icon || 'ph-folder-simple-dashed'} project-icon"></i>
          <div class="project-info">
            <span class="project-name">${this._escapeHtml(this._truncateName(project.name, 18))}</span>
            <span class="project-meta-inline">${createdDate}</span>
          </div>
          <span class="nav-item-count" title="${itemCount} items">${itemCount}</span>
        </div>
      `;
    }

    container.innerHTML = html;

    // Attach event handlers
    this._attachProjectsNavEventHandlers(container);
  }

  /**
   * Attach event handlers for projects navigation
   */
  _attachProjectsNavEventHandlers(container) {
    // All Items option
    container.querySelector('.all-projects-item')?.addEventListener('click', () => {
      this._selectProject(null);
    });

    // Project items
    container.querySelectorAll('.project-item').forEach(item => {
      item.addEventListener('click', () => {
        const projectId = item.dataset.projectId;
        this._selectProject(projectId);
      });

      item.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        this._showProjectContextMenu(e, item.dataset.projectId);
      });
    });
  }

  /**
   * Show projects as a table view in the main content area
   * Each row represents a project with its metadata
   */
  _showProjectsExplorer() {
    const contentArea = this.elements.contentArea;
    if (!contentArea) return;

    // Get all active projects
    const activeProjects = (this.projects || []).filter(p => p.status !== 'archived');

    // Sort by creation date (newest first)
    const sortedProjects = activeProjects.sort((a, b) => {
      if (!a.createdAt) return 1;
      if (!b.createdAt) return -1;
      return new Date(b.createdAt) - new Date(a.createdAt);
    });

    // Clear other selections
    this.currentSourceId = null;
    this.currentDefinitionId = null;
    this.currentSetId = null;
    this.currentViewId = null;

    // Clear selections in sidebar
    document.querySelectorAll('.project-item, .source-item, .set-item').forEach(item => {
      item.classList.remove('active');
    });

    // Update breadcrumb
    this._updateBreadcrumb({
      workspace: this._getCurrentWorkspaceName(),
      set: 'Projects',
      view: 'Explorer'
    });

    // Build the projects table HTML
    contentArea.innerHTML = `
      <div class="sources-table-view projects-table-view">
        <!-- Header -->
        <div class="sources-table-header">
          <div class="sources-table-title">
            <div class="sources-table-icon">
              <i class="ph ph-folder-simple-dashed"></i>
            </div>
            <div class="sources-table-info">
              <h2>
                <span>Projects</span>
                <span class="org-badge" style="margin-left: 8px; font-size: 11px; padding: 2px 8px; border-radius: 4px; background: var(--accent-gray, #6b7280); color: white;">
                  ORG
                </span>
              </h2>
              <div class="sources-table-meta">
                ${sortedProjects.length} project${sortedProjects.length !== 1 ? 's' : ''} in workspace
              </div>
            </div>
          </div>
          <div class="sources-table-actions">
            <button class="source-action-btn" id="projects-table-new-btn" title="Create new project">
              <i class="ph ph-plus"></i>
              <span>New Project</span>
            </button>
          </div>
        </div>

        <!-- Toolbar -->
        <div class="sources-table-toolbar">
          <div class="sources-table-search">
            <i class="ph ph-magnifying-glass"></i>
            <input type="text" id="projects-table-search" placeholder="Search projects...">
          </div>
          <div class="sources-table-count">
            ${sortedProjects.length} project${sortedProjects.length !== 1 ? 's' : ''}
          </div>
        </div>

        <!-- Table -->
        <div class="sources-table-container">
          ${sortedProjects.length > 0 ? `
            <table class="sources-table projects-table">
              <thead>
                <tr>
                  <th class="col-icon"></th>
                  <th class="col-name">Name</th>
                  <th class="col-sources">Sources</th>
                  <th class="col-definitions">Definitions</th>
                  <th class="col-sets">Sets</th>
                  <th class="col-exports">Exports</th>
                  <th class="col-created">Created</th>
                  <th class="col-actions"></th>
                </tr>
              </thead>
              <tbody>
                ${sortedProjects.map(project => {
                  const icon = project.icon || 'ph-folder-simple-dashed';
                  const color = project.color || '#6b7280';
                  const sourceCount = project.sourceIds?.length || 0;
                  const definitionCount = project.definitionIds?.length || 0;
                  const setCount = project.setIds?.length || 0;
                  const exportCount = project.exportIds?.length || 0;
                  const createdDate = project.createdAt ? new Date(project.createdAt).toLocaleDateString() : 'Unknown';

                  return `
                    <tr class="sources-table-row projects-table-row" data-project-id="${project.id}">
                      <td class="col-icon">
                        <i class="ph ${icon}" style="color: ${color};"></i>
                      </td>
                      <td class="col-name">
                        <span class="project-name-text" style="color: ${color}; font-weight: 600;">${this._escapeHtml(project.name)}</span>
                      </td>
                      <td class="col-sources">${sourceCount}</td>
                      <td class="col-definitions">${definitionCount}</td>
                      <td class="col-sets">${setCount}</td>
                      <td class="col-exports">${exportCount}</td>
                      <td class="col-created">${createdDate}</td>
                      <td class="col-actions">
                        <button class="sources-table-action-btn" data-action="select" title="Select project">
                          <i class="ph ph-check"></i>
                        </button>
                        <button class="sources-table-action-btn" data-action="rename" title="Rename project">
                          <i class="ph ph-pencil"></i>
                        </button>
                        <button class="sources-table-action-btn sources-table-delete-btn" data-action="delete" title="Delete project">
                          <i class="ph ph-trash"></i>
                        </button>
                      </td>
                    </tr>
                  `;
                }).join('')}
              </tbody>
            </table>
          ` : `
            <div class="sources-table-empty">
              <i class="ph ph-folder-simple-dashed"></i>
              <p>No projects created yet</p>
              <button class="btn-primary" id="projects-table-first-create">
                <i class="ph ph-plus"></i>
                Create your first project
              </button>
            </div>
          `}
        </div>
      </div>
    `;

    // Attach event handlers
    this._attachProjectsTableHandlers(sortedProjects);
  }

  /**
   * Attach event handlers for projects table view
   */
  _attachProjectsTableHandlers(projects) {
    // New project button
    document.getElementById('projects-table-new-btn')?.addEventListener('click', () => {
      this._createProject();
    });

    // First create button (empty state)
    document.getElementById('projects-table-first-create')?.addEventListener('click', () => {
      this._createProject();
    });

    // Search
    const searchInput = document.getElementById('projects-table-search');
    searchInput?.addEventListener('input', (e) => {
      this._filterProjectsTable(e.target.value);
    });

    // Row click to select project
    document.querySelectorAll('.projects-table-row').forEach(row => {
      row.addEventListener('click', (e) => {
        // Ignore if clicking action buttons
        if (e.target.closest('.sources-table-action-btn')) return;

        const projectId = row.dataset.projectId;
        this._selectProject(projectId);
      });

      row.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        this._showProjectContextMenu(e, row.dataset.projectId);
      });
    });

    // Action buttons
    document.querySelectorAll('.projects-table-row .sources-table-action-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const row = btn.closest('.projects-table-row');
        const projectId = row.dataset.projectId;
        const action = btn.dataset.action;

        switch (action) {
          case 'select':
            this._selectProject(projectId);
            break;
          case 'rename':
            this._renameProject(projectId);
            break;
          case 'delete':
            if (confirm('Are you sure you want to delete this project?')) {
              this._deleteProject(projectId);
              this._showProjectsExplorer(); // Refresh
            }
            break;
        }
      });
    });
  }

  /**
   * Filter projects table by search term
   */
  _filterProjectsTable(searchTerm) {
    const rows = document.querySelectorAll('.projects-table-row');
    const term = searchTerm.toLowerCase();

    rows.forEach(row => {
      const name = row.querySelector('.project-name-text')?.textContent.toLowerCase() || '';
      const visible = name.includes(term);
      row.style.display = visible ? '' : 'none';
    });

    // Update count
    const visibleRows = document.querySelectorAll('.projects-table-row:not([style*="display: none"])');
    const countEl = document.querySelector('.projects-table-view .sources-table-count');
    if (countEl) {
      countEl.textContent = `${visibleRows.length} project${visibleRows.length !== 1 ? 's' : ''}`;
    }
  }

  /**
   * Select a project (or null for "All Items")
   */
  _selectProject(projectId) {
    this.currentProjectId = projectId;

    // Clear other selections when switching projects
    this.currentSourceId = null;
    this.currentDefinitionId = null;
    this.currentExportId = null;

    // Re-render sidebar to show filtered content
    this._renderSidebar();

    // Update breadcrumb
    this._updateBreadcrumb();

    // Save state
    this._saveData();
  }

  /**
   * Get sources for the current project (or all if no project selected)
   */
  _getProjectSources() {
    if (!this.currentProjectId) {
      return this.sources.filter(s => s.status !== 'archived');
    }
    const project = this.projects.find(p => p.id === this.currentProjectId);
    if (!project) return [];
    return this.sources.filter(s =>
      s.status !== 'archived' && project.sourceIds?.includes(s.id)
    );
  }

  /**
   * Get sets for the current project (or all if no project selected)
   */
  _getProjectSets() {
    if (!this.currentProjectId) {
      return this.sets;
    }
    const project = this.projects.find(p => p.id === this.currentProjectId);
    if (!project) return [];
    return this.sets.filter(s => project.setIds?.includes(s.id));
  }

  /**
   * Get definitions for the current project (or all if no project selected)
   */
  _getProjectDefinitions() {
    if (!this.currentProjectId) {
      return this.definitions.filter(d => d.status !== 'archived');
    }
    const project = this.projects.find(p => p.id === this.currentProjectId);
    if (!project) return [];
    return this.definitions.filter(d =>
      d.status !== 'archived' && project.definitionIds?.includes(d.id)
    );
  }

  /**
   * Get exports for the current project (or all if no project selected)
   */
  _getProjectExports() {
    if (!this.currentProjectId) {
      return this.exports;
    }
    const project = this.projects.find(p => p.id === this.currentProjectId);
    if (!project) return [];
    return this.exports.filter(e => project.exportIds?.includes(e.id));
  }

  /**
   * Update panel header with project context indicator
   * Shows "in [Project Name]" or item count when filtering by project
   */
  _updatePanelProjectContext(panelType, filteredCount, totalCount) {
    const panelMap = {
      sources: '.sources-panel',
      sets: '.sets-panel',
      definitions: '.definitions-panel',
      exports: '.exports-panel'
    };

    const selector = panelMap[panelType];
    if (!selector) return;

    const panel = document.querySelector(selector);
    if (!panel) return;

    // Find or create the project context element
    let contextEl = panel.querySelector('.nav-panel-project-context');
    if (!contextEl) {
      const header = panel.querySelector('.nav-panel-header');
      if (header) {
        contextEl = document.createElement('div');
        contextEl.className = 'nav-panel-project-context';
        header.after(contextEl);
      }
    }

    if (!contextEl) return;

    // Show context when a project is selected
    if (this.currentProjectId) {
      const project = this.projects.find(p => p.id === this.currentProjectId);
      if (project) {
        contextEl.innerHTML = `
          <span class="project-context-badge" style="border-left-color: ${project.color || '#3B82F6'}">
            <i class="ph ph-folder-simple"></i>
            <span class="project-context-name">${this._escapeHtml(this._truncateName(project.name, 15))}</span>
            <span class="project-context-count">${filteredCount}</span>
          </span>
        `;
        contextEl.style.display = 'flex';
      } else {
        contextEl.style.display = 'none';
      }
    } else {
      // Show "All Items" mode with total count
      if (totalCount > 0) {
        contextEl.innerHTML = `
          <span class="project-context-badge all-items">
            <i class="ph ph-stack"></i>
            <span class="project-context-name">All Items</span>
            <span class="project-context-count">${totalCount}</span>
          </span>
        `;
        contextEl.style.display = 'flex';
      } else {
        contextEl.style.display = 'none';
      }
    }
  }

  /**
   * Show project context menu
   */
  _showProjectContextMenu(e, projectId) {
    const project = this.projects.find(p => p.id === projectId);
    if (!project) return;

    const menuItems = [
      {
        label: 'Rename',
        icon: 'ph-pencil-simple',
        action: () => this._renameProject(projectId)
      },
      {
        label: 'Edit Color',
        icon: 'ph-palette',
        action: () => this._editProjectColor(projectId)
      },
      { divider: true },
      {
        label: 'Create Sub-project',
        icon: 'ph-folder-plus',
        action: () => this._showNewProjectModal(projectId)
      },
      {
        label: 'Move to...',
        icon: 'ph-arrow-square-out',
        action: () => this._showMoveProjectModal(projectId)
      },
      { divider: true }
    ];

    // Sample data can only be cleared via Settings > Clear Sample Data
    if (project.isSample) {
      menuItems.push({
        label: 'Sample Data (use Settings to clear)',
        icon: 'ph-flask',
        disabled: true,
        action: () => {
          this._showToast('Sample data can only be cleared via Settings → Clear Sample Data', 'info');
        }
      });
    } else {
      menuItems.push({
        label: 'Archive Project',
        icon: 'ph-archive',
        danger: true,
        action: () => this._archiveProject(projectId)
      });
      menuItems.push({
        label: 'Delete Project',
        icon: 'ph-trash',
        danger: true,
        action: () => this._deleteProject(projectId)
      });
    }

    this._showContextMenu(e, menuItems);
  }

  /**
   * Show modal for creating a new project
   */
  _showNewProjectModal(defaultParentId = null) {
    const modal = document.getElementById('modal-overlay');
    const modalTitle = modal?.querySelector('.modal-title');
    const modalBody = document.getElementById('modal-body');
    const modalFooter = document.getElementById('modal-footer');
    if (!modal || !modalBody) return;

    // Project colors
    const colors = [
      '#3B82F6', // Blue
      '#10B981', // Green
      '#F59E0B', // Amber
      '#EF4444', // Red
      '#8B5CF6', // Purple
      '#EC4899', // Pink
      '#06B6D4', // Cyan
      '#84CC16', // Lime
    ];

    // Get available parent projects (exclude sample and archived)
    const availableParents = (this.projects || []).filter(p =>
      p.status !== 'archived' && !p.isSample
    );

    // Build parent project options
    const parentOptions = availableParents.map(p =>
      `<option value="${p.id}" ${p.id === defaultParentId ? 'selected' : ''}>${this._escapeHtml(p.name)}</option>`
    ).join('');

    modalTitle.textContent = 'New Project';
    modalBody.innerHTML = `
      <div class="form-group">
        <label class="form-label">Project Name</label>
        <input type="text" id="new-project-name" class="form-input" placeholder="My Project" autofocus>
      </div>
      <div class="form-group">
        <label class="form-label">Description (optional)</label>
        <textarea id="new-project-description" class="form-textarea" rows="2" placeholder="What is this project about?"></textarea>
      </div>
      <div class="form-group">
        <label class="form-label">Parent Folder (optional)</label>
        <select id="new-project-parent" class="form-input">
          <option value="">None (top-level project)</option>
          ${parentOptions}
        </select>
        <span class="form-hint">Nest this project inside another project</span>
      </div>
      <div class="form-group">
        <label class="form-label">Color</label>
        <div class="color-picker-grid">
          ${colors.map((color, i) => `
            <button class="color-picker-item ${i === 0 ? 'selected' : ''}"
                    data-color="${color}"
                    style="background-color: ${color}">
            </button>
          `).join('')}
        </div>
      </div>
    `;

    // Color picker interaction
    let selectedColor = colors[0];
    modalBody.querySelectorAll('.color-picker-item').forEach(btn => {
      btn.addEventListener('click', () => {
        modalBody.querySelectorAll('.color-picker-item').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        selectedColor = btn.dataset.color;
      });
    });

    modalFooter.innerHTML = `
      <button class="btn btn-secondary" id="modal-cancel">Cancel</button>
      <button class="btn btn-primary" id="modal-confirm">Create Project</button>
    `;

    modal.classList.add('active');

    // Focus the name input
    setTimeout(() => document.getElementById('new-project-name')?.focus(), 100);

    // Handle confirm
    const confirmBtn = document.getElementById('modal-confirm');
    const cancelBtn = document.getElementById('modal-cancel');

    confirmBtn.addEventListener('click', () => {
      const name = document.getElementById('new-project-name').value.trim();
      const description = document.getElementById('new-project-description').value.trim();
      const parentId = document.getElementById('new-project-parent').value || null;

      if (!name) {
        this._showToast('Please enter a project name', 'error');
        return;
      }

      this._createProject({
        name,
        description,
        color: selectedColor,
        parentId
      });

      modal.classList.remove('active');
    });

    cancelBtn.addEventListener('click', () => {
      modal.classList.remove('active');
    });

    // Enter key to submit
    document.getElementById('new-project-name').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        confirmBtn.click();
      }
    });
  }

  /**
   * Create a new project
   */
  _createProject(config) {
    const project = {
      id: 'proj_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 9),
      name: config.name || 'Untitled Project',
      description: config.description || '',
      icon: config.icon || 'ph-folder-simple-dashed',
      color: config.color || '#3B82F6',
      parentId: config.parentId || null, // Parent project for nesting
      sourceIds: [],
      setIds: [],
      definitionIds: [],
      exportIds: [],
      settings: {
        isDefault: this.projects.length === 0 // First project is default
      },
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      status: 'active',
      // Helper method
      getItemCount() {
        return (this.sourceIds?.length || 0) + (this.setIds?.length || 0) +
               (this.definitionIds?.length || 0) + (this.exportIds?.length || 0);
      }
    };

    this.projects.push(project);
    this._selectProject(project.id);
    this._renderSidebar();
    this._saveData();
    this._showToast(`Created project "${project.name}"`, 'success');

    return project;
  }

  /**
   * Rename a project
   */
  _renameProject(projectId) {
    const project = this.projects.find(p => p.id === projectId);
    if (!project) return;

    const oldName = project.name;
    const newName = prompt('Rename project:', project.name);
    if (newName && newName.trim() && newName.trim() !== oldName) {
      project.name = newName.trim();
      project.updatedAt = new Date().toISOString();

      // Record activity for project rename
      this._recordActivity({
        action: 'rename',
        entityType: 'project',
        name: newName.trim(),
        details: `Renamed project from "${oldName}" to "${newName.trim()}"`,
        canReverse: false
      });

      this._renderProjectsNav();
      this._updateBreadcrumb();
      this._saveData();
      this._showToast(`Project renamed to "${project.name}"`, 'success');
    }
  }

  /**
   * Edit project color
   */
  _editProjectColor(projectId) {
    const project = this.projects.find(p => p.id === projectId);
    if (!project) return;

    const colors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899', '#06B6D4', '#84CC16'];
    const currentIndex = colors.indexOf(project.color);
    const nextIndex = (currentIndex + 1) % colors.length;

    const oldColor = project.color;
    project.color = colors[nextIndex];
    project.updatedAt = new Date().toISOString();

    // Record activity for project color change
    this._recordActivity({
      action: 'update',
      entityType: 'project',
      name: project.name,
      details: `Changed color for project "${project.name}"`,
      canReverse: false
    });

    this._renderProjectsNav();
    this._saveData();
  }

  /**
   * Show modal to move a project to a different parent
   */
  _showMoveProjectModal(projectId) {
    const project = this.projects.find(p => p.id === projectId);
    if (!project) return;

    const modal = document.getElementById('modal-overlay');
    const modalTitle = modal?.querySelector('.modal-title');
    const modalBody = document.getElementById('modal-body');
    const modalFooter = document.getElementById('modal-footer');
    if (!modal || !modalBody) return;

    // Get all projects that can be parents (exclude self, descendants, sample, and archived)
    const descendants = this._getProjectDescendants(projectId);
    const availableParents = (this.projects || []).filter(p =>
      p.id !== projectId &&
      !descendants.includes(p.id) &&
      p.status !== 'archived' &&
      !p.isSample
    );

    // Build parent project options
    const parentOptions = availableParents.map(p => {
      const indent = this._getProjectDepth(p.id);
      const prefix = '—'.repeat(indent);
      return `<option value="${p.id}" ${p.id === project.parentId ? 'selected' : ''}>${prefix}${prefix ? ' ' : ''}${this._escapeHtml(p.name)}</option>`;
    }).join('');

    modalTitle.textContent = `Move "${project.name}"`;
    modalBody.innerHTML = `
      <div class="form-group">
        <label class="form-label">Move to</label>
        <select id="move-project-parent" class="form-input">
          <option value="" ${!project.parentId ? 'selected' : ''}>Top level (no parent)</option>
          ${parentOptions}
        </select>
      </div>
    `;

    modalFooter.innerHTML = `
      <button class="btn btn-secondary" id="modal-cancel">Cancel</button>
      <button class="btn btn-primary" id="modal-confirm">Move</button>
    `;

    modal.classList.add('active');

    // Handle confirm
    document.getElementById('modal-confirm').addEventListener('click', () => {
      const newParentId = document.getElementById('move-project-parent').value || null;

      if (newParentId === project.parentId) {
        modal.classList.remove('active');
        return;
      }

      project.parentId = newParentId;
      project.updatedAt = new Date().toISOString();

      modal.classList.remove('active');
      this._renderSidebar();
      this._saveData();
      this._showToast(`Moved "${project.name}"`, 'success');
    });

    document.getElementById('modal-cancel').addEventListener('click', () => {
      modal.classList.remove('active');
    });
  }

  /**
   * Get all descendant project IDs of a given project
   */
  _getProjectDescendants(projectId) {
    const descendants = [];
    const children = this.projects.filter(p => p.parentId === projectId);

    for (const child of children) {
      descendants.push(child.id);
      descendants.push(...this._getProjectDescendants(child.id));
    }

    return descendants;
  }

  /**
   * Get the depth of a project in the hierarchy
   */
  _getProjectDepth(projectId) {
    const project = this.projects.find(p => p.id === projectId);
    if (!project || !project.parentId) return 0;
    return 1 + this._getProjectDepth(project.parentId);
  }

  /**
   * Archive a project
   */
  _archiveProject(projectId) {
    const project = this.projects.find(p => p.id === projectId);
    if (!project) return;

    // Sample data cannot be archived
    if (project.isSample) {
      this._showToast('Sample data can only be cleared via Settings → Clear Sample Data', 'info');
      return;
    }

    if (!confirm(`Archive project "${project.name}"? You can restore it from the Archive section.`)) {
      return;
    }

    const previousStatus = project.status || 'active';
    project.status = 'archived';
    project.updatedAt = new Date().toISOString();

    // If this was the current project, clear selection
    if (this.currentProjectId === projectId) {
      this.currentProjectId = null;
    }

    // Record activity for state reconstruction
    this._recordActivity({
      action: 'archive',
      entityType: 'project',
      entityId: projectId,
      name: project.name,
      delta: [previousStatus, 'archived']
    });

    this._renderSidebar();
    this._updateBreadcrumb();
    this._saveData();
    this._showToast(`Archived project "${project.name}"`, 'success');
  }

  /**
   * Delete a project permanently
   */
  _deleteProject(projectId) {
    const project = this.projects.find(p => p.id === projectId);
    if (!project) return;

    // Sample data cannot be deleted via context menu
    if (project.isSample) {
      this._showToast('Sample data can only be cleared via Settings → Clear Sample Data', 'info');
      return;
    }

    const itemCount = (project.sourceIds?.length || 0) + (project.setIds?.length || 0) +
                      (project.definitionIds?.length || 0) + (project.exportIds?.length || 0);

    if (!confirm(`Delete project "${project.name}" and all its contents (${itemCount} items)? This cannot be undone.`)) {
      return;
    }

    // Remove associated sources
    if (project.sourceIds?.length) {
      this.sources = this.sources?.filter(s => !project.sourceIds.includes(s.id)) || [];
    }

    // Remove associated sets
    if (project.setIds?.length) {
      this.sets = this.sets?.filter(s => !project.setIds.includes(s.id)) || [];
    }

    // Remove associated definitions
    if (project.definitionIds?.length) {
      this.definitions = this.definitions?.filter(d => !project.definitionIds.includes(d.id)) || [];
    }

    // Remove associated exports
    if (project.exportIds?.length) {
      this.exports = this.exports?.filter(e => !project.exportIds.includes(e.id)) || [];
    }

    // Remove the project itself
    this.projects = this.projects?.filter(p => p.id !== projectId) || [];

    // Clear current project selection if it was this project
    if (this.currentProjectId === projectId) {
      this.currentProjectId = null;
    }

    this._renderSidebar();
    this._updateBreadcrumb();
    this._saveData();
    this._showToast(`Deleted project "${project.name}"`, 'success');
  }

  /**
   * Unarchive a project
   */
  _unarchiveProject(projectId) {
    const project = this.projects.find(p => p.id === projectId);
    if (!project) return;

    const previousStatus = project.status;
    project.status = 'active';
    project.updatedAt = new Date().toISOString();

    // Record activity for state reconstruction
    this._recordActivity({
      action: 'restore',
      entityType: 'project',
      entityId: projectId,
      name: project.name,
      delta: [previousStatus, 'active']
    });

    this._renderSidebar();
    this._saveData();
    this._showToast(`Restored project "${project.name}"`, 'success');
  }

  /**
   * Archive a source
   */
  _archiveSource(sourceId) {
    const source = this.sources?.find(s => s.id === sourceId);
    if (!source) return;

    // Sample data cannot be archived
    if (source.isSample) {
      this._showToast('Sample data can only be cleared via Settings → Clear Sample Data', 'info');
      return;
    }

    const previousStatus = source.status || 'active';
    source.status = 'archived';
    source.updatedAt = new Date().toISOString();

    // Record activity for state reconstruction
    this._recordActivity({
      action: 'archive',
      entityType: 'source',
      entityId: sourceId,
      name: source.name,
      delta: [previousStatus, 'archived']
    });

    this._renderSidebar();
    this._saveData();
    this._showToast(`Archived source "${source.name}"`, 'success');
  }

  /**
   * Unarchive a source
   */
  _unarchiveSource(sourceId) {
    const source = this.sources?.find(s => s.id === sourceId);
    if (!source) return;

    const previousStatus = source.status;
    source.status = 'active';
    source.updatedAt = new Date().toISOString();

    // Record activity for state reconstruction
    this._recordActivity({
      action: 'restore',
      entityType: 'source',
      entityId: sourceId,
      name: source.name,
      delta: [previousStatus, 'active']
    });

    this._renderSidebar();
    this._saveData();
    this._showToast(`Restored source "${source.name}"`, 'success');
  }

  /**
   * Archive a set
   */
  _archiveSet(setId) {
    const set = this.sets?.find(s => s.id === setId);
    if (!set) return;

    // Sample data cannot be archived
    if (set.isSample) {
      this._showToast('Sample data can only be cleared via Settings → Clear Sample Data', 'info');
      return;
    }

    const previousStatus = set.status || 'active';
    set.status = 'archived';
    set.updatedAt = new Date().toISOString();

    // Close any open tabs for this set
    if (this.browserTabs) {
      this.browserTabs = this.browserTabs.filter(tab => tab.setId !== setId);
      if (this.activeTabId) {
        const activeTab = this.browserTabs.find(t => t.id === this.activeTabId);
        if (!activeTab && this.browserTabs.length > 0) {
          this.activeTabId = this.browserTabs[0].id;
        } else if (this.browserTabs.length === 0) {
          this.activeTabId = null;
        }
      }
    }

    // Clear current set selection if it was this set
    if (this.currentSetId === setId) {
      this.currentSetId = null;
    }

    // Record activity for state reconstruction
    this._recordActivity({
      action: 'archive',
      entityType: 'set',
      entityId: setId,
      name: set.name,
      delta: [previousStatus, 'archived']
    });

    this._renderSidebar();
    this._renderTabBar();
    this._saveData();
    this._showToast(`Archived set "${set.name}"`, 'success');
  }

  /**
   * Unarchive a set
   */
  _unarchiveSet(setId) {
    const set = this.sets?.find(s => s.id === setId);
    if (!set) return;

    const previousStatus = set.status;
    set.status = 'active';
    set.updatedAt = new Date().toISOString();

    // Record activity for state reconstruction
    this._recordActivity({
      action: 'restore',
      entityType: 'set',
      entityId: setId,
      name: set.name,
      delta: [previousStatus, 'active']
    });

    this._renderSidebar();
    this._saveData();
    this._showToast(`Restored set "${set.name}"`, 'success');
  }

  /**
   * Archive a definition
   */
  _archiveDefinition(definitionId) {
    const definition = this.definitions?.find(d => d.id === definitionId);
    if (!definition) return;

    const previousStatus = definition.status || 'active';
    definition.status = 'archived';
    definition.updatedAt = new Date().toISOString();

    // Record activity for state reconstruction
    this._recordActivity({
      action: 'archive',
      entityType: 'definition',
      entityId: definitionId,
      name: definition.name,
      delta: [previousStatus, 'archived']
    });

    this._renderSidebar();
    this._saveData();
    this._showToast(`Archived definition "${definition.name}"`, 'success');
  }

  /**
   * Unarchive a definition
   */
  _unarchiveDefinition(definitionId) {
    const definition = this.definitions?.find(d => d.id === definitionId);
    if (!definition) return;

    const previousStatus = definition.status;
    definition.status = 'active';
    definition.updatedAt = new Date().toISOString();

    // Record activity for state reconstruction
    this._recordActivity({
      action: 'restore',
      entityType: 'definition',
      entityId: definitionId,
      name: definition.name,
      delta: [previousStatus, 'active']
    });

    this._renderSidebar();
    this._saveData();
    this._showToast(`Restored definition "${definition.name}"`, 'success');
  }

  /**
   * Get or create a default project for new items
   * If no project is selected, uses the first project or creates a default one
   */
  _getOrCreateDefaultProject() {
    // If a project is already selected, use it
    if (this.currentProjectId) {
      const project = this.projects.find(p => p.id === this.currentProjectId);
      if (project) return project;
    }

    // If no projects exist, create a default one
    if (!this.projects || this.projects.length === 0) {
      const defaultProject = this._createProject({
        name: 'My Project',
        description: 'Default project for organizing data',
        color: '#3B82F6'
      });
      return defaultProject;
    }

    // Otherwise, return the first active project
    const activeProjects = this.projects.filter(p => p.status !== 'archived');
    if (activeProjects.length > 0) {
      return activeProjects[0];
    }

    // All projects are archived - create a new default
    return this._createProject({
      name: 'My Project',
      description: 'Default project for organizing data',
      color: '#3B82F6'
    });
  }

  /**
   * Add a source to the current project (or a specific project)
   * Creates a default project if none exists
   */
  _addSourceToProject(sourceId, projectId = null) {
    let targetProjectId = projectId || this.currentProjectId;

    // If no project selected, get or create a default
    if (!targetProjectId) {
      const defaultProject = this._getOrCreateDefaultProject();
      targetProjectId = defaultProject.id;
      this.currentProjectId = targetProjectId;
    }

    const project = this.projects.find(p => p.id === targetProjectId);
    if (!project) return;

    if (!project.sourceIds) project.sourceIds = [];
    if (!project.sourceIds.includes(sourceId)) {
      project.sourceIds.push(sourceId);
      project.updatedAt = new Date().toISOString();
      this._renderProjectsNav();
      this._saveData();
    }
  }

  /**
   * Add a set to the current project (or a specific project)
   * Creates a default project if none exists
   */
  _addSetToProject(setId, projectId = null) {
    let targetProjectId = projectId || this.currentProjectId;

    // If no project selected, get or create a default
    if (!targetProjectId) {
      const defaultProject = this._getOrCreateDefaultProject();
      targetProjectId = defaultProject.id;
      this.currentProjectId = targetProjectId;
    }

    const project = this.projects.find(p => p.id === targetProjectId);
    if (!project) return;

    if (!project.setIds) project.setIds = [];
    if (!project.setIds.includes(setId)) {
      project.setIds.push(setId);
      project.updatedAt = new Date().toISOString();
      this._renderProjectsNav();
      this._saveData();
    }
  }

  /**
   * Add a definition to the current project (or a specific project)
   * Creates a default project if none exists
   */
  _addDefinitionToProject(definitionId, projectId = null) {
    let targetProjectId = projectId || this.currentProjectId;

    // If no project selected, get or create a default
    if (!targetProjectId) {
      const defaultProject = this._getOrCreateDefaultProject();
      targetProjectId = defaultProject.id;
      this.currentProjectId = targetProjectId;
    }

    const project = this.projects.find(p => p.id === targetProjectId);
    if (!project) return;

    if (!project.definitionIds) project.definitionIds = [];
    if (!project.definitionIds.includes(definitionId)) {
      project.definitionIds.push(definitionId);
      project.updatedAt = new Date().toISOString();
      this._renderProjectsNav();
      this._saveData();
    }
  }

  /**
   * Add an export to the current project (or a specific project)
   * Creates a default project if none exists
   */
  _addExportToProject(exportId, projectId = null) {
    let targetProjectId = projectId || this.currentProjectId;

    // If no project selected, get or create a default
    if (!targetProjectId) {
      const defaultProject = this._getOrCreateDefaultProject();
      targetProjectId = defaultProject.id;
      this.currentProjectId = targetProjectId;
    }

    const project = this.projects.find(p => p.id === targetProjectId);
    if (!project) return;

    if (!project.exportIds) project.exportIds = [];
    if (!project.exportIds.includes(exportId)) {
      project.exportIds.push(exportId);
      project.updatedAt = new Date().toISOString();
      this._renderProjectsNav();
      this._saveData();
    }
  }

  // --------------------------------------------------------------------------
  // Sources Panel Rendering
  // --------------------------------------------------------------------------

  /**
   * Render Sources Navigation - REBUILT FROM SCRATCH
   *
   * Simplified approach: reads directly from this.sources array
   * which is the single source of truth for imported data.
   */
  _renderSourcesNav() {
    const container = document.getElementById('sources-nav');
    if (!container) return;

    // Ensure sources array exists (should always be initialized in constructor)
    if (!Array.isArray(this.sources)) {
      console.warn('_renderSourcesNav: sources was not an array, initializing to empty');
      this.sources = [];
    }

    // Get sources filtered by current project
    const activeSources = this._getProjectSources();
    const totalSources = this.sources.filter(s => s.status !== 'archived').length;
    console.log('_renderSourcesNav: Rendering sources', {
      totalSources: totalSources,
      filteredSources: activeSources.length,
      currentProject: this.currentProjectId
    });

    // Update panel header with project context
    this._updatePanelProjectContext('sources', activeSources.length, totalSources);

    // Sort sources by import date (newest first)
    const sortedSources = activeSources.sort((a, b) => {
      if (!a.importedAt) return 1;
      if (!b.importedAt) return -1;
      return new Date(b.importedAt) - new Date(a.importedAt);
    });

    // Empty state - no sources imported yet
    if (sortedSources.length === 0) {
      container.innerHTML = `
        <div class="nav-empty-state">
          <i class="ph ph-file-arrow-down"></i>
          <span>No data imported yet</span>
          <button class="btn-link" id="btn-first-import">Import data</button>
        </div>
      `;
      container.querySelector('#btn-first-import')?.addEventListener('click', () => {
        this._showImportModal();
      });
      return;
    }

    // Render sources as a flat list
    let html = '';
    for (const source of sortedSources) {
      const sourceIcon = this._getSourceIcon(source);
      const provenanceInfo = this._formatSourceProvenance(source);
      const importDate = source.importedAt ? new Date(source.importedAt).toLocaleDateString() : '';
      const recordCount = source.recordCount || source.records?.length || 0;

      // Check if this is a live source (API or RSS)
      const isLiveSource = source.sourceType === 'api' || source.sourceType === 'rss';
      const liveSourceClass = isLiveSource ? 'live-source' : '';
      const syncStatus = source.liveSource?.syncStatus || 'fresh';

      // Determine source type class for visual distinction
      const sourceTypeClass = `source-type-${source.sourceType || 'file'}`;

      // Determine live indicator
      let liveIndicator = '';
      if (isLiveSource) {
        const syncInfo = this._getLiveSyncInfo(source);
        liveIndicator = `
          <span class="live-source-indicator ${syncStatus}" title="${syncInfo.tooltip}">
            <span class="live-dot"></span>
            <span class="live-label">${syncInfo.label}</span>
          </span>
        `;
      }

      // Type badge for visual distinction
      const typeBadgeLabel = source.sourceType === 'rss' ? 'RSS'
        : source.sourceType === 'api' ? 'API'
        : 'FILE';

      html += `
        <div class="nav-item source-item ${liveSourceClass} ${sourceTypeClass}" data-source-id="${source.id}" title="${provenanceInfo}">
          <span class="source-type-badge">${typeBadgeLabel}</span>
          <i class="ph ${sourceIcon} source-icon"></i>
          <div class="source-info">
            <span class="source-name">${this._escapeHtml(this._truncateSourceName(source.name))}</span>
            ${isLiveSource ? liveIndicator : `<span class="source-meta-inline">${importDate}</span>`}
          </div>
          <span class="nav-item-count" title="${recordCount} rows">${recordCount} rows</span>
          <span class="nav-item-given-badge">GIVEN</span>
        </div>
      `;
    }

    container.innerHTML = html;

    // Attach event handlers for source items
    container.querySelectorAll('.source-item').forEach(item => {
      item.addEventListener('click', () => {
        const sourceId = item.dataset.sourceId;
        this._selectSource(sourceId);
      });

      item.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        this._showSourceContextMenu(e, item.dataset.sourceId);
      });
    });
  }

  // --------------------------------------------------------------------------
  // Definitions Panel Rendering
  // --------------------------------------------------------------------------

  /**
   * Render Definitions navigation panel
   * Definitions are schema definitions for columns/keys, imported from URIs (e.g., JSON-LD, RDF)
   * They provide vocabulary and type definitions that can be applied to sets
   */
  _renderDefinitionsNav() {
    const container = document.getElementById('definitions-nav');
    if (!container) return;

    // Ensure definitions array exists
    if (!Array.isArray(this.definitions)) {
      this.definitions = [];
    }

    // Ensure all keys from project sets have stub definitions
    this._ensureAllKeysHaveDefinitions();

    // Get definitions filtered by current project
    const activeDefinitions = this._getProjectDefinitions();
    const totalDefinitions = this.definitions.filter(d => d.status !== 'archived').length;

    // Update panel header with project context
    this._updatePanelProjectContext('definitions', activeDefinitions.length, totalDefinitions);

    // Sort definitions by import date (newest first)
    const sortedDefinitions = activeDefinitions.sort((a, b) => {
      if (!a.importedAt) return 1;
      if (!b.importedAt) return -1;
      return new Date(b.importedAt) - new Date(a.importedAt);
    });

    // Empty state - no definitions yet
    if (sortedDefinitions.length === 0) {
      container.innerHTML = `
        <div class="nav-empty-state">
          <i class="ph ph-book-open"></i>
          <span>No definitions yet</span>
          <button class="btn-link" id="btn-first-definition">Import from URI or create</button>
        </div>
      `;
      container.querySelector('#btn-first-definition')?.addEventListener('click', () => {
        this._showImportDefinitionModal();
      });
      return;
    }

    // Count pending definitions
    const pendingCount = sortedDefinitions.filter(d => this._isDefinitionPending(d)).length;

    // Update the panel header to show pending count if any
    this._updateDefinitionsPanelHeaderPendingCount(pendingCount);

    // Render definitions as a flat list
    let html = '';
    for (const definition of sortedDefinitions) {
      const defIcon = this._getDefinitionIcon(definition);
      const importDate = definition.importedAt ? new Date(definition.importedAt).toLocaleDateString() : '';
      const termCount = definition.terms?.length || definition.properties?.length || 0;
      const isStub = definition.status === 'stub' || definition.populationMethod === 'pending';
      const sourceLabel = definition.sourceUri ? 'URI' : (isStub ? 'stub' : 'local');
      const isActive = this.currentDefinitionId === definition.id;
      const isPending = this._isDefinitionPending(definition);

      html += `
        <div class="nav-item definition-item ${isActive ? 'active' : ''} ${isPending ? 'pending' : ''} ${isStub ? 'stub' : ''}"
             data-definition-id="${definition.id}"
             title="${this._escapeHtml(definition.description || definition.name)}${isPending ? ' (Pending approval)' : ''}${isStub ? ' (Stub - needs population)' : ''}">
          <i class="ph ${defIcon} definition-icon"></i>
          <div class="definition-info">
            <span class="definition-name">${this._escapeHtml(this._truncateName(definition.name, 20))}</span>
            <span class="definition-meta-inline">${isPending ? 'pending' : sourceLabel}</span>
          </div>
          ${isPending ? `
            <span class="definition-pending-badge" title="Pending approval">
              <i class="ph ph-clock"></i>
            </span>
          ` : isStub ? `
            <span class="definition-stub-badge" title="Stub definition - needs population">
              <i class="ph ph-warning-circle"></i>
            </span>
          ` : `
            <span class="definition-source-badge" title="${sourceLabel === 'URI' ? 'Imported from external URI' : 'Locally created'}">
              ${sourceLabel === 'URI' ? '<i class="ph ph-link"></i>' : '<i class="ph ph-pencil-simple"></i>'}
            </span>
          `}
          <span class="nav-item-count" title="${termCount} terms defined">${termCount}</span>
        </div>
      `;
    }

    container.innerHTML = html;

    // Attach event handlers for definition items
    this._attachDefinitionsNavEventHandlers(container);
  }

  /**
   * Update the definitions panel header to show pending count
   */
  _updateDefinitionsPanelHeaderPendingCount(pendingCount) {
    const definitionsPanel = document.querySelector('.definitions-panel');
    if (!definitionsPanel) return;

    // Find or create the pending badge element
    const panelTitle = definitionsPanel.querySelector('.nav-panel-title');
    if (!panelTitle) return;

    // Remove existing pending indicator
    const existingBadge = panelTitle.querySelector('.definition-pending-indicator');
    if (existingBadge) {
      existingBadge.remove();
    }

    // Add pending indicator if there are pending definitions
    if (pendingCount > 0) {
      const badge = document.createElement('span');
      badge.className = 'definition-pending-indicator';
      badge.title = `${pendingCount} definition${pendingCount !== 1 ? 's' : ''} pending approval`;
      badge.textContent = pendingCount > 99 ? '99+' : pendingCount;
      panelTitle.appendChild(badge);
    }
  }

  /**
   * Attach event handlers for definitions navigation items
   */
  _attachDefinitionsNavEventHandlers(container) {
    container.querySelectorAll('.definition-item').forEach(item => {
      item.addEventListener('click', () => {
        const definitionId = item.dataset.definitionId;
        this._showDefinitionDetail(definitionId);
      });

      item.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        this._showDefinitionContextMenu(e, item.dataset.definitionId);
      });
    });
  }

  /**
   * Get icon for definition based on its type
   */
  _getDefinitionIcon(definition) {
    if (definition.type === 'jsonld' || definition.format === 'jsonld') {
      return 'ph-brackets-curly';
    } else if (definition.type === 'rdf' || definition.format === 'rdf') {
      return 'ph-graph';
    } else if (definition.type === 'csv-schema' || definition.format === 'csvw') {
      return 'ph-table';
    } else if (definition.sourceUri) {
      return 'ph-link';
    }
    return 'ph-book-open';
  }

  /**
   * Render identity options as clickable badges
   * @param {string} currentIdentity - The currently selected identity value
   * @returns {string} HTML string with all identity options
   */
  _renderIdentityOptions(currentIdentity) {
    const options = [
      { value: 'Declared', icon: 'ph-stamp', color: '#6366f1', description: 'Meaning exists because someone with authority said so. The definition holds as long as the authority holds. If the declaring party loses legitimacy, changes their mind, or disappears, the meaning collapses.' },
      { value: 'Stabilized', icon: 'ph-check-circle', color: '#10b981', description: 'Meaning persists because multiple systems, processes, or actors have converged on it and now reinforce each other. No single authority owns it — it has become infrastructural.' },
      { value: 'Contested', icon: 'ph-warning', color: '#f59e0b', description: 'Meaning is actively disputed, under review, or has multiple competing interpretations in play. No stable consensus exists.' }
    ];

    return options.map(opt => {
      const isSelected = currentIdentity === opt.value;
      const selectedClass = isSelected ? 'selected' : '';
      const style = isSelected
        ? `background: ${opt.color}15; color: ${opt.color}; border-color: ${opt.color};`
        : `background: transparent; color: #64748b; border-color: #e2e8f0;`;

      return `<button class="eo-ontological-option ${selectedClass}" data-dimension="identity" data-value="${opt.value}" style="${style}" title="${opt.description}">
        <i class="ph ${opt.icon}"></i>
        ${opt.value}
      </button>`;
    }).join('');
  }

  /**
   * Render space options as clickable badges
   * @param {string} currentSpace - The currently selected space value
   * @returns {string} HTML string with all space options
   */
  _renderSpaceOptions(currentSpace) {
    const options = [
      { value: 'Local', icon: 'ph-house', color: '#64748b', description: 'Meaning applies only within this specific context. It makes no claims about compatibility with anything outside. Translation is not expected.' },
      { value: 'Federated', icon: 'ph-handshake', color: '#10b981', description: 'Meaning travels across contexts but requires explicit translation rules. The definition includes mappings that explain how it relates to definitions elsewhere.' },
      { value: 'Universal', icon: 'ph-globe', color: '#6366f1', description: 'Meaning is the same everywhere. The definition points to a shared standard and commits to its semantics without local modification.' }
    ];

    return options.map(opt => {
      const isSelected = currentSpace === opt.value;
      const selectedClass = isSelected ? 'selected' : '';
      const style = isSelected
        ? `background: ${opt.color}15; color: ${opt.color}; border-color: ${opt.color};`
        : `background: transparent; color: #64748b; border-color: #e2e8f0;`;

      return `<button class="eo-ontological-option ${selectedClass}" data-dimension="space" data-value="${opt.value}" style="${style}" title="${opt.description}">
        <i class="ph ${opt.icon}"></i>
        ${opt.value}
      </button>`;
    }).join('');
  }

  /**
   * Render time options as clickable badges
   * @param {string} currentTime - The currently selected time value
   * @returns {string} HTML string with all time options
   */
  _renderTimeOptions(currentTime) {
    const options = [
      { value: 'Immutable', icon: 'ph-lock-simple', color: '#6366f1', description: 'Meaning is fixed at the moment of definition and should never change. If circumstances change, create a new definition rather than mutating this one.' },
      { value: 'Versioned', icon: 'ph-clock-counter-clockwise', color: '#8b5cf6', description: 'Meaning changes at discrete, documented moments. Each version is internally stable. History is preserved and queryable.' },
      { value: 'Evolving', icon: 'ph-arrows-clockwise', color: '#f59e0b', description: 'Meaning is continuously reinterpreted and may shift without formal versioning. The current state is provisional.' }
    ];

    return options.map(opt => {
      const isSelected = currentTime === opt.value;
      const selectedClass = isSelected ? 'selected' : '';
      const style = isSelected
        ? `background: ${opt.color}15; color: ${opt.color}; border-color: ${opt.color};`
        : `background: transparent; color: #64748b; border-color: #e2e8f0;`;

      return `<button class="eo-ontological-option ${selectedClass}" data-dimension="time" data-value="${opt.value}" style="${style}" title="${opt.description}">
        <i class="ph ${opt.icon}"></i>
        ${opt.value}
      </button>`;
    }).join('');
  }

  /**
   * Determine the Identity of a definition - how is this meaning stabilized in the world?
   * Identity: Declared, Stabilized, Contested
   *
   * The validation question: "If this meaning were challenged tomorrow, would it collapse, bend, or hold?"
   * - Collapse → Declared (meaning exists because authority asserts it)
   * - Bend but persist → Stabilized (meaning persists because systems agree and reinforce it)
   * - Already bending → Contested (meaning is disputed, provisional, or actively evolving)
   *
   * @param {Object} definition - The definition object
   * @returns {Object} { identity: string, icon: string, color: string, description: string, authoritySource?: string }
   */
  _getDefinitionIdentity(definition) {
    // Check for user override first (support new identity values, legacy kind, and legacy governance)
    const overrideValue = definition.overrides?.identity;
    if (overrideValue) {
      // Migration map from old values to new identity values
      const migrationMap = {
        // New identity values (pass through)
        'Declared': 'Declared',
        'Stabilized': 'Stabilized',
        'Contested': 'Contested',
        // Legacy kind values mapped to new identity values (absorbing governance)
        'Identifier': 'Stabilized',
        'Descriptor': 'Stabilized',
        'Relationship': 'Stabilized'
      };
      const mappedValue = migrationMap[overrideValue] || 'Stabilized';
      const identityMap = {
        'Declared': {
          identity: 'Declared',
          icon: 'ph-stamp',
          color: '#6366f1',
          description: 'Meaning exists because an authority asserts it'
        },
        'Stabilized': {
          identity: 'Stabilized',
          icon: 'ph-check-circle',
          color: '#10b981',
          description: 'Meaning persists because systems agree and reinforce it'
        },
        'Contested': {
          identity: 'Contested',
          icon: 'ph-warning',
          color: '#f59e0b',
          description: 'Meaning is disputed, provisional, or actively evolving'
        }
      };
      const result = identityMap[mappedValue];
      // Include optional authority source annotation if present
      const authoritySource = definition.overrides?.authoritySource ||
                              definition.overrides?.governance?.authorityName ||
                              definition.definitionSource?.authority?.name;
      if (authoritySource) {
        result.authoritySource = authoritySource;
      }
      return result;
    }

    // Check legacy governance.confidence override and map to new identity
    const legacyConfidence = definition.overrides?.governance?.confidence || definition.overrides?.stability;
    if (legacyConfidence) {
      const confidenceToIdentity = {
        'Established': 'Stabilized',
        'Provisional': 'Contested',
        'Contested': 'Contested',
        'Stable': 'Stabilized',
        'Contextual': 'Contested',
        'Experimental': 'Contested',
        'Superseded': 'Contested'
      };
      const mappedIdentity = confidenceToIdentity[legacyConfidence] || 'Stabilized';
      return this._getIdentityInfo(mappedIdentity, definition);
    }

    // Infer identity from definition properties
    const hasUri = !!definition.sourceUri;
    const hasAuthority = !!(definition.definitionSource?.authority?.name);
    const isVerified = definition.status === 'verified' || definition.status === 'complete';
    const isPending = this._isDefinitionPending(definition);
    const validity = definition.definitionSource?.validity;
    const isSuperseded = validity?.supersededBy;

    // Contested: superseded, pending, or explicitly marked as disputed
    if (isSuperseded || isPending) {
      return this._getIdentityInfo('Contested', definition);
    }

    // Declared: has clear authority but limited system reinforcement
    const authorityType = definition.definitionSource?.authority?.type;
    const isOfficialAuthority = authorityType === 'federal_agency' ||
                                 authorityType === 'state_agency' ||
                                 authorityType === 'standards_body' ||
                                 authorityType === 'international';
    if (isOfficialAuthority && !hasUri) {
      return this._getIdentityInfo('Declared', definition);
    }

    // Stabilized: verified with URI or system-reinforced
    if (hasUri && isVerified) {
      return this._getIdentityInfo('Stabilized', definition);
    }

    // Default based on verification status
    if (isVerified || hasAuthority) {
      return this._getIdentityInfo('Stabilized', definition);
    }

    // Unverified definitions are contested by default
    return this._getIdentityInfo('Contested', definition);
  }

  /**
   * Helper to build identity info object
   */
  _getIdentityInfo(identity, definition) {
    const identityMap = {
      'Declared': {
        identity: 'Declared',
        icon: 'ph-stamp',
        color: '#6366f1',
        description: 'Meaning exists because an authority asserts it'
      },
      'Stabilized': {
        identity: 'Stabilized',
        icon: 'ph-check-circle',
        color: '#10b981',
        description: 'Meaning persists because systems agree and reinforce it'
      },
      'Contested': {
        identity: 'Contested',
        icon: 'ph-warning',
        color: '#f59e0b',
        description: 'Meaning is disputed, provisional, or actively evolving'
      }
    };
    const result = { ...identityMap[identity] };
    // Include optional authority source annotation if present
    const authoritySource = definition?.overrides?.authoritySource ||
                            definition?.overrides?.governance?.authorityName ||
                            definition?.definitionSource?.authority?.name;
    if (authoritySource) {
      result.authoritySource = authoritySource;
    }
    return result;
  }

  /**
   * @deprecated Use _getDefinitionIdentity instead
   * Legacy method for backwards compatibility
   */
  _getDefinitionKind(definition) {
    const identityInfo = this._getDefinitionIdentity(definition);
    // Map new identity values back to legacy kind values for components still using kind
    const kindMap = {
      'Identifier': { kind: 'Identifier', icon: 'ph-key', color: '#6366f1' },
      'Descriptor': { kind: 'Descriptive', icon: 'ph-tag', color: '#0ea5e9' },
      'Relationship': { kind: 'Relational', icon: 'ph-git-branch', color: '#8b5cf6' }
    };
    return kindMap[identityInfo.identity] || kindMap['Descriptor'];
  }

  /**
   * Calculate semantic dependency usage for a definition.
   * Usage is a roll-up of places that trust this definition enough to build on it.
   *
   * Usage Tiers:
   * - Tier 1: Direct field bindings (lowest weight)
   * - Tier 2: Interpretive surfaces - reports, dashboards, views (medium weight)
   * - Tier 3: Operational logic - automations, validations, permissions (high weight)
   * - Tier 4: External commitments - APIs, exports, integrations (maximum weight)
   *
   * @param {Object} definition - The definition object
   * @returns {Object} { total: number, tiers: Object, breakdown: Object, details: Array }
   */
  _getDefinitionUsage(definition) {
    const breakdown = {
      fields: 0,
      reports: 0,
      automations: 0,
      apis: 0,
      exports: 0
    };
    const details = [];

    // Tier 1: Count linked fields across all sets
    this.sets.forEach(set => {
      (set.fields || []).forEach(field => {
        if (field.definitionRef?.definitionId === definition.id ||
            field.semanticBinding?.definitionId === definition.id) {
          breakdown.fields++;
          details.push({
            tier: 1,
            type: 'field',
            name: field.name || field.key,
            context: set.name,
            weight: 1
          });
        }
      });
    });

    // Tier 2: Check if used in views/reports (check set views)
    this.sets.forEach(set => {
      (set.views || []).forEach(view => {
        const viewFields = view.fields || view.columns || [];
        const hasDefinition = viewFields.some(vf => {
          const field = (set.fields || []).find(f => f.id === vf.fieldId || f.key === vf.fieldId);
          return field?.definitionRef?.definitionId === definition.id ||
                 field?.semanticBinding?.definitionId === definition.id;
        });
        if (hasDefinition) {
          breakdown.reports++;
          details.push({
            tier: 2,
            type: 'view',
            name: view.name,
            context: set.name,
            weight: 2
          });
        }
      });
    });

    // Tier 3: Check automations/pipelines
    (this.pipelines || []).forEach(pipeline => {
      const usesDefinition = (pipeline.steps || []).some(step => {
        return step.definitionId === definition.id ||
               step.fieldMappings?.some(fm => fm.definitionId === definition.id);
      });
      if (usesDefinition) {
        breakdown.automations++;
        details.push({
          tier: 3,
          type: 'pipeline',
          name: pipeline.name,
          context: 'Automation',
          weight: 3
        });
      }
    });

    // Tier 4: Check exports
    (this.exports || []).forEach(exp => {
      const usesDefinition = (exp.fieldMappings || []).some(fm =>
        fm.definitionId === definition.id
      );
      if (usesDefinition || exp.definitionIds?.includes(definition.id)) {
        breakdown.exports++;
        details.push({
          tier: 4,
          type: 'export',
          name: exp.name,
          context: 'External',
          weight: 4
        });
      }
    });

    // Check if has external URI (implies API/external usage)
    if (definition.sourceUri) {
      breakdown.apis++;
      details.push({
        tier: 4,
        type: 'uri',
        name: 'External URI',
        context: definition.sourceUri,
        weight: 4
      });
    }

    // Calculate weighted total
    const total = breakdown.fields +
                  breakdown.reports +
                  breakdown.automations +
                  breakdown.apis +
                  breakdown.exports;

    // Tier summary
    const tiers = {
      tier1: breakdown.fields,
      tier2: breakdown.reports,
      tier3: breakdown.automations,
      tier4: breakdown.apis + breakdown.exports
    };

    return { total, tiers, breakdown, details };
  }

  /**
   * Derive risk/attention level for a definition.
   * Risk is derived from: Usage (breadth) × Stability (volatility) × Authority gaps × External commitments
   *
   * Risk Levels:
   * - safe: Low usage or high stability with clear authority
   * - review: Medium usage with contextual stability or unclear authority
   * - attention: High usage with low stability or external commitments without authority
   *
   * @param {Object} definition - The definition object
   * @returns {Object} { level: string, icon: string, color: string, reasons: Array }
   */
  _getDefinitionRisk(definition) {
    const usage = this._getDefinitionUsage(definition);
    const stability = this._getDefinitionStability(definition);
    const hasAuthority = !!(definition.definitionSource?.authority?.name);
    const hasUri = !!definition.sourceUri;
    const isPending = this._isDefinitionPending(definition);

    const reasons = [];
    let riskScore = 0;

    // High usage increases risk
    if (usage.total >= 10) {
      riskScore += 3;
      reasons.push('High usage across system');
    } else if (usage.total >= 5) {
      riskScore += 1;
      reasons.push('Moderate usage');
    }

    // External commitments (Tier 4) significantly increase risk
    if (usage.tiers.tier4 > 0) {
      riskScore += 2;
      reasons.push('External dependencies');
    }

    // Operational usage (Tier 3) increases risk
    if (usage.tiers.tier3 > 0) {
      riskScore += 1;
      reasons.push('Used in automations');
    }

    // Low stability with any usage is risky
    if (stability.stability === 'Experimental') {
      if (usage.total > 0) {
        riskScore += 2;
        reasons.push('Experimental with active usage');
      }
    } else if (stability.stability === 'Superseded') {
      riskScore += 3;
      reasons.push('Superseded definition still in use');
    }

    // Missing authority with high usage
    if (!hasAuthority && usage.total >= 3) {
      riskScore += 1;
      reasons.push('Authority not established');
    }

    // Pending definitions that have usage need attention
    if (isPending && usage.total > 0) {
      riskScore += 2;
      reasons.push('Pending definition has active usage');
    }

    // Determine level based on score
    if (riskScore >= 4) {
      return {
        level: 'attention',
        icon: 'ph-warning-circle',
        color: '#ef4444',
        reasons
      };
    } else if (riskScore >= 2) {
      return {
        level: 'review',
        icon: 'ph-info',
        color: '#f59e0b',
        reasons
      };
    }

    return {
      level: 'safe',
      icon: 'ph-check-circle',
      color: '#10b981',
      reasons: reasons.length > 0 ? reasons : ['No issues detected']
    };
  }

  /**
   * Determine how this meaning changes over time.
   * Time: Immutable, Versioned, Evolving
   *
   * @param {Object} definition - The definition object
   * @returns {Object} { time: string, icon: string, color: string, description: string }
   */
  _getDefinitionTime(definition) {
    // Check for user override first (support both new 'time' and legacy 'timeSensitivity')
    const overrideValue = definition.overrides?.time || definition.overrides?.timeSensitivity;
    if (overrideValue) {
      // Migration map from old timeSensitivity values to new time values
      const migrationMap = {
        // New time values (pass through)
        'Immutable': 'Immutable',
        'Versioned': 'Versioned',
        'Evolving': 'Evolving',
        // Legacy timeSensitivity values mapped to new time values
        'Evolves': 'Evolving',
        'Mutable': 'Evolving'
      };
      const mappedValue = migrationMap[overrideValue] || 'Evolving';
      const timeMap = {
        'Immutable': { time: 'Immutable', icon: 'ph-lock-simple', color: '#6366f1', description: 'Fixed at creation, should not change' },
        'Versioned': { time: 'Versioned', icon: 'ph-clock-counter-clockwise', color: '#8b5cf6', description: 'Changes at defined epochs (v1 → v2)' },
        'Evolving': { time: 'Evolving', icon: 'ph-arrows-clockwise', color: '#f59e0b', description: 'Continuously updating' }
      };
      return timeMap[mappedValue];
    }

    const validity = definition.definitionSource?.validity;
    const identityInfo = this._getDefinitionIdentity(definition);
    const hasSupersession = validity?.supersededBy || validity?.supersedes;
    const hasTemporalBounds = validity?.from || validity?.to;

    // Check if this is an identifier type (typically immutable)
    if (identityInfo.identity === 'Identifier') {
      return {
        time: 'Immutable',
        icon: 'ph-lock-simple',
        color: '#6366f1',
        description: 'Fixed at creation, should not change'
      };
    }

    // Check for versioning indicators
    if (hasSupersession) {
      return {
        time: 'Versioned',
        icon: 'ph-clock-counter-clockwise',
        color: '#8b5cf6',
        description: 'Changes at defined epochs (v1 → v2)'
      };
    }

    // Default to immutable for stable definitions with URI
    if (definition.sourceUri && definition.status === 'verified') {
      return {
        time: 'Immutable',
        icon: 'ph-lock-simple',
        color: '#6366f1',
        description: 'Fixed meaning anchored by external standard'
      };
    }

    // Check for lifecycle/temporal bounds - suggests evolving
    if (hasTemporalBounds) {
      return {
        time: 'Evolving',
        icon: 'ph-arrows-clockwise',
        color: '#f59e0b',
        description: 'Continuously updating'
      };
    }

    // Default to evolving for local/incomplete definitions
    return {
      time: 'Evolving',
      icon: 'ph-arrows-clockwise',
      color: '#f59e0b',
      description: 'Continuously updating'
    };
  }

  /**
   * @deprecated Use _getDefinitionTime instead
   * Legacy method for backwards compatibility
   */
  _getDefinitionTimeSensitivity(definition) {
    const timeInfo = this._getDefinitionTime(definition);
    // Map new time values back to legacy sensitivity values
    const sensitivityMap = {
      'Immutable': { sensitivity: 'Immutable', icon: 'ph-lock-simple', color: '#6366f1', description: timeInfo.description },
      'Versioned': { sensitivity: 'Versioned', icon: 'ph-git-branch', color: '#8b5cf6', description: timeInfo.description },
      'Evolving': { sensitivity: 'Evolves', icon: 'ph-arrows-clockwise', color: '#f59e0b', description: timeInfo.description }
    };
    return sensitivityMap[timeInfo.time] || sensitivityMap['Evolving'];
  }

  /**
   * @deprecated Governance has been absorbed into Identity. Use _getDefinitionIdentity instead.
   * This method is kept for backwards compatibility but Identity now handles meaning stabilization.
   *
   * Determine who maintains this meaning - the authority for a definition.
   * Authority (Governance): Human, Process, System
   *
   * @param {Object} definition - The definition object
   * @returns {Object} { authority: string, icon: string, color: string, description: string, name: string }
   */
  _getDefinitionGovernanceAuthority(definition) {
    // Check for user override first (support both new 'governance.authority' and legacy 'authorityType')
    const overrideValue = definition.overrides?.governance?.authority || definition.overrides?.authorityType;
    if (overrideValue) {
      // Migration map from old authorityType values to new governance.authority values
      const migrationMap = {
        // New governance.authority values (pass through)
        'Human': 'Human',
        'Process': 'Process',
        'System': 'System',
        // Legacy authorityType value - External maps to Process (external authorities are organizational)
        'External': 'Process'
      };
      const mappedValue = migrationMap[overrideValue] || 'Human';
      const authorityMap = {
        'Human': { authority: 'Human', icon: 'ph-user', color: '#0ea5e9', description: 'Requires subjective judgment' },
        'Process': { authority: 'Process', icon: 'ph-gear', color: '#10b981', description: 'Emerges from defined workflow' },
        'System': { authority: 'System', icon: 'ph-cpu', color: '#64748b', description: 'Computed automatically' }
      };
      const base = authorityMap[mappedValue];
      return {
        ...base,
        name: definition.overrides?.governance?.authorityName || definition.overrides?.authorityName || definition.definitionSource?.authority?.name || ''
      };
    }

    const authorityData = definition.definitionSource?.authority;
    const hasUri = !!definition.sourceUri;
    const authorityType = authorityData?.type;
    const populationMethod = definition.populationMethod;

    // System authority (auto-generated, imported, API lookup)
    if (populationMethod === 'imported' || populationMethod === 'api_lookup') {
      return {
        authority: 'System',
        icon: 'ph-cpu',
        color: '#64748b',
        name: 'System Generated',
        description: 'Computed automatically'
      };
    }

    // Process authority (organizations, standards bodies, agencies)
    if (authorityType === 'federal_agency' ||
        authorityType === 'state_agency' ||
        authorityType === 'international' ||
        authorityType === 'standards_body' ||
        authorityType === 'ngo' ||
        authorityType === 'local_gov' ||
        authorityType === 'academic') {
      return {
        authority: 'Process',
        icon: 'ph-gear',
        color: '#10b981',
        name: authorityData?.name || authorityData?.shortName,
        description: 'Emerges from defined workflow'
      };
    }

    // Manual/Human authority
    if (populationMethod === 'manual' || populationMethod === 'selected') {
      return {
        authority: 'Human',
        icon: 'ph-user',
        color: '#0ea5e9',
        name: 'User Defined',
        description: 'Requires subjective judgment'
      };
    }

    // Default based on URI presence - external URIs suggest process authority
    if (hasUri) {
      return {
        authority: 'Process',
        icon: 'ph-gear',
        color: '#10b981',
        name: 'Linked Standard',
        description: 'Emerges from defined workflow'
      };
    }

    // Pending/Unknown - default to Human
    return {
      authority: 'Human',
      icon: 'ph-user',
      color: '#0ea5e9',
      name: 'Not Established',
      description: 'Requires subjective judgment'
    };
  }

  /**
   * @deprecated Governance has been absorbed into Identity. Use _getDefinitionIdentity instead.
   * This method is kept for backwards compatibility. The Confidence dimension (Established/Provisional/Contested)
   * has been replaced by Identity (Declared/Stabilized/Contested) in the new schema.
   *
   * Determine how established the authority is for this definition.
   * Confidence (Governance): Established, Provisional, Contested
   *
   * @param {Object} definition - The definition object
   * @returns {Object} { confidence: string, icon: string, color: string, description: string }
   */
  _getDefinitionGovernanceConfidence(definition) {
    // Check for user override first (support both new 'governance.confidence' and legacy 'stability')
    const overrideValue = definition.overrides?.governance?.confidence || definition.overrides?.stability;
    if (overrideValue) {
      // Migration map from old stability values to new governance.confidence values
      const migrationMap = {
        // New governance.confidence values (pass through)
        'Established': 'Established',
        'Provisional': 'Provisional',
        'Contested': 'Contested',
        // Legacy stability values mapped to new governance.confidence values
        'Stable': 'Established',
        'Contextual': 'Provisional',
        'Experimental': 'Provisional',
        'Superseded': 'Contested'
      };
      const mappedValue = migrationMap[overrideValue] || 'Provisional';
      const confidenceMap = {
        'Established': { confidence: 'Established', icon: 'ph-seal-check', color: '#10b981', description: 'Authority is clear and accepted' },
        'Provisional': { confidence: 'Provisional', icon: 'ph-clock', color: '#f59e0b', description: 'Accepted for now, subject to review' },
        'Contested': { confidence: 'Contested', icon: 'ph-warning', color: '#ef4444', description: 'Authority is disputed or unclear' }
      };
      return confidenceMap[mappedValue];
    }

    const hasUri = !!definition.sourceUri;
    const hasAuthority = !!(definition.definitionSource?.authority?.name);
    const isVerified = definition.status === 'verified' || definition.status === 'complete';
    const isPending = this._isDefinitionPending(definition);
    const validity = definition.definitionSource?.validity;
    const isSuperseded = validity?.supersededBy;

    // Superseded definitions are contested
    if (isSuperseded) {
      return {
        confidence: 'Contested',
        icon: 'ph-warning',
        color: '#ef4444',
        description: 'Authority is disputed or unclear'
      };
    }

    // Pending definitions are provisional
    if (isPending) {
      return {
        confidence: 'Provisional',
        icon: 'ph-clock',
        color: '#f59e0b',
        description: 'Accepted for now, subject to review'
      };
    }

    // Verified with URI and authority = established
    if (hasUri && hasAuthority && isVerified) {
      return {
        confidence: 'Established',
        icon: 'ph-seal-check',
        color: '#10b981',
        description: 'Authority is clear and accepted'
      };
    }

    // Has URI or is verified locally = provisional (accepted but may evolve)
    if (hasUri || isVerified) {
      return {
        confidence: 'Provisional',
        icon: 'ph-clock',
        color: '#f59e0b',
        description: 'Accepted for now, subject to review'
      };
    }

    // Default to provisional for unverified definitions
    return {
      confidence: 'Provisional',
      icon: 'ph-clock',
      color: '#f59e0b',
      description: 'Accepted for now, subject to review'
    };
  }

  /**
   * @deprecated Use _getDefinitionGovernanceAuthority instead
   * Legacy method for backwards compatibility
   */
  _getDefinitionAuthority(definition) {
    const govAuthority = this._getDefinitionGovernanceAuthority(definition);
    // Map new governance.authority values back to legacy authority type values
    const typeMap = {
      'Human': 'Human',
      'Process': 'Process',
      'System': 'System'
    };
    return {
      type: typeMap[govAuthority.authority] || 'Human',
      icon: govAuthority.icon,
      color: govAuthority.color,
      name: govAuthority.name,
      description: govAuthority.description
    };
  }

  /**
   * Get interop status for a definition.
   * Interop Status: Linked, Local, Deferred
   *
   * @param {Object} definition - The definition object
   * @returns {Object} { status: string, icon: string, color: string, uri: string|null }
   */
  _getDefinitionInteropStatus(definition) {
    // Check both old format (sourceUri) and new Definitions Set format (values.fld_def_meaning_uri)
    const uri = definition.sourceUri || definition.values?.fld_def_meaning_uri || null;
    const hasUri = !!uri;
    const hasSuggestions = (definition.apiSuggestions || []).length > 0;
    const isLocalOnly = definition.status === 'local_only';

    if (hasUri) {
      return {
        status: 'Linked',
        icon: 'ph-link',
        color: '#10b981',
        uri: uri,
        description: 'Linked to external standard'
      };
    }

    if (isLocalOnly) {
      return {
        status: 'Local',
        icon: 'ph-house',
        color: '#64748b',
        uri: null,
        description: 'Intentionally local, no external link needed'
      };
    }

    if (hasSuggestions) {
      return {
        status: 'Deferred',
        icon: 'ph-clock',
        color: '#f59e0b',
        uri: null,
        description: 'External links available but not yet selected'
      };
    }

    return {
      status: 'Local',
      icon: 'ph-house',
      color: '#64748b',
      uri: null,
      description: 'Local definition, no external link'
    };
  }

  /**
   * @deprecated Use _getDefinitionGovernanceConfidence instead
   * Legacy method for backwards compatibility - maps confidence to stability
   * @param {Object} definition - The definition object
   * @returns {Object} { stability: string, icon: string, color: string, description: string }
   */
  _getDefinitionStability(definition) {
    const confidenceInfo = this._getDefinitionGovernanceConfidence(definition);
    // Map new governance.confidence values back to legacy stability values
    const stabilityMap = {
      'Established': { stability: 'Stable', icon: 'ph-seal-check', color: '#10b981', description: confidenceInfo.description },
      'Provisional': { stability: 'Experimental', icon: 'ph-flask', color: '#f59e0b', description: confidenceInfo.description },
      'Contested': { stability: 'Superseded', icon: 'ph-arrow-bend-double-up-right', color: '#ef4444', description: confidenceInfo.description }
    };
    return stabilityMap[confidenceInfo.confidence] || stabilityMap['Provisional'];
  }

  /**
   * Infer where this meaning applies - the space of a definition.
   * Space: Local, Universal, Federated
   *
   * @param {Object} definition - The definition object
   * @returns {Object} { space: string, spaceDetail: string, icon: string, color: string }
   */
  _getDefinitionSpace(definition) {
    // Check for user override first (support both new 'space' and legacy 'scope')
    const overrideValue = definition.overrides?.space || definition.overrides?.scope;
    if (overrideValue) {
      // Migration map from old scope values to new space values
      const migrationMap = {
        // New space values (pass through)
        'Local': 'Local',
        'Universal': 'Universal',
        'Federated': 'Federated',
        // Legacy scope values mapped to new space values
        'Global': 'Universal',
        'Project': 'Local',
        'Dataset': 'Local'
      };
      const mappedValue = migrationMap[overrideValue] || 'Local';
      const spaceMap = {
        'Local': { space: 'Local', spaceDetail: 'Bounded to this workspace/project', icon: 'ph-house', color: '#64748b' },
        'Universal': { space: 'Universal', spaceDetail: 'Same meaning everywhere (linked to standard URI)', icon: 'ph-globe', color: '#6366f1' },
        'Federated': { space: 'Federated', spaceDetail: 'Travels with explicit translation rules', icon: 'ph-handshake', color: '#10b981' }
      };
      return spaceMap[mappedValue];
    }

    const hasUri = !!definition.sourceUri;
    const hasTranslationRules = definition.translationRules?.length > 0 || definition.mappings?.length > 0;

    // Check where this definition is used
    const linkedSets = this._getLinkedSetsForDefinition(definition);
    const linkedSetCount = linkedSets?.size || 0;

    if (hasUri) {
      return {
        space: 'Universal',
        spaceDetail: 'Linked to standard URI',
        icon: 'ph-globe',
        color: '#6366f1'
      };
    }

    if (hasTranslationRules || linkedSetCount > 1) {
      return {
        space: 'Federated',
        spaceDetail: linkedSetCount > 1 ? `Used across ${linkedSetCount} datasets with mappings` : 'Has explicit translation rules',
        icon: 'ph-handshake',
        color: '#10b981'
      };
    }

    return {
      space: 'Local',
      spaceDetail: 'Bounded to this workspace',
      icon: 'ph-house',
      color: '#64748b'
    };
  }

  /**
   * @deprecated Use _getDefinitionSpace instead
   * Legacy method for backwards compatibility
   */
  _getDefinitionScope(definition) {
    const spaceInfo = this._getDefinitionSpace(definition);
    // Map new space values back to legacy scope values
    const scopeMap = {
      'Local': { scope: 'Local', scopeDetail: spaceInfo.spaceDetail, icon: 'ph-house' },
      'Universal': { scope: 'Global', scopeDetail: spaceInfo.spaceDetail, icon: 'ph-globe' },
      'Federated': { scope: 'Project', scopeDetail: spaceInfo.spaceDetail, icon: 'ph-folder-notch' }
    };
    return scopeMap[spaceInfo.space] || scopeMap['Local'];
  }

  /**
   * Get the icon for a definition kind
   */
  _getDefinitionKindIcon(kind) {
    const kindIcons = {
      'Identifier': 'ph-key',
      'Measure': 'ph-chart-bar',
      'Temporal': 'ph-calendar',
      'Descriptive': 'ph-tag',
      'Relational': 'ph-git-branch',
      'Administrative': 'ph-gear'
    };
    return kindIcons[kind] || 'ph-tag';
  }

  /**
   * Group definitions by their semantic kind
   * @param {Array} definitions - Array of definition objects
   * @returns {Object} Grouped definitions by kind
   */
  _groupDefinitionsByKind(definitions) {
    const groups = {
      'Identifier': [],
      'Measure': [],
      'Temporal': [],
      'Descriptive': [],
      'Relational': [],
      'Administrative': []
    };

    definitions.forEach(def => {
      const { kind } = this._getDefinitionKind(def);
      if (groups[kind]) {
        groups[kind].push(def);
      } else {
        groups['Descriptive'].push(def);
      }
    });

    // Filter out empty groups
    return Object.fromEntries(
      Object.entries(groups).filter(([_, defs]) => defs.length > 0)
    );
  }

  /**
   * Truncate name for display
   */
  _truncateName(name, maxLength = 20) {
    if (!name) return 'Untitled';
    if (name.length <= maxLength) return name;
    return name.substring(0, maxLength - 1) + '…';
  }

  // --------------------------------------------------------------------------
  // Exports Panel Rendering
  // --------------------------------------------------------------------------

  /**
   * Render Exports navigation panel
   * Exports are immutable frozen captures (downloads and records)
   * Rule 9: Exports are immutable and can be superseded but never modified
   */
  _renderExportsNav() {
    const container = document.getElementById('exports-nav');
    if (!container) return;

    // Ensure exports array exists
    if (!Array.isArray(this.exports)) {
      this.exports = [];
    }

    // Get exports filtered by current project
    const filteredExports = this._getProjectExports();
    const totalExports = this.exports.length;

    // Update panel header with project context
    this._updatePanelProjectContext('exports', filteredExports.length, totalExports);

    // Sort exports by date
    const sortedExports = [...filteredExports].sort((a, b) => {
      if (!a.createdAt) return 1;
      if (!b.createdAt) return -1;
      return new Date(b.createdAt) - new Date(a.createdAt);
    });

    // Empty state - no exports yet
    if (sortedExports.length === 0) {
      container.innerHTML = `
        <div class="nav-empty-state">
          <i class="ph ph-export"></i>
          <span>No exports yet</span>
          <button class="btn-link" id="btn-first-export">Create an export</button>
        </div>
      `;
      container.querySelector('#btn-first-export')?.addEventListener('click', () => {
        this._showNewExportModal();
      });
      return;
    }

    // Render exports as a flat list
    let html = '';
    for (const exp of sortedExports) {
      const exportIcon = this._getExportIcon(exp);
      const createdDate = exp.createdAt ? new Date(exp.createdAt).toLocaleDateString() : '';
      const isActive = this.currentExportId === exp.id;
      const purposeLabel = exp.purpose || 'export';

      html += `
        <div class="nav-item export-item ${isActive ? 'active' : ''}"
             data-export-id="${exp.id}"
             title="${this._escapeHtml(exp.notes || exp.name)}">
          <i class="ph ${exportIcon} export-icon"></i>
          <div class="export-info">
            <span class="export-name">${this._escapeHtml(this._truncateName(exp.name, 20))}</span>
            <span class="export-meta-inline">${createdDate}</span>
          </div>
          <span class="export-purpose-badge" title="${purposeLabel}">
            <i class="ph ph-snowflake"></i>
          </span>
        </div>
      `;
    }

    container.innerHTML = html;

    // Attach event handlers for export items
    this._attachExportsNavEventHandlers(container);
  }

  /**
   * Attach event handlers for exports navigation items
   */
  _attachExportsNavEventHandlers(container) {
    container.querySelectorAll('.export-item').forEach(item => {
      item.addEventListener('click', () => {
        const exportId = item.dataset.exportId;
        this._showExportDetail(exportId);
      });

      item.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        this._showExportContextMenu(e, item.dataset.exportId);
      });
    });
  }

  /**
   * Get icon for export based on its purpose
   */
  _getExportIcon(exp) {
    switch (exp.purpose) {
      case 'backup': return 'ph-cloud-arrow-down';
      case 'milestone': return 'ph-flag';
      case 'comparison': return 'ph-arrows-out-line-horizontal';
      case 'review': return 'ph-magnifying-glass';
      default: return 'ph-export';
    }
  }

  /**
   * Show export detail view
   */
  _showExportDetail(exportId) {
    const exp = this.exports?.find(e => e.id === exportId);
    if (!exp) {
      this._showNotification('Export not found', 'error');
      return;
    }

    // Set current export
    this.currentExportId = exportId;

    // Clear other selections
    this.currentSourceId = null;
    this.currentSetId = null;
    this.currentViewId = null;
    this.currentDefinitionId = null;
    this.showingSetFields = false;

    // Update sidebar highlighting
    this._updateSidebarHighlighting();

    // Update breadcrumb
    this._updateBreadcrumb('Export: ' + exp.name, 'ph-export');

    // Render export detail view
    this._renderExportDetailView(exp);
  }

  /**
   * Render export detail view in main content area
   */
  _renderExportDetailView(exp) {
    const contentArea = this.elements.contentArea;
    if (!contentArea) return;

    const createdDate = exp.createdAt ? new Date(exp.createdAt).toLocaleString() : 'Unknown';
    const purposeLabel = exp.purpose || 'export';

    contentArea.innerHTML = `
      <div class="export-detail-view">
        <div class="export-detail-header">
          <div class="export-detail-icon">
            <i class="ph ${this._getExportIcon(exp)}"></i>
          </div>
          <div class="export-detail-info">
            <h2>
              <span>${this._escapeHtml(exp.name)}</span>
              <span class="export-frozen-badge">
                <i class="ph ph-snowflake"></i>
                SNAPSHOT
              </span>
            </h2>
            <div class="export-detail-meta">
              Created ${createdDate} • Purpose: ${purposeLabel}
            </div>
          </div>
          <div class="export-detail-actions">
            <button class="source-action-btn" id="export-download-btn" title="Download export">
              <i class="ph ph-download-simple"></i>
              <span>Download</span>
            </button>
          </div>
        </div>

        <div class="export-detail-content">
          ${exp.notes ? `
            <div class="export-notes">
              <h3>Notes</h3>
              <p>${this._escapeHtml(exp.notes)}</p>
            </div>
          ` : ''}

          <div class="export-provenance">
            <h3>Provenance</h3>
            <div class="provenance-item">
              <span class="provenance-label">Source View:</span>
              <span class="provenance-value">${exp.sourceViewId || 'N/A'}</span>
            </div>
            <div class="provenance-item">
              <span class="provenance-label">Captured At:</span>
              <span class="provenance-value">${exp.capturedAt || createdDate}</span>
            </div>
            <div class="provenance-item">
              <span class="provenance-label">Created By:</span>
              <span class="provenance-value">${exp.createdBy || 'Unknown'}</span>
            </div>
          </div>

          <div class="compliance-note frozen">
            <i class="ph ph-snowflake"></i>
            <span><strong>Rule 9:</strong> This export is immutable. It can be superseded but never modified.</span>
          </div>
        </div>
      </div>
    `;

    // Attach event handlers
    contentArea.querySelector('#export-download-btn')?.addEventListener('click', () => {
      this._downloadExport(exp.id);
    });
  }

  /**
   * Download export as JSON file
   */
  _downloadExport(exportId) {
    const exp = this.exports?.find(e => e.id === exportId);
    if (!exp) {
      this._showToast('Export not found', 'error');
      return;
    }

    const json = JSON.stringify(exp, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${exp.name.replace(/[^a-z0-9]/gi, '_')}_export.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    this._showToast('Export downloaded', 'success');
  }

  /**
   * Show export context menu
   */
  _showExportContextMenu(e, exportId) {
    const menu = this.elements.contextMenu;
    if (!menu) return;

    menu.innerHTML = `
      <div class="context-menu-item" data-action="view">
        <i class="ph ph-eye"></i>
        <span>View Details</span>
      </div>
      <div class="context-menu-item" data-action="download">
        <i class="ph ph-download-simple"></i>
        <span>Download</span>
      </div>
      <div class="context-menu-divider"></div>
      <div class="context-menu-item" data-action="supersede">
        <i class="ph ph-arrows-clockwise"></i>
        <span>Supersede (Create New)</span>
      </div>
      <div class="context-menu-divider"></div>
      <div class="context-menu-item danger" data-action="delete">
        <i class="ph ph-trash"></i>
        <span>Delete Export</span>
      </div>
    `;

    menu.style.left = e.pageX + 'px';
    menu.style.top = e.pageY + 'px';
    menu.classList.add('active');

    menu.querySelectorAll('.context-menu-item').forEach(item => {
      item.addEventListener('click', () => {
        menu.classList.remove('active');
        const action = item.dataset.action;

        switch (action) {
          case 'view':
            this._showExportDetail(exportId);
            break;
          case 'download':
            this._downloadExport(exportId);
            break;
          case 'supersede':
            this._showNewExportModal();
            break;
          case 'delete':
            this._deleteExport(exportId);
            break;
        }
      });
    });
  }

  /**
   * Delete an export
   */
  _deleteExport(exportId) {
    const exportItem = this.exports?.find(e => e.id === exportId);
    const exportName = exportItem?.name || 'Export';

    this.exports = this.exports.filter(e => e.id !== exportId);

    // Record activity for export deletion
    this._recordActivity({
      action: 'delete',
      entityType: 'export',
      name: exportName,
      details: `Deleted export "${exportName}"`,
      canReverse: false
    });

    this._saveData();
    this._renderExportsNav();

    if (this.currentExportId === exportId) {
      this.currentExportId = null;
      this._renderView();
    }

    this._showToast('Export deleted', 'success');
  }

  /**
   * Show definitions table view for a project
   * Displays all definitions in a table format
   */
  _showDefinitionsTable(projectId) {
    // Get definitions for this project
    const projectDefinitions = this.definitions?.filter(d => d.projectId === projectId) || [];

    // Clear other selections
    this.currentSourceId = null;
    this.currentSetId = null;
    this.currentViewId = null;
    this.currentDefinitionId = null;
    this.showingSetFields = false;
    this.showingSetDetail = false;
    this.isViewingDefinitions = false;

    // Set definitions table view flag
    this.isViewingDefinitionsTable = true;
    this.currentProjectId = projectId;

    // Update tab bar
    this._renderTabBar();

    // Update sidebar selection
    document.querySelectorAll('.source-item, .set-item, .set-item-header, .set-view-item, .definition-nested-item').forEach(item => {
      item.classList.remove('active');
    });
    document.querySelectorAll('.definitions-table-item').forEach(item => {
      item.classList.toggle('active', item.dataset.projectId === projectId);
    });

    // Render definitions table view
    this._renderDefinitionsTableView(projectDefinitions, projectId);

    // Update breadcrumb
    this._updateBreadcrumb();
  }

  /**
   * Show definition detail view
   */
  _showDefinitionDetail(definitionId) {
    const definition = this.definitions?.find(d => d.id === definitionId);
    if (!definition) {
      this._showNotification('Definition not found', 'error');
      return;
    }

    // Clear definitions table view flag
    this.isViewingDefinitionsTable = false;

    // Set current definition
    this.currentDefinitionId = definitionId;

    // Clear other selections
    this.currentSourceId = null;
    this.currentSetId = null;
    this.currentViewId = null;
    this.showingSetFields = false;
    this.showingSetDetail = false;

    // Set viewing definitions flag and update tab bar
    this.isViewingDefinitions = true;
    this._renderTabBar();

    // Update sidebar selection
    document.querySelectorAll('.source-item, .set-item, .set-item-header, .set-view-item').forEach(item => {
      item.classList.remove('active');
    });
    document.querySelectorAll('.definition-item').forEach(item => {
      item.classList.toggle('active', item.dataset.definitionId === definitionId);
    });

    // Render definition detail view
    this._renderDefinitionDetailView(definition);

    // Update breadcrumb
    this._updateBreadcrumb();
  }

  /**
   * Get all set linkages for terms in a definition
   */
  _getTermSetLinkages(definition) {
    const linkages = new Map(); // termId -> [{setId, setName, fieldId, fieldName}]
    const sets = this.sets || [];
    const terms = definition.terms || definition.properties || [];

    terms.forEach(term => {
      const termId = term.id || term.name;
      linkages.set(termId, []);
    });

    sets.forEach(set => {
      (set.fields || []).forEach(field => {
        if (field.definitionRef?.definitionId === definition.id) {
          const termId = field.definitionRef.termId;
          if (linkages.has(termId)) {
            linkages.get(termId).push({
              setId: set.id,
              setName: set.name,
              fieldId: field.id,
              fieldName: field.name
            });
          }
        }
      });
    });

    return linkages;
  }

  /**
   * Get unique types from terms
   */
  _getUniqueTermTypes(terms) {
    const types = new Set();
    terms.forEach(term => {
      const type = term.type || term.datatype || 'string';
      types.add(type);
    });
    return Array.from(types).sort();
  }

  /**
   * Get sets that have terms linked from this definition
   */
  _getLinkedSetsForDefinition(definition) {
    const linkedSets = new Map(); // setId -> {set, fields: [{fieldId, fieldName, termId}]}
    const sets = this.sets || [];

    sets.forEach(set => {
      const linkedFields = [];
      (set.fields || []).forEach(field => {
        if (field.definitionRef?.definitionId === definition.id) {
          linkedFields.push({
            fieldId: field.id,
            fieldName: field.name,
            termId: field.definitionRef.termId
          });
        }
      });
      if (linkedFields.length > 0) {
        linkedSets.set(set.id, { set, fields: linkedFields });
      }
    });

    return linkedSets;
  }

  /**
   * Render terms table rows
   */
  _renderTermsTableRows(terms, termLinkages, definitionId) {
    return terms.map(term => {
      const termId = term.id || term.name;
      const termName = term.name || term.label || termId;
      const termLabel = term.label || term.altLabel || term.prefLabel || '';
      const termType = term.type || term.datatype || 'string';
      const termDesc = term.description || term.comment || '';
      const termUri = term.uri || term['@id'] || '';
      const linkages = termLinkages.get(termId) || [];

      // Build searchable data attributes
      const searchText = [termName, termLabel, termDesc, termUri].filter(Boolean).join(' ').toLowerCase();

      return `
        <tr class="definition-term-row"
            data-term-id="${this._escapeHtml(termId)}"
            data-definition-id="${this._escapeHtml(definitionId)}"
            data-term-type="${this._escapeHtml(termType)}"
            data-linked="${linkages.length > 0 ? 'true' : 'false'}"
            data-search="${this._escapeHtml(searchText)}">
          <td class="term-name-cell">
            <div class="term-name-content">
              <i class="ph ph-tag"></i>
              <span class="term-id">${this._escapeHtml(termName)}</span>
            </div>
          </td>
          <td class="term-label-cell">
            ${termLabel && termLabel !== termName ? `
              <span class="term-label">${this._escapeHtml(termLabel)}</span>
            ` : '<span class="term-label-empty">—</span>'}
          </td>
          <td class="term-type-cell">
            <span class="type-badge type-${this._escapeHtml(termType.toLowerCase().replace(/[^a-z0-9]/g, '-'))}">${this._escapeHtml(termType)}</span>
          </td>
          <td class="term-description-cell">
            <span class="term-description" title="${this._escapeHtml(termDesc)}">${this._escapeHtml(termDesc || '—')}</span>
          </td>
          <td class="term-linked-cell">
            ${linkages.length > 0 ? `
              <div class="term-linkages">
                ${linkages.slice(0, 2).map(link => `
                  <span class="term-link-badge" title="${this._escapeHtml(link.setName)}.${this._escapeHtml(link.fieldName)}">
                    <i class="ph ph-link"></i>
                    ${this._escapeHtml(link.setName)}
                  </span>
                `).join('')}
                ${linkages.length > 2 ? `<span class="term-link-more">+${linkages.length - 2} more</span>` : ''}
              </div>
            ` : '<span class="term-not-linked">—</span>'}
          </td>
          <td class="term-uri-cell">
            ${termUri ? `
              <a href="${this._escapeHtml(termUri)}" target="_blank" class="term-uri-link" title="${this._escapeHtml(termUri)}">
                ${this._escapeHtml(this._truncateName(termUri, 25))}
              </a>
            ` : '<span class="term-no-uri">—</span>'}
          </td>
          <td class="term-actions-cell">
            <button class="term-action-btn term-link-action-btn"
                    data-term-id="${this._escapeHtml(termId)}"
                    data-definition-id="${this._escapeHtml(definitionId)}"
                    title="${linkages.length > 0 ? 'Manage links' : 'Link to field'}">
              <i class="ph ${linkages.length > 0 ? 'ph-pencil-simple' : 'ph-arrow-right'}"></i>
            </button>
          </td>
        </tr>
      `;
    }).join('');
  }

  /**
   * Render grouped terms view
   */
  _renderGroupedTermsView(terms, termLinkages, definitionId, groupBy) {
    if (groupBy === 'type') {
      // Group by type
      const grouped = new Map();
      terms.forEach(term => {
        const type = term.type || term.datatype || 'string';
        if (!grouped.has(type)) {
          grouped.set(type, []);
        }
        grouped.get(type).push(term);
      });

      let html = '';
      grouped.forEach((groupTerms, type) => {
        html += `
          <div class="terms-group">
            <div class="terms-group-header">
              <span class="type-badge">${this._escapeHtml(type)}</span>
              <span class="terms-group-count">${groupTerms.length} term${groupTerms.length !== 1 ? 's' : ''}</span>
            </div>
            <div class="terms-group-table">
              <table class="data-table terms-data-table compact">
                <tbody>
                  ${this._renderTermsTableRows(groupTerms, termLinkages, definitionId)}
                </tbody>
              </table>
            </div>
          </div>
        `;
      });
      return html;
    } else if (groupBy === 'set') {
      // Group by linked set
      const grouped = new Map();
      grouped.set('unlinked', { name: 'Not Linked', terms: [] });

      terms.forEach(term => {
        const termId = term.id || term.name;
        const linkages = termLinkages.get(termId) || [];
        if (linkages.length === 0) {
          grouped.get('unlinked').terms.push(term);
        } else {
          linkages.forEach(link => {
            if (!grouped.has(link.setId)) {
              grouped.set(link.setId, { name: link.setName, terms: [] });
            }
            // Avoid duplicates
            const existing = grouped.get(link.setId).terms.find(t => (t.id || t.name) === termId);
            if (!existing) {
              grouped.get(link.setId).terms.push(term);
            }
          });
        }
      });

      let html = '';
      grouped.forEach((group, setId) => {
        if (group.terms.length > 0) {
          html += `
            <div class="terms-group" data-set-id="${setId}">
              <div class="terms-group-header">
                <i class="ph ${setId === 'unlinked' ? 'ph-link-break' : 'ph-table'}"></i>
                <span class="terms-group-name">${this._escapeHtml(group.name)}</span>
                <span class="terms-group-count">${group.terms.length} term${group.terms.length !== 1 ? 's' : ''}</span>
              </div>
              <div class="terms-group-table">
                <table class="data-table terms-data-table compact">
                  <tbody>
                    ${this._renderTermsTableRows(group.terms, termLinkages, definitionId)}
                  </tbody>
                </table>
              </div>
            </div>
          `;
        }
      });
      return html;
    }

    return '';
  }

  /**
   * Render definitions table view showing all definitions for a project
   */
  _renderDefinitionsTableView(definitions, projectId) {
    const contentArea = this.elements.contentArea;
    if (!contentArea) return;

    const project = this.projects?.find(p => p.id === projectId);
    const projectName = project?.name || 'Project';
    const projectSets = this.sets?.filter(s => s.projectId === projectId) || [];

    contentArea.innerHTML = `
      <div class="definitions-table-view">
        <div class="definitions-table-header">
          <div class="definitions-table-title">
            <i class="ph ph-book-open"></i>
            <h2>Definitions</h2>
            <span class="definitions-count">${definitions.length} definition${definitions.length !== 1 ? 's' : ''}</span>
          </div>
          <div class="definitions-table-actions">
            <button class="btn btn-primary" id="btn-import-definition">
              <i class="ph ph-download"></i> Import Definition
            </button>
          </div>
        </div>

        ${definitions.length === 0 ? `
          <div class="definitions-empty-state">
            <i class="ph ph-book-open"></i>
            <h3>No definitions yet</h3>
            <p>Import a definition schema to get started</p>
            <button class="btn btn-primary" id="btn-import-definition-empty">
              <i class="ph ph-download"></i> Import Definition
            </button>
          </div>
        ` : `
          <div class="definitions-table-container">
            <table class="data-table definitions-data-table">
              <thead>
                <tr>
                  <th class="col-name" style="width: 200px;">
                    <div class="th-content">
                      <span>Name</span>
                    </div>
                  </th>
                  <th class="col-terms" style="width: 100px;">
                    <div class="th-content">
                      <span>Terms</span>
                    </div>
                  </th>
                  <th class="col-source" style="width: 200px;">
                    <div class="th-content">
                      <span>Source</span>
                    </div>
                  </th>
                  <th class="col-linked" style="width: 150px;">
                    <div class="th-content">
                      <span>Linked Fields</span>
                    </div>
                  </th>
                  <th class="col-imported">
                    <div class="th-content">
                      <span>Imported</span>
                    </div>
                  </th>
                  <th class="col-actions" style="width: 80px;"></th>
                </tr>
              </thead>
              <tbody>
                ${definitions.map(def => {
                  const termCount = def.terms?.length || def.properties?.length || 0;
                  const importDate = def.importedAt ? new Date(def.importedAt).toLocaleDateString() : '—';
                  const sourceDisplay = def.sourceUri
                    ? this._truncateName(def.sourceUri.replace(/^https?:\/\//, ''), 30)
                    : 'Local';
                  const linkedFields = this._getDefinitionLinkedFields(def, projectSets);

                  return `
                    <tr class="definition-table-row" data-definition-id="${def.id}">
                      <td class="definition-name-cell">
                        <div class="definition-name-content">
                          <i class="ph ${this._getDefinitionIcon(def)}"></i>
                          <span class="definition-name">${this._escapeHtml(def.name)}</span>
                        </div>
                      </td>
                      <td class="definition-terms-cell">
                        <span class="term-count-badge">${termCount}</span>
                      </td>
                      <td class="definition-source-cell">
                        ${def.sourceUri ? `
                          <a href="${this._escapeHtml(def.sourceUri)}" target="_blank" class="source-link" title="${this._escapeHtml(def.sourceUri)}">
                            ${this._escapeHtml(sourceDisplay)}
                            <i class="ph ph-arrow-square-out"></i>
                          </a>
                        ` : `<span class="source-local">Local</span>`}
                      </td>
                      <td class="definition-linked-cell">
                        ${linkedFields.length > 0 ? `
                          <div class="linked-fields-badges">
                            ${linkedFields.slice(0, 3).map(lf => `
                              <span class="linked-field-badge" title="${lf.setName}: ${lf.fieldName}">
                                ${this._escapeHtml(this._truncateName(lf.fieldName, 10))}
                              </span>
                            `).join('')}
                            ${linkedFields.length > 3 ? `<span class="linked-more">+${linkedFields.length - 3}</span>` : ''}
                          </div>
                        ` : '<span class="no-links">—</span>'}
                      </td>
                      <td class="definition-imported-cell">
                        <span class="import-date">${importDate}</span>
                      </td>
                      <td class="definition-actions-cell">
                        <button class="btn-icon btn-view-definition" data-definition-id="${def.id}" title="View details">
                          <i class="ph ph-eye"></i>
                        </button>
                        <button class="btn-icon btn-delete-definition" data-definition-id="${def.id}" title="Delete">
                          <i class="ph ph-trash"></i>
                        </button>
                      </td>
                    </tr>
                  `;
                }).join('')}
              </tbody>
            </table>
          </div>
        `}
      </div>
    `;

    // Attach event handlers
    this._attachDefinitionsTableHandlers(projectId);
  }

  /**
   * Attach event handlers for definitions table view
   */
  _attachDefinitionsTableHandlers(projectId) {
    // Import definition buttons
    document.getElementById('btn-import-definition')?.addEventListener('click', () => {
      this._showImportDefinitionModal();
    });
    document.getElementById('btn-import-definition-empty')?.addEventListener('click', () => {
      this._showImportDefinitionModal();
    });

    // Row click to view definition details
    document.querySelectorAll('.definition-table-row').forEach(row => {
      row.addEventListener('click', (e) => {
        // Don't trigger if clicking on action buttons
        if (e.target.closest('.btn-icon') || e.target.closest('a')) return;
        const definitionId = row.dataset.definitionId;
        this._showDefinitionDetail(definitionId);
      });
    });

    // View definition button
    document.querySelectorAll('.btn-view-definition').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const definitionId = btn.dataset.definitionId;
        this._showDefinitionDetail(definitionId);
      });
    });

    // Delete definition button
    document.querySelectorAll('.btn-delete-definition').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const definitionId = btn.dataset.definitionId;
        this._deleteDefinition(definitionId);
      });
    });
  }

  /**
   * Render definition detail view in EO-aligned stacked cards layout
   * Layout: Meaning → Scope → Stability & Time → Authority → Usage → Interop → Risk
   */
  _renderDefinitionDetailView(definition) {
    const contentArea = this.elements.contentArea;
    if (!contentArea) return;

    const terms = definition.terms || definition.properties || [];
    const defSource = definition.definitionSource;
    const termLinkages = this._getTermSetLinkages(definition);
    const linkedSets = this._getLinkedSetsForDefinition(definition);
    const linkedSetsArray = Array.from(linkedSets.values());
    const isLocal = !definition.sourceUri;

    // Get all EO-aligned metadata (new three-dimensional schema: Identity, Space, Time)
    const identityInfo = this._getDefinitionIdentity(definition);
    const spaceInfo = this._getDefinitionSpace(definition);
    const timeInfo = this._getDefinitionTime(definition);
    const interopStatus = this._getDefinitionInteropStatus(definition);
    const usageInfo = this._getDefinitionUsage(definition);
    const riskInfo = this._getDefinitionRisk(definition);

    // Legacy compatibility aliases
    const kindInfo = this._getDefinitionKind(definition);
    const stabilityInfo = this._getDefinitionStability(definition);
    const timeSensitivity = this._getDefinitionTimeSensitivity(definition);
    const authorityInfo = this._getDefinitionAuthority(definition);
    const scopeInfo = this._getDefinitionScope(definition);

    // Build meaning text
    const meaningName = definition.name || definition.term?.label || definition.term?.term || 'Unnamed';
    const meaningText = definition.term?.definitionText || definition.description ||
                        'No meaning description yet. Add a plain-language explanation of what this definition represents.';

    contentArea.innerHTML = `
      <div class="definition-detail-view eo-stacked-cards">
        <!-- ════════════════════════════════════════════════════════════════
             SECTION 1: MEANING (Primary - Always First)
             ════════════════════════════════════════════════════════════════ -->
        <div class="eo-card eo-card-meaning">
          <div class="eo-card-header">
            <div class="eo-meaning-header-content">
              <h1 class="eo-meaning-title eo-editable" contenteditable="true" data-field="name" data-placeholder="Enter name...">${this._escapeHtml(meaningName)}</h1>
              <p class="eo-meaning-source eo-editable" contenteditable="true" data-field="source" data-placeholder="Enter source...">${this._escapeHtml(definition.sourceLabel || definition.definitionSource?.source?.title || '')}</p>
            </div>
            <div class="eo-card-actions">
              <button class="btn btn-icon btn-sm" id="btn-edit-meaning" title="Edit meaning">
                <i class="ph ph-pencil-simple"></i>
              </button>
            </div>
          </div>
          <div class="eo-card-content">
            <p class="eo-meaning-description ${!definition.term?.definitionText ? 'placeholder' : ''}">
              ${this._escapeHtml(meaningText)}
            </p>
          </div>
        </div>

        <!-- ════════════════════════════════════════════════════════════════
             ONTOLOGICAL PANELS ROW (Identity, Space, Time)
             ════════════════════════════════════════════════════════════════ -->
        <div class="eo-ontological-panels">
          <!-- Panel 1: IDENTITY -->
          <div class="eo-card eo-card-ontological eo-card-identity">
            <div class="eo-card-header">
              <div class="eo-card-header-icon" style="background: ${identityInfo.color}15;">
                <i class="ph ${identityInfo.icon}" style="color: ${identityInfo.color};"></i>
              </div>
              <div class="eo-card-header-info">
                <h3 class="eo-card-title eo-editable" contenteditable="true" data-field="identityTitle" data-placeholder="Title...">${this._escapeHtml(definition.overrides?.identityTitle || 'Identity')}</h3>
              </div>
              <div class="eo-card-actions">
                <button class="btn btn-icon btn-sm" id="btn-edit-identity" title="Edit identity settings and authority source">
                  <i class="ph ph-pencil-simple"></i>
                </button>
              </div>
            </div>
            <div class="eo-card-content">
              <p class="eo-ontological-question">${this._escapeHtml(definition.overrides?.identityQuestion || 'How is this meaning stabilized in the world?')}</p>
              <div class="eo-ontological-options">
                ${this._renderIdentityOptions(identityInfo.identity)}
              </div>
            </div>
          </div>

          <!-- Panel 2: SPACE -->
          <div class="eo-card eo-card-ontological eo-card-space">
            <div class="eo-card-header">
              <div class="eo-card-header-icon" style="background: ${spaceInfo.color}15;">
                <i class="ph ${spaceInfo.icon}" style="color: ${spaceInfo.color};"></i>
              </div>
              <div class="eo-card-header-info">
                <h3 class="eo-card-title eo-editable" contenteditable="true" data-field="spaceTitle" data-placeholder="Title...">${this._escapeHtml(definition.overrides?.spaceTitle || 'Space')}</h3>
              </div>
              <div class="eo-card-actions">
                <button class="btn btn-icon btn-sm" id="btn-edit-space" title="Edit where this meaning applies">
                  <i class="ph ph-pencil-simple"></i>
                </button>
              </div>
            </div>
            <div class="eo-card-content">
              <p class="eo-ontological-question">${this._escapeHtml(definition.overrides?.spaceQuestion || 'Where does this meaning apply?')}</p>
              <div class="eo-ontological-options">
                ${this._renderSpaceOptions(spaceInfo.space)}
              </div>
            </div>
          </div>

          <!-- Panel 3: TIME -->
          <div class="eo-card eo-card-ontological eo-card-time">
            <div class="eo-card-header">
              <div class="eo-card-header-icon" style="background: ${timeInfo.color}15;">
                <i class="ph ${timeInfo.icon}" style="color: ${timeInfo.color};"></i>
              </div>
              <div class="eo-card-header-info">
                <h3 class="eo-card-title eo-editable" contenteditable="true" data-field="timeTitle" data-placeholder="Title...">${this._escapeHtml(definition.overrides?.timeTitle || 'Time')}</h3>
              </div>
              <div class="eo-card-actions">
                <button class="btn btn-icon btn-sm" id="btn-edit-time" title="Edit how this meaning changes over time">
                  <i class="ph ph-pencil-simple"></i>
                </button>
              </div>
            </div>
            <div class="eo-card-content">
              <p class="eo-ontological-question">${this._escapeHtml(definition.overrides?.timeQuestion || 'How does this meaning change?')}</p>
              <div class="eo-ontological-options">
                ${this._renderTimeOptions(timeInfo.time)}
              </div>
            </div>
          </div>
        </div>

        <!-- ════════════════════════════════════════════════════════════════
             SECTION 4: USAGE (Dependency Awareness)
             ════════════════════════════════════════════════════════════════ -->
        <div class="eo-card eo-card-usage">
          <div class="eo-card-header">
            <div class="eo-card-header-icon" style="background: #0ea5e915;">
              <i class="ph ph-graph" style="color: #0ea5e9;"></i>
            </div>
            <div class="eo-card-header-info">
              <h3 class="eo-card-title">Usage</h3>
              <p class="eo-card-subtitle">If this meaning changes, what breaks?</p>
            </div>
            <div class="eo-usage-total">
              <span class="eo-usage-count ${usageInfo.total > 0 ? 'has-usage' : ''}">${usageInfo.total}</span>
              <span class="eo-usage-label">dependencies</span>
            </div>
          </div>
          <div class="eo-card-content">
            ${usageInfo.total > 0 ? `
              <div class="eo-usage-breakdown">
                <div class="eo-usage-tier ${usageInfo.breakdown.fields > 0 ? 'active' : ''}">
                  <div class="eo-usage-tier-header">
                    <i class="ph ph-columns"></i>
                    <span class="eo-usage-tier-label">Fields</span>
                    <span class="eo-usage-tier-count">${usageInfo.breakdown.fields}</span>
                  </div>
                </div>
                <div class="eo-usage-tier ${usageInfo.breakdown.reports > 0 ? 'active' : ''}">
                  <div class="eo-usage-tier-header">
                    <i class="ph ph-chart-bar"></i>
                    <span class="eo-usage-tier-label">Views & Reports</span>
                    <span class="eo-usage-tier-count">${usageInfo.breakdown.reports}</span>
                  </div>
                </div>
                <div class="eo-usage-tier ${usageInfo.breakdown.automations > 0 ? 'active' : ''}">
                  <div class="eo-usage-tier-header">
                    <i class="ph ph-lightning"></i>
                    <span class="eo-usage-tier-label">Automations</span>
                    <span class="eo-usage-tier-count">${usageInfo.breakdown.automations}</span>
                  </div>
                </div>
                <div class="eo-usage-tier eo-usage-tier-clickable ${(usageInfo.breakdown.apis + usageInfo.breakdown.exports) > 0 ? 'active external' : ''}" id="tier-apis-exports" title="Browse available URI APIs">
                  <div class="eo-usage-tier-header">
                    <i class="ph ph-arrow-square-out"></i>
                    <span class="eo-usage-tier-label">APIs & Exports</span>
                    <span class="eo-usage-tier-count">${usageInfo.breakdown.apis + usageInfo.breakdown.exports}</span>
                  </div>
                </div>
              </div>
              ${linkedSetsArray.length > 0 ? `
                <div class="eo-usage-details">
                  <h4>Applied to Fields</h4>
                  ${linkedSetsArray.map(({ set, fields }) => `
                    <div class="eo-usage-detail-item">
                      <i class="ph ph-table"></i>
                      <span class="eo-usage-set-name">${this._escapeHtml(set.name)}</span>
                      <span class="eo-usage-field-list">${fields.map(f => this._escapeHtml(f.fieldName)).join(', ')}</span>
                    </div>
                  `).join('')}
                </div>
              ` : ''}
            ` : `
              <div class="eo-usage-empty">
                <p>No dependencies yet. This definition is safe to modify.</p>
                <button class="btn btn-primary btn-sm" id="btn-apply-to-fields-empty">
                  <i class="ph ph-arrow-right"></i> Apply to Fields
                </button>
              </div>
            `}
          </div>
        </div>

        <!-- ════════════════════════════════════════════════════════════════
             SECTION 6: INTEROP & STANDARDS (Optional, Deferred)
             ════════════════════════════════════════════════════════════════ -->
        <div class="eo-card eo-card-interop">
          <div class="eo-card-header">
            <div class="eo-card-header-icon" style="background: ${interopStatus.color}15;">
              <i class="ph ${interopStatus.icon}" style="color: ${interopStatus.color};"></i>
            </div>
            <div class="eo-card-header-info">
              <h3 class="eo-card-title">Interoperability</h3>
              <p class="eo-card-subtitle">Does this meaning align with an external standard?</p>
            </div>
            <span class="eo-interop-status-badge" style="background: ${interopStatus.color}15; color: ${interopStatus.color};">
              ${interopStatus.status}
            </span>
          </div>
          <div class="eo-card-content">
            ${interopStatus.uri ? `
              <div class="eo-interop-linked">
                <a href="${this._escapeHtml(interopStatus.uri)}" target="_blank" rel="noopener noreferrer" class="eo-interop-uri">
                  <i class="ph ph-arrow-square-out"></i>
                  <span>${this._escapeHtml(interopStatus.uri)}</span>
                </a>
                <button class="btn btn-secondary btn-xs" id="btn-change-uri">
                  <i class="ph ph-pencil-simple"></i> Change
                </button>
              </div>
            ` : `
              <div class="eo-interop-unlinked">
                <p class="eo-interop-hint">${interopStatus.description}</p>
                <div class="eo-interop-actions">
                  <button class="btn btn-secondary btn-sm" id="btn-link-to-uri">
                    <i class="ph ph-link"></i> Link to Standard
                  </button>
                  <button class="btn btn-ghost btn-sm" id="btn-mark-local">
                    <i class="ph ph-house"></i> Keep Local
                  </button>
                </div>
              </div>
            `}
          </div>
        </div>

        <!-- ════════════════════════════════════════════════════════════════
             SECTION 7: RISK / ATTENTION (Derived, Explained)
             ════════════════════════════════════════════════════════════════ -->
        <div class="eo-card eo-card-risk eo-card-risk-${riskInfo.level}">
          <div class="eo-card-header">
            <div class="eo-card-header-icon" style="background: ${riskInfo.color}15;">
              <i class="ph ${riskInfo.icon}" style="color: ${riskInfo.color};"></i>
            </div>
            <div class="eo-card-header-info">
              <h3 class="eo-card-title">Risk Assessment</h3>
              <p class="eo-card-subtitle">Current attention status</p>
            </div>
            <span class="eo-risk-level-badge" style="background: ${riskInfo.color}15; color: ${riskInfo.color};">
              ${riskInfo.level === 'safe' ? 'Safe' : riskInfo.level === 'review' ? 'Needs Review' : 'Needs Attention'}
            </span>
          </div>
          <div class="eo-card-content">
            <ul class="eo-risk-reasons">
              ${riskInfo.reasons.map(reason => `
                <li class="eo-risk-reason">
                  <i class="ph ${riskInfo.level === 'safe' ? 'ph-check' : 'ph-warning'}"></i>
                  ${this._escapeHtml(reason)}
                </li>
              `).join('')}
            </ul>
          </div>
        </div>

        <!-- ════════════════════════════════════════════════════════════════
             ACTIONS BAR
             ════════════════════════════════════════════════════════════════ -->
        <div class="eo-actions-bar">
          <button class="btn btn-secondary btn-sm" id="btn-refresh-definition" title="Refresh from URI" ${isLocal ? 'disabled' : ''}>
            <i class="ph ph-arrows-clockwise"></i> Refresh
          </button>
          <button class="btn btn-primary btn-sm" id="btn-apply-definition" title="Apply this definition to fields">
            <i class="ph ph-arrow-right"></i> Apply to Fields
          </button>
          <button class="btn btn-icon btn-danger btn-sm" id="btn-delete-definition" title="Delete definition">
            <i class="ph ph-trash"></i>
          </button>
        </div>
      </div>
    `;

    // Attach event handlers
    this._attachDefinitionDetailHandlersEO(definition);
  }

  /**
   * Attach event handlers for the EO-aligned definition detail view
   */
  _attachDefinitionDetailHandlersEO(definition) {
    const contentArea = this.elements.contentArea;

    // Edit meaning button
    const editMeaningBtn = contentArea.querySelector('#btn-edit-meaning');
    if (editMeaningBtn) {
      editMeaningBtn.addEventListener('click', () => this._openEditMeaningModal(definition));
    }

    // Apply to Fields buttons
    const applyBtn = contentArea.querySelector('#btn-apply-definition');
    const applyBtnEmpty = contentArea.querySelector('#btn-apply-to-fields-empty');
    [applyBtn, applyBtnEmpty].forEach(btn => {
      if (btn) {
        btn.addEventListener('click', () => this._showApplyToFieldsModal(definition.id));
      }
    });

    // Refresh button
    const refreshBtn = contentArea.querySelector('#btn-refresh-definition');
    if (refreshBtn) {
      refreshBtn.addEventListener('click', () => this._refreshDefinitionFromUri(definition));
    }

    // Delete button
    const deleteBtn = contentArea.querySelector('#btn-delete-definition');
    if (deleteBtn) {
      deleteBtn.addEventListener('click', () => this._deleteDefinition(definition.id));
    }

    // Link to URI button
    const linkUriBtn = contentArea.querySelector('#btn-link-to-uri');
    if (linkUriBtn) {
      linkUriBtn.addEventListener('click', () => this._openLinkToUriModal(definition));
    }

    // Change URI button
    const changeUriBtn = contentArea.querySelector('#btn-change-uri');
    if (changeUriBtn) {
      changeUriBtn.addEventListener('click', () => this._openLinkToUriModal(definition));
    }

    // Mark as local button
    const markLocalBtn = contentArea.querySelector('#btn-mark-local');
    if (markLocalBtn) {
      markLocalBtn.addEventListener('click', () => this._markDefinitionAsLocal(definition));
    }

    // APIs & Exports tier click - opens URI APIs browser
    const apisExportsTier = contentArea.querySelector('#tier-apis-exports');
    if (apisExportsTier) {
      apisExportsTier.addEventListener('click', () => this._openUriApisBrowserModal(definition));
    }

    // Edit Identity button (new schema)
    const editIdentityBtn = contentArea.querySelector('#btn-edit-identity');
    if (editIdentityBtn) {
      editIdentityBtn.addEventListener('click', () => this._openEditIdentityModal(definition));
    }

    // Edit Space button (new schema)
    const editSpaceBtn = contentArea.querySelector('#btn-edit-space');
    if (editSpaceBtn) {
      editSpaceBtn.addEventListener('click', () => this._openEditSpaceModal(definition));
    }

    // Edit Time button (new schema)
    const editTimeBtn = contentArea.querySelector('#btn-edit-time');
    if (editTimeBtn) {
      editTimeBtn.addEventListener('click', () => this._openEditTimeModal(definition));
    }

    // Legacy: Edit Governance button - now redirects to Identity (governance absorbed into Identity)
    const editGovernanceBtn = contentArea.querySelector('#btn-edit-governance');
    if (editGovernanceBtn) {
      editGovernanceBtn.addEventListener('click', () => this._openEditIdentityModal(definition));
    }

    // Legacy: Edit scope button (What This Refers To) - for backwards compatibility
    const editScopeBtn = contentArea.querySelector('#btn-edit-scope');
    if (editScopeBtn) {
      editScopeBtn.addEventListener('click', () => this._openEditIdentityModal(definition));
    }

    // Legacy: Edit stability button (Stability & Time) - for backwards compatibility
    const editStabilityBtn = contentArea.querySelector('#btn-edit-stability');
    if (editStabilityBtn) {
      editStabilityBtn.addEventListener('click', () => this._openEditTimeModal(definition));
    }

    // Legacy: Edit authority button (Authority & Confidence) - now redirects to Identity
    const editAuthorityBtn = contentArea.querySelector('#btn-edit-authority');
    if (editAuthorityBtn) {
      editAuthorityBtn.addEventListener('click', () => this._openEditIdentityModal(definition));
    }

    // Ontological option selection buttons (direct selection)
    const optionButtons = contentArea.querySelectorAll('.eo-ontological-option');
    optionButtons.forEach(btn => {
      btn.addEventListener('click', (e) => {
        const dimension = btn.dataset.dimension;
        const value = btn.dataset.value;
        this._selectOntologicalOption(definition, dimension, value, btn);
      });
    });

    // Inline editable elements
    this._setupInlineEditing(contentArea, definition);
  }

  /**
   * Handle direct selection of an ontological option (identity, space, or time)
   * @param {Object} definition - The definition object
   * @param {string} dimension - The dimension being changed ('identity', 'space', or 'time')
   * @param {string} value - The new value for the dimension
   * @param {HTMLElement} clickedBtn - The button that was clicked
   */
  _selectOntologicalOption(definition, dimension, value, clickedBtn) {
    // Initialize overrides if needed
    if (!definition.overrides) {
      definition.overrides = {};
    }

    // Update the override value
    definition.overrides[dimension] = value;

    // Save the definition
    this._saveDefinition(definition);

    // Update visual state of all buttons in this dimension's container
    const container = clickedBtn.closest('.eo-ontological-options');
    const allButtons = container.querySelectorAll('.eo-ontological-option');

    // Color maps for each dimension
    const colorMaps = {
      identity: {
        'Declared': '#6366f1',
        'Stabilized': '#10b981',
        'Contested': '#f59e0b'
      },
      space: {
        'Local': '#64748b',
        'Federated': '#10b981',
        'Universal': '#6366f1'
      },
      time: {
        'Immutable': '#6366f1',
        'Versioned': '#8b5cf6',
        'Evolving': '#f59e0b'
      }
    };

    allButtons.forEach(btn => {
      const btnValue = btn.dataset.value;
      const color = colorMaps[dimension][btnValue];
      const isSelected = btnValue === value;

      btn.classList.toggle('selected', isSelected);

      if (isSelected) {
        btn.style.background = `${color}15`;
        btn.style.color = color;
        btn.style.borderColor = color;
      } else {
        btn.style.background = 'transparent';
        btn.style.color = '#64748b';
        btn.style.borderColor = '#e2e8f0';
      }
    });

    // Update the header icon to match the new selection
    this._updateOntologicalPanelHeader(dimension, value);
  }

  /**
   * Update the ontological panel header icon and color based on selection
   */
  _updateOntologicalPanelHeader(dimension, value) {
    const contentArea = this.elements.contentArea;
    const card = contentArea.querySelector(`.eo-card-${dimension}`);
    if (!card) return;

    const headerIcon = card.querySelector('.eo-card-header-icon');
    const iconElement = headerIcon?.querySelector('i');
    if (!headerIcon || !iconElement) return;

    // Get the metadata for the new value
    const metaMap = {
      identity: {
        'Declared': { icon: 'ph-stamp', color: '#6366f1' },
        'Stabilized': { icon: 'ph-check-circle', color: '#10b981' },
        'Contested': { icon: 'ph-warning', color: '#f59e0b' }
      },
      space: {
        'Local': { icon: 'ph-house', color: '#64748b' },
        'Federated': { icon: 'ph-handshake', color: '#10b981' },
        'Universal': { icon: 'ph-globe', color: '#6366f1' }
      },
      time: {
        'Immutable': { icon: 'ph-lock-simple', color: '#6366f1' },
        'Versioned': { icon: 'ph-clock-counter-clockwise', color: '#8b5cf6' },
        'Evolving': { icon: 'ph-arrows-clockwise', color: '#f59e0b' }
      }
    };

    const meta = metaMap[dimension]?.[value];
    if (meta) {
      headerIcon.style.background = `${meta.color}15`;
      iconElement.className = `ph ${meta.icon}`;
      iconElement.style.color = meta.color;
    }
  }

  /**
   * Setup inline editing for all editable elements in the definition detail view
   */
  _setupInlineEditing(contentArea, definition) {
    const editableElements = contentArea.querySelectorAll('.eo-editable');

    editableElements.forEach(element => {
      const field = element.dataset.field;
      const placeholder = element.dataset.placeholder || '';

      // Show placeholder when empty
      const updatePlaceholder = () => {
        const text = element.textContent.trim();
        if (!text) {
          element.classList.add('eo-editable-empty');
        } else {
          element.classList.remove('eo-editable-empty');
        }
      };
      updatePlaceholder();

      // Handle focus - select all text
      element.addEventListener('focus', () => {
        element.classList.add('eo-editable-focused');
        // Store original value for potential cancel
        element.dataset.originalValue = element.textContent;
      });

      // Handle blur - save changes
      element.addEventListener('blur', () => {
        element.classList.remove('eo-editable-focused');
        const newValue = element.textContent.trim();
        const originalValue = element.dataset.originalValue;

        if (newValue !== originalValue) {
          this._saveInlineEdit(definition, field, newValue);
        }
        updatePlaceholder();
      });

      // Handle Enter key - save and blur
      element.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          element.blur();
        }
        // Handle Escape - cancel editing
        if (e.key === 'Escape') {
          element.textContent = element.dataset.originalValue || '';
          element.blur();
        }
      });

      // Handle input - update placeholder state
      element.addEventListener('input', updatePlaceholder);
    });
  }

  /**
   * Save an inline edit to the definition
   */
  _saveInlineEdit(definition, field, value) {
    if (!definition.overrides) definition.overrides = {};

    switch (field) {
      case 'name':
        definition.name = value;
        break;
      case 'source':
        definition.sourceLabel = value;
        if (!definition.definitionSource) definition.definitionSource = {};
        if (!definition.definitionSource.source) definition.definitionSource.source = {};
        definition.definitionSource.source.title = value;
        break;
      case 'identityTitle':
        definition.overrides.identityTitle = value;
        break;
      case 'identityQuestion':
        definition.overrides.identityQuestion = value;
        break;
      case 'spaceTitle':
        definition.overrides.spaceTitle = value;
        break;
      case 'spaceQuestion':
        definition.overrides.spaceQuestion = value;
        break;
      case 'timeTitle':
        definition.overrides.timeTitle = value;
        break;
      case 'timeQuestion':
        definition.overrides.timeQuestion = value;
        break;
    }

    this._saveDefinition(definition);
  }

  /**
   * Save a definition to storage
   * Since the definition is passed by reference and already modified,
   * this function ensures the changes are persisted to storage
   */
  _saveDefinition(definition) {
    if (!definition || !definition.id) return;

    // Ensure the definition exists in our definitions array
    const index = this.definitions.findIndex(d => d.id === definition.id);
    if (index !== -1) {
      // Update the definition in the array (should already be updated via reference, but ensure it)
      this.definitions[index] = definition;
    }

    // Persist to storage
    this._saveData();
  }

  /**
   * Open modal to browse available URI API sources
   */
  _openUriApisBrowserModal(definition) {
    // Get URI sources from the global registry
    const sources = window.EO?.getAllURISources?.() || [];

    // Group sources by category
    const byCategory = {};
    for (const source of sources) {
      if (!byCategory[source.category]) {
        byCategory[source.category] = [];
      }
      byCategory[source.category].push(source);
    }

    // Category display names and icons
    const categoryMeta = {
      knowledge: { name: 'Knowledge Bases', icon: 'ph-brain' },
      government: { name: 'Government', icon: 'ph-buildings' },
      geographic: { name: 'Geographic', icon: 'ph-map-pin' },
      organization: { name: 'Organizations', icon: 'ph-briefcase' },
      academic: { name: 'Academic', icon: 'ph-graduation-cap' },
      legal: { name: 'Legal', icon: 'ph-scales' }
    };

    // Auth badge styling
    const getAuthBadge = (auth) => {
      switch (auth) {
        case 'none': return '<span class="uri-auth-badge auth-none">No Auth</span>';
        case 'username': return '<span class="uri-auth-badge auth-free">Free Account</span>';
        case 'api_key_optional': return '<span class="uri-auth-badge auth-optional">Key Optional</span>';
        case 'api_key': return '<span class="uri-auth-badge auth-required">API Key</span>';
        case 'account': return '<span class="uri-auth-badge auth-account">Account</span>';
        default: return '';
      }
    };

    // Build the HTML
    const categoriesHtml = Object.entries(byCategory).map(([category, categorySources]) => {
      const meta = categoryMeta[category] || { name: category, icon: 'ph-folder' };
      const sourcesHtml = categorySources.map(source => `
        <div class="uri-source-item" data-source-id="${source.id}">
          <div class="uri-source-info">
            <div class="uri-source-name">
              <span>${this._escapeHtml(source.name)}</span>
              <span class="uri-tier-badge">Tier ${source.tier}</span>
              ${getAuthBadge(source.auth)}
            </div>
            ${source.authNote ? `<div class="uri-source-note">${this._escapeHtml(source.authNote)}</div>` : ''}
          </div>
          <div class="uri-source-actions">
            <a href="${this._escapeHtml(source.docs)}" target="_blank" rel="noopener noreferrer" class="btn btn-xs btn-secondary" title="View documentation">
              <i class="ph ph-arrow-square-out"></i> Docs
            </a>
          </div>
        </div>
      `).join('');

      return `
        <div class="uri-category-section">
          <h4 class="uri-category-header">
            <i class="ph ${meta.icon}"></i>
            ${meta.name}
            <span class="uri-category-count">${categorySources.length}</span>
          </h4>
          <div class="uri-sources-list">
            ${sourcesHtml}
          </div>
        </div>
      `;
    }).join('');

    const html = `
      <div class="uri-apis-browser">
        <p class="uri-browser-intro">
          Browse available URI API sources for linking definitions to external standards and vocabularies.
        </p>
        <div class="uri-categories">
          ${categoriesHtml}
        </div>
      </div>
    `;

    this._showModal('URI API Sources', html, null, { hideConfirm: true, cancelText: 'Close' });
  }

  /**
   * Open modal to edit the meaning/description of a definition
   */
  _openEditMeaningModal(definition) {
    // Create a simple modal for editing the meaning
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.innerHTML = `
      <div class="modal-content" style="max-width: 500px;">
        <div class="modal-header">
          <h3>Edit Meaning</h3>
          <button class="modal-close-btn">&times;</button>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label for="meaning-name">Name</label>
            <input type="text" id="meaning-name" value="${this._escapeHtml(definition.name || '')}" />
          </div>
          <div class="form-group">
            <label for="meaning-description">Plain-language meaning</label>
            <textarea id="meaning-description" rows="4" placeholder="Describe what this definition represents in simple terms...">${this._escapeHtml(definition.term?.definitionText || definition.description || '')}</textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" id="btn-cancel-meaning">Cancel</button>
          <button class="btn btn-primary" id="btn-save-meaning">Save</button>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    // Event handlers
    const closeModal = () => modal.remove();
    modal.querySelector('.modal-close-btn').addEventListener('click', closeModal);
    modal.querySelector('#btn-cancel-meaning').addEventListener('click', closeModal);
    modal.querySelector('.modal-overlay').addEventListener('click', (e) => {
      if (e.target === modal) closeModal();
    });

    modal.querySelector('#btn-save-meaning').addEventListener('click', () => {
      const newName = modal.querySelector('#meaning-name').value.trim();
      const newDescription = modal.querySelector('#meaning-description').value.trim();

      if (newName) {
        definition.name = newName;
      }
      if (newDescription) {
        if (!definition.term) definition.term = {};
        definition.term.definitionText = newDescription;
        definition.description = newDescription;
      }

      this._saveDefinition(definition);
      closeModal();
      this._renderDefinitionDetailView(definition);
    });
  }

  /**
   * Open modal to edit the Identity of a definition
   * Identity: Declared, Stabilized, Contested
   *
   * Question: "How is this meaning stabilized in the world?"
   * - Declared: Meaning exists because an authority asserts it
   * - Stabilized: Meaning persists because systems agree and reinforce it
   * - Contested: Meaning is disputed, provisional, or actively evolving
   */
  _openEditIdentityModal(definition) {
    const identityInfo = this._getDefinitionIdentity(definition);
    const currentIdentity = definition.overrides?.identity || identityInfo.identity;
    const currentAuthoritySource = definition.overrides?.authoritySource ||
                                    definition.overrides?.governance?.authorityName ||
                                    definition.definitionSource?.authority?.name || '';

    const identityOptions = [
      { value: 'Declared', icon: 'ph-stamp', color: '#6366f1', description: 'Meaning exists because an authority asserts it' },
      { value: 'Stabilized', icon: 'ph-check-circle', color: '#10b981', description: 'Meaning persists because systems agree and reinforce it' },
      { value: 'Contested', icon: 'ph-warning', color: '#f59e0b', description: 'Meaning is disputed, provisional, or actively evolving' }
    ];

    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.innerHTML = `
      <div class="modal-content" style="max-width: 480px;">
        <div class="modal-header">
          <h3>Edit Identity</h3>
          <button class="modal-close-btn">&times;</button>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label>How is this meaning stabilized in the world?</label>
            <p class="form-hint" style="margin-bottom: 12px; color: #64748b; font-size: 0.85rem;">If this meaning were challenged tomorrow, would it collapse, bend, or hold?</p>
            <div class="radio-card-group">
              ${identityOptions.map(opt => `
                <label class="radio-card ${currentIdentity === opt.value ? 'selected' : ''}">
                  <input type="radio" name="edit-identity" value="${opt.value}" ${currentIdentity === opt.value ? 'checked' : ''}>
                  <div class="radio-card-content">
                    <i class="ph ${opt.icon}" style="color: ${opt.color};"></i>
                    <span class="radio-card-label">${opt.value}</span>
                    <span class="radio-card-desc">${opt.description}</span>
                  </div>
                </label>
              `).join('')}
            </div>
          </div>
          <div class="form-group" style="margin-top: 16px;">
            <label for="authority-source">Authority Source <span style="color: #94a3b8; font-weight: normal;">(optional)</span></label>
            <input type="text" id="authority-source" value="${this._escapeHtml(currentAuthoritySource)}" placeholder="e.g., ISO, USDA, Company Policy" />
            <p class="form-hint" style="margin-top: 4px; color: #94a3b8; font-size: 0.8rem;">Who or what asserts this meaning?</p>
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" id="btn-cancel-identity">Cancel</button>
          <button class="btn btn-primary" id="btn-save-identity">Save</button>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    modal.querySelectorAll('.radio-card input').forEach(radio => {
      radio.addEventListener('change', () => {
        const group = radio.closest('.radio-card-group');
        group.querySelectorAll('.radio-card').forEach(card => card.classList.remove('selected'));
        radio.closest('.radio-card').classList.add('selected');
      });
    });

    const closeModal = () => modal.remove();
    modal.querySelector('.modal-close-btn').addEventListener('click', closeModal);
    modal.querySelector('#btn-cancel-identity').addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => {
      if (e.target === modal) closeModal();
    });

    modal.querySelector('#btn-save-identity').addEventListener('click', () => {
      const selectedIdentity = modal.querySelector('input[name="edit-identity"]:checked')?.value;
      const authoritySource = modal.querySelector('#authority-source').value.trim();
      if (!definition.overrides) definition.overrides = {};
      if (selectedIdentity) definition.overrides.identity = selectedIdentity;
      if (authoritySource) {
        definition.overrides.authoritySource = authoritySource;
      } else {
        delete definition.overrides.authoritySource;
      }
      this._saveDefinition(definition);
      closeModal();
      this._renderDefinitionDetailView(definition);
    });
  }

  /**
   * Open modal to edit the Space of a definition
   * Space: Local, Universal, Federated
   */
  _openEditSpaceModal(definition) {
    const spaceInfo = this._getDefinitionSpace(definition);
    const currentSpace = definition.overrides?.space || spaceInfo.space;

    const spaceOptions = [
      { value: 'Local', icon: 'ph-house', color: '#64748b', description: 'Bounded to this workspace/project' },
      { value: 'Universal', icon: 'ph-globe', color: '#6366f1', description: 'Same meaning everywhere (linked to standard URI)' },
      { value: 'Federated', icon: 'ph-handshake', color: '#10b981', description: 'Travels with explicit translation rules' }
    ];

    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.innerHTML = `
      <div class="modal-content" style="max-width: 450px;">
        <div class="modal-header">
          <h3>Edit Space</h3>
          <button class="modal-close-btn">&times;</button>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label>Where does this meaning apply?</label>
            <div class="radio-card-group">
              ${spaceOptions.map(opt => `
                <label class="radio-card ${currentSpace === opt.value ? 'selected' : ''}">
                  <input type="radio" name="edit-space" value="${opt.value}" ${currentSpace === opt.value ? 'checked' : ''}>
                  <div class="radio-card-content">
                    <i class="ph ${opt.icon}" style="color: ${opt.color};"></i>
                    <span class="radio-card-label">${opt.value}</span>
                    <span class="radio-card-desc">${opt.description}</span>
                  </div>
                </label>
              `).join('')}
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" id="btn-cancel-space">Cancel</button>
          <button class="btn btn-primary" id="btn-save-space">Save</button>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    modal.querySelectorAll('.radio-card input').forEach(radio => {
      radio.addEventListener('change', () => {
        const group = radio.closest('.radio-card-group');
        group.querySelectorAll('.radio-card').forEach(card => card.classList.remove('selected'));
        radio.closest('.radio-card').classList.add('selected');
      });
    });

    const closeModal = () => modal.remove();
    modal.querySelector('.modal-close-btn').addEventListener('click', closeModal);
    modal.querySelector('#btn-cancel-space').addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => {
      if (e.target === modal) closeModal();
    });

    modal.querySelector('#btn-save-space').addEventListener('click', () => {
      const selectedSpace = modal.querySelector('input[name="edit-space"]:checked')?.value;
      if (!definition.overrides) definition.overrides = {};
      if (selectedSpace) definition.overrides.space = selectedSpace;
      this._saveDefinition(definition);
      closeModal();
      this._renderDefinitionDetailView(definition);
    });
  }

  /**
   * Open modal to edit the Time of a definition
   * Time: Immutable, Versioned, Evolving
   */
  _openEditTimeModal(definition) {
    const timeInfo = this._getDefinitionTime(definition);
    const currentTime = definition.overrides?.time || timeInfo.time;

    const timeOptions = [
      { value: 'Immutable', icon: 'ph-lock-simple', color: '#6366f1', description: 'Fixed at creation, should not change' },
      { value: 'Versioned', icon: 'ph-clock-counter-clockwise', color: '#8b5cf6', description: 'Changes at defined epochs (v1 → v2)' },
      { value: 'Evolving', icon: 'ph-arrows-clockwise', color: '#f59e0b', description: 'Continuously updating' }
    ];

    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.innerHTML = `
      <div class="modal-content" style="max-width: 450px;">
        <div class="modal-header">
          <h3>Edit Time</h3>
          <button class="modal-close-btn">&times;</button>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label>How does this meaning change?</label>
            <div class="radio-card-group">
              ${timeOptions.map(opt => `
                <label class="radio-card ${currentTime === opt.value ? 'selected' : ''}">
                  <input type="radio" name="edit-time" value="${opt.value}" ${currentTime === opt.value ? 'checked' : ''}>
                  <div class="radio-card-content">
                    <i class="ph ${opt.icon}" style="color: ${opt.color};"></i>
                    <span class="radio-card-label">${opt.value}</span>
                    <span class="radio-card-desc">${opt.description}</span>
                  </div>
                </label>
              `).join('')}
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" id="btn-cancel-time">Cancel</button>
          <button class="btn btn-primary" id="btn-save-time">Save</button>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    modal.querySelectorAll('.radio-card input').forEach(radio => {
      radio.addEventListener('change', () => {
        const group = radio.closest('.radio-card-group');
        group.querySelectorAll('.radio-card').forEach(card => card.classList.remove('selected'));
        radio.closest('.radio-card').classList.add('selected');
      });
    });

    const closeModal = () => modal.remove();
    modal.querySelector('.modal-close-btn').addEventListener('click', closeModal);
    modal.querySelector('#btn-cancel-time').addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => {
      if (e.target === modal) closeModal();
    });

    modal.querySelector('#btn-save-time').addEventListener('click', () => {
      const selectedTime = modal.querySelector('input[name="edit-time"]:checked')?.value;
      if (!definition.overrides) definition.overrides = {};
      if (selectedTime) definition.overrides.time = selectedTime;
      this._saveDefinition(definition);
      closeModal();
      this._renderDefinitionDetailView(definition);
    });
  }

  /**
   * @deprecated Governance has been absorbed into Identity.
   * Use _openEditIdentityModal instead. This modal is kept for backwards compatibility.
   */
  _openEditGovernanceModal(definition) {
    // Redirect to Identity modal - governance is now part of Identity
    this._openEditIdentityModal(definition);
  }

  /**
   * @deprecated Legacy modal - use _openEditIdentityModal instead
   * Open modal to edit the Kind and Scope of a definition
   */
  _openEditScopeModal(definition) {
    // Redirect to new Identity modal
    this._openEditIdentityModal(definition);
  }

  /**
   * @deprecated Legacy modal - use _openEditTimeModal instead
   * Open modal to edit the Stability and Time Sensitivity of a definition
   */
  _openEditStabilityModal(definition) {
    // Redirect to new Time modal
    this._openEditTimeModal(definition);
  }

  /**
   * @deprecated Legacy modal - use _openEditIdentityModal instead
   * Open modal to edit the Authority of a definition
   */
  _openEditAuthorityModal(definition) {
    // Redirect to Identity modal - authority is now an annotation within Identity
    this._openEditIdentityModal(definition);
  }

  /**
   * Mark a definition as intentionally local (no external link needed)
   */
  _markDefinitionAsLocal(definition) {
    definition.status = 'local_only';
    this._saveDefinition(definition);
    this._renderDefinitionDetailView(definition);
  }

  /**
   * Render terms table rows for the v2 layout (simplified)
   */
  _renderTermsTableRowsV2(terms, termLinkages, definitionId) {
    return terms.map((term, index) => {
      const termName = term.name || term.term || term.label || 'Unnamed';
      const termLabel = term.label || term.displayLabel || null;
      const termRole = term.type || term.role || 'text';
      const termNotes = term.description || term.notes || '';
      const linkage = termLinkages.get(termName);
      const linkedTo = linkage ? `${linkage.setName}.${linkage.fieldName}` : null;

      return `
        <tr class="term-row" data-term-index="${index}">
          <td class="col-term">
            <div class="term-name-cell">
              <span class="term-indicator">◇</span>
              <span class="term-name">${this._escapeHtml(termName)}</span>
            </div>
          </td>
          <td class="col-label">
            <span class="term-label-value">${termLabel ? this._escapeHtml(termLabel) : '—'}</span>
          </td>
          <td class="col-role">
            <span class="term-role-badge">${this._escapeHtml(termRole)}</span>
          </td>
          <td class="col-notes">
            <span class="term-notes-text">${this._escapeHtml(termNotes)}</span>
          </td>
          <td class="col-linked">
            <span class="term-linked-value">${linkedTo ? this._escapeHtml(linkedTo) : '—'}</span>
          </td>
          <td class="col-actions">
            <button class="btn-icon term-action-btn" data-term-name="${this._escapeHtml(termName)}" title="View term details">
              <i class="ph ph-arrow-right"></i>
            </button>
          </td>
        </tr>
      `;
    }).join('');
  }

  /**
   * Attach event handlers for the v2 definition detail view
   */
  _attachDefinitionDetailHandlersV2(definition) {
    // Tab switching
    const tabButtons = this.elements.contentArea.querySelectorAll('.def-profile-tab');
    const tabPanes = this.elements.contentArea.querySelectorAll('.def-profile-tab-pane');

    tabButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const tabId = btn.dataset.tab;
        this._definitionActiveTab = tabId;

        // Update active states
        tabButtons.forEach(b => b.classList.remove('active'));
        tabPanes.forEach(p => p.classList.remove('active'));

        btn.classList.add('active');
        const pane = this.elements.contentArea.querySelector(`[data-pane="${tabId}"]`);
        if (pane) pane.classList.add('active');
      });
    });

    // Apply to Fields buttons
    const applyBtn = this.elements.contentArea.querySelector('#btn-apply-definition');
    const applyBtnEmpty = this.elements.contentArea.querySelector('#btn-apply-to-fields-empty');
    [applyBtn, applyBtnEmpty].forEach(btn => {
      if (btn) {
        btn.addEventListener('click', () => this._showApplyToFieldsModal(definition.id));
      }
    });

    // Refresh button
    const refreshBtn = this.elements.contentArea.querySelector('#btn-refresh-definition');
    if (refreshBtn) {
      refreshBtn.addEventListener('click', () => this._refreshDefinitionFromUri(definition));
    }

    // Delete button
    const deleteBtn = this.elements.contentArea.querySelector('#btn-delete-definition');
    if (deleteBtn) {
      deleteBtn.addEventListener('click', () => this._deleteDefinition(definition.id));
    }

    // Add term buttons
    const addTermBtn = this.elements.contentArea.querySelector('#btn-add-term');
    const addFirstTermBtn = this.elements.contentArea.querySelector('#btn-add-first-term');
    [addTermBtn, addFirstTermBtn].forEach(btn => {
      if (btn) {
        btn.addEventListener('click', () => this._showAddTermModal(definition.id));
      }
    });

    // Link to URI button
    const linkUriBtn = this.elements.contentArea.querySelector('#btn-link-to-uri');
    if (linkUriBtn) {
      linkUriBtn.addEventListener('click', () => this._openLinkToUriModal(definition));
    }

    // Change URI button (for already linked definitions)
    const changeUriBtn = this.elements.contentArea.querySelector('#btn-change-uri');
    if (changeUriBtn) {
      changeUriBtn.addEventListener('click', () => this._openLinkToUriModal(definition));
    }

    // Find Similar button
    const findSimilarBtn = this.elements.contentArea.querySelector('#btn-find-similar');
    if (findSimilarBtn) {
      findSimilarBtn.addEventListener('click', () => this._searchSimilarDefinitions(definition));
    }

    // Import from Vocabulary button
    const importVocabBtn = this.elements.contentArea.querySelector('#btn-import-vocabulary');
    if (importVocabBtn) {
      importVocabBtn.addEventListener('click', () => this._openImportVocabularyModal(definition));
    }

    // Save notes button
    const saveNotesBtn = this.elements.contentArea.querySelector('#btn-save-interpretation-notes');
    if (saveNotesBtn) {
      saveNotesBtn.addEventListener('click', () => this._saveInterpretationNotes(definition));
    }

    // Terms search
    const termsSearchInput = this.elements.contentArea.querySelector('#terms-search-input');
    if (termsSearchInput) {
      termsSearchInput.addEventListener('input', (e) => this._filterTermsV2(e.target.value, definition));
    }

    // Term row actions
    const termActionBtns = this.elements.contentArea.querySelectorAll('.term-action-btn');
    termActionBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        const termName = btn.dataset.termName;
        this._openTermDetailModal(definition, termName);
      });
    });
  }

  /**
   * Filter terms in the v2 table
   */
  _filterTermsV2(searchTerm, definition) {
    const terms = definition.terms || definition.properties || [];
    const rows = this.elements.contentArea.querySelectorAll('.term-row');
    const searchLower = searchTerm.toLowerCase();

    rows.forEach((row, index) => {
      const term = terms[index];
      if (!term) return;

      const termName = (term.name || term.term || term.label || '').toLowerCase();
      const termLabel = (term.label || term.displayLabel || '').toLowerCase();
      const termNotes = (term.description || term.notes || '').toLowerCase();

      const matches = termName.includes(searchLower) ||
                      termLabel.includes(searchLower) ||
                      termNotes.includes(searchLower);

      row.style.display = matches ? '' : 'none';
    });
  }

  /**
   * Open modal showing term details
   */
  _openTermDetailModal(definition, termName) {
    const terms = definition.terms || definition.properties || [];
    const term = terms.find(t => (t.name || t.term || t.label) === termName);

    if (!term) {
      this._showNotification('Term not found', 'error');
      return;
    }

    const name = term.name || term.term || term.label || 'Unnamed';
    const label = term.label || term.displayLabel || '';
    const role = term.type || term.role || 'text';
    const notes = term.description || term.notes || '';
    const uri = term.uri || term.sourceUri || '';

    // Get linkages for this term
    const termLinkages = this._getTermSetLinkages(definition);
    const linkage = termLinkages.get(name);
    const linkedTo = linkage ? `${linkage.setName}.${linkage.fieldName}` : null;

    const html = `
      <div class="term-detail-modal">
        <div class="form-group">
          <label class="form-label">Term Name</label>
          <div class="form-value">${this._escapeHtml(name)}</div>
        </div>
        ${label ? `
          <div class="form-group">
            <label class="form-label">Display Label</label>
            <div class="form-value">${this._escapeHtml(label)}</div>
          </div>
        ` : ''}
        <div class="form-group">
          <label class="form-label">Role / Type</label>
          <div class="form-value"><span class="term-role-badge">${this._escapeHtml(role)}</span></div>
        </div>
        ${notes ? `
          <div class="form-group">
            <label class="form-label">Notes</label>
            <div class="form-value">${this._escapeHtml(notes)}</div>
          </div>
        ` : ''}
        ${uri ? `
          <div class="form-group">
            <label class="form-label">URI</label>
            <div class="form-value">
              <a href="${this._escapeHtml(uri)}" target="_blank" rel="noopener noreferrer">${this._escapeHtml(uri)}</a>
            </div>
          </div>
        ` : ''}
        <div class="form-group">
          <label class="form-label">Linked To</label>
          <div class="form-value">${linkedTo ? this._escapeHtml(linkedTo) : '<span style="color: var(--text-tertiary);">Not linked</span>'}</div>
        </div>
      </div>
    `;

    this._showModal(`Term: ${name}`, html, null, { hideFooter: true });
  }

  /**
   * Render DefinitionSource metadata section
   */
  _renderDefinitionSourceSection(defSource) {
    const authority = defSource.authority;
    const source = defSource.source;
    const validity = defSource.validity;
    const version = defSource.version;
    const jurisdiction = defSource.jurisdiction;
    const term = defSource.term;

    // Check if validity is current
    const now = new Date().toISOString().split('T')[0];
    const isCurrent = validity?.from <= now && (!validity?.to || validity.to >= now) && !validity?.supersededBy;

    return `
      <div class="definition-source-section">
        <div class="definition-source-grid">
          <!-- Authority -->
          <div class="definition-source-card">
            <div class="definition-source-card-header">
              <i class="ph ph-buildings"></i>
              <span>Authority</span>
            </div>
            <div class="definition-source-card-content">
              <div class="definition-source-field">
                <span class="field-label">Name</span>
                <span class="field-value">${this._escapeHtml(authority?.name || '—')}</span>
              </div>
              ${authority?.shortName ? `
                <div class="definition-source-field">
                  <span class="field-label">Short Name</span>
                  <span class="field-value"><strong>${this._escapeHtml(authority.shortName)}</strong></span>
                </div>
              ` : ''}
              <div class="definition-source-field">
                <span class="field-label">Type</span>
                <span class="field-value">
                  <span class="definition-source-badge">${this._formatAuthorityType(authority?.type)}</span>
                </span>
              </div>
              ${authority?.uri ? `
                <div class="definition-source-field">
                  <span class="field-label">URI</span>
                  <span class="field-value">
                    <a href="${this._escapeHtml(authority.uri)}" target="_blank" class="definition-source-link">
                      ${this._escapeHtml(this._truncateName(authority.uri, 35))}
                    </a>
                  </span>
                </div>
              ` : ''}
            </div>
          </div>

          <!-- Source Document -->
          <div class="definition-source-card">
            <div class="definition-source-card-header">
              <i class="ph ph-file-text"></i>
              <span>Source Document</span>
            </div>
            <div class="definition-source-card-content">
              ${source?.title ? `
                <div class="definition-source-field">
                  <span class="field-label">Title</span>
                  <span class="field-value">${this._escapeHtml(source.title)}</span>
                </div>
              ` : ''}
              ${source?.citation ? `
                <div class="definition-source-field">
                  <span class="field-label">Citation</span>
                  <span class="field-value"><code>${this._escapeHtml(source.citation)}</code></span>
                </div>
              ` : ''}
              ${source?.section ? `
                <div class="definition-source-field">
                  <span class="field-label">Section</span>
                  <span class="field-value">${this._escapeHtml(source.section)}</span>
                </div>
              ` : ''}
              <div class="definition-source-field">
                <span class="field-label">Type</span>
                <span class="field-value">
                  <span class="definition-source-badge">${this._formatSourceType(source?.type)}</span>
                </span>
              </div>
              ${source?.url ? `
                <div class="definition-source-field">
                  <span class="field-label">URL</span>
                  <span class="field-value">
                    <a href="${this._escapeHtml(source.url)}" target="_blank" class="definition-source-link">
                      View Source <i class="ph ph-arrow-square-out"></i>
                    </a>
                  </span>
                </div>
              ` : ''}
            </div>
          </div>

          <!-- Validity -->
          <div class="definition-source-card">
            <div class="definition-source-card-header">
              <i class="ph ph-calendar-check"></i>
              <span>Validity</span>
              <span class="definition-source-status ${isCurrent ? 'status-current' : 'status-superseded'}">
                ${isCurrent ? 'Current' : 'Superseded'}
              </span>
            </div>
            <div class="definition-source-card-content">
              <div class="definition-source-field">
                <span class="field-label">Effective From</span>
                <span class="field-value">${validity?.from || '—'}</span>
              </div>
              ${validity?.to ? `
                <div class="definition-source-field">
                  <span class="field-label">Effective Until</span>
                  <span class="field-value">${validity.to}</span>
                </div>
              ` : ''}
              ${validity?.supersedes ? `
                <div class="definition-source-field">
                  <span class="field-label">Supersedes</span>
                  <span class="field-value">${this._escapeHtml(validity.supersedes)}</span>
                </div>
              ` : ''}
              ${validity?.supersededBy ? `
                <div class="definition-source-field">
                  <span class="field-label">Superseded By</span>
                  <span class="field-value">${this._escapeHtml(validity.supersededBy)}</span>
                </div>
              ` : ''}
              ${version?.id ? `
                <div class="definition-source-field">
                  <span class="field-label">Version</span>
                  <span class="field-value">${this._escapeHtml(version.id)}</span>
                </div>
              ` : ''}
              ${version?.published ? `
                <div class="definition-source-field">
                  <span class="field-label">Published</span>
                  <span class="field-value">${version.published}</span>
                </div>
              ` : ''}
            </div>
          </div>

          <!-- Jurisdiction -->
          ${jurisdiction ? `
            <div class="definition-source-card">
              <div class="definition-source-card-header">
                <i class="ph ph-globe"></i>
                <span>Jurisdiction</span>
              </div>
              <div class="definition-source-card-content">
                ${jurisdiction.geographic ? `
                  <div class="definition-source-field">
                    <span class="field-label">Geographic</span>
                    <span class="field-value">${this._escapeHtml(jurisdiction.geographic)}</span>
                  </div>
                ` : ''}
                ${jurisdiction.programs && jurisdiction.programs.length > 0 ? `
                  <div class="definition-source-field">
                    <span class="field-label">Programs</span>
                    <span class="field-value">
                      ${jurisdiction.programs.map(p => `<span class="definition-source-tag">${this._escapeHtml(p)}</span>`).join(' ')}
                    </span>
                  </div>
                ` : ''}
              </div>
            </div>
          ` : ''}
        </div>

        ${term?.categories && term.categories.length > 0 ? `
          <div class="definition-source-categories">
            <div class="definition-source-card-header">
              <i class="ph ph-list-bullets"></i>
              <span>Categories / Subdivisions</span>
            </div>
            <ul class="definition-source-category-list">
              ${term.categories.map(cat => `<li>${this._escapeHtml(cat)}</li>`).join('')}
            </ul>
          </div>
        ` : ''}
      </div>
    `;
  }

  /**
   * Format authority type for display
   */
  _formatAuthorityType(type) {
    const typeMap = {
      'federal_agency': 'Federal Agency',
      'state_agency': 'State Agency',
      'local_gov': 'Local Government',
      'standards_body': 'Standards Body',
      'ngo': 'NGO',
      'academic': 'Academic',
      'international': 'International',
      'other': 'Other'
    };
    return typeMap[type] || type || 'Unknown';
  }

  /**
   * Format source document type for display
   */
  _formatSourceType(type) {
    const typeMap = {
      'regulation': 'Regulation',
      'statute': 'Statute',
      'guidance': 'Guidance',
      'policy': 'Policy',
      'standard': 'Standard',
      'manual': 'Manual',
      'other': 'Other'
    };
    return typeMap[type] || type || 'Unknown';
  }

  /**
   * Attach event handlers for definition detail view
   */
  _attachDefinitionDetailHandlers(definition) {
    const contentArea = this.elements.contentArea;

    contentArea.querySelector('#btn-refresh-definition')?.addEventListener('click', () => {
      this._refreshDefinitionFromUri(definition.id);
    });

    contentArea.querySelector('#btn-apply-definition')?.addEventListener('click', () => {
      this._showApplyToFieldsModal(definition.id);
    });

    contentArea.querySelector('#btn-delete-definition')?.addEventListener('click', () => {
      this._deleteDefinition(definition.id);
    });

    contentArea.querySelector('#btn-add-term')?.addEventListener('click', () => {
      this._showAddTermModal(definition.id);
    });

    // Back navigation button
    contentArea.querySelector('#btn-back-to-usage')?.addEventListener('click', () => {
      this._navigateToDefinitionUsage(definition.id);
    });

    // Collapsible sections - Provenance & Authority
    contentArea.querySelector('#provenance-toggle')?.addEventListener('click', () => {
      const section = contentArea.querySelector('#provenance-section');
      section?.classList.toggle('collapsed');
    });

    // Collapsible sections - Notes & Rationale
    contentArea.querySelector('#notes-rationale-toggle')?.addEventListener('click', () => {
      const section = contentArea.querySelector('#notes-rationale-section');
      section?.classList.toggle('collapsed');
    });

    // Semantic Actions buttons
    contentArea.querySelector('#btn-apply-to-fields')?.addEventListener('click', () => {
      this._showApplyToFieldsModal(definition.id);
    });

    contentArea.querySelector('#btn-find-related')?.addEventListener('click', () => {
      this._showFindRelatedConceptsModal(definition);
    });

    contentArea.querySelector('#btn-compare-definitions')?.addEventListener('click', () => {
      this._showCompareDefinitionsModal(definition.id);
    });

    contentArea.querySelector('#btn-create-refinement')?.addEventListener('click', () => {
      this._showCreateRefinementModal(definition.id);
    });

    // Interpretation Notes save button
    contentArea.querySelector('#btn-save-interpretation-notes')?.addEventListener('click', () => {
      this._saveInterpretationNotes(definition.id);
    });

    // Terms table search and filter handlers
    this._attachTermsTableHandlers(definition);
  }

  /**
   * Navigate to the first set/field that uses this definition
   */
  _navigateToDefinitionUsage(definitionId) {
    const linkedSets = this._getLinkedSetsForDefinition({ id: definitionId });
    const firstUsage = Array.from(linkedSets.values())[0];

    if (firstUsage && firstUsage.set) {
      this._selectSet(firstUsage.set.id);
    }
  }

  /**
   * Save interpretation notes for a definition
   */
  _saveInterpretationNotes(definitionId) {
    const definition = this.definitions?.find(d => d.id === definitionId);
    if (!definition) return;

    const contentArea = this.elements.contentArea;
    const notesText = contentArea.querySelector('#interpretation-notes-text')?.value || '';
    const scopeCheckboxes = contentArea.querySelectorAll('input[name="scope"]:checked');
    const scopes = Array.from(scopeCheckboxes).map(cb => cb.value);

    definition.interpretationNotes = notesText;
    definition.interpretationScope = scopes;

    this._saveData();
    this._showNotification('Interpretation notes saved', 'success');
  }

  /**
   * Show modal to find related concepts (for externally grounded definitions)
   */
  _showFindRelatedConceptsModal(definition) {
    if (!definition.sourceUri) {
      this._showNotification('This action requires an externally grounded definition', 'warning');
      return;
    }

    const isWikidata = definition.sourceUri.includes('wikidata.org');
    const sourceLabel = isWikidata ? 'Wikidata' : 'external source';

    this._showModal('Find Related Concepts', `
      <div class="find-related-form">
        <p>Search for concepts related to <strong>${this._escapeHtml(definition.name)}</strong> from ${sourceLabel}.</p>
        <div class="form-group">
          <label class="form-label">Search for:</label>
          <div class="related-search-options">
            <label class="radio-option">
              <input type="radio" name="related-type" value="broader" checked>
              <span>Broader concepts (parents)</span>
            </label>
            <label class="radio-option">
              <input type="radio" name="related-type" value="narrower">
              <span>Narrower concepts (children)</span>
            </label>
            <label class="radio-option">
              <input type="radio" name="related-type" value="related">
              <span>Related concepts</span>
            </label>
          </div>
        </div>
        <p class="hint-text">This will search ${sourceLabel} for semantically related definitions you can import.</p>
      </div>
    `, () => {
      const relationType = document.querySelector('input[name="related-type"]:checked')?.value || 'broader';
      this._searchRelatedConcepts(definition, relationType);
    });
  }

  /**
   * Search for related concepts (placeholder - would integrate with Wikidata API)
   */
  _searchRelatedConcepts(definition, relationType) {
    this._showNotification(`Searching for ${relationType} concepts... (Feature coming soon)`, 'info');
  }

  /**
   * Show modal to compare definitions
   */
  _showCompareDefinitionsModal(definitionId) {
    const definition = this.definitions?.find(d => d.id === definitionId);
    if (!definition) return;

    const otherDefinitions = this.definitions?.filter(d => d.id !== definitionId) || [];

    if (otherDefinitions.length === 0) {
      this._showNotification('No other definitions to compare with', 'info');
      return;
    }

    this._showModal('Compare Definitions', `
      <div class="compare-definitions-form">
        <p>Compare <strong>${this._escapeHtml(definition.name)}</strong> with:</p>
        <div class="form-group">
          <select id="compare-target" class="form-input">
            ${otherDefinitions.map(d => `
              <option value="${d.id}">${this._escapeHtml(d.name)}</option>
            `).join('')}
          </select>
        </div>
        <p class="hint-text">This will show term overlap and differences between definitions.</p>
      </div>
    `, () => {
      const targetId = document.getElementById('compare-target')?.value;
      if (targetId) {
        this._showDefinitionComparison(definitionId, targetId);
      }
    });
  }

  /**
   * Show definition comparison view
   */
  _showDefinitionComparison(defId1, defId2) {
    const def1 = this.definitions?.find(d => d.id === defId1);
    const def2 = this.definitions?.find(d => d.id === defId2);

    if (!def1 || !def2) return;

    const terms1 = new Set((def1.terms || []).map(t => t.name?.toLowerCase()));
    const terms2 = new Set((def2.terms || []).map(t => t.name?.toLowerCase()));

    const overlap = [...terms1].filter(t => terms2.has(t));
    const onlyIn1 = [...terms1].filter(t => !terms2.has(t));
    const onlyIn2 = [...terms2].filter(t => !terms1.has(t));

    this._showModal('Definition Comparison', `
      <div class="definition-comparison">
        <div class="comparison-header">
          <span class="def-name">${this._escapeHtml(def1.name)}</span>
          <span class="vs">vs</span>
          <span class="def-name">${this._escapeHtml(def2.name)}</span>
        </div>
        <div class="comparison-stats">
          <div class="stat-item overlap">
            <span class="stat-value">${overlap.length}</span>
            <span class="stat-label">Overlapping terms</span>
          </div>
          <div class="stat-item unique">
            <span class="stat-value">${onlyIn1.length}</span>
            <span class="stat-label">Only in ${this._escapeHtml(def1.name)}</span>
          </div>
          <div class="stat-item unique">
            <span class="stat-value">${onlyIn2.length}</span>
            <span class="stat-label">Only in ${this._escapeHtml(def2.name)}</span>
          </div>
        </div>
        ${overlap.length > 0 ? `
          <div class="comparison-section">
            <h4>Overlapping Terms</h4>
            <div class="term-list">${overlap.map(t => `<span class="term-tag">${this._escapeHtml(t)}</span>`).join('')}</div>
          </div>
        ` : ''}
      </div>
    `, null, { showCancel: false, confirmText: 'Close' });
  }

  /**
   * Show modal to create a local refinement of a definition
   */
  _showCreateRefinementModal(definitionId) {
    const definition = this.definitions?.find(d => d.id === definitionId);
    if (!definition) return;

    this._showModal('Create Local Refinement', `
      <div class="create-refinement-form">
        <p>Create a local refinement of <strong>${this._escapeHtml(definition.name)}</strong>.</p>
        <p class="hint-text">This creates a copy that maintains a link to the original definition, allowing domain-specific nuance while preserving semantic lineage.</p>
        <div class="form-group">
          <label for="refinement-name" class="form-label">Refinement Name</label>
          <input type="text" id="refinement-name" class="form-input" value="${this._escapeHtml(definition.name)} (Local)" placeholder="e.g., homelessness (HUD CoC)">
        </div>
        <div class="form-group">
          <label for="refinement-notes" class="form-label">How does this refine the original?</label>
          <textarea id="refinement-notes" class="form-input" rows="3" placeholder="e.g., Scoped to individuals in HUD Continuum of Care programs..."></textarea>
        </div>
      </div>
    `, () => {
      const name = document.getElementById('refinement-name')?.value?.trim();
      const notes = document.getElementById('refinement-notes')?.value?.trim();

      if (!name) {
        this._showNotification('Name is required', 'error');
        return;
      }

      this._createDefinitionRefinement(definitionId, name, notes);
    });
  }

  /**
   * Create a local refinement of a definition
   */
  _createDefinitionRefinement(originalId, name, notes) {
    const original = this.definitions?.find(d => d.id === originalId);
    if (!original) return;

    const refinement = {
      id: `def_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
      name: name,
      description: notes || original.description,
      terms: JSON.parse(JSON.stringify(original.terms || [])),
      sourceUri: null, // Local refinement
      refinedFrom: {
        definitionId: originalId,
        definitionName: original.name,
        originalUri: original.sourceUri
      },
      importedAt: new Date().toISOString()
    };

    if (!this.definitions) this.definitions = [];
    this.definitions.push(refinement);

    this._saveData();
    this._renderDefinitionsNav();
    this._showDefinitionDetail(refinement.id);
    this._showNotification(`Created refinement: ${name}`, 'success');
  }

  /**
   * Attach event handlers for terms table search, filter, and sorting
   */
  _attachTermsTableHandlers(definition) {
    const contentArea = this.elements.contentArea;
    const terms = definition.terms || definition.properties || [];
    const termLinkages = this._getTermSetLinkages(definition);

    // Search input handler
    const searchInput = contentArea.querySelector('#terms-search-input');
    if (searchInput) {
      searchInput.addEventListener('input', (e) => {
        this._filterTermsTable(definition);
      });
    }

    // Type filter handler
    const typeFilter = contentArea.querySelector('#terms-type-filter');
    if (typeFilter) {
      typeFilter.addEventListener('change', () => {
        this._filterTermsTable(definition);
      });
    }

    // Link status filter handler
    const linkFilter = contentArea.querySelector('#terms-link-filter');
    if (linkFilter) {
      linkFilter.addEventListener('change', () => {
        this._filterTermsTable(definition);
      });
    }

    // Group by handler
    const groupFilter = contentArea.querySelector('#terms-group-filter');
    if (groupFilter) {
      groupFilter.addEventListener('change', (e) => {
        this._updateTermsGrouping(definition, e.target.value);
      });
    }

    // Clear filters button
    const clearFiltersBtn = contentArea.querySelector('#terms-clear-filters');
    if (clearFiltersBtn) {
      clearFiltersBtn.addEventListener('click', () => {
        this._clearTermsFilters(definition);
      });
    }

    // Sort buttons
    contentArea.querySelectorAll('.th-sort-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const sortKey = btn.dataset.sort;
        this._sortTermsTable(definition, sortKey);
      });
    });

    // Link action buttons
    contentArea.querySelectorAll('.term-link-action-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const termId = btn.dataset.termId;
        const definitionId = btn.dataset.definitionId;
        this._showLinkTermToSetModal(definitionId, termId);
      });
    });
  }

  /**
   * Filter terms table based on search and filters
   */
  _filterTermsTable(definition) {
    const contentArea = this.elements.contentArea;
    const searchInput = contentArea.querySelector('#terms-search-input');
    const typeFilter = contentArea.querySelector('#terms-type-filter');
    const linkFilter = contentArea.querySelector('#terms-link-filter');
    const clearBtn = contentArea.querySelector('#terms-clear-filters');
    const resultsCount = contentArea.querySelector('#terms-results-count');

    const searchTerm = (searchInput?.value || '').toLowerCase().trim();
    const typeValue = typeFilter?.value || '';
    const linkValue = linkFilter?.value || '';

    // Show/hide clear button
    const hasFilters = searchTerm || typeValue || linkValue;
    if (clearBtn) {
      clearBtn.style.display = hasFilters ? '' : 'none';
    }

    const rows = contentArea.querySelectorAll('#terms-table-body .definition-term-row');
    let visibleCount = 0;

    rows.forEach(row => {
      const searchData = row.dataset.search || '';
      const termType = row.dataset.termType || '';
      const isLinked = row.dataset.linked === 'true';

      let matchesSearch = !searchTerm || searchData.includes(searchTerm);
      let matchesType = !typeValue || termType === typeValue;
      let matchesLink = !linkValue ||
        (linkValue === 'linked' && isLinked) ||
        (linkValue === 'unlinked' && !isLinked);

      const visible = matchesSearch && matchesType && matchesLink;
      row.style.display = visible ? '' : 'none';
      if (visible) visibleCount++;
    });

    // Update results count
    if (resultsCount) {
      const totalTerms = (definition.terms || definition.properties || []).length;
      if (hasFilters) {
        resultsCount.textContent = `Showing ${visibleCount} of ${totalTerms} terms`;
      } else {
        resultsCount.textContent = `Showing ${totalTerms} terms`;
      }
    }
  }

  /**
   * Update terms grouping view
   */
  _updateTermsGrouping(definition, groupBy) {
    const contentArea = this.elements.contentArea;
    const tableContainer = contentArea.querySelector('#terms-table-container');
    const groupedContainer = contentArea.querySelector('#terms-grouped-container');

    if (!tableContainer || !groupedContainer) return;

    const terms = definition.terms || definition.properties || [];
    const termLinkages = this._getTermSetLinkages(definition);

    if (groupBy === 'none') {
      tableContainer.style.display = '';
      groupedContainer.style.display = 'none';
    } else {
      tableContainer.style.display = 'none';
      groupedContainer.style.display = '';
      groupedContainer.innerHTML = this._renderGroupedTermsView(terms, termLinkages, definition.id, groupBy);

      // Re-attach link action handlers for grouped view
      groupedContainer.querySelectorAll('.term-link-action-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const termId = btn.dataset.termId;
          const definitionId = btn.dataset.definitionId;
          this._showLinkTermToSetModal(definitionId, termId);
        });
      });
    }
  }

  /**
   * Clear all terms filters
   */
  _clearTermsFilters(definition) {
    const contentArea = this.elements.contentArea;

    const searchInput = contentArea.querySelector('#terms-search-input');
    const typeFilter = contentArea.querySelector('#terms-type-filter');
    const linkFilter = contentArea.querySelector('#terms-link-filter');
    const groupFilter = contentArea.querySelector('#terms-group-filter');

    if (searchInput) searchInput.value = '';
    if (typeFilter) typeFilter.value = '';
    if (linkFilter) linkFilter.value = '';
    if (groupFilter) groupFilter.value = 'none';

    this._filterTermsTable(definition);
    this._updateTermsGrouping(definition, 'none');
  }

  /**
   * Sort terms table
   */
  _sortTermsTable(definition, sortKey) {
    const contentArea = this.elements.contentArea;
    const tbody = contentArea.querySelector('#terms-table-body');
    if (!tbody) return;

    const terms = definition.terms || definition.properties || [];
    const termLinkages = this._getTermSetLinkages(definition);

    // Get current sort state
    const currentSort = tbody.dataset.sortKey;
    const currentDir = tbody.dataset.sortDir || 'asc';
    let newDir = 'asc';

    if (currentSort === sortKey) {
      newDir = currentDir === 'asc' ? 'desc' : 'asc';
    }

    // Sort terms
    const sortedTerms = [...terms].sort((a, b) => {
      let aVal, bVal;
      if (sortKey === 'name') {
        aVal = (a.name || a.label || '').toLowerCase();
        bVal = (b.name || b.label || '').toLowerCase();
      } else if (sortKey === 'label') {
        aVal = (a.label || a.altLabel || a.prefLabel || '').toLowerCase();
        bVal = (b.label || b.altLabel || b.prefLabel || '').toLowerCase();
      }

      if (aVal < bVal) return newDir === 'asc' ? -1 : 1;
      if (aVal > bVal) return newDir === 'asc' ? 1 : -1;
      return 0;
    });

    // Update sort state
    tbody.dataset.sortKey = sortKey;
    tbody.dataset.sortDir = newDir;

    // Update sort button icons
    contentArea.querySelectorAll('.th-sort-btn').forEach(btn => {
      const icon = btn.querySelector('i');
      if (btn.dataset.sort === sortKey) {
        icon.className = `ph ${newDir === 'asc' ? 'ph-sort-ascending' : 'ph-sort-descending'}`;
      } else {
        icon.className = 'ph ph-arrows-down-up';
      }
    });

    // Re-render table body
    tbody.innerHTML = this._renderTermsTableRows(sortedTerms, termLinkages, definition.id);

    // Re-attach link handlers
    tbody.querySelectorAll('.term-link-action-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const termId = btn.dataset.termId;
        const definitionId = btn.dataset.definitionId;
        this._showLinkTermToSetModal(definitionId, termId);
      });
    });

    // Re-apply current filters
    this._filterTermsTable(definition);
  }

  /**
   * Show context menu for a definition
   */
  _showDefinitionContextMenu(e, definitionId) {
    const definition = this.definitions?.find(d => d.id === definitionId);

    // Handle stub definitions (virtual definitions not yet created)
    if (definitionId.startsWith('stub_')) {
      const termKey = definitionId.replace('stub_', '');
      const menuItems = [
        { label: 'Create Definition', icon: 'ph-plus', action: () => this._promptCreateDefinition(termKey) },
        { label: 'Mark as Local Only', icon: 'ph-house', action: () => this._createLocalDefinition(termKey) },
        { divider: true },
        { label: 'Search for Definition', icon: 'ph-magnifying-glass', action: () => this._searchForDefinition(termKey) }
      ];
      this._showContextMenu(e, menuItems);
      return;
    }

    if (!definition) return;

    const menuItems = [
      { label: 'View Details', icon: 'ph-eye', action: () => this._showDefinitionDetail(definitionId) },
      { label: 'Apply to Keys...', icon: 'ph-arrow-right', action: () => this._showApplyDefinitionModal(definitionId) },
      { divider: true },
      { label: 'Refresh from URI', icon: 'ph-arrows-clockwise', action: () => this._refreshDefinitionFromUri(definitionId), disabled: !definition.sourceUri },
      { label: 'Edit Definition', icon: 'ph-pencil', action: () => this._showEditDefinitionModal(definitionId) },
      { divider: true },
      { label: 'Delete', icon: 'ph-trash', action: () => this._deleteDefinition(definitionId), danger: true }
    ];

    this._showContextMenu(e, menuItems);
  }

  /**
   * Show context menu for a field's definition binding
   */
  _showFieldDefinitionContextMenu(e, setId, fieldId, definitionId) {
    const set = this.sets?.find(s => s.id === setId);
    const field = set?.fields?.find(f => f.id === fieldId);
    const definition = this.definitions?.find(d => d.id === definitionId);

    if (!set || !field) return;

    const isBound = field.semanticBinding?.definitionId === definitionId ||
                    field.definitionId === definitionId ||
                    field.boundDefinitionId === definitionId;

    const menuItems = [
      { label: `Go to ${set.name}`, icon: 'ph-arrow-right', action: () => this._selectSet(setId) },
      { label: 'View Field Schema', icon: 'ph-blueprint', action: () => this._openSchemaTab(setId, fieldId) },
      { divider: true }
    ];

    if (isBound) {
      menuItems.push({ label: 'Unbind Definition', icon: 'ph-link-break', action: () => this._unbindFieldDefinition(setId, fieldId) });
    } else {
      if (definitionId.startsWith('stub_')) {
        menuItems.push({ label: 'Create & Bind Definition', icon: 'ph-link', action: () => this._promptCreateDefinition(definitionId.replace('stub_', ''), setId, fieldId) });
      } else {
        menuItems.push({ label: 'Bind Definition', icon: 'ph-link', action: () => this._bindFieldDefinition(setId, fieldId, definitionId) });
      }
    }

    this._showContextMenu(e, menuItems);
  }

  /**
   * Prompt to create a new definition for a term key
   */
  _promptCreateDefinition(termKey, setId = null, fieldId = null) {
    // Use the Definition Builder if available
    if (window.EODefinitionBuilder?.showDefinitionBuilderModal) {
      window.EODefinitionBuilder.showDefinitionBuilderModal({
        frame: this.currentProjectId || 'default',
        user: this._getCurrentUser(),
        api: window.EO?.getDefinitionAPI ? window.EO.getDefinitionAPI() : null,
        initialTerm: termKey,
        bindToField: setId && fieldId ? { setId, fieldId } : null
      }).then((definition) => {
        if (definition) {
          this._addDefinition(definition);

          // Auto-bind if we have a field context
          if (setId && fieldId) {
            this._bindFieldDefinition(setId, fieldId, definition.id);
          }

          this._showToast('Definition created successfully', 'success');
          this._renderSidebar();
        }
      });
    } else {
      // Fallback to simple modal
      this._showSimpleDefinitionModal(termKey, setId, fieldId);
    }
  }

  /**
   * Simple definition creation modal (fallback)
   */
  _showSimpleDefinitionModal(termKey, setId = null, fieldId = null) {
    const displayName = termKey
      .replace(/[_-]/g, ' ')
      .replace(/([a-z])([A-Z])/g, '$1 $2')
      .split(' ')
      .map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
      .join(' ');

    // Create a simple modal for definition
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.innerHTML = `
      <div class="modal-content" style="max-width: 500px;">
        <div class="modal-header">
          <h3><i class="ph ph-book-open"></i> Create Definition</h3>
          <button class="modal-close"><i class="ph ph-x"></i></button>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label>Term</label>
            <input type="text" id="def-term" value="${this._escapeHtml(termKey)}" class="form-input" />
          </div>
          <div class="form-group">
            <label>Label</label>
            <input type="text" id="def-label" value="${this._escapeHtml(displayName)}" class="form-input" />
          </div>
          <div class="form-group">
            <label>Definition Text</label>
            <textarea id="def-text" class="form-input" rows="3" placeholder="Enter the definition..."></textarea>
          </div>
          <div class="form-group">
            <label>Authority (optional)</label>
            <input type="text" id="def-authority" class="form-input" placeholder="e.g., ISO, IRS, NIST" />
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary modal-cancel">Cancel</button>
          <button class="btn btn-primary modal-save">Create Definition</button>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    // Event handlers
    const closeModal = () => modal.remove();

    modal.querySelector('.modal-close').addEventListener('click', closeModal);
    modal.querySelector('.modal-cancel').addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => {
      if (e.target === modal) closeModal();
    });

    modal.querySelector('.modal-save').addEventListener('click', () => {
      const term = modal.querySelector('#def-term').value.trim();
      const label = modal.querySelector('#def-label').value.trim();
      const definitionText = modal.querySelector('#def-text').value.trim();
      const authority = modal.querySelector('#def-authority').value.trim();

      if (!term) {
        this._showToast('Term is required', 'error');
        return;
      }

      // Create the definition
      const definition = {
        id: `def_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        status: definitionText ? 'complete' : 'partial',
        populationMethod: 'manual',
        term: {
          term: term,
          label: label || term,
          definitionText: definitionText || null
        },
        authority: authority ? {
          name: authority,
          shortName: authority.split(' ')[0]
        } : null,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };

      this._addDefinition(definition);

      // Bind to field if context provided
      if (setId && fieldId) {
        this._bindFieldDefinition(setId, fieldId, definition.id);
      }

      // Add to project
      if (this.currentProjectId) {
        const project = this.projects?.find(p => p.id === this.currentProjectId);
        if (project) {
          if (!project.definitionIds) project.definitionIds = [];
          project.definitionIds.push(definition.id);
        }
      }

      this._showToast('Definition created', 'success');
      this._renderSidebar();
      closeModal();
    });
  }

  /**
   * Create a local-only definition (no external authority needed)
   */
  _createLocalDefinition(termKey) {
    const displayName = termKey
      .replace(/[_-]/g, ' ')
      .replace(/([a-z])([A-Z])/g, '$1 $2')
      .split(' ')
      .map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
      .join(' ');

    const definition = {
      id: `def_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      status: 'local_only',
      populationMethod: 'manual',
      term: {
        term: termKey,
        label: displayName,
        definitionText: `Local term: ${displayName}`
      },
      authority: null,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };

    this._addDefinition(definition);

    // Add to project
    if (this.currentProjectId) {
      const project = this.projects?.find(p => p.id === this.currentProjectId);
      if (project) {
        if (!project.definitionIds) project.definitionIds = [];
        project.definitionIds.push(definition.id);
      }
    }

    this._showToast(`"${displayName}" marked as local term`, 'success');
    this._renderSidebar();
  }

  /**
   * Search for a definition using the API
   */
  _searchForDefinition(termKey) {
    // Try to use the key suggestion panel if available
    if (window.EOKeySuggestionPanel) {
      window.EOKeySuggestionPanel.show?.(termKey);
    } else {
      // Fallback: open definitions tab with search
      this.openTab('definitions');
      // TODO: implement search focus
      this._showToast(`Search for: ${termKey}`, 'info');
    }
  }

  /**
   * Bind a definition to a field
   */
  _bindFieldDefinition(setId, fieldId, definitionId) {
    const set = this.sets?.find(s => s.id === setId);
    if (!set) return;

    const field = set.fields?.find(f => f.id === fieldId);
    if (!field) return;

    // Set the semantic binding
    if (!field.semanticBinding) {
      field.semanticBinding = {};
    }
    field.semanticBinding.definitionId = definitionId;

    // Also set legacy bindings for compatibility
    field.definitionId = definitionId;
    field.boundDefinitionId = definitionId;

    this._showToast('Definition bound to field', 'success');
    this._renderSidebar();
    this._emitChange?.('field_definition_bound', { setId, fieldId, definitionId });
  }

  /**
   * Unbind a definition from a field
   */
  _unbindFieldDefinition(setId, fieldId) {
    const set = this.sets?.find(s => s.id === setId);
    if (!set) return;

    const field = set.fields?.find(f => f.id === fieldId);
    if (!field) return;

    // Clear all bindings
    if (field.semanticBinding) {
      delete field.semanticBinding.definitionId;
    }
    delete field.definitionId;
    delete field.boundDefinitionId;

    this._showToast('Definition unbound from field', 'success');
    this._renderSidebar();
    this._emitChange?.('field_definition_unbound', { setId, fieldId });
  }

  /**
   * Show the Definition Builder modal for creating new definitions
   * Uses the 9-parameter EO definition schema
   */
  _showNewDefinitionModal() {
    // Use the Definition Builder if available
    if (window.EODefinitionBuilder?.showDefinitionBuilderModal) {
      window.EODefinitionBuilder.showDefinitionBuilderModal({
        frame: this.currentProjectId || 'default',
        user: this._getCurrentUser(),
        api: window.EO?.getDefinitionAPI ? window.EO.getDefinitionAPI() : null
      }).then((definition) => {
        if (definition) {
          this._addDefinition(definition);
          this._showToast('Definition created successfully', 'success');
          this._renderDefinitionsNav();
        }
      });
    } else {
      // Fallback to import modal if builder not available
      this._showImportDefinitionModal();
    }
  }

  /**
   * Get current user for provenance
   * @private
   */
  _getCurrentUser() {
    return window.EO?.agent?.userId || 'anonymous';
  }

  /**
   * Add a definition to the definitions list
   * @param {Object} definition - The definition object from the builder
   * @private
   */
  _addDefinition(definition) {
    if (!this.definitions) {
      this.definitions = [];
    }

    // Create a definition record with ID
    const defRecord = {
      id: definition.id || `def_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      name: definition.referent?.label || definition.referent?.term || 'Untitled Definition',
      term: definition.referent?.term,
      description: definition.scopeNote,
      format: 'eo-9param',
      type: 'definition',
      status: 'active',
      importedAt: new Date().toISOString(),
      ...definition
    };

    this.definitions.push(defRecord);

    // Record activity for definition creation
    this._recordActivity({
      action: 'create',
      entityType: 'definition',
      name: defRecord.name,
      details: `Created definition "${defRecord.name}"${defRecord.term ? ` (term: ${defRecord.term})` : ''}`,
      canReverse: false
    });

    // Emit event for persistence
    if (this.eventBus) {
      this.eventBus.emit('definition:created', { definition: defRecord });
    }

    return defRecord;
  }

  /**
   * Show modal to import definition from URI or search APIs
   */
  _showImportDefinitionModal() {
    const html = `
      <div class="import-definition-form">
        <div class="import-tabs">
          <button class="import-tab active" data-tab="search">Search APIs</button>
          <button class="import-tab" data-tab="uri">From URI</button>
          <button class="import-tab" data-tab="json">Paste JSON</button>
          <button class="import-tab" data-tab="manual">Create Manually</button>
        </div>

        <!-- Search APIs Tab -->
        <div class="import-tab-content" id="tab-search">
          <div class="api-source-selector">
            <div class="api-source-group">
              <label class="api-source-label">Concept Sources</label>
              <div class="api-source-pills" id="concept-source-pills">
                <button class="api-pill active" data-source="wikidata" data-type="concept">
                  <span class="api-status live"></span>Wikidata
                </button>
                <button class="api-pill" data-source="dbpedia" data-type="concept">
                  <span class="api-status live"></span>DBpedia
                </button>
                <button class="api-pill" data-source="lov" data-type="concept">
                  <span class="api-status live"></span>LOV
                </button>
                <button class="api-pill" data-source="schemaOrg" data-type="concept">
                  <span class="api-status static"></span>Schema.org
                </button>
              </div>
            </div>
            <div class="api-source-group">
              <label class="api-source-label">Regulatory Sources</label>
              <div class="api-source-pills" id="regulatory-source-pills">
                <button class="api-pill" data-source="ecfr" data-type="regulatory">
                  <span class="api-status live"></span>eCFR
                </button>
                <button class="api-pill" data-source="federalRegister" data-type="regulatory">
                  <span class="api-status live"></span>Fed Register
                </button>
                <button class="api-pill" data-source="usCode" data-type="regulatory">
                  <span class="api-status link"></span>US Code
                </button>
              </div>
            </div>
          </div>

          <div class="form-group">
            <label for="definition-search-query" class="form-label">Search</label>
            <div class="search-input-row">
              <input type="text" id="definition-search-query" class="form-input"
                     placeholder="Search for concepts, terms, regulations...">
              <button class="btn btn-primary" id="btn-search-definitions">
                <i class="ph ph-magnifying-glass"></i> Search
              </button>
            </div>
          </div>

          <div id="definition-search-results" class="definition-search-results">
            <div class="search-empty-state">
              <i class="ph ph-magnifying-glass"></i>
              <p>Select a source and search for definitions</p>
            </div>
          </div>

          <div id="definition-selected-item" class="definition-selected-item" style="display: none;">
            <!-- Selected item will be rendered here -->
          </div>

          <div class="form-group" id="definition-term-group" style="display: none;">
            <label for="definition-term-name" class="form-label">Term Name (for your column)</label>
            <input type="text" id="definition-term-name" class="form-input"
                   placeholder="e.g., housing_status">
            <span class="form-hint">This will be the key used in your data columns</span>
          </div>

          <div class="form-group" id="definition-scope-group" style="display: none;">
            <label for="definition-scope-note" class="form-label">Your Scope Note (optional)</label>
            <textarea id="definition-scope-note" class="form-input" rows="2"
                      placeholder="How are YOU using this definition? What's included/excluded?"></textarea>
          </div>
        </div>

        <div class="import-tab-content" id="tab-uri" style="display: none;">
          <div class="form-group">
            <label for="definition-uri" class="form-label">Definition URI</label>
            <input type="url" id="definition-uri" class="form-input"
                   placeholder="https://schema.org/Person.jsonld">
            <span class="form-hint">Supports JSON-LD, RDF, CSV Schema (CSVW)</span>
          </div>
          <div class="form-group">
            <label for="definition-name-uri" class="form-label">Name (optional)</label>
            <input type="text" id="definition-name-uri" class="form-input"
                   placeholder="Will be inferred from URI if not provided">
          </div>
        </div>

        <div class="import-tab-content" id="tab-json" style="display: none;">
          <div class="form-group">
            <label for="definition-json" class="form-label">DefinitionSource JSON</label>
            <textarea id="definition-json" class="form-input" rows="10"
                      placeholder='Paste DefinitionSource JSON here...

{
  "term": { "term": "homeless", "label": "Homelessness Status" },
  "authority": { "name": "HUD", "type": "federal_agency" },
  "source": { "citation": "24 CFR 578.3" },
  "validity": { "from": "2015-12-04" }
}'></textarea>
            <span class="form-hint">Supports single definition or array of definitions.</span>
          </div>
        </div>

        <div class="import-tab-content" id="tab-manual" style="display: none;">
          <div class="form-group">
            <label for="definition-name" class="form-label">Definition Name</label>
            <input type="text" id="definition-name" class="form-input"
                   placeholder="Case Status">
          </div>
          <div class="form-group">
            <label for="definition-description" class="form-label">Purpose / Description</label>
            <textarea id="definition-description" class="form-input" rows="2"
                      placeholder="Describes what this vocabulary defines..."></textarea>
          </div>
          <div class="form-group">
            <label for="definition-custom-uri" class="form-label">
              URI <span class="optional-label">(optional)</span>
            </label>
            <input type="url" id="definition-custom-uri" class="form-input"
                   placeholder="https://yoursite.com/vocab/case_status">
            <div class="uri-nudge-hint">
              <i class="ph ph-lightbulb"></i>
              <span>Definitions with URIs travel better — exports, APIs, and collaborators can understand them without asking you.</span>
            </div>
          </div>
        </div>
      </div>
    `;

    // Store selected search result
    this._selectedDefinitionResult = null;
    this._selectedApiSource = 'wikidata';
    this._selectedApiType = 'concept';

    this._showModal('Import Definition', html, () => {
      const activeTab = document.querySelector('.import-tab.active')?.dataset.tab;

      if (activeTab === 'search') {
        if (this._selectedDefinitionResult) {
          const termName = document.getElementById('definition-term-name')?.value?.trim();
          const scopeNote = document.getElementById('definition-scope-note')?.value?.trim();
          this._importFromSearchResult(this._selectedDefinitionResult, termName, scopeNote);
        } else {
          this._showNotification('Please search and select a definition', 'error');
        }
      } else if (activeTab === 'uri') {
        const uri = document.getElementById('definition-uri')?.value?.trim();
        const name = document.getElementById('definition-name-uri')?.value?.trim();
        if (uri) {
          this._importDefinitionFromUri(uri, name);
        } else {
          this._showNotification('Please enter a URI', 'error');
        }
      } else if (activeTab === 'json') {
        const json = document.getElementById('definition-json')?.value?.trim();
        if (json) {
          this._importDefinitionSourceFromJson(json);
        } else {
          this._showNotification('Please paste JSON', 'error');
        }
      } else {
        const name = document.getElementById('definition-name')?.value?.trim();
        const description = document.getElementById('definition-description')?.value?.trim();
        const customUri = document.getElementById('definition-custom-uri')?.value?.trim();
        if (name) {
          this._createManualDefinition(name, description, customUri);
        } else {
          this._showNotification('Please enter a name', 'error');
        }
      }
    });

    // Initialize event listeners after modal renders
    setTimeout(() => {
      this._initDefinitionModalListeners();
    }, 0);
  }

  /**
   * Initialize definition modal event listeners
   */
  _initDefinitionModalListeners() {
    // Tab switching
    document.querySelectorAll('.import-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.import-tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        document.querySelectorAll('.import-tab-content').forEach(content => {
          content.style.display = content.id === `tab-${tab.dataset.tab}` ? 'block' : 'none';
        });
      });
    });

    // API source pills
    document.querySelectorAll('.api-pill').forEach(pill => {
      pill.addEventListener('click', () => {
        // Only allow one source at a time
        document.querySelectorAll('.api-pill').forEach(p => p.classList.remove('active'));
        pill.classList.add('active');
        this._selectedApiSource = pill.dataset.source;
        this._selectedApiType = pill.dataset.type;
      });
    });

    // Search button
    document.getElementById('btn-search-definitions')?.addEventListener('click', () => {
      this._searchDefinitions();
    });

    // Enter key to search
    document.getElementById('definition-search-query')?.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        this._searchDefinitions();
      }
    });
  }

  /**
   * Search definitions using the selected API
   */
  async _searchDefinitions() {
    const query = document.getElementById('definition-search-query')?.value?.trim();
    if (!query) {
      this._showNotification('Please enter a search term', 'error');
      return;
    }

    const resultsDiv = document.getElementById('definition-search-results');
    if (!resultsDiv) return;

    resultsDiv.innerHTML = '<div class="search-loading"><i class="ph ph-spinner ph-spin"></i> Searching...</div>';

    try {
      const api = window.EO?.getDefinitionAPI?.();
      if (!api) {
        throw new Error('Definition API not loaded');
      }

      let results = [];
      if (this._selectedApiType === 'concept') {
        results = await api.searchConcepts(query, { sources: [this._selectedApiSource] });
      } else {
        results = await api.searchRegulatory(query, { sources: [this._selectedApiSource] });
      }

      if (results.length === 0) {
        resultsDiv.innerHTML = '<div class="search-empty-state"><p>No results found. Try a different search term.</p></div>';
        return;
      }

      // Render results
      resultsDiv.innerHTML = results.map((r, i) => this._renderSearchResult(r, i)).join('');

      // Add click listeners
      resultsDiv.querySelectorAll('.search-result-item').forEach((item, i) => {
        item.addEventListener('click', () => {
          this._selectDefinitionResult(results[i]);
        });
      });

    } catch (error) {
      console.error('Definition search failed:', error);
      resultsDiv.innerHTML = `<div class="search-error"><i class="ph ph-warning"></i> Error: ${error.message}</div>`;
    }
  }

  /**
   * Render a search result item
   */
  _renderSearchResult(result, index) {
    const isRegulatory = result.citation !== undefined;

    if (isRegulatory) {
      return `
        <div class="search-result-item" data-index="${index}">
          <div class="search-result-header">
            <span class="search-result-label">${this._escapeHtml(result.title?.substring(0, 60) || 'Untitled')}${result.title?.length > 60 ? '...' : ''}</span>
            <span class="search-result-source">${result.source}</span>
          </div>
          <div class="search-result-citation">${this._escapeHtml(result.citation || '')}</div>
          <div class="search-result-desc">${this._escapeHtml(result.snippet?.substring(0, 150) || '')}${result.snippet?.length > 150 ? '...' : ''}</div>
          <div class="search-result-uri">${this._escapeHtml(result.url || '')}</div>
        </div>
      `;
    }

    return `
      <div class="search-result-item" data-index="${index}">
        <div class="search-result-header">
          <span class="search-result-label">${this._escapeHtml(result.label || result.id || 'Unknown')}</span>
          <span class="search-result-source">${result.source}</span>
        </div>
        <div class="search-result-desc">${this._escapeHtml(result.description || '')}</div>
        <div class="search-result-uri">${this._escapeHtml(result.uri || '')}</div>
      </div>
    `;
  }

  /**
   * Select a definition result
   */
  async _selectDefinitionResult(result) {
    this._selectedDefinitionResult = result;

    const selectedDiv = document.getElementById('definition-selected-item');
    const termGroup = document.getElementById('definition-term-group');
    const scopeGroup = document.getElementById('definition-scope-group');

    if (!selectedDiv) return;

    // Fetch additional details for Wikidata
    let details = null;
    if (result.source === 'Wikidata' && result.id) {
      try {
        const api = window.EO?.getDefinitionAPI?.();
        details = await api?.getWikidataDetails(result.id);
        if (details) {
          this._selectedDefinitionResult.details = details;
        }
      } catch (e) {
        console.warn('Failed to fetch Wikidata details:', e);
      }
    }

    const isRegulatory = result.citation !== undefined;

    selectedDiv.style.display = 'block';
    selectedDiv.innerHTML = `
      <div class="selected-definition">
        <div class="selected-header">
          <span class="selected-label">${this._escapeHtml(isRegulatory ? result.title?.substring(0, 50) : result.label)}</span>
          <button class="btn-clear-selection" id="btn-clear-definition">
            <i class="ph ph-x"></i>
          </button>
        </div>
        <div class="selected-meta">
          <span class="meta-tag source">${result.source}</span>
          ${isRegulatory && result.citation ? `<span class="meta-tag">${this._escapeHtml(result.citation)}</span>` : ''}
          ${details?.instanceOf?.length ? `<span class="meta-tag">P31: ${details.instanceOf.map(x => x.id).join(', ')}</span>` : ''}
        </div>
        <div class="selected-uri">${this._escapeHtml(result.uri || result.url || '')}</div>
        ${result.description || result.snippet ? `<div class="selected-desc">${this._escapeHtml((result.description || result.snippet)?.substring(0, 200))}...</div>` : ''}
      </div>
    `;

    // Pre-fill term name
    const termNameInput = document.getElementById('definition-term-name');
    if (termNameInput && !termNameInput.value) {
      const suggestedTerm = isRegulatory
        ? result.citation?.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase() || 'term'
        : (result.id || result.label || '').toLowerCase().replace(/[^a-z0-9]/g, '_');
      termNameInput.value = suggestedTerm;
    }

    // Show term and scope groups
    if (termGroup) termGroup.style.display = 'block';
    if (scopeGroup) scopeGroup.style.display = 'block';

    // Clear button
    document.getElementById('btn-clear-definition')?.addEventListener('click', () => {
      this._clearDefinitionSelection();
    });

    // Highlight in results
    document.querySelectorAll('.search-result-item').forEach(item => {
      item.classList.remove('selected');
    });
    document.querySelector(`.search-result-item[data-index="${document.querySelectorAll('.search-result-item').length > 0 ? Array.from(document.querySelectorAll('.search-result-item')).findIndex(el => el.querySelector('.search-result-uri')?.textContent === (result.uri || result.url)) : 0}"]`)?.classList.add('selected');
  }

  /**
   * Clear definition selection
   */
  _clearDefinitionSelection() {
    this._selectedDefinitionResult = null;

    const selectedDiv = document.getElementById('definition-selected-item');
    const termGroup = document.getElementById('definition-term-group');
    const scopeGroup = document.getElementById('definition-scope-group');

    if (selectedDiv) selectedDiv.style.display = 'none';
    if (termGroup) termGroup.style.display = 'none';
    if (scopeGroup) scopeGroup.style.display = 'none';

    document.querySelectorAll('.search-result-item').forEach(item => {
      item.classList.remove('selected');
    });
  }

  /**
   * Import from a search result
   */
  _importFromSearchResult(result, termName, scopeNote) {
    const isRegulatory = result.citation !== undefined;

    if (isRegulatory) {
      // Build DefinitionSource for regulatory result
      const defSource = {
        term: {
          term: termName || result.citation?.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase() || 'term',
          label: result.title,
          definitionText: result.snippet
        },
        authority: {
          name: result.meta?.agencies?.[0]?.name || result.source,
          shortName: result.meta?.agencies?.[0]?.slug?.toUpperCase(),
          type: 'federal_agency'
        },
        source: {
          title: result.title,
          citation: result.citation,
          url: result.url,
          type: 'regulation'
        },
        validity: {
          from: result.meta?.effectiveDate || result.meta?.publicationDate || new Date().toISOString().split('T')[0]
        },
        scopeNote: scopeNote || undefined
      };

      this._importDefinitionSourceFromJson(JSON.stringify(defSource));
    } else {
      // Build definition for concept result
      const definition = {
        id: `def_${Date.now()}`,
        name: `${result.label} (${result.source})`,
        description: result.description || '',
        sourceUri: result.uri,
        format: 'concept',
        importedAt: new Date().toISOString(),
        status: 'active',
        terms: [{
          id: `term_${Date.now()}`,
          name: termName || result.id || result.label,
          label: result.label,
          type: 'concept',
          description: result.description,
          uri: result.uri
        }],
        mapping: {
          uri: result.uri,
          label: result.label,
          source: result.source,
          details: result.details || null
        },
        scopeNote: scopeNote || null
      };

      this.definitions.push(definition);
      this._saveData();
      this._renderDefinitionsNav();
      this._showDefinitionDetail(definition.id);
      this._showNotification(`Imported "${result.label}" from ${result.source}`, 'success');
    }
  }

  /**
   * Import DefinitionSource from pasted JSON
   * Supports both single definition and array of definitions
   */
  _importDefinitionSourceFromJson(jsonString) {
    try {
      let data = JSON.parse(jsonString);

      // Normalize to array
      if (!Array.isArray(data)) {
        data = [data];
      }

      let importedCount = 0;
      const errors = [];

      data.forEach((defSource, index) => {
        // Validate DefinitionSource schema
        const validationErrors = this._validateDefinitionSource(defSource);
        if (validationErrors.length > 0) {
          errors.push(`Item ${index + 1}: ${validationErrors.join(', ')}`);
          return;
        }

        // Convert DefinitionSource to internal definition format
        const definition = this._convertDefinitionSourceToDefinition(defSource);
        this.definitions.push(definition);

        // Add definition to current project if applicable
        if (this.currentProjectId) {
          const project = this.projects.find(p => p.id === this.currentProjectId);
          if (project) {
            if (!project.definitionIds) project.definitionIds = [];
            if (!project.definitionIds.includes(definition.id)) {
              project.definitionIds.push(definition.id);
            }
          }
        }

        importedCount++;
      });

      this._saveData();
      this._renderDefinitionsNav();

      if (importedCount > 0) {
        // Show the first imported definition
        const lastDef = this.definitions[this.definitions.length - 1];
        this._showDefinitionDetail(lastDef.id);
        this._showNotification(`Imported ${importedCount} definition(s)`, 'success');
      }

      if (errors.length > 0) {
        console.warn('Definition import errors:', errors);
        this._showNotification(`${errors.length} error(s): ${errors[0]}`, 'warning');
      }

    } catch (error) {
      console.error('Failed to import definition JSON:', error);
      this._showNotification(`Invalid JSON: ${error.message}`, 'error');
    }
  }

  /**
   * Validate DefinitionSource object
   * @returns {string[]} Array of validation error messages
   */
  _validateDefinitionSource(defSource) {
    const errors = [];

    // Term validation
    if (!defSource.term) {
      errors.push('missing term object');
    } else if (!defSource.term.term) {
      errors.push('missing term.term');
    }

    // Authority validation
    if (!defSource.authority) {
      errors.push('missing authority object');
    } else {
      if (!defSource.authority.name && !defSource.authority.shortName) {
        errors.push('missing authority name');
      }
      if (!defSource.authority.type) {
        errors.push('missing authority.type');
      }
    }

    // Source validation
    if (!defSource.source) {
      errors.push('missing source object');
    } else if (!defSource.source.citation && !defSource.source.title) {
      errors.push('missing source citation or title');
    }

    // Validity validation
    if (!defSource.validity) {
      errors.push('missing validity object');
    } else if (!defSource.validity.from) {
      errors.push('missing validity.from');
    }

    return errors;
  }

  /**
   * Convert DefinitionSource to internal definition format
   */
  _convertDefinitionSourceToDefinition(defSource) {
    const id = defSource.id || `def_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    // Build name from term and authority
    const authorityName = defSource.authority?.shortName || defSource.authority?.name || 'Unknown';
    const termName = defSource.term?.label || defSource.term?.term;
    const name = `${termName} (${authorityName})`;

    // Build description from definition text and citation
    const description = defSource.term?.definitionText || '';
    const citation = defSource.source?.citation || defSource.source?.title || '';

    // Create single term from the DefinitionSource
    const term = {
      id: `term_${Date.now()}`,
      name: defSource.term.term,
      label: defSource.term.label,
      type: 'definition',
      description: defSource.term.definitionText,
      uri: defSource.authority?.uri,
      asWritten: defSource.term.asWritten,
      categories: defSource.term.categories
    };

    return {
      id,
      name,
      description,
      sourceUri: defSource.source?.url || null,
      format: 'definition_source',
      importedAt: new Date().toISOString(),
      status: 'active',
      terms: [term],

      // Store the full DefinitionSource for rich display
      definitionSource: {
        term: defSource.term,
        authority: defSource.authority,
        source: defSource.source,
        version: defSource.version || null,
        validity: defSource.validity,
        jurisdiction: defSource.jurisdiction || null
      }
    };
  }

  /**
   * Import definition from a URI
   */
  async _importDefinitionFromUri(uri, providedName = null) {
    try {
      this._showNotification('Fetching definition...', 'info');

      const response = await fetch(uri);
      if (!response.ok) {
        throw new Error(`Failed to fetch: ${response.status} ${response.statusText}`);
      }

      const contentType = response.headers.get('content-type') || '';
      const text = await response.text();
      let data;
      let format = 'unknown';

      // Try to parse based on content type or content
      if (contentType.includes('json') || text.trim().startsWith('{') || text.trim().startsWith('[')) {
        data = JSON.parse(text);
        format = data['@context'] ? 'jsonld' : 'json';
      } else if (contentType.includes('xml') || text.trim().startsWith('<')) {
        format = 'rdf';
        // Basic RDF/XML parsing would go here
        data = { raw: text };
      } else {
        format = 'text';
        data = { raw: text };
      }

      // Extract terms from JSON-LD or JSON
      const terms = this._extractTermsFromData(data, format);

      // Create definition object
      const definition = {
        id: `def_${Date.now()}`,
        name: providedName || this._extractNameFromUri(uri) || 'Imported Definition',
        description: data.description || data['schema:description'] || '',
        sourceUri: uri,
        format: format,
        importedAt: new Date().toISOString(),
        status: 'active',
        terms: terms,
        rawData: data
      };

      this.definitions.push(definition);
      this._saveData();
      this._renderDefinitionsNav();
      this._showDefinitionDetail(definition.id);
      this._showNotification(`Imported ${terms.length} terms from ${this._truncateName(uri, 30)}`, 'success');

    } catch (error) {
      console.error('Failed to import definition:', error);
      this._showNotification(`Import failed: ${error.message}`, 'error');
    }
  }

  /**
   * Extract terms from parsed data (JSON-LD, JSON, etc.)
   */
  _extractTermsFromData(data, format) {
    const terms = [];

    if (format === 'jsonld') {
      // Handle JSON-LD @context
      const context = data['@context'];
      if (context && typeof context === 'object') {
        for (const [key, value] of Object.entries(context)) {
          if (key.startsWith('@')) continue; // Skip @vocab, @base, etc.

          const term = {
            id: `term_${Date.now()}_${terms.length}`,
            name: key,
            type: 'string'
          };

          if (typeof value === 'string') {
            term.uri = value;
          } else if (typeof value === 'object') {
            term.uri = value['@id'];
            term.type = value['@type'] || 'string';
          }

          terms.push(term);
        }
      }

      // Handle @graph with property definitions
      const graph = data['@graph'];
      if (Array.isArray(graph)) {
        for (const node of graph) {
          if (node['@type'] === 'rdf:Property' || node['@type'] === 'rdfs:Property') {
            terms.push({
              id: `term_${Date.now()}_${terms.length}`,
              name: node['rdfs:label'] || node['@id']?.split(/[#/]/).pop(),
              description: node['rdfs:comment'],
              uri: node['@id'],
              type: node['rdfs:range']?.['@id'] || 'string'
            });
          }
        }
      }
    } else if (format === 'json') {
      // Handle plain JSON schema-like structures
      if (data.properties) {
        for (const [key, value] of Object.entries(data.properties)) {
          terms.push({
            id: `term_${Date.now()}_${terms.length}`,
            name: key,
            type: value.type || 'string',
            description: value.description
          });
        }
      }
      // Handle array of property definitions
      if (Array.isArray(data)) {
        for (const item of data) {
          if (item.name || item.property || item.label) {
            terms.push({
              id: `term_${Date.now()}_${terms.length}`,
              name: item.name || item.property || item.label,
              type: item.type || item.datatype || 'string',
              description: item.description || item.comment,
              uri: item.uri || item['@id']
            });
          }
        }
      }
    }

    return terms;
  }

  /**
   * Extract a name from a URI
   */
  _extractNameFromUri(uri) {
    try {
      const url = new URL(uri);
      // Try to get meaningful name from path or hostname
      const pathParts = url.pathname.split('/').filter(p => p);
      if (pathParts.length > 0) {
        const lastPart = pathParts[pathParts.length - 1];
        // Remove file extension
        return lastPart.replace(/\.[^.]+$/, '');
      }
      return url.hostname;
    } catch {
      return uri.split('/').pop() || 'Definition';
    }
  }

  /**
   * Create a manual definition (no URI import)
   */
  _createManualDefinition(name, description = '', customUri = '') {
    const definition = {
      id: `def_${Date.now()}`,
      name: name,
      description: description,
      sourceUri: customUri || null,
      format: 'manual',
      importedAt: new Date().toISOString(),
      status: 'active',
      terms: []
    };

    this.definitions.push(definition);
    this._saveData();
    this._renderDefinitionsNav();
    this._showDefinitionDetail(definition.id);

    // Show appropriate notification based on whether URI was provided
    if (customUri) {
      this._showNotification(`Created definition: ${name} (linked to URI)`, 'success');
    } else {
      this._showNotification(`Created local definition: ${name}`, 'success');
    }
  }

  /**
   * Refresh definition from its source URI
   */
  async _refreshDefinitionFromUri(definitionId) {
    const definition = this.definitions?.find(d => d.id === definitionId);
    if (!definition || !definition.sourceUri) {
      this._showNotification('No source URI to refresh from', 'error');
      return;
    }

    try {
      this._showNotification('Refreshing from URI...', 'info');

      const response = await fetch(definition.sourceUri);
      if (!response.ok) {
        throw new Error(`Failed to fetch: ${response.status}`);
      }

      const text = await response.text();
      const data = JSON.parse(text);
      const format = data['@context'] ? 'jsonld' : 'json';
      const terms = this._extractTermsFromData(data, format);

      // Update definition
      definition.terms = terms;
      definition.rawData = data;
      definition.format = format;
      definition.refreshedAt = new Date().toISOString();

      this._saveData();
      this._renderDefinitionsNav();
      this._showDefinitionDetail(definitionId);
      this._showNotification(`Refreshed: ${terms.length} terms loaded`, 'success');

    } catch (error) {
      console.error('Failed to refresh definition:', error);
      this._showNotification(`Refresh failed: ${error.message}`, 'error');
    }
  }

  /**
   * Delete a definition
   */
  _deleteDefinition(definitionId) {
    const definition = this.definitions?.find(d => d.id === definitionId);
    if (!definition) return;

    const definitionName = definition.name || 'Unnamed definition';

    // Remove from array
    this.definitions = this.definitions.filter(d => d.id !== definitionId);

    // Clear current selection if this was selected
    if (this.currentDefinitionId === definitionId) {
      this.currentDefinitionId = null;
    }

    // Record activity for definition deletion
    this._recordActivity({
      action: 'delete',
      entityType: 'definition',
      name: definitionName,
      details: `Deleted definition "${definitionName}"`,
      canReverse: false
    });

    this._saveData();
    this._renderDefinitionsNav();

    // Show empty state in content area if nothing else selected
    if (!this.currentSetId && !this.currentSourceId) {
      this._renderWelcomeView();
    }

    this._showNotification('Definition deleted', 'success');
  }

  /**
   * Approve a pending definition (change status from stub to complete)
   */
  _approveDefinition(definitionId) {
    const definition = this.definitions?.find(d => d.id === definitionId);
    if (!definition) return;

    const definitionName = definition.name || 'Unnamed definition';

    // Update status to complete/verified
    definition.status = 'complete';
    definition.populationMethod = 'manual';
    definition.approvedAt = new Date().toISOString();

    // Record activity for definition approval
    this._recordActivity({
      action: 'update',
      entityType: 'definition',
      name: definitionName,
      details: `Approved definition "${definitionName}" (status: stub → complete)`,
      canReverse: false
    });

    this._saveData();
    this._renderDefinitionsNav();

    // Re-render the definitions panel to update the row
    if (this.isViewingDefinitions) {
      this._showDefinitionsPanel();
    }

    this._showNotification('Definition approved', 'success');
  }

  /**
   * Dismiss a pending definition (remove it from the list)
   */
  _dismissDefinition(definitionId) {
    const definition = this.definitions?.find(d => d.id === definitionId);
    if (!definition) return;

    // Confirm before dismissing
    const confirmHtml = `
      <div class="dismiss-definition-confirm">
        <p>Are you sure you want to dismiss this pending definition?</p>
        <p class="definition-name"><strong>${this._escapeHtml(definition.name)}</strong></p>
        <p class="muted">This will remove the definition from your workspace.</p>
      </div>
    `;

    this._showModal({
      title: 'Dismiss Definition',
      content: confirmHtml,
      buttons: [
        {
          label: 'Cancel',
          className: 'btn btn-secondary',
          action: () => this._closeModal()
        },
        {
          label: 'Dismiss',
          className: 'btn btn-danger',
          action: () => {
            const definitionName = definition.name || 'Unnamed definition';

            // Remove from array
            this.definitions = this.definitions.filter(d => d.id !== definitionId);

            // Clear current selection if this was selected
            if (this.currentDefinitionId === definitionId) {
              this.currentDefinitionId = null;
            }

            // Record activity for definition dismissal
            this._recordActivity({
              action: 'delete',
              entityType: 'definition',
              name: definitionName,
              details: `Dismissed pending definition "${definitionName}"`,
              canReverse: false
            });

            this._saveData();
            this._renderDefinitionsNav();
            this._closeModal();

            // Re-render the definitions panel
            if (this.isViewingDefinitions) {
              this._showDefinitionsPanel();
            }

            this._showNotification('Definition dismissed', 'success');
          }
        }
      ]
    });
  }

  /**
   * Show modal to add a term to a definition
   */
  _showAddTermModal(definitionId) {
    const html = `
      <div class="add-term-form">
        <div class="form-group">
          <label for="term-name" class="form-label">Term Name</label>
          <input type="text" id="term-name" class="form-input" placeholder="propertyName">
        </div>
        <div class="form-group">
          <label for="term-type" class="form-label">Data Type</label>
          <select id="term-type" class="form-input">
            <option value="string">String (text)</option>
            <option value="number">Number</option>
            <option value="integer">Integer</option>
            <option value="boolean">Boolean</option>
            <option value="date">Date</option>
            <option value="dateTime">DateTime</option>
            <option value="url">URL</option>
            <option value="email">Email</option>
          </select>
        </div>
        <div class="form-group">
          <label for="term-description" class="form-label">Description (optional)</label>
          <textarea id="term-description" class="form-input" rows="2" placeholder="What this term represents"></textarea>
        </div>
        <div class="form-group">
          <label for="term-uri" class="form-label">URI / IRI (optional)</label>
          <input type="url" id="term-uri" class="form-input" placeholder="https://schema.org/name">
        </div>
      </div>
    `;

    this._showModal('Add Term', html, () => {
      const name = document.getElementById('term-name')?.value?.trim();
      const type = document.getElementById('term-type')?.value;
      const description = document.getElementById('term-description')?.value?.trim();
      const uri = document.getElementById('term-uri')?.value?.trim();

      if (!name) {
        this._showNotification('Please enter a term name', 'error');
        return;
      }

      this._addTermToDefinition(definitionId, { name, type, description, uri });
    });
  }

  /**
   * Add a term to a definition
   */
  _addTermToDefinition(definitionId, termData) {
    const definition = this.definitions?.find(d => d.id === definitionId);
    if (!definition) return;

    if (!definition.terms) {
      definition.terms = [];
    }

    const term = {
      id: `term_${Date.now()}`,
      name: termData.name,
      type: termData.type || 'string',
      description: termData.description || '',
      uri: termData.uri || null
    };

    definition.terms.push(term);
    this._saveData();
    this._showDefinitionDetail(definitionId);
    this._showNotification(`Added term: ${term.name}`, 'success');
  }

  /**
   * Show modal to apply definition to a set
   */
  _showApplyDefinitionModal(definitionId) {
    const definition = this.definitions?.find(d => d.id === definitionId);
    if (!definition) return;

    if (this.sets.length === 0) {
      this._showNotification('No sets available. Create a set first.', 'error');
      return;
    }

    const html = `
      <div class="apply-definition-form">
        <p>Apply terms from <strong>${this._escapeHtml(definition.name)}</strong> as fields to:</p>
        <div class="form-group">
          <label for="target-set" class="form-label">Target Set</label>
          <select id="target-set" class="form-input">
            ${this.sets.map(set => `
              <option value="${set.id}">${this._escapeHtml(set.name)}</option>
            `).join('')}
          </select>
        </div>
        <div class="form-group">
          <label class="checkbox-label">
            <input type="checkbox" id="merge-fields" checked>
            Merge with existing fields (uncheck to replace)
          </label>
        </div>
      </div>
    `;

    this._showModal('Apply Definition to Set', html, () => {
      const setId = document.getElementById('target-set')?.value;
      const merge = document.getElementById('merge-fields')?.checked;

      if (setId) {
        this._applyDefinitionToSet(definitionId, setId, merge);
      }
    });
  }

  /**
   * Apply definition terms as fields to a set
   */
  _applyDefinitionToSet(definitionId, setId, merge = true) {
    const definition = this.definitions?.find(d => d.id === definitionId);
    const set = this.sets?.find(s => s.id === setId);

    if (!definition || !set) return;

    const terms = definition.terms || [];
    if (terms.length === 0) {
      this._showNotification('Definition has no terms to apply', 'error');
      return;
    }

    // Convert terms to fields
    const newFields = terms.map(term => ensureValidField({
      id: `fld_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
      name: term.name,
      type: this._mapTermTypeToFieldType(term.type),
      definitionRef: {
        definitionId: definition.id,
        termId: term.id,
        uri: term.uri
      }
    }));

    if (merge) {
      // Merge: add new fields that don't already exist (by name)
      const existingNames = new Set(set.fields.map(f => f.name.toLowerCase()));
      const fieldsToAdd = newFields.filter(f => !existingNames.has(f.name.toLowerCase()));
      set.fields.push(...fieldsToAdd);
      this._showNotification(`Added ${fieldsToAdd.length} new fields to ${set.name}`, 'success');
    } else {
      // Replace: remove all fields and add new ones
      set.fields = newFields;
      this._showNotification(`Replaced fields in ${set.name} with ${newFields.length} fields`, 'success');
    }

    this._saveData();
    this._renderSidebar();

    // If viewing this set, refresh the view
    if (this.currentSetId === setId) {
      this._renderView();
    }
  }

  /**
   * Map definition term type to field type
   */
  _mapTermTypeToFieldType(termType) {
    const mapping = {
      'string': 'text',
      'text': 'text',
      'number': 'number',
      'integer': 'number',
      'float': 'number',
      'double': 'number',
      'boolean': 'checkbox',
      'bool': 'checkbox',
      'date': 'date',
      'dateTime': 'date',
      'datetime': 'date',
      'url': 'url',
      'uri': 'url',
      'email': 'email',
      'phone': 'phone'
    };
    return mapping[termType] || mapping[termType?.toLowerCase()] || 'text';
  }

  /**
   * Show meaning-aware Apply to Fields modal
   * This is the enhanced version of the apply modal that suggests field matches
   */
  _showApplyToFieldsModal(definitionId) {
    const definition = this.definitions?.find(d => d.id === definitionId);
    if (!definition) return;

    const terms = definition.terms || definition.properties || [];
    const activeSets = this.sets.filter(s => s.status !== 'archived');

    if (activeSets.length === 0) {
      this._showNotification('No sets available. Create a set first.', 'error');
      return;
    }

    // Get all fields from all sets
    const allFields = [];
    activeSets.forEach(set => {
      (set.fields || []).forEach(field => {
        // Check if already linked to this definition
        const isLinked = field.definitionRef?.definitionId === definitionId;
        allFields.push({
          setId: set.id,
          setName: set.name,
          fieldId: field.id,
          fieldName: field.name,
          fieldType: field.type,
          isLinked
        });
      });
    });

    // Calculate suggested matches based on name similarity
    const suggestedFields = this._getSuggestedFieldMatches(definition, allFields);
    const otherFields = allFields.filter(f => !suggestedFields.find(s => s.fieldId === f.fieldId));

    const html = `
      <div class="apply-to-fields-modal">
        <div class="apply-modal-header">
          <p>Apply "<strong>${this._escapeHtml(definition.name)}</strong>" to fields</p>
          <p class="apply-modal-hint">Bind this meaning to one or more columns. This adds semantic context but does not change your data.</p>
        </div>

        ${suggestedFields.length > 0 ? `
          <div class="apply-field-section">
            <h4 class="section-label">
              <i class="ph ph-sparkle"></i> Suggested matches
            </h4>
            <div class="apply-field-list">
              ${suggestedFields.map(f => `
                <label class="apply-field-option ${f.isLinked ? 'already-linked' : ''}" title="${f.matchReason || ''}">
                  <input type="checkbox" name="apply-field" value="${f.setId}:${f.fieldId}" ${f.isLinked ? 'checked' : ''}>
                  <span class="field-info">
                    <span class="field-name">${this._escapeHtml(f.fieldName)}</span>
                    <span class="set-name">in ${this._escapeHtml(f.setName)}</span>
                  </span>
                  ${f.matchReason ? `<span class="match-reason">${this._escapeHtml(f.matchReason)}</span>` : ''}
                  ${f.isLinked ? `<span class="linked-badge"><i class="ph ph-check"></i> Linked</span>` : ''}
                </label>
              `).join('')}
            </div>
          </div>
        ` : ''}

        <div class="apply-field-section">
          <h4 class="section-label">
            <i class="ph ph-list"></i> ${suggestedFields.length > 0 ? 'Other fields' : 'Available fields'}
          </h4>
          <div class="apply-field-list">
            ${otherFields.length > 0 ? otherFields.map(f => `
              <label class="apply-field-option ${f.isLinked ? 'already-linked' : ''}">
                <input type="checkbox" name="apply-field" value="${f.setId}:${f.fieldId}" ${f.isLinked ? 'checked' : ''}>
                <span class="field-info">
                  <span class="field-name">${this._escapeHtml(f.fieldName)}</span>
                  <span class="set-name">in ${this._escapeHtml(f.setName)}</span>
                </span>
                ${f.isLinked ? `<span class="linked-badge"><i class="ph ph-check"></i> Linked</span>` : ''}
              </label>
            `).join('') : `
              <p class="no-fields-message">No additional fields available.</p>
            `}
          </div>
        </div>

        <div class="apply-modal-info">
          <i class="ph ph-info"></i>
          <span>Selected fields will be bound to this definition's meaning. You can unlink them later.</span>
        </div>
      </div>
    `;

    this._showModal('Apply to Fields…', html, () => {
      const checkedBoxes = document.querySelectorAll('input[name="apply-field"]:checked');
      const selections = Array.from(checkedBoxes).map(cb => {
        const [setId, fieldId] = cb.value.split(':');
        return { setId, fieldId };
      });

      if (selections.length === 0) {
        this._showNotification('Please select at least one field', 'warning');
        return;
      }

      this._applyDefinitionToFields(definitionId, selections);
    }, { confirmText: 'Apply Meaning', cancelText: 'Cancel' });
  }

  /**
   * Get suggested field matches based on semantic similarity
   */
  _getSuggestedFieldMatches(definition, allFields) {
    const suggestions = [];
    const defName = definition.name?.toLowerCase() || '';
    const defDescription = definition.description?.toLowerCase() || '';
    const terms = definition.terms || definition.properties || [];
    const termNames = terms.map(t => (t.name || t.label || '').toLowerCase());

    // Keywords from definition name and description
    const keywords = [
      defName,
      ...defName.split(/[\s_-]+/),
      ...defDescription.split(/[\s_-]+/).filter(w => w.length > 3)
    ];

    allFields.forEach(field => {
      const fieldName = field.fieldName?.toLowerCase() || '';
      const fieldParts = fieldName.split(/[\s_-]+/);

      let matchReason = null;
      let score = 0;

      // Check direct name match
      if (fieldName.includes(defName) || defName.includes(fieldName)) {
        matchReason = `Matches concept: ${definition.name}`;
        score = 10;
      }

      // Check term name matches
      if (!matchReason) {
        for (const termName of termNames) {
          if (fieldName.includes(termName) || termName.includes(fieldName)) {
            matchReason = `Matches term: ${termName}`;
            score = 8;
            break;
          }
        }
      }

      // Check keyword overlaps
      if (!matchReason) {
        for (const keyword of keywords) {
          if (keyword.length > 3 && (fieldName.includes(keyword) || fieldParts.some(p => keyword.includes(p) && p.length > 3))) {
            matchReason = `Related to: ${keyword}`;
            score = 5;
            break;
          }
        }
      }

      // Common semantic patterns
      if (!matchReason) {
        const semanticPatterns = [
          { pattern: /status|condition|state/, match: /status|condition|state/, reason: 'Field type: status/condition' },
          { pattern: /date|time|when/, match: /date|time|when/, reason: 'Field type: temporal' },
          { pattern: /id|code|identifier/, match: /id|code|identifier/, reason: 'Field type: identifier' },
          { pattern: /name|title|label/, match: /name|title|label/, reason: 'Field type: naming' },
          { pattern: /amount|count|number|total/, match: /amount|count|number|total/, reason: 'Field type: quantity' }
        ];

        for (const sp of semanticPatterns) {
          if (sp.pattern.test(defName) && sp.match.test(fieldName)) {
            matchReason = sp.reason;
            score = 3;
            break;
          }
        }
      }

      if (matchReason) {
        suggestions.push({
          ...field,
          matchReason,
          score
        });
      }
    });

    // Sort by score and return top matches
    return suggestions.sort((a, b) => b.score - a.score).slice(0, 5);
  }

  /**
   * Apply definition to multiple fields
   */
  _applyDefinitionToFields(definitionId, selections) {
    const definition = this.definitions?.find(d => d.id === definitionId);
    if (!definition) return;

    const terms = definition.terms || definition.properties || [];
    const firstTerm = terms[0];

    let linkedCount = 0;

    selections.forEach(({ setId, fieldId }) => {
      const set = this.sets.find(s => s.id === setId);
      if (!set) return;

      const field = set.fields?.find(f => f.id === fieldId);
      if (!field) return;

      // Set the definition reference
      field.definitionRef = {
        definitionId: definitionId,
        termId: firstTerm?.id || null,
        uri: definition.sourceUri || null,
        lastSyncedAt: new Date().toISOString()
      };

      linkedCount++;
    });

    this._saveData();
    this._closeModal();
    this._showDefinitionDetail(definitionId);
    this._showNotification(`Applied "${definition.name}" to ${linkedCount} field${linkedCount !== 1 ? 's' : ''}`, 'success');
  }

  /**
   * Search for similar definitions in external vocabularies
   * Uses the Definition API to find matching concepts from Wikidata, Schema.org, etc.
   */
  async _searchSimilarDefinitions(definition) {
    if (!definition) return;

    const searchTerm = definition.name || '';
    if (!searchTerm) {
      this._showNotification('Definition needs a name to search for similar concepts', 'warning');
      return;
    }

    const html = `
      <div class="find-similar-modal">
        <div class="search-section">
          <div class="form-group">
            <label class="form-label">Search Term</label>
            <div class="search-input-row">
              <input type="text" id="similar-search-input" class="form-input"
                     value="${this._escapeHtml(searchTerm)}" placeholder="Enter search term...">
              <button class="btn btn-primary" id="btn-run-similar-search">
                <i class="ph ph-magnifying-glass"></i> Search
              </button>
            </div>
          </div>
          <div class="form-group">
            <label class="form-label">Search In</label>
            <div class="source-checkboxes">
              <label class="checkbox-label">
                <input type="checkbox" name="similar-source" value="wikidata" checked> Wikidata
              </label>
              <label class="checkbox-label">
                <input type="checkbox" name="similar-source" value="schemaOrg" checked> Schema.org
              </label>
              <label class="checkbox-label">
                <input type="checkbox" name="similar-source" value="dbpedia"> DBpedia
              </label>
            </div>
          </div>
        </div>
        <div class="results-section">
          <div id="similar-search-results" class="search-results-container">
            <div class="empty-state">
              <i class="ph ph-magnifying-glass"></i>
              <p>Click Search to find similar concepts</p>
            </div>
          </div>
        </div>
        <div id="similar-selected-item" class="selected-item-preview" style="display: none;"></div>
      </div>
    `;

    let selectedResult = null;

    this._showModal('Find Similar Concepts', html, () => {
      if (!selectedResult) {
        this._showNotification('Please select a concept first', 'warning');
        return;
      }

      // Update the definition with the selected URI
      definition.sourceUri = selectedResult.uri;
      definition.externalId = selectedResult.id;
      definition.externalSource = selectedResult.source;
      if (selectedResult.description && !definition.description) {
        definition.description = selectedResult.description;
      }

      // Update status from stub to partial/complete
      if (definition.status === 'stub') {
        definition.status = 'partial';
      }
      definition.populationMethod = 'api_lookup';
      definition.linkedAt = new Date().toISOString();

      this._saveData();
      this._renderDefinitionsNav();
      this._showDefinitionDetail(definition.id);
      this._showNotification(`Linked to ${selectedResult.source}: ${selectedResult.label}`, 'success');
    }, { confirmText: 'Link Selected', cancelText: 'Cancel' });

    // Attach search handler
    const searchBtn = document.getElementById('btn-run-similar-search');
    const searchInput = document.getElementById('similar-search-input');
    const resultsDiv = document.getElementById('similar-search-results');

    const runSearch = async () => {
      const query = searchInput?.value?.trim();
      if (!query) {
        this._showNotification('Please enter a search term', 'warning');
        return;
      }

      const checkedSources = Array.from(document.querySelectorAll('input[name="similar-source"]:checked'))
        .map(cb => cb.value);

      if (checkedSources.length === 0) {
        this._showNotification('Please select at least one source', 'warning');
        return;
      }

      resultsDiv.innerHTML = '<div class="loading-state"><i class="ph ph-spinner ph-spin"></i> Searching...</div>';

      try {
        const api = window.EO?.getDefinitionAPI?.();
        if (!api) {
          throw new Error('Definition API not available');
        }

        const results = await api.searchConcepts(query, { sources: checkedSources, limit: 15 });

        if (results.length === 0) {
          resultsDiv.innerHTML = `
            <div class="empty-state">
              <i class="ph ph-magnifying-glass"></i>
              <p>No results found for "${this._escapeHtml(query)}"</p>
              <span class="hint">Try different keywords or enable more sources</span>
            </div>
          `;
          return;
        }

        resultsDiv.innerHTML = results.map((r, i) => `
          <div class="search-result-item" data-index="${i}">
            <div class="result-header">
              <span class="result-label">${this._escapeHtml(r.label)}</span>
              <span class="result-source">${this._escapeHtml(r.source)}</span>
            </div>
            <div class="result-description">${this._escapeHtml(r.description || 'No description')}</div>
            <div class="result-uri">${this._escapeHtml(r.uri)}</div>
          </div>
        `).join('');

        // Store results for selection
        resultsDiv._results = results;

        // Attach click handlers
        resultsDiv.querySelectorAll('.search-result-item').forEach(item => {
          item.addEventListener('click', () => {
            const index = parseInt(item.dataset.index, 10);
            const result = resultsDiv._results[index];

            // Update selection UI
            resultsDiv.querySelectorAll('.search-result-item').forEach(el => el.classList.remove('selected'));
            item.classList.add('selected');

            selectedResult = result;

            // Show selected preview
            const previewDiv = document.getElementById('similar-selected-item');
            if (previewDiv) {
              previewDiv.style.display = 'block';
              previewDiv.innerHTML = `
                <div class="selected-badge"><i class="ph ph-check-circle"></i> Selected</div>
                <div class="selected-label">${this._escapeHtml(result.label)}</div>
                <div class="selected-uri">${this._escapeHtml(result.uri)}</div>
              `;
            }
          });
        });

      } catch (error) {
        console.error('Similar search error:', error);
        resultsDiv.innerHTML = `
          <div class="error-state">
            <i class="ph ph-warning-circle"></i>
            <p>Search failed: ${this._escapeHtml(error.message)}</p>
          </div>
        `;
      }
    };

    searchBtn?.addEventListener('click', runSearch);
    searchInput?.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') runSearch();
    });

    // Auto-run search on open
    setTimeout(runSearch, 100);
  }

  /**
   * Open modal to import/browse vocabulary terms
   * Searches all vocabulary sources (Schema.org, Wikidata, LOV) simultaneously
   * with fuzzy matching for better auto-suggestions
   */
  async _openImportVocabularyModal(definition) {
    if (!definition) return;

    // Get source badge color based on source name
    const getSourceColor = (source) => {
      const colors = {
        'Schema.org': '#4285f4',
        'Wikidata': '#006699',
        'LOV': '#7c3aed'
      };
      return colors[source] || '#666';
    };

    const html = `
      <div class="import-vocabulary-modal">
        <div class="vocab-content">
          <div class="vocab-search">
            <input type="text" id="vocab-search-input" class="form-input"
                   placeholder="Search all vocabularies (Schema.org, Wikidata, SKOS)..."
                   value="${this._escapeHtml(definition.name || '')}">
            <div class="search-hint">Searches Schema.org, Wikidata, and Linked Open Vocabularies with fuzzy matching</div>
          </div>

          <div id="vocab-browse-results" class="vocab-results">
            <div class="loading-state">
              <i class="ph ph-spinner ph-spin"></i> Searching all vocabularies...
            </div>
          </div>
        </div>

        <div id="vocab-selected-term" class="selected-term-preview" style="display: none;"></div>
      </div>
      <style>
        .import-vocabulary-modal .search-hint {
          font-size: 11px;
          color: var(--text-tertiary, #888);
          margin-top: 4px;
        }
        .import-vocabulary-modal .vocab-term-item {
          display: flex;
          flex-direction: column;
          gap: 2px;
          padding: 10px 12px;
          border-bottom: 1px solid var(--border-color, #e5e7eb);
          cursor: pointer;
          transition: background-color 0.15s;
        }
        .import-vocabulary-modal .vocab-term-item:hover {
          background-color: var(--hover-bg, #f3f4f6);
        }
        .import-vocabulary-modal .vocab-term-item.selected {
          background-color: var(--selected-bg, #eff6ff);
          border-left: 3px solid var(--primary-color, #3b82f6);
        }
        .import-vocabulary-modal .term-header {
          display: flex;
          align-items: center;
          gap: 8px;
        }
        .import-vocabulary-modal .term-label {
          font-weight: 500;
          color: var(--text-primary, #111);
        }
        .import-vocabulary-modal .source-badge {
          font-size: 10px;
          padding: 2px 6px;
          border-radius: 3px;
          color: white;
          font-weight: 500;
        }
        .import-vocabulary-modal .match-score {
          font-size: 10px;
          color: var(--text-tertiary, #888);
          margin-left: auto;
        }
        .import-vocabulary-modal .term-description {
          font-size: 12px;
          color: var(--text-secondary, #666);
          line-height: 1.4;
        }
        .import-vocabulary-modal .term-uri {
          font-size: 11px;
          color: var(--text-tertiary, #888);
          font-family: monospace;
        }
        .import-vocabulary-modal .vocab-results {
          max-height: 350px;
          overflow-y: auto;
          border: 1px solid var(--border-color, #e5e7eb);
          border-radius: 6px;
          margin-top: 12px;
        }
        .import-vocabulary-modal .empty-state,
        .import-vocabulary-modal .loading-state,
        .import-vocabulary-modal .error-state {
          padding: 40px 20px;
          text-align: center;
          color: var(--text-secondary, #666);
        }
        .import-vocabulary-modal .empty-state i,
        .import-vocabulary-modal .loading-state i,
        .import-vocabulary-modal .error-state i {
          font-size: 32px;
          margin-bottom: 12px;
          display: block;
        }
      </style>
    `;

    let selectedTerm = null;

    this._showModal('Import from Vocabulary', html, () => {
      if (!selectedTerm) {
        this._showNotification('Please select a term first', 'warning');
        return;
      }

      // Update the definition with selected term
      definition.sourceUri = selectedTerm.uri;
      definition.externalId = selectedTerm.id;
      definition.externalSource = selectedTerm.source;
      if (selectedTerm.description && !definition.description) {
        definition.description = selectedTerm.description;
      }
      if (selectedTerm.label && definition.name === definition.id) {
        definition.name = selectedTerm.label;
      }

      // Update status
      if (definition.status === 'stub') {
        definition.status = 'partial';
      }
      definition.populationMethod = 'imported';
      definition.importedFrom = selectedTerm.source;
      definition.linkedAt = new Date().toISOString();

      this._saveData();
      this._renderDefinitionsNav();
      this._showDefinitionDetail(definition.id);
      this._showNotification(`Imported from ${selectedTerm.source}: ${selectedTerm.label}`, 'success');
    }, { confirmText: 'Import Selected', cancelText: 'Cancel' });

    const resultsDiv = document.getElementById('vocab-browse-results');
    const searchInput = document.getElementById('vocab-search-input');

    const searchAllVocabularies = async (searchTerm = '') => {
      resultsDiv.innerHTML = '<div class="loading-state"><i class="ph ph-spinner ph-spin"></i> Searching all vocabularies...</div>';

      try {
        const api = window.EO?.getDefinitionAPI?.();
        if (!api) {
          throw new Error('Definition API not available');
        }

        const query = searchTerm || definition.name || 'identifier';

        // Use the new searchAllConcepts method that searches all sources
        let results = [];
        if (api.searchAllConcepts) {
          results = await api.searchAllConcepts(query, { limit: 30 });
        } else {
          // Fallback: search all sources in parallel
          const [schemaResults, wikidataResults, lovResults] = await Promise.all([
            api.searchConcepts(query, { sources: ['schemaOrg'], limit: 15 }).catch(() => []),
            api.searchConcepts(query, { sources: ['wikidata'], limit: 15 }).catch(() => []),
            api.searchConcepts(query, { sources: ['lov'], limit: 15 }).catch(() => [])
          ]);
          results = [...schemaResults, ...wikidataResults, ...lovResults];
        }

        if (results.length === 0) {
          resultsDiv.innerHTML = `
            <div class="empty-state">
              <i class="ph ph-folder-open"></i>
              <p>No terms found</p>
              <span class="hint">Try a different search term or check your spelling</span>
            </div>
          `;
          return;
        }

        resultsDiv.innerHTML = results.map((r, i) => {
          const scorePercent = r.score ? Math.round(r.score * 100) : null;
          return `
            <div class="vocab-term-item" data-index="${i}">
              <div class="term-header">
                <span class="term-label">${this._escapeHtml(r.label)}</span>
                <span class="source-badge" style="background-color: ${getSourceColor(r.source)}">${this._escapeHtml(r.source)}</span>
                ${scorePercent !== null ? `<span class="match-score">${scorePercent}% match</span>` : ''}
              </div>
              <div class="term-description">${this._escapeHtml(r.description || '')}</div>
              <div class="term-uri">${this._escapeHtml(r.uri)}</div>
            </div>
          `;
        }).join('');

        resultsDiv._results = results;

        // Click handlers
        resultsDiv.querySelectorAll('.vocab-term-item').forEach(item => {
          item.addEventListener('click', () => {
            const index = parseInt(item.dataset.index, 10);
            const term = resultsDiv._results[index];

            resultsDiv.querySelectorAll('.vocab-term-item').forEach(el => el.classList.remove('selected'));
            item.classList.add('selected');

            selectedTerm = term;

            const previewDiv = document.getElementById('vocab-selected-term');
            if (previewDiv) {
              previewDiv.style.display = 'block';
              previewDiv.innerHTML = `
                <div class="selected-badge"><i class="ph ph-check-circle"></i> Selected</div>
                <div class="selected-label">${this._escapeHtml(term.label)}</div>
                <div class="selected-uri">${this._escapeHtml(term.uri)}</div>
              `;
            }
          });
        });

      } catch (error) {
        console.error('Vocabulary load error:', error);
        resultsDiv.innerHTML = `
          <div class="error-state">
            <i class="ph ph-warning-circle"></i>
            <p>Failed to load: ${this._escapeHtml(error.message)}</p>
          </div>
        `;
      }
    };

    // Search handler with debounce
    let searchTimeout;
    searchInput?.addEventListener('input', () => {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        searchAllVocabularies(searchInput.value.trim());
      }, 300);
    });

    // Initial search using definition name
    setTimeout(() => searchAllVocabularies(searchInput?.value?.trim()), 100);
  }

  /**
   * Open modal to manually link a definition to a URI
   */
  _openLinkToUriModal(definition) {
    const html = `
      <div class="link-uri-form">
        <div class="form-group">
          <label for="link-uri-input" class="form-label">URI / IRI</label>
          <input type="url" id="link-uri-input" class="form-input"
                 placeholder="https://schema.org/Person"
                 value="${definition.sourceUri ? this._escapeHtml(definition.sourceUri) : ''}">
          <p class="form-help">Enter a URI to link this definition to a standard vocabulary or external resource.</p>
        </div>
        <div class="uri-examples">
          <p class="form-label" style="margin-bottom: 8px;">Example URIs:</p>
          <div class="uri-example-list" style="font-size: 12px; color: var(--text-secondary);">
            <div>• Schema.org: <code>https://schema.org/Person</code></div>
            <div>• Wikidata: <code>https://www.wikidata.org/wiki/Q5</code></div>
            <div>• Dublin Core: <code>http://purl.org/dc/terms/title</code></div>
          </div>
        </div>
      </div>
    `;

    this._showModal('Link to URI', html, () => {
      const uri = document.getElementById('link-uri-input')?.value?.trim();

      if (!uri) {
        this._showNotification('Please enter a URI', 'error');
        return;
      }

      // Basic URL validation
      try {
        new URL(uri);
      } catch (e) {
        this._showNotification('Please enter a valid URI', 'error');
        return;
      }

      // Update the definition
      definition.sourceUri = uri;
      definition.populationMethod = 'manual';
      if (definition.status === 'stub') {
        definition.status = 'partial';
      }

      this._saveData();
      this._showDefinitionDetail(definition.id);
      this._showNotification('URI linked successfully', 'success');
    });
  }

  /**
   * Show modal to edit a definition
   */
  _showEditDefinitionModal(definitionId) {
    const definition = this.definitions?.find(d => d.id === definitionId);
    if (!definition) return;

    const html = `
      <div class="edit-definition-form">
        <div class="form-group">
          <label for="edit-definition-name" class="form-label">Name</label>
          <input type="text" id="edit-definition-name" class="form-input"
                 value="${this._escapeHtml(definition.name)}">
        </div>
        <div class="form-group">
          <label for="edit-definition-description" class="form-label">Description</label>
          <textarea id="edit-definition-description" class="form-input" rows="3">${this._escapeHtml(definition.description || '')}</textarea>
        </div>
        ${definition.sourceUri ? `
          <div class="form-group">
            <label class="form-label">Source URI</label>
            <input type="text" class="form-input" value="${this._escapeHtml(definition.sourceUri)}" readonly disabled>
          </div>
        ` : ''}
      </div>
    `;

    this._showModal('Edit Definition', html, () => {
      const name = document.getElementById('edit-definition-name')?.value?.trim();
      const description = document.getElementById('edit-definition-description')?.value?.trim();

      if (!name) {
        this._showNotification('Name is required', 'error');
        return;
      }

      definition.name = name;
      definition.description = description;
      this._saveData();
      this._renderDefinitionsNav();
      this._showDefinitionDetail(definitionId);
      this._showNotification('Definition updated', 'success');
    });
  }

  /**
   * Show source data viewer - REBUILT FROM SCRATCH
   *
   * Simplified approach: reads directly from this.sources array.
   * Displays source data in main content area as read-only table.
   */
  async _showSourceDetail(sourceId) {
    console.log('_showSourceDetail called', {
      sourceId,
      availableSources: this.sources?.length || 0,
      sourceIds: this.sources?.map(s => s.id)
    });

    // Find the source from the sources array (single source of truth)
    const source = this.sources?.find(s => s.id === sourceId);

    if (!source) {
      console.error('Source not found:', sourceId, 'Available sources:', this.sources);
      this._showNotification('Source not found', 'error');
      return;
    }

    console.log('_showSourceDetail: Found source', {
      id: source.id,
      name: source.name,
      recordCount: source.recordCount,
      hasRecords: !!(source.records && source.records.length > 0),
      recordsInIndexedDB: source._recordsInIndexedDB
    });

    // Set current source and clear set selection
    this.currentSourceId = sourceId;

    // Update source item selection in sidebar
    document.querySelectorAll('.source-item').forEach(item => {
      item.classList.toggle('active', item.dataset.sourceId === sourceId);
    });

    // Clear set selection in sidebar (both .set-item and .set-item-header)
    document.querySelectorAll('.set-item, .set-item-header').forEach(item => {
      item.classList.remove('active');
    });

    // Update tab bar to deselect any active set tab
    this._renderTabBar();

    // Ensure source records are loaded from IndexedDB if needed
    await this._ensureSourceRecords(source);

    // Render source data view in main content area
    this._renderSourceDataView(source);

    // Update breadcrumb to show we're viewing a source
    this._updateSourceBreadcrumb(source);
  }

  /**
   * Render source data viewer in main content area - REBUILT FROM SCRATCH
   *
   * Shows source data as read-only table with provenance info.
   * Source data is read directly from the source object passed in.
   */
  _renderSourceDataView(source) {
    const contentArea = this.elements.contentArea;
    if (!contentArea) return;

    // Get records directly from source - this is the raw imported data
    const rawRecords = source.records || [];
    console.log('_renderSourceDataView: Rendering source data', {
      sourceName: source.name,
      rawRecordCount: rawRecords.length,
      hasSchema: !!source.schema,
      schemaFieldCount: source.schema?.fields?.length || 0
    });

    // Build fields from schema
    let fields = [];
    if (source.schema?.fields && source.schema.fields.length > 0) {
      fields = source.schema.fields.map(f => ({
        id: f.name || f.sourceColumn,
        name: f.name || f.sourceColumn,
        type: f.type || 'text'
      }));
    } else if (rawRecords.length > 0) {
      // Infer fields from ALL records (some records may have fields others don't)
      const fieldSet = new Set();
      const fieldOrder = [];

      // First, add fields from the first record (preserves typical order)
      for (const key of Object.keys(rawRecords[0])) {
        fieldOrder.push(key);
        fieldSet.add(key);
      }

      // Then scan remaining records for any additional fields
      for (let i = 1; i < rawRecords.length; i++) {
        for (const key of Object.keys(rawRecords[i])) {
          if (!fieldSet.has(key)) {
            fieldOrder.push(key);
            fieldSet.add(key);
          }
        }
      }

      // Use ensureValidField to guarantee proper width (TABLE RULE 1)
      fields = fieldOrder.map(key => ensureValidField({
        id: key,
        name: key,
        type: this._inferFieldType(rawRecords, key)
      }));
    }

    // Transform raw records to display format
    const records = rawRecords.map((record, index) => ({
      id: `rec_${index}`,
      values: record
    }));

    // Compute multiRecordAnalysis on-the-fly if not present
    if (!source.multiRecordAnalysis && rawRecords.length > 1) {
      source.multiRecordAnalysis = this._computeMultiRecordAnalysis(rawRecords, fields);
      if (source.multiRecordAnalysis) {
        // Persist the computed analysis
        this._saveData();
      }
    }

    // Find derived sets (sets created from this source)
    const derivedSets = this.sets.filter(set => {
      const prov = set.datasetProvenance;
      if (!prov) return false;
      return prov.sourceId === source.id ||
             prov.originalFilename?.toLowerCase() === source.name.toLowerCase();
    });

    // Check if provenance panel should be hidden (from localStorage)
    const hideProvenance = localStorage.getItem('eo-hide-source-provenance') === 'true';

    // Build the source data viewer HTML
    contentArea.innerHTML = `
      <div class="source-data-viewer${hideProvenance ? ' provenance-hidden' : ''}">
        <!-- Source Header -->
        <div class="source-viewer-header">
          <div class="source-viewer-title">
            <div class="source-viewer-icon">
              <i class="ph ${this._getSourceIcon(source.name)}"></i>
            </div>
            <div class="source-viewer-info">
              <h2>
                <span id="source-name-display">${this._escapeHtml(source.name)}</span>
                <button class="source-name-edit-btn" id="source-name-edit-btn" title="Rename source">
                  <i class="ph ph-pencil-simple"></i>
                </button>
                <span class="given-badge">
                  <i class="ph ph-lock-simple"></i>
                  GIVEN
                </span>
              </h2>
              <div class="source-viewer-meta">
                Imported ${source.importedAt ? new Date(source.importedAt).toLocaleString() : 'Unknown'} ·
                ${source.recordCount || records.length} records ·
                ${fields.length} fields
              </div>
            </div>
          </div>
          <div class="source-viewer-actions">
            <button class="source-action-btn" id="source-export-btn" title="Export source data">
              <i class="ph ph-export"></i>
              <span>Export</span>
            </button>
            <button class="source-action-btn primary" id="source-create-set-btn" title="Create a new Set from this source">
              <i class="ph ph-git-branch"></i>
              <span>Create Set</span>
            </button>
          </div>
        </div>

        <!-- Toolbar -->
        <div class="source-viewer-toolbar">
          <div class="source-search-box">
            <i class="ph ph-magnifying-glass"></i>
            <input type="text" id="source-search-input" placeholder="Search records... (read-only view)">
          </div>
          ${source.multiRecordAnalysis ? `
            <div class="source-view-mode-toggle">
              <button class="source-view-mode-btn ${!source.sourceViewMode || source.sourceViewMode === 'unified' ? 'active' : ''}" data-mode="unified" title="View all records in one table">
                <i class="ph ph-table"></i>
                <span>Unified</span>
              </button>
              <button class="source-view-mode-btn ${source.sourceViewMode === 'split' ? 'active' : ''}" data-mode="split" title="View records split by type">
                <i class="ph ph-rows"></i>
                <span>By Type</span>
              </button>
              <button class="source-view-mode-btn ${source.sourceViewMode === 'cards' ? 'active' : ''}" data-mode="cards" title="View record types as cards">
                <i class="ph ph-cards"></i>
                <span>Cards</span>
              </button>
            </div>
          ` : ''}
          <div class="source-record-count">
            Showing ${Math.min(records.length, 100)} of ${source.recordCount || records.length} records
          </div>
          <button class="source-provenance-toggle-btn" id="source-provenance-toggle-btn" title="Toggle provenance panel">
            <i class="ph ph-sidebar-simple"></i>
          </button>
        </div>

        <!-- Data Table Container -->
        <div class="source-data-table-container" id="source-data-table-container">
          ${this._renderSourceTableContent(source, fields, records)}
        </div>

        <!-- Provenance Panel -->
        <div class="source-provenance-panel">
          <div class="source-provenance-header">
            <i class="ph ph-fingerprint"></i>
            <span>Provenance</span>
            <button class="source-prov-edit-all-btn" id="source-prov-edit-btn" title="Edit provenance metadata">
              <i class="ph ph-pencil-simple"></i>
            </button>
          </div>
          <div class="source-provenance-items" id="source-provenance-items">
            ${this._renderSourceProvenanceItems(source)}
          </div>
          ${source.editHistory && source.editHistory.length > 0 ? `
            <div class="source-edit-history">
              <div class="source-edit-history-header" id="source-edit-history-toggle">
                <i class="ph ph-clock-counter-clockwise"></i>
                <span>Edit History (${source.editHistory.length})</span>
                <i class="ph ph-caret-down"></i>
              </div>
              <div class="source-edit-history-items" id="source-edit-history-items" style="display: none;">
                ${source.editHistory.slice(0, 10).map(edit => `
                  <div class="source-edit-history-item">
                    <div class="edit-timestamp">${new Date(edit.timestamp).toLocaleString()}</div>
                    <div class="edit-details">
                      <span class="edit-field">${this._escapeHtml(edit.field)}</span>:
                      <span class="edit-old">${this._escapeHtml(String(edit.oldValue || '(empty)'))}</span>
                      → <span class="edit-new">${this._escapeHtml(String(edit.newValue || '(empty)'))}</span>
                    </div>
                  </div>
                `).join('')}
              </div>
            </div>
          ` : ''}
          ${this._renderSourceFileMetadata(source)}
          <div class="source-immutable-notice">
            <i class="ph ph-lock"></i>
            <p><strong>Read-only source data.</strong> Records are immutable. Metadata (name, provenance) can be edited with full history tracking.</p>
          </div>
          ${derivedSets.length > 0 ? `
            <div class="source-derived-sets">
              <div class="source-derived-header">
                <i class="ph ph-git-branch"></i>
                <span>Lenses (${derivedSets.length})</span>
              </div>
              ${derivedSets.map(set => `
                <div class="source-derived-item" data-set-id="${set.id}">
                  <i class="${set.icon || 'ph ph-table'}"></i>
                  <span>${this._escapeHtml(set.name)}</span>
                  <span class="count">${set.records?.length || 0}</span>
                </div>
              `).join('')}
            </div>
          ` : ''}
        </div>

        <!-- Floating Provenance Tab (visible when panel is hidden) -->
        <div class="source-provenance-floating-tab" id="source-provenance-floating-tab" title="Show provenance panel">
          <i class="ph ph-fingerprint"></i>
          <span>Provenance</span>
        </div>
      </div>
    `;

    // Attach event handlers
    this._attachSourceViewerHandlers(source, derivedSets);

    // Update status bar with source record count
    this._updateSourceStatus(source);
  }

  /**
   * Attach event handlers for source viewer
   */
  _attachSourceViewerHandlers(source, derivedSets) {
    // Export button
    document.getElementById('source-export-btn')?.addEventListener('click', () => {
      this._exportSource(source.id);
    });

    // Create Set button
    document.getElementById('source-create-set-btn')?.addEventListener('click', () => {
      this._createSetFromSource(source);
    });

    // Search input
    const searchInput = document.getElementById('source-search-input');
    searchInput?.addEventListener('input', (e) => {
      this._filterSourceRecords(source, e.target.value);
    });

    // Derived set clicks
    document.querySelectorAll('.source-derived-item').forEach(item => {
      item.addEventListener('click', () => {
        const setId = item.dataset.setId;
        this.currentSourceId = null; // Clear source view
        this._selectSet(setId);
      });
    });

    // Name edit button
    document.getElementById('source-name-edit-btn')?.addEventListener('click', () => {
      this._renameSource(source.id);
    });

    // Provenance edit button
    document.getElementById('source-prov-edit-btn')?.addEventListener('click', () => {
      this._editSourceProvenance(source.id);
    });

    // Edit history toggle
    document.getElementById('source-edit-history-toggle')?.addEventListener('click', () => {
      const items = document.getElementById('source-edit-history-items');
      const toggle = document.getElementById('source-edit-history-toggle');
      if (items && toggle) {
        const isHidden = items.style.display === 'none';
        items.style.display = isHidden ? 'block' : 'none';
        toggle.querySelector('.ph-caret-down, .ph-caret-up')?.classList.toggle('ph-caret-down', !isHidden);
        toggle.querySelector('.ph-caret-down, .ph-caret-up')?.classList.toggle('ph-caret-up', isHidden);
      }
    });

    // View mode toggle buttons
    document.querySelectorAll('.source-view-mode-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const mode = btn.dataset.mode;
        if (!mode) return;

        // Always update button states for visual feedback
        document.querySelectorAll('.source-view-mode-btn').forEach(b => {
          b.classList.toggle('active', b.dataset.mode === mode);
        });

        // Get the effective current mode (default is 'unified')
        const currentMode = source.sourceViewMode || 'unified';

        // Only re-render if mode actually changed
        if (currentMode !== mode) {
          source.sourceViewMode = mode;
          this._saveData();

          // Re-render just the table container
          const container = document.getElementById('source-data-table-container');
          if (container) {
            // Rebuild fields and records for re-render
            const rawRecords = source.records || [];
            let fields = [];
            if (source.schema?.fields && source.schema.fields.length > 0) {
              fields = source.schema.fields.map(f => ({
                id: f.name || f.sourceColumn,
                name: f.name || f.sourceColumn,
                type: f.type || 'text'
              }));
            } else if (rawRecords.length > 0) {
              const fieldSet = new Set();
              const fieldOrder = [];
              for (const key of Object.keys(rawRecords[0])) {
                fieldOrder.push(key);
                fieldSet.add(key);
              }
              for (let i = 1; i < rawRecords.length; i++) {
                for (const key of Object.keys(rawRecords[i])) {
                  if (!fieldSet.has(key)) {
                    fieldOrder.push(key);
                    fieldSet.add(key);
                  }
                }
              }
              fields = fieldOrder.map(key => ensureValidField({
                id: key,
                name: key,
                type: this._inferFieldType(rawRecords, key)
              }));
            }
            const records = rawRecords.map((record, index) => ({
              id: `rec_${index}`,
              values: record
            }));
            container.innerHTML = this._renderSourceTableContent(source, fields, records);
          }
        }
      });
    });

    // Provenance panel toggle
    document.getElementById('source-provenance-toggle-btn')?.addEventListener('click', () => {
      const viewer = document.querySelector('.source-data-viewer');
      const toggleBtn = document.getElementById('source-provenance-toggle-btn');
      if (viewer) {
        const isHidden = viewer.classList.toggle('provenance-hidden');
        localStorage.setItem('eo-hide-source-provenance', isHidden);
        // Update icon
        const icon = toggleBtn?.querySelector('i');
        if (icon) {
          icon.className = isHidden ? 'ph ph-sidebar-simple' : 'ph ph-sidebar-simple';
        }
        this._showToast(isHidden ? 'Provenance panel hidden' : 'Provenance panel visible', 'info');
      }
    });

    // Floating provenance tab (shows panel when clicked)
    document.getElementById('source-provenance-floating-tab')?.addEventListener('click', () => {
      const viewer = document.querySelector('.source-data-viewer');
      if (viewer && viewer.classList.contains('provenance-hidden')) {
        viewer.classList.remove('provenance-hidden');
        localStorage.setItem('eo-hide-source-provenance', 'false');
        this._showToast('Provenance panel visible', 'info');
      }
    });

    // Expand button clicks for long text cells (use event delegation for dynamic content)
    // Also allow clicking on the cell wrapper itself to open the modal
    document.getElementById('source-data-table-container')?.addEventListener('click', (e) => {
      // Check for expand button click
      const expandBtn = e.target.closest('.source-cell-expand-btn');
      if (expandBtn) {
        e.stopPropagation();
        const fieldName = expandBtn.dataset.fieldName || 'Field';
        const fullValue = expandBtn.dataset.fullValue || '';
        this._showSourceLongTextModal(fieldName, fullValue);
        return;
      }
      // Check for wrapper click (to allow clicking anywhere on the truncated text)
      const wrapper = e.target.closest('.source-cell-longtext-wrapper');
      if (wrapper) {
        e.stopPropagation();
        const btn = wrapper.querySelector('.source-cell-expand-btn');
        if (btn) {
          const fieldName = btn.dataset.fieldName || 'Field';
          const fullValue = btn.dataset.fullValue || '';
          this._showSourceLongTextModal(fieldName, fullValue);
        }
      }
    });
  }

  /**
   * Render source table content based on view mode (unified, split, or cards)
   */
  _renderSourceTableContent(source, fields, records) {
    if (records.length === 0) {
      return `
        <div class="source-empty-state">
          <i class="ph ph-file-dashed"></i>
          <p>No records found in this source</p>
        </div>
      `;
    }

    const viewMode = source.sourceViewMode || 'unified';
    const multiRecord = source.multiRecordAnalysis;

    if (viewMode === 'split' && multiRecord) {
      return this._renderSourceSplitTables(source, fields, records, multiRecord);
    } else if (viewMode === 'cards' && multiRecord) {
      return this._renderSourceCardsView(source, fields, records, multiRecord);
    } else {
      return this._renderSourceUnifiedTable(source, fields, records, multiRecord);
    }
  }

  /**
   * Render unified table view with column shading for different record types
   */
  _renderSourceUnifiedTable(source, fields, records, multiRecord) {
    // Define colors for record types
    // Using higher opacity (0.15) for better visibility and text separation
    const typeColors = [
      { bg: 'var(--type-color-1-bg, rgba(59, 130, 246, 0.15))', border: 'var(--type-color-1-border, rgba(59, 130, 246, 0.35))' },  // blue
      { bg: 'var(--type-color-2-bg, rgba(16, 185, 129, 0.15))', border: 'var(--type-color-2-border, rgba(16, 185, 129, 0.35))' },  // green
      { bg: 'var(--type-color-3-bg, rgba(245, 158, 11, 0.15))', border: 'var(--type-color-3-border, rgba(245, 158, 11, 0.35))' },  // amber
      { bg: 'var(--type-color-4-bg, rgba(139, 92, 246, 0.15))', border: 'var(--type-color-4-border, rgba(139, 92, 246, 0.35))' },  // purple
      { bg: 'var(--type-color-5-bg, rgba(236, 72, 153, 0.15))', border: 'var(--type-color-5-border, rgba(236, 72, 153, 0.35))' },  // pink
    ];

    // Build field-to-type mapping
    const fieldTypeMap = {};
    if (multiRecord) {
      const commonFields = new Set(multiRecord.commonFields || []);
      multiRecord.types.forEach((typeInfo, index) => {
        const color = typeColors[index % typeColors.length];
        (typeInfo.specificFields || []).forEach(fieldName => {
          fieldTypeMap[fieldName] = {
            type: typeInfo.value,
            label: typeInfo.label,
            color: color,
            index: index
          };
        });
      });
    }

    // Group fields by ownership for header row
    const groupedFields = { common: [], typed: {} };
    fields.forEach(field => {
      const typeOwner = fieldTypeMap[field.name];
      if (typeOwner) {
        if (!groupedFields.typed[typeOwner.type]) {
          groupedFields.typed[typeOwner.type] = {
            fields: [],
            color: typeOwner.color,
            label: typeOwner.label,
            index: typeOwner.index
          };
        }
        groupedFields.typed[typeOwner.type].fields.push(field);
      } else {
        groupedFields.common.push(field);
      }
    });

    // Build column group header if we have typed fields
    const hasTypedFields = Object.keys(groupedFields.typed).length > 0;
    let colGroupHeader = '';
    if (hasTypedFields && multiRecord) {
      const sortedTypes = Object.entries(groupedFields.typed)
        .sort((a, b) => a[1].index - b[1].index);

      colGroupHeader = `
        <tr class="source-col-group-header">
          <th class="source-row-num"></th>
          ${groupedFields.common.length > 0 ? `
            <th colspan="${groupedFields.common.length}" class="source-col-group common">
              <span>Common</span>
            </th>
          ` : ''}
          ${sortedTypes.map(([typeName, info]) => `
            <th colspan="${info.fields.length}" class="source-col-group typed" style="background: ${info.color.bg}; border-bottom: 2px solid ${info.color.border};">
              <span>${this._escapeHtml(info.label)}</span>
              <span class="source-col-group-count">${info.fields.length} field${info.fields.length !== 1 ? 's' : ''}</span>
            </th>
          `).join('')}
        </tr>
      `;
    }

    // Reorder fields: common first, then typed groups
    const orderedFields = [...groupedFields.common];
    Object.entries(groupedFields.typed)
      .sort((a, b) => a[1].index - b[1].index)
      .forEach(([_, info]) => {
        orderedFields.push(...info.fields);
      });

    return `
      <table class="source-data-table ${multiRecord ? 'multi-record' : ''}">
        <thead>
          ${colGroupHeader}
          <tr>
            <th class="source-row-num">#</th>
            ${orderedFields.map(field => {
              const typeOwner = fieldTypeMap[field.name];
              const style = typeOwner
                ? `background: ${typeOwner.color.bg};`
                : 'background: var(--common-col-bg, rgba(148, 163, 184, 0.12));';
              return `
                <th style="${style}">
                  <div class="source-col-header">
                    <span class="source-col-name">${this._escapeHtml(field.name)}</span>
                    <span class="source-col-type">${field.type || 'text'}</span>
                  </div>
                </th>
              `;
            }).join('')}
          </tr>
        </thead>
        <tbody>
          ${records.slice(0, 100).map((record, index) => `
            <tr>
              <td class="source-row-num">${index + 1}</td>
              ${orderedFields.map(field => {
                const value = record.values?.[field.id];
                const typeOwner = fieldTypeMap[field.name];
                const bgStyle = typeOwner
                  ? `background: ${typeOwner.color.bg};`
                  : 'background: var(--common-col-bg, rgba(148, 163, 184, 0.12));';
                const cellClass = this._getSourceCellClass(value);
                const displayValue = this._formatSourceCellValue(value, { fieldName: field.name });
                const titleValue = typeof value === 'object' && value !== null ? JSON.stringify(value) : String(value ?? '');
                return `<td class="${cellClass}" style="${bgStyle}" title="${this._escapeHtml(titleValue)}">${displayValue}</td>`;
              }).join('')}
            </tr>
          `).join('')}
        </tbody>
      </table>
      ${records.length > 100 ? `
        <div class="source-more-records">
          <i class="ph ph-info"></i>
          Showing first 100 of ${records.length} records. Export or create a Set to work with all data.
        </div>
      ` : ''}
    `;
  }

  /**
   * Render split sub-tables view, one table per record type
   */
  _renderSourceSplitTables(source, fields, records, multiRecord) {
    const typeField = multiRecord.typeField;
    // Using higher opacity (0.15) for better visibility - consistent with unified view
    const typeColors = [
      { bg: 'var(--type-color-1-bg, rgba(59, 130, 246, 0.15))', border: 'var(--type-color-1-border, rgba(59, 130, 246, 0.35))', text: 'var(--type-color-1-text, #3b82f6)' },
      { bg: 'var(--type-color-2-bg, rgba(16, 185, 129, 0.15))', border: 'var(--type-color-2-border, rgba(16, 185, 129, 0.35))', text: 'var(--type-color-2-text, #10b981)' },
      { bg: 'var(--type-color-3-bg, rgba(245, 158, 11, 0.15))', border: 'var(--type-color-3-border, rgba(245, 158, 11, 0.35))', text: 'var(--type-color-3-text, #f59e0b)' },
      { bg: 'var(--type-color-4-bg, rgba(139, 92, 246, 0.15))', border: 'var(--type-color-4-border, rgba(139, 92, 246, 0.35))', text: 'var(--type-color-4-text, #8b5cf6)' },
      { bg: 'var(--type-color-5-bg, rgba(236, 72, 153, 0.15))', border: 'var(--type-color-5-border, rgba(236, 72, 153, 0.35))', text: 'var(--type-color-5-text, #ec4899)' },
    ];

    // Group records by type
    const recordsByType = {};
    records.forEach(record => {
      const typeValue = record.values?.[typeField] || '_untyped';
      if (!recordsByType[typeValue]) {
        recordsByType[typeValue] = [];
      }
      recordsByType[typeValue].push(record);
    });

    // Build field sets per type (common + type-specific)
    const commonFieldNames = new Set(multiRecord.commonFields || []);
    const typeFieldSets = {};

    multiRecord.types.forEach(typeInfo => {
      const specificFields = new Set(typeInfo.specificFields || []);
      // Get fields that have values for this type
      typeFieldSets[typeInfo.value] = fields.filter(f =>
        commonFieldNames.has(f.name) || specificFields.has(f.name) || f.name === typeField
      );
    });

    // Sort types by the order they appear in multiRecordAnalysis
    const sortedTypes = multiRecord.types.map((t, i) => ({ ...t, index: i }));

    return `
      <div class="source-split-tables">
        ${sortedTypes.map((typeInfo, idx) => {
          const typeValue = typeInfo.value;
          const typeRecords = recordsByType[typeValue] || [];
          const typeFields = typeFieldSets[typeValue] || fields;
          const color = typeColors[idx % typeColors.length];

          if (typeRecords.length === 0) return '';

          return `
            <div class="source-split-table-section" style="border-color: ${color.border};">
              <div class="source-split-table-header" style="background: ${color.bg}; border-bottom-color: ${color.border};">
                <span class="source-split-table-type" style="color: ${color.text};">
                  ${this._escapeHtml(typeInfo.label || typeValue)}
                </span>
                <span class="source-split-table-count">${typeRecords.length} record${typeRecords.length !== 1 ? 's' : ''}</span>
              </div>
              <table class="source-data-table source-split-table">
                <thead>
                  <tr>
                    <th class="source-row-num">#</th>
                    ${typeFields.filter(f => f.name !== typeField).map(field => `
                      <th>
                        <div class="source-col-header">
                          <span class="source-col-name">${this._escapeHtml(field.name)}</span>
                          <span class="source-col-type">${field.type || 'text'}</span>
                        </div>
                      </th>
                    `).join('')}
                  </tr>
                </thead>
                <tbody>
                  ${typeRecords.slice(0, 50).map((record, index) => `
                    <tr>
                      <td class="source-row-num">${index + 1}</td>
                      ${typeFields.filter(f => f.name !== typeField).map(field => {
                        const value = record.values?.[field.id];
                        const cellClass = this._getSourceCellClass(value);
                        const displayValue = this._formatSourceCellValue(value, { fieldName: field.name });
                        const titleValue = typeof value === 'object' && value !== null ? JSON.stringify(value) : String(value ?? '');
                        return `<td class="${cellClass}" title="${this._escapeHtml(titleValue)}">${displayValue}</td>`;
                      }).join('')}
                    </tr>
                  `).join('')}
                </tbody>
              </table>
              ${typeRecords.length > 50 ? `
                <div class="source-more-records">
                  <i class="ph ph-info"></i>
                  Showing first 50 of ${typeRecords.length} ${this._escapeHtml(typeInfo.label || typeValue)} records.
                </div>
              ` : ''}
            </div>
          `;
        }).join('')}
      </div>
    `;
  }

  /**
   * Render cards view showing record types as visual cards with key stats
   */
  _renderSourceCardsView(source, fields, records, multiRecord) {
    const typeField = multiRecord.typeField;
    const typeColors = [
      { bg: 'var(--type-color-1-bg, rgba(59, 130, 246, 0.08))', border: 'var(--type-color-1-border, rgba(59, 130, 246, 0.3))', text: 'var(--type-color-1-text, #3b82f6)', solid: '#3b82f6' },
      { bg: 'var(--type-color-2-bg, rgba(16, 185, 129, 0.08))', border: 'var(--type-color-2-border, rgba(16, 185, 129, 0.3))', text: 'var(--type-color-2-text, #10b981)', solid: '#10b981' },
      { bg: 'var(--type-color-3-bg, rgba(245, 158, 11, 0.08))', border: 'var(--type-color-3-border, rgba(245, 158, 11, 0.3))', text: 'var(--type-color-3-text, #f59e0b)', solid: '#f59e0b' },
      { bg: 'var(--type-color-4-bg, rgba(139, 92, 246, 0.08))', border: 'var(--type-color-4-border, rgba(139, 92, 246, 0.3))', text: 'var(--type-color-4-text, #8b5cf6)', solid: '#8b5cf6' },
      { bg: 'var(--type-color-5-bg, rgba(236, 72, 153, 0.08))', border: 'var(--type-color-5-border, rgba(236, 72, 153, 0.3))', text: 'var(--type-color-5-text, #ec4899)', solid: '#ec4899' },
    ];

    // Group records by type
    const recordsByType = {};
    records.forEach(record => {
      const typeValue = record.values?.[typeField] || '_untyped';
      if (!recordsByType[typeValue]) {
        recordsByType[typeValue] = [];
      }
      recordsByType[typeValue].push(record);
    });

    // Build common and specific field sets
    const commonFieldNames = new Set(multiRecord.commonFields || []);
    const typeFieldSets = {};

    multiRecord.types.forEach(typeInfo => {
      const specificFields = new Set(typeInfo.specificFields || []);
      typeFieldSets[typeInfo.value] = {
        common: fields.filter(f => commonFieldNames.has(f.name)),
        specific: fields.filter(f => specificFields.has(f.name))
      };
    });

    // Sort types by the order they appear in multiRecordAnalysis
    const sortedTypes = multiRecord.types.map((t, i) => ({ ...t, index: i }));
    const totalRecords = records.length;

    return `
      <div class="source-cards-view">
        <div class="source-cards-grid">
          ${sortedTypes.map((typeInfo, idx) => {
            const typeValue = typeInfo.value;
            const typeRecords = recordsByType[typeValue] || [];
            const color = typeColors[idx % typeColors.length];
            const fieldSet = typeFieldSets[typeValue] || { common: [], specific: [] };
            const percentage = totalRecords > 0 ? ((typeRecords.length / totalRecords) * 100).toFixed(1) : 0;

            if (typeRecords.length === 0) return '';

            return `
              <div class="source-type-card" style="border-color: ${color.border};">
                <div class="source-type-card-header" style="background: ${color.bg}; border-bottom-color: ${color.border};">
                  <div class="source-type-card-icon" style="background: ${color.solid};">
                    <i class="ph ph-database"></i>
                  </div>
                  <div class="source-type-card-title">
                    <span class="source-type-card-name" style="color: ${color.text};">
                      ${this._escapeHtml(typeInfo.label || typeValue)}
                    </span>
                    <span class="source-type-card-badge">${percentage}%</span>
                  </div>
                </div>
                <div class="source-type-card-body">
                  <div class="source-type-card-stat source-type-card-stat-primary">
                    <span class="source-type-card-stat-value">${typeRecords.length.toLocaleString()}</span>
                    <span class="source-type-card-stat-label">Records</span>
                  </div>
                  <div class="source-type-card-stats-row">
                    <div class="source-type-card-stat">
                      <span class="source-type-card-stat-value">${fieldSet.common.length}</span>
                      <span class="source-type-card-stat-label">Common Fields</span>
                    </div>
                    <div class="source-type-card-stat">
                      <span class="source-type-card-stat-value">${fieldSet.specific.length}</span>
                      <span class="source-type-card-stat-label">Specific Fields</span>
                    </div>
                  </div>
                  ${fieldSet.specific.length > 0 ? `
                    <div class="source-type-card-fields">
                      <span class="source-type-card-fields-label">Unique fields:</span>
                      <div class="source-type-card-fields-list">
                        ${fieldSet.specific.slice(0, 6).map(f => `
                          <span class="source-type-card-field-tag" style="background: ${color.bg}; border-color: ${color.border}; color: ${color.text};">
                            ${this._escapeHtml(f.name)}
                          </span>
                        `).join('')}
                        ${fieldSet.specific.length > 6 ? `
                          <span class="source-type-card-field-more">+${fieldSet.specific.length - 6} more</span>
                        ` : ''}
                      </div>
                    </div>
                  ` : ''}
                </div>
                <div class="source-type-card-footer" style="border-top-color: ${color.border};">
                  <div class="source-type-card-progress">
                    <div class="source-type-card-progress-bar" style="width: ${percentage}%; background: ${color.solid};"></div>
                  </div>
                </div>
              </div>
            `;
          }).join('')}
        </div>
        <div class="source-cards-summary">
          <div class="source-cards-summary-item">
            <i class="ph ph-stack"></i>
            <span>${sortedTypes.length} record types</span>
          </div>
          <div class="source-cards-summary-item">
            <i class="ph ph-rows"></i>
            <span>${totalRecords.toLocaleString()} total records</span>
          </div>
          <div class="source-cards-summary-item">
            <i class="ph ph-columns"></i>
            <span>${multiRecord.commonFields?.length || 0} common fields</span>
          </div>
        </div>
      </div>
    `;
  }

  /**
   * Compute multi-record analysis on-the-fly for sources that don't have it stored.
   * Detects if records have different schemas based on a type field.
   */
  _computeMultiRecordAnalysis(records, fields) {
    if (!records || records.length < 2) return null;

    // Look for a type field
    const typeFieldCandidates = ['type', '_type', 'recordType', 'record_type', 'kind', 'category', 'filetype'];
    const fieldNames = fields.map(f => f.name);

    let typeField = null;
    for (const candidate of typeFieldCandidates) {
      if (fieldNames.includes(candidate)) {
        typeField = candidate;
        break;
      }
    }

    if (!typeField) return null;

    // Get unique type values
    const typeValues = new Set();
    records.forEach(r => {
      const val = r[typeField];
      if (val !== null && val !== undefined && val !== '') {
        typeValues.add(val);
      }
    });

    // Need at least 2 types for this to be relevant
    if (typeValues.size < 2) return null;

    // Group records by type and track which fields have values
    const typeSchemas = {};
    for (const record of records) {
      const typeValue = record[typeField] || '_untyped';

      if (!typeSchemas[typeValue]) {
        typeSchemas[typeValue] = {
          count: 0,
          fieldsWithValues: new Set()
        };
      }

      typeSchemas[typeValue].count++;

      for (const field of fields) {
        const val = record[field.name];
        if (val !== null && val !== undefined && val !== '') {
          typeSchemas[typeValue].fieldsWithValues.add(field.name);
        }
      }
    }

    // Calculate common and type-specific fields
    const types = Object.keys(typeSchemas);
    const allFields = new Set();
    for (const type of types) {
      for (const field of typeSchemas[type].fieldsWithValues) {
        if (field !== typeField) allFields.add(field);
      }
    }

    const commonFields = [];
    const typeSpecificFields = {};

    for (const field of allFields) {
      const typesWithField = types.filter(t => typeSchemas[t].fieldsWithValues.has(field));
      if (typesWithField.length === types.length) {
        commonFields.push(field);
      } else {
        for (const t of typesWithField) {
          if (!typeSpecificFields[t]) typeSpecificFields[t] = [];
          typeSpecificFields[t].push(field);
        }
      }
    }

    // Check if there's meaningful divergence (at least one type has specific fields)
    const hasSpecificFields = Object.values(typeSpecificFields).some(arr => arr.length > 0);
    if (!hasSpecificFields) return null;

    // Build the analysis result
    const divergenceScore = allFields.size > 0 ? 1 - (commonFields.length / allFields.size) : 0;

    return {
      typeField: typeField,
      types: types.map(t => ({
        value: t,
        label: t,
        count: typeSchemas[t].count,
        specificFields: typeSpecificFields[t] || []
      })).sort((a, b) => b.count - a.count),
      commonFields: commonFields,
      divergenceScore: divergenceScore
    };
  }

  /**
   * Show sources as a table view in the main content area
   * Each row represents a source with its metadata
   */
  _showSourcesTableView() {
    const contentArea = this.elements.contentArea;
    if (!contentArea) return;

    // Get sources filtered by current project hierarchy
    const activeSources = this._getProjectSources();

    // Sort by import date (newest first)
    const sortedSources = activeSources.sort((a, b) => {
      if (!a.importedAt) return 1;
      if (!b.importedAt) return -1;
      return new Date(b.importedAt) - new Date(a.importedAt);
    });

    // Mark that we're viewing the sources table
    this.currentSourceId = 'sources-table';

    // Clear set/view selection in sidebar
    document.querySelectorAll('.set-item, .source-item').forEach(item => {
      item.classList.remove('active');
    });

    // Update breadcrumb
    this._updateBreadcrumb({
      workspace: this._getCurrentWorkspaceName(),
      set: 'Sources',
      view: 'Table View'
    });

    // Build the sources table HTML
    contentArea.innerHTML = `
      <div class="sources-table-view">
        <!-- Header -->
        <div class="sources-table-header">
          <div class="sources-table-title">
            <div class="sources-table-icon">
              <i class="ph ph-download-simple"></i>
            </div>
            <div class="sources-table-info">
              <h2>
                <span>Sources</span>
                <span class="given-badge">
                  <i class="ph ph-lock-simple"></i>
                  GIVEN
                </span>
              </h2>
              <div class="sources-table-meta">
                ${sortedSources.length} source${sortedSources.length !== 1 ? 's' : ''}${this.currentProjectId ? ` in ${this._escapeHtml(this._getCurrentProjectName())}` : ' imported'}
              </div>
            </div>
          </div>
          <div class="sources-table-actions">
            <button class="source-action-btn" id="sources-table-import-btn" title="Import new data">
              <i class="ph ph-plus"></i>
              <span>Import</span>
            </button>
          </div>
        </div>

        <!-- Toolbar -->
        <div class="sources-table-toolbar">
          <div class="sources-table-search">
            <i class="ph ph-magnifying-glass"></i>
            <input type="text" id="sources-table-search" placeholder="Search sources...">
          </div>
          <div class="sources-table-count">
            ${sortedSources.length} source${sortedSources.length !== 1 ? 's' : ''}
          </div>
        </div>

        <!-- Table -->
        <div class="sources-table-container">
          ${sortedSources.length > 0 ? `
            <table class="sources-table">
              <thead>
                <tr>
                  <th class="col-icon"></th>
                  <th class="col-name">Name</th>
                  <th class="col-type">Type</th>
                  <th class="col-records">Records</th>
                  <th class="col-fields">Fields</th>
                  <th class="col-imported">Imported</th>
                  <th class="col-agent">Agent</th>
                  <th class="col-derived">Lenses</th>
                  <th class="col-actions"></th>
                </tr>
              </thead>
              <tbody>
                ${sortedSources.map(source => {
                  const icon = this._getSourceIcon(source.name);
                  const fileType = this._getSourceFileType(source.name);
                  const recordCount = source.recordCount || source.records?.length || 0;
                  const fieldCount = source.schema?.fields?.length || 0;
                  const importDate = source.importedAt ? new Date(source.importedAt).toLocaleDateString() : 'Unknown';
                  const agent = source.provenance?.agent || '(not set)';
                  const derivedSets = this.sets.filter(set => {
                    const prov = set.datasetProvenance;
                    return prov?.sourceId === source.id ||
                           prov?.originalFilename?.toLowerCase() === source.name.toLowerCase();
                  });

                  return `
                    <tr class="sources-table-row" data-source-id="${source.id}">
                      <td class="col-icon">
                        <i class="ph ${icon}"></i>
                      </td>
                      <td class="col-name">
                        <span class="source-name-text">${this._escapeHtml(source.name)}</span>
                      </td>
                      <td class="col-type">
                        <span class="source-type-badge">${fileType}</span>
                      </td>
                      <td class="col-records">${recordCount.toLocaleString()}</td>
                      <td class="col-fields">${fieldCount}</td>
                      <td class="col-imported">${importDate}</td>
                      <td class="col-agent" title="${this._escapeHtml(agent)}">
                        ${this._escapeHtml(this._truncateText(agent, 20))}
                      </td>
                      <td class="col-derived">
                        ${derivedSets.length > 0 ? `
                          <span class="derived-sets-badge" title="${derivedSets.map(s => s.name).join(', ')}">
                            ${derivedSets.length}
                          </span>
                        ` : '-'}
                      </td>
                      <td class="col-actions">
                        <button class="sources-table-action-btn" data-action="view" title="View source data">
                          <i class="ph ph-eye"></i>
                        </button>
                        <button class="sources-table-action-btn" data-action="create-set" title="Create set from source">
                          <i class="ph ph-git-branch"></i>
                        </button>
                        <button class="sources-table-action-btn" data-action="export" title="Export source">
                          <i class="ph ph-export"></i>
                        </button>
                        <button class="sources-table-action-btn sources-table-delete-btn" data-action="delete" title="Delete source">
                          <i class="ph ph-trash"></i>
                        </button>
                      </td>
                    </tr>
                  `;
                }).join('')}
              </tbody>
            </table>
          ` : `
            <div class="sources-table-empty">
              <i class="ph ph-file-arrow-down"></i>
              <p>No sources imported yet</p>
              <button class="btn-primary" id="sources-table-first-import">
                <i class="ph ph-plus"></i>
                Import your first data file
              </button>
            </div>
          `}
        </div>
      </div>
    `;

    // Attach event handlers
    this._attachSourcesTableHandlers(sortedSources);
  }

  /**
   * Get file type label from source name
   */
  _getSourceFileType(name) {
    const ext = name?.split('.').pop()?.toLowerCase();
    switch (ext) {
      case 'csv': return 'CSV';
      case 'json': return 'JSON';
      case 'ics': return 'ICS';
      case 'xlsx':
      case 'xls': return 'Excel';
      default: return ext?.toUpperCase() || 'File';
    }
  }

  /**
   * Truncate text to specified length with ellipsis
   */
  _truncateText(text, maxLength) {
    if (!text || text.length <= maxLength) return text || '';
    return text.substring(0, maxLength) + '...';
  }

  /**
   * Attach event handlers for sources table view
   */
  _attachSourcesTableHandlers(sources) {
    // Import button
    document.getElementById('sources-table-import-btn')?.addEventListener('click', () => {
      this._showImportModal();
    });

    // First import button (empty state)
    document.getElementById('sources-table-first-import')?.addEventListener('click', () => {
      this._showImportModal();
    });

    // Search
    const searchInput = document.getElementById('sources-table-search');
    searchInput?.addEventListener('input', (e) => {
      this._filterSourcesTable(e.target.value);
    });

    // Row click to view source
    document.querySelectorAll('.sources-table-row').forEach(row => {
      row.addEventListener('click', (e) => {
        // Ignore if clicking action buttons
        if (e.target.closest('.sources-table-action-btn')) return;

        const sourceId = row.dataset.sourceId;
        // Switch back to list view and show the source
        this.sourcesViewMode = 'list';
        this._renderSourcesNav();
        this._showSourceDetail(sourceId);
      });

      row.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        this._showSourceContextMenu(e, row.dataset.sourceId);
      });
    });

    // Action buttons
    document.querySelectorAll('.sources-table-action-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const row = btn.closest('.sources-table-row');
        const sourceId = row.dataset.sourceId;
        const action = btn.dataset.action;
        const source = this.sources.find(s => s.id === sourceId);

        if (!source) return;

        switch (action) {
          case 'view':
            this.sourcesViewMode = 'list';
            this._renderSourcesNav();
            this._showSourceDetail(sourceId);
            break;
          case 'create-set':
            this._createSetFromSource(source);
            break;
          case 'export':
            this._exportSource(sourceId);
            break;
          case 'delete':
            this._deleteSource(sourceId);
            break;
        }
      });
    });
  }

  /**
   * Filter sources table by search term
   */
  _filterSourcesTable(searchTerm) {
    const rows = document.querySelectorAll('.sources-table-row');
    const term = searchTerm.toLowerCase().trim();
    let visibleCount = 0;

    rows.forEach(row => {
      const sourceId = row.dataset.sourceId;
      const source = this.sources.find(s => s.id === sourceId);
      if (!source) {
        row.style.display = 'none';
        return;
      }

      const searchFields = [
        source.name,
        source.provenance?.agent,
        this._getSourceFileType(source.name)
      ].filter(Boolean).join(' ').toLowerCase();

      const matches = !term || searchFields.includes(term);
      row.style.display = matches ? '' : 'none';
      if (matches) visibleCount++;
    });

    // Update count display
    const countEl = document.querySelector('.sources-table-count');
    if (countEl) {
      const total = this.sources.filter(s => s.status !== 'archived').length;
      countEl.textContent = term
        ? `${visibleCount} of ${total} source${total !== 1 ? 's' : ''}`
        : `${total} source${total !== 1 ? 's' : ''}`;
    }
  }

  // ==========================================================================
  // Sets Table View
  // ==========================================================================

  /**
   * Show sets as a table view in the main content area
   * Each row represents a set with its metadata
   */
  _showSetsTableView() {
    const contentArea = this.elements.contentArea;
    if (!contentArea) return;

    // Get all sets filtered by project
    const filteredSets = this._getProjectSets();

    // Sort by creation date (newest first)
    const sortedSets = filteredSets.sort((a, b) => {
      if (!a.createdAt) return 1;
      if (!b.createdAt) return -1;
      return new Date(b.createdAt) - new Date(a.createdAt);
    });

    // Mark that we're viewing the sets table
    this.currentSetId = 'sets-table';
    this.currentSourceId = null;
    this.currentDefinitionId = null;
    this.currentViewId = null;

    // Clear set/view selection in sidebar
    document.querySelectorAll('.set-item, .source-item').forEach(item => {
      item.classList.remove('active');
    });

    // Update breadcrumb
    this._updateBreadcrumb({
      workspace: this._getCurrentWorkspaceName(),
      set: 'Sets',
      view: 'Table View'
    });

    // Build the sets table HTML
    contentArea.innerHTML = `
      <div class="sources-table-view sets-table-view">
        <!-- Header -->
        <div class="sources-table-header">
          <div class="sources-table-title">
            <div class="sources-table-icon">
              <i class="ph ph-database"></i>
            </div>
            <div class="sources-table-info">
              <h2>
                <span>Sets</span>
                <span class="schema-badge" style="margin-left: 8px; font-size: 11px; padding: 2px 8px; border-radius: 4px; background: var(--accent-purple, #8b5cf6); color: white;">
                  SCHEMA
                </span>
              </h2>
              <div class="sources-table-meta">
                ${sortedSets.length} set${sortedSets.length !== 1 ? 's' : ''}${this.currentProjectId ? ` in ${this._escapeHtml(this._getCurrentProjectName())}` : ' in workspace'}
              </div>
            </div>
          </div>
          <div class="sources-table-actions">
            <button class="source-action-btn" id="sets-table-new-btn" title="Create new set">
              <i class="ph ph-plus"></i>
              <span>New Set</span>
            </button>
          </div>
        </div>

        <!-- Toolbar -->
        <div class="sources-table-toolbar">
          <div class="sources-table-search">
            <i class="ph ph-magnifying-glass"></i>
            <input type="text" id="sets-table-search" placeholder="Search sets...">
          </div>
          <div class="sources-table-count">
            ${sortedSets.length} set${sortedSets.length !== 1 ? 's' : ''}
          </div>
        </div>

        <!-- Table -->
        <div class="sources-table-container">
          ${sortedSets.length > 0 ? `
            <table class="sources-table sets-table">
              <thead>
                <tr>
                  <th class="col-icon"></th>
                  <th class="col-name">Name</th>
                  <th class="col-operator">Operator</th>
                  <th class="col-records">Records</th>
                  <th class="col-fields">Fields</th>
                  <th class="col-views">Views</th>
                  <th class="col-lenses">Lenses</th>
                  <th class="col-source">Source</th>
                  <th class="col-created">Created</th>
                  <th class="col-actions"></th>
                </tr>
              </thead>
              <tbody>
                ${sortedSets.map(set => {
                  const icon = set.icon || 'ph-database';
                  const recordCount = set.records?.length || 0;
                  const fieldCount = set.fields?.length || 0;
                  const viewCount = set.views?.length || 0;
                  const lensCount = set.lenses?.length || 0;
                  const createdDate = set.createdAt ? new Date(set.createdAt).toLocaleDateString() : 'Unknown';

                  // Get derivation info
                  const derivation = this._getSetDerivationInfo(set);
                  const operatorBadge = derivation.operator;
                  const operatorBadges = {
                    'SEG': { symbol: '｜', color: '#a855f7', title: 'Segmented (filtered)' },
                    'CON': { symbol: '⋈', color: '#3b82f6', title: 'Connected (joined)' },
                    'ALT': { symbol: '∿', color: '#22c55e', title: 'Alternated (transformed)' },
                    'SYN': { symbol: '∨', color: '#f97316', title: 'Synthesized (merged)' },
                    'INS': { symbol: '△', color: '#6b7280', title: 'Instantiated (created)' }
                  };
                  const opInfo = operatorBadges[operatorBadge] || operatorBadges['INS'];

                  // Get source name
                  const sourceName = this._getSetSourceName(set);

                  return `
                    <tr class="sources-table-row sets-table-row" data-set-id="${set.id}">
                      <td class="col-icon">
                        <i class="ph ${icon}"></i>
                      </td>
                      <td class="col-name">
                        <span class="set-name-text">${this._escapeHtml(set.name)}</span>
                      </td>
                      <td class="col-operator">
                        <span class="operator-badge" style="background: ${opInfo.color}; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; font-weight: 600;" title="${opInfo.title}">
                          ${operatorBadge}
                        </span>
                      </td>
                      <td class="col-records">${recordCount.toLocaleString()}</td>
                      <td class="col-fields">${fieldCount}</td>
                      <td class="col-views">${viewCount}</td>
                      <td class="col-lenses">${lensCount}</td>
                      <td class="col-source" title="${this._escapeHtml(sourceName)}">
                        ${this._escapeHtml(this._truncateText(sourceName, 20))}
                      </td>
                      <td class="col-created">${createdDate}</td>
                      <td class="col-actions">
                        <button class="sources-table-action-btn" data-action="view" title="View set">
                          <i class="ph ph-eye"></i>
                        </button>
                        <button class="sources-table-action-btn" data-action="edit" title="Edit fields">
                          <i class="ph ph-pencil"></i>
                        </button>
                        <button class="sources-table-action-btn" data-action="export" title="Export set">
                          <i class="ph ph-export"></i>
                        </button>
                        <button class="sources-table-action-btn sources-table-delete-btn" data-action="delete" title="Delete set">
                          <i class="ph ph-trash"></i>
                        </button>
                      </td>
                    </tr>
                  `;
                }).join('')}
              </tbody>
            </table>
          ` : `
            <div class="sources-table-empty">
              <i class="ph ph-database"></i>
              <p>No sets created yet</p>
              <button class="btn-primary" id="sets-table-first-create">
                <i class="ph ph-plus"></i>
                Create your first set
              </button>
            </div>
          `}
        </div>
      </div>
    `;

    // Attach event handlers
    this._attachSetsTableHandlers(sortedSets);
  }

  /**
   * Get the source name for a set (from provenance or source bindings)
   */
  _getSetSourceName(set) {
    // Check dataset provenance first
    if (set.datasetProvenance?.originalFilename) {
      return set.datasetProvenance.originalFilename;
    }

    // Check source bindings
    if (set.sourceBindings?.length > 0) {
      const sourceId = set.sourceBindings[0].sourceId;
      const source = this.sources.find(s => s.id === sourceId);
      if (source) return source.name;
    }

    // Check derivation source items
    if (set.derivation?.sourceItems?.length > 0) {
      const firstSource = set.derivation.sourceItems[0];
      if (firstSource.type === 'source') {
        const source = this.sources.find(s => s.id === firstSource.id);
        if (source) return source.name;
      } else if (firstSource.type === 'set') {
        const sourceSet = this.sets.find(s => s.id === firstSource.id);
        if (sourceSet) return `← ${sourceSet.name}`;
      }
    }

    return '(manual)';
  }

  /**
   * Attach event handlers for sets table view
   */
  _attachSetsTableHandlers(sets) {
    // New set button
    document.getElementById('sets-table-new-btn')?.addEventListener('click', () => {
      this._showNewSetModal();
    });

    // First create button (empty state)
    document.getElementById('sets-table-first-create')?.addEventListener('click', () => {
      this._showNewSetModal();
    });

    // Search
    const searchInput = document.getElementById('sets-table-search');
    searchInput?.addEventListener('input', (e) => {
      this._filterSetsTable(e.target.value);
    });

    // Row click to view set
    document.querySelectorAll('.sets-table-row').forEach(row => {
      row.addEventListener('click', (e) => {
        // Ignore if clicking action buttons
        if (e.target.closest('.sources-table-action-btn')) return;

        const setId = row.dataset.setId;
        this._selectSet(setId);
      });

      row.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        this._showSetContextMenu(e, row.dataset.setId);
      });
    });

    // Action buttons
    document.querySelectorAll('.sets-table-row .sources-table-action-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const row = btn.closest('.sets-table-row');
        const setId = row.dataset.setId;
        const action = btn.dataset.action;
        const set = this.sets.find(s => s.id === setId);

        if (!set) return;

        switch (action) {
          case 'view':
            this._selectSet(setId);
            break;
          case 'edit':
            this._selectSet(setId, 'schema');
            break;
          case 'export':
            this._exportSet(setId);
            break;
          case 'delete':
            this._deleteSet(setId);
            break;
        }
      });
    });
  }

  /**
   * Filter sets table by search term
   */
  _filterSetsTable(searchTerm) {
    const rows = document.querySelectorAll('.sets-table-row');
    const term = searchTerm.toLowerCase().trim();
    let visibleCount = 0;

    rows.forEach(row => {
      const setId = row.dataset.setId;
      const set = this.sets.find(s => s.id === setId);
      if (!set) {
        row.style.display = 'none';
        return;
      }

      const searchFields = [
        set.name,
        this._getSetSourceName(set),
        set.derivation?.strategy
      ].filter(Boolean).join(' ').toLowerCase();

      const matches = !term || searchFields.includes(term);
      row.style.display = matches ? '' : 'none';
      if (matches) visibleCount++;
    });

    // Update count display
    const countEl = document.querySelector('.sources-table-count');
    if (countEl) {
      const total = this._getProjectSets().length;
      countEl.textContent = term
        ? `${visibleCount} of ${total} set${total !== 1 ? 's' : ''}`
        : `${total} set${total !== 1 ? 's' : ''}`;
    }
  }

  // ==========================================================================
  // Source Provenance Display
  // ==========================================================================

  /**
   * Render source provenance items for display
   * Shows all 9 provenance elements grouped by triad with values or placeholders
   */
  _renderSourceProvenanceItems(source) {
    const prov = source.provenance || {};

    // Define the 9 provenance elements grouped by triad
    const triads = [
      {
        name: 'Epistemic',
        subtitle: 'How was this produced?',
        icon: 'ph-brain',
        elements: [
          { key: 'agent', label: 'Agent', icon: 'ph-user', description: 'Who provided this data' },
          { key: 'method', label: 'Method', icon: 'ph-flask', description: 'How it was produced' },
          { key: 'source', label: 'Source', icon: 'ph-file-text', description: 'Where it came from' }
        ]
      },
      {
        name: 'Semantic',
        subtitle: 'What does it mean?',
        icon: 'ph-book-open',
        elements: [
          { key: 'term', label: 'Term', icon: 'ph-bookmark', description: 'Key concept' },
          { key: 'definition', label: 'Definition', icon: 'ph-book-open', description: 'What it means here' },
          { key: 'jurisdiction', label: 'Jurisdiction', icon: 'ph-map-pin', description: 'Scope or authority' }
        ]
      },
      {
        name: 'Situational',
        subtitle: 'When/where does it hold?',
        icon: 'ph-compass',
        elements: [
          { key: 'scale', label: 'Scale', icon: 'ph-arrows-out', description: 'Operational level' },
          { key: 'timeframe', label: 'Timeframe', icon: 'ph-calendar', description: 'Observation period' },
          { key: 'background', label: 'Background', icon: 'ph-info', description: 'Enabling conditions' }
        ]
      }
    ];

    // Count filled elements for status
    const allKeys = ['agent', 'method', 'source', 'term', 'definition', 'jurisdiction', 'scale', 'timeframe', 'background'];
    const filledCount = allKeys.filter(k => this._getProvenanceValue(prov[k])).length;
    const statusClass = filledCount === 9 ? 'complete' : filledCount > 0 ? 'partial' : 'none';
    const statusText = filledCount === 9 ? 'Complete' : filledCount > 0 ? `${filledCount}/9 filled` : 'Not set';

    return `
      <div class="source-prov-status ${statusClass}">
        <span class="source-prov-indicator">${filledCount === 9 ? '◉' : filledCount > 0 ? '◐' : '○'}</span>
        <span class="source-prov-status-text">${statusText}</span>
      </div>
      ${triads.map(triad => {
        const hasAnyValue = triad.elements.some(el => this._getProvenanceValue(prov[el.key]));
        return `
          <div class="source-prov-triad ${hasAnyValue ? '' : 'empty'}">
            <div class="source-prov-triad-header">
              <i class="ph ${triad.icon}"></i>
              <span class="source-prov-triad-name">${triad.name}</span>
              <span class="source-prov-triad-subtitle">${triad.subtitle}</span>
            </div>
            ${triad.elements.map(el => {
              const value = this._getProvenanceValue(prov[el.key]);
              const isEmpty = !value;
              return `
                <div class="source-provenance-item ${isEmpty ? 'empty' : ''}">
                  <i class="ph ${el.icon}"></i>
                  <div>
                    <span class="label">${el.label}</span>
                    <span class="value ${isEmpty ? 'placeholder' : ''}" title="${el.description}">${this._escapeHtml(value || '(not set)')}</span>
                  </div>
                </div>
              `;
            }).join('')}
          </div>
        `;
      }).join('')}
    `;
  }

  /**
   * Render file metadata section for source detail view
   * Shows extracted file identity and parsing decisions
   */
  _renderSourceFileMetadata(source) {
    const fileId = source.fileIdentity || {};
    const parsing = source.parsingDecisions || {};
    const schema = source.schema || {};

    const metadataItems = [];

    // File identity metadata
    if (fileId.originalFilename) {
      metadataItems.push({ label: 'Original Filename', value: fileId.originalFilename, icon: 'ph-file' });
    }
    if (fileId.rawSize) {
      const sizeStr = this._formatFileSize(fileId.rawSize);
      metadataItems.push({ label: 'File Size', value: sizeStr, icon: 'ph-hard-drive' });
    }
    if (fileId.mimeType) {
      metadataItems.push({ label: 'MIME Type', value: fileId.mimeType, icon: 'ph-file-code' });
    }
    if (fileId.encoding) {
      metadataItems.push({ label: 'Encoding', value: fileId.encoding, icon: 'ph-text-aa' });
    }
    if (fileId.contentHash) {
      const shortHash = fileId.contentHash.substring(0, 16) + '...';
      metadataItems.push({ label: 'SHA-256 Hash', value: shortHash, icon: 'ph-fingerprint', fullValue: fileId.contentHash });
    }
    if (fileId.lastModified) {
      metadataItems.push({ label: 'File Modified', value: new Date(fileId.lastModified).toLocaleString(), icon: 'ph-clock' });
    }

    // Parsing decisions metadata
    if (parsing.delimiterDetected || parsing.delimiter) {
      const delim = parsing.delimiterDetected || parsing.delimiter;
      const delimDisplay = delim === ',' ? 'comma (,)' : delim === '\t' ? 'tab' : delim === ';' ? 'semicolon (;)' : delim === '|' ? 'pipe (|)' : `"${delim}"`;
      metadataItems.push({ label: 'Delimiter', value: delimDisplay, icon: 'ph-split-horizontal' });
    }
    if (parsing.delimiterConfidence) {
      metadataItems.push({ label: 'Delimiter Confidence', value: `${(parsing.delimiterConfidence * 100).toFixed(0)}%`, icon: 'ph-chart-bar' });
    }
    if (typeof parsing.headerDetected === 'boolean' || typeof parsing.hasHeaders === 'boolean') {
      const hasHeaders = parsing.headerDetected ?? parsing.hasHeaders;
      metadataItems.push({ label: 'Headers Detected', value: hasHeaders ? 'Yes' : 'No', icon: 'ph-rows' });
    }
    if (parsing.headerConfidence) {
      metadataItems.push({ label: 'Header Confidence', value: `${(parsing.headerConfidence * 100).toFixed(0)}%`, icon: 'ph-chart-bar' });
    }
    if (parsing.quotedFieldsFound) {
      metadataItems.push({ label: 'Quoted Fields', value: 'Yes', icon: 'ph-quotes' });
    }
    if (parsing.lineEndingNormalized) {
      const endingType = parsing.originalLineEnding === '\r\n' ? 'CRLF (Windows)' : parsing.originalLineEnding === '\r' ? 'CR (Mac)' : 'LF (Unix)';
      metadataItems.push({ label: 'Line Ending', value: endingType, icon: 'ph-arrow-line-down' });
    }
    if (parsing.processingTimeMs) {
      metadataItems.push({ label: 'Parse Time', value: `${parsing.processingTimeMs}ms`, icon: 'ph-timer' });
    }

    // Schema inference metadata
    if (schema.inferenceDecisions) {
      const inf = schema.inferenceDecisions;
      if (inf.fieldsInferred) {
        metadataItems.push({ label: 'Fields Inferred', value: inf.fieldsInferred, icon: 'ph-columns' });
      }
      if (inf.typesInferred) {
        const typeList = Object.entries(inf.typesInferred).map(([t, c]) => `${t}: ${c}`).join(', ');
        metadataItems.push({ label: 'Types Detected', value: typeList, icon: 'ph-code' });
      }
    }

    if (metadataItems.length === 0) {
      return '';
    }

    return `
      <div class="source-file-metadata">
        <div class="source-file-metadata-header">
          <i class="ph ph-file-magnifying-glass"></i>
          <span>File Metadata</span>
        </div>
        <div class="source-file-metadata-items">
          ${metadataItems.map(item => `
            <div class="source-file-metadata-item" ${item.fullValue ? `title="${this._escapeHtml(item.fullValue)}"` : ''}>
              <i class="ph ${item.icon}"></i>
              <span class="label">${item.label}</span>
              <span class="value">${this._escapeHtml(String(item.value))}</span>
            </div>
          `).join('')}
        </div>
      </div>
    `;
  }

  /**
   * Rename a source - opens inline editor
   */
  _renameSource(sourceId) {
    const source = this.sources?.find(s => s.id === sourceId);
    if (!source) {
      this._showToast('Source not found', 'error');
      return;
    }

    const nameDisplay = document.getElementById('source-name-display');
    if (!nameDisplay) {
      // Fall back to prompt if not in source view
      const newName = prompt('Rename source:', source.name);
      if (newName && newName.trim() && newName !== source.name) {
        this._updateSourceName(source, newName.trim());
      }
      return;
    }

    const oldName = source.name;
    const rect = nameDisplay.getBoundingClientRect();

    // Create inline editor
    nameDisplay.innerHTML = `
      <input type="text" class="source-name-input" id="source-name-input"
             value="${this._escapeHtml(oldName)}"
             style="font-size: inherit; font-weight: inherit; padding: 2px 8px;
                    border: 2px solid var(--primary-500); border-radius: 4px;
                    outline: none; min-width: 200px;">
    `;

    const input = document.getElementById('source-name-input');
    input.focus();
    input.select();

    const saveEdit = () => {
      const newName = input.value.trim();
      if (newName && newName !== oldName) {
        this._updateSourceName(source, newName);
      } else {
        nameDisplay.textContent = oldName;
      }
    };

    input.addEventListener('blur', saveEdit);
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        saveEdit();
      } else if (e.key === 'Escape') {
        nameDisplay.textContent = oldName;
      }
    });
  }

  /**
   * Update source name with history tracking
   */
  _updateSourceName(source, newName) {
    const oldName = source.name;

    // Initialize edit history if needed
    if (!source.editHistory) {
      source.editHistory = [];
    }

    // Record the edit
    source.editHistory.unshift({
      timestamp: new Date().toISOString(),
      field: 'name',
      oldValue: oldName,
      newValue: newName,
      actor: 'user' // Could be expanded to track actual user
    });

    // Update the name
    source.name = newName;
    source.updatedAt = new Date().toISOString();

    // Record activity for source rename
    this._recordActivity({
      action: 'rename',
      entityType: 'source',
      name: newName,
      details: `Renamed source from "${oldName}" to "${newName}"`,
      canReverse: true,
      reverseData: { sourceId: source.id, oldName, newName }
    });

    // Save and refresh
    this._saveData();
    this._renderSidebar();
    this._showSourceDetail(source.id);
    this._showToast(`Source renamed to "${newName}"`, 'success');
  }

  /**
   * Edit source provenance - opens modal with all 9 fields
   */
  _editSourceProvenance(sourceId) {
    const source = this.sources?.find(s => s.id === sourceId);
    if (!source) {
      this._showToast('Source not found', 'error');
      return;
    }

    const provenanceGroups = [
      {
        title: 'Source & Attribution',
        subtitle: 'Where did this data come from?',
        icon: 'ph-identification-card',
        fields: [
          { key: 'agent', label: 'Agent', icon: 'ph-user', description: 'Person, team, or system that provided or created this data' },
          { key: 'method', label: 'Method', icon: 'ph-gear', description: 'How this data was collected or generated (e.g., survey, API, manual entry)' },
          { key: 'source', label: 'Origin', icon: 'ph-link', description: 'Original file, database, or system where this data came from' }
        ]
      },
      {
        title: 'Meaning & Scope',
        subtitle: 'What does this data represent?',
        icon: 'ph-book-open-text',
        fields: [
          { key: 'term', label: 'Term', icon: 'ph-tag', description: 'The key concept or entity this data describes' },
          { key: 'definition', label: 'Definition', icon: 'ph-book-open', description: 'Precise meaning of the term in this context' },
          { key: 'jurisdiction', label: 'Jurisdiction', icon: 'ph-globe', description: 'Geographic region, legal authority, or organizational scope' }
        ]
      },
      {
        title: 'Context & Conditions',
        subtitle: 'When and where does this apply?',
        icon: 'ph-map-trifold',
        fields: [
          { key: 'scale', label: 'Scale', icon: 'ph-chart-line', description: 'Level of analysis (e.g., individual, department, company-wide)' },
          { key: 'timeframe', label: 'Timeframe', icon: 'ph-calendar', description: 'Time period this data covers or when it was observed' },
          { key: 'background', label: 'Background', icon: 'ph-info', description: 'Assumptions or conditions required for this data to be valid' }
        ]
      }
    ];

    // Flatten for save processing
    const provenanceFields = provenanceGroups.flatMap(g => g.fields);

    const html = `
      <div class="source-provenance-edit-modal">
        <h3>
          <i class="ph ph-fingerprint"></i>
          Edit Provenance Metadata
        </h3>
        <p class="modal-subtitle">All changes are tracked in edit history.</p>

        ${provenanceGroups.map(group => `
          <div class="provenance-edit-section">
            <div class="provenance-section-header">
              <i class="ph ${group.icon}"></i>
              <div class="provenance-section-title">
                <span class="section-name">${group.title}</span>
                <span class="section-subtitle">${group.subtitle}</span>
              </div>
            </div>
            <div class="provenance-edit-grid">
              ${group.fields.map(field => {
                const currentValue = this._getProvenanceValue(source.provenance?.[field.key]) || '';
                return `
                  <div class="provenance-edit-field">
                    <label for="prov-${field.key}">
                      <i class="ph ${field.icon}"></i>
                      ${field.label}
                    </label>
                    <input type="text"
                           id="prov-${field.key}"
                           name="${field.key}"
                           value="${this._escapeHtml(currentValue)}"
                           placeholder="${field.description}">
                  </div>
                `;
              }).join('')}
            </div>
          </div>
        `).join('')}
      </div>
    `;

    this._showModal('Edit Provenance', html, [
      { label: 'Cancel', action: 'close' },
      { label: 'Save Changes', action: 'save', primary: true }
    ], (action) => {
      if (action === 'save') {
        const changes = [];

        // Ensure source.provenance exists and is not frozen
        // Create a new provenance object since the original may be frozen
        const newProvenance = { ...(source.provenance || {}) };

        provenanceFields.forEach(field => {
          const input = document.getElementById(`prov-${field.key}`);
          if (input) {
            const newValue = input.value.trim();
            const oldValue = this._getProvenanceValue(source.provenance?.[field.key]) || '';

            if (newValue !== oldValue) {
              changes.push({
                field: `provenance.${field.key}`,
                oldValue,
                newValue
              });
              newProvenance[field.key] = newValue || null;
            }
          }
        });

        if (changes.length > 0) {
          // Replace provenance with new unfrozen object
          source.provenance = newProvenance;

          // Initialize edit history if needed
          if (!source.editHistory) {
            source.editHistory = [];
          }

          // Record all changes
          const timestamp = new Date().toISOString();
          changes.forEach(change => {
            source.editHistory.unshift({
              timestamp,
              field: change.field,
              oldValue: change.oldValue,
              newValue: change.newValue,
              actor: 'user'
            });
          });

          source.updatedAt = timestamp;

          // Save and refresh
          this._saveData();
          this._showSourceDetail(source.id);
          this._showToast(`Updated ${changes.length} provenance field${changes.length > 1 ? 's' : ''}`, 'success');
        } else {
          this._showToast('No changes made', 'info');
        }
      }
    });
  }

  /**
   * Update breadcrumb when viewing a source
   */
  _updateSourceBreadcrumb(source) {
    const setBreadcrumb = document.getElementById('current-set-name');
    if (setBreadcrumb) {
      setBreadcrumb.innerHTML = `
        <i class="ph ${this._getSourceIcon(source.name)}"></i>
        ${this._escapeHtml(source.name)}
        <span class="given-badge" style="margin-left: 8px; font-size: 10px;">GIVEN</span>
      `;
    }
  }

  /**
   * Infer field type from record values
   */
  _inferFieldType(records, field) {
    const sample = records.slice(0, 10);
    let types = sample.map(r => {
      const val = r[field];
      if (val === null || val === undefined || val === '') return 'null';
      if (typeof val === 'number') return 'number';
      if (typeof val === 'boolean') return 'boolean';
      if (!isNaN(Date.parse(val)) && String(val).match(/^\d{4}-\d{2}-\d{2}/)) return 'date';
      if (!isNaN(Number(val))) return 'number';
      return 'string';
    }).filter(t => t !== 'null');

    const primary = types[0] || 'string';
    return primary;
  }

  /**
   * Get CSS class for source cell based on value type
   */
  _getSourceCellClass(value) {
    if (value === null || value === undefined) return 'source-cell source-cell-null';
    if (typeof value === 'number') return 'source-cell source-cell-number';
    if (typeof value === 'boolean') return 'source-cell source-cell-boolean';
    if (!isNaN(Date.parse(value)) && String(value).match(/^\d{4}-\d{2}-\d{2}/)) return 'source-cell source-cell-date';
    return 'source-cell';
  }

  /**
   * Format source cell value for display
   * Uses compact single-line format for source tables to maintain row heights
   */
  _formatSourceCellValue(value, options = {}) {
    if (value === null || value === undefined) return '<span class="null-value">null</span>';
    if (typeof value === 'boolean') return value ? 'true' : 'false';
    // Handle objects and arrays with compact single-line display for source tables
    if (typeof value === 'object') {
      return this._renderSourceObjectCompact(value);
    }
    const str = String(value);
    // For long text, truncate and show tooltip
    if (str.length > 50) {
      const escapedStr = this._escapeHtml(str);
      return `<span class="source-cell-longtext-content" title="${escapedStr}">${this._escapeHtml(str.substring(0, 50))}...</span>`;
    }
    return this._escapeHtml(str);
  }

  /**
   * Render object/array as compact single-line string for source tables
   * This keeps row heights consistent by avoiding multi-line JSON displays
   */
  _renderSourceObjectCompact(value) {
    if (value === null) return '<span class="null-value">null</span>';
    if (value === undefined) return '<span class="null-value">null</span>';

    // Arrays - show count and preview
    if (Array.isArray(value)) {
      if (value.length === 0) {
        return '<span class="source-cell-object">[]</span>';
      }
      const preview = value.slice(0, 2).map(item =>
        typeof item === 'object' ? (Array.isArray(item) ? '[...]' : '{...}') : String(item).substring(0, 15)
      ).join(', ');
      const hasMore = value.length > 2 ? `, +${value.length - 2}` : '';
      const fullJson = JSON.stringify(value);
      return `<span class="source-cell-object" title="${this._escapeHtml(fullJson)}">[${this._escapeHtml(preview)}${hasMore}]</span>`;
    }

    // Objects - show key count and preview
    const keys = Object.keys(value);
    if (keys.length === 0) {
      return '<span class="source-cell-object">{}</span>';
    }

    // Show first 2 key:value pairs inline
    const preview = keys.slice(0, 2).map(key => {
      const val = value[key];
      const valStr = val === null ? 'null'
        : typeof val === 'object' ? (Array.isArray(val) ? `[${val.length}]` : '{...}')
        : String(val).substring(0, 10);
      return `${key}: ${valStr}`;
    }).join(', ');
    const hasMore = keys.length > 2 ? `, +${keys.length - 2}` : '';
    const fullJson = JSON.stringify(value);
    return `<span class="source-cell-object" title="${this._escapeHtml(fullJson)}">{${this._escapeHtml(preview)}${hasMore}}</span>`;
  }

  /**
   * Filter source records based on search term
   * Handles all view modes: unified, split (By Type), and cards
   */
  _filterSourceRecords(source, searchTerm) {
    const term = searchTerm.toLowerCase();
    const viewMode = source.sourceViewMode || 'unified';
    let totalRows = 0;
    let visibleCount = 0;

    if (viewMode === 'unified') {
      // Unified view - single table
      const tbody = document.querySelector('.source-data-table tbody');
      if (tbody) {
        const rows = tbody.querySelectorAll('tr');
        totalRows = rows.length;
        rows.forEach(row => {
          const text = row.textContent.toLowerCase();
          const visible = term === '' || text.includes(term);
          row.style.display = visible ? '' : 'none';
          if (visible) visibleCount++;
        });
      }
    } else if (viewMode === 'split') {
      // Split view (By Type) - multiple tables
      const tables = document.querySelectorAll('.source-split-table tbody');
      tables.forEach(tbody => {
        const rows = tbody.querySelectorAll('tr');
        totalRows += rows.length;
        rows.forEach(row => {
          const text = row.textContent.toLowerCase();
          const visible = term === '' || text.includes(term);
          row.style.display = visible ? '' : 'none';
          if (visible) visibleCount++;
        });
      });

      // Also update section visibility - hide sections with no visible rows
      document.querySelectorAll('.source-split-table-section').forEach(section => {
        const tbody = section.querySelector('tbody');
        if (tbody) {
          const visibleRows = Array.from(tbody.querySelectorAll('tr')).filter(r => r.style.display !== 'none');
          section.style.display = visibleRows.length > 0 ? '' : 'none';
        }
      });
    } else if (viewMode === 'cards') {
      // Cards view - filter type cards by matching records
      const cards = document.querySelectorAll('.source-type-card');
      // In cards view, we don't filter individual records, just show/hide based on type name match
      cards.forEach(card => {
        const text = card.textContent.toLowerCase();
        const visible = term === '' || text.includes(term);
        card.style.display = visible ? '' : 'none';
        if (visible) {
          totalRows++;
          visibleCount++;
        }
      });
    }

    // Update count display
    const countEl = document.querySelector('.source-record-count');
    if (countEl) {
      const totalRecords = source.recordCount || totalRows;
      countEl.textContent = term
        ? `Showing ${visibleCount} matching records`
        : `Showing ${Math.min(totalRows, 100)} of ${totalRecords} records`;
    }
  }

  /**
   * Create a new Set from a source - simplified to use this.sources
   */
  _createSetFromSource(source) {
    // If source has records, use SetFromSourceUI
    if (source && source.records && source.records.length > 0) {
      this._showSetFromSourceUI(source.id);
      return;
    }

    // Fallback: Find source in this.sources
    const fullSource = this.sources?.find(s => s.id === source.id);
    if (fullSource && fullSource.records && fullSource.records.length > 0) {
      this._showSetFromSourceUI(fullSource.id);
      return;
    }

    // No source data available
    this._showToast('No source data available. Please re-import the file.', 'error');
  }

  /**
   * Export source data - simplified to use this.sources
   */
  _exportSource(sourceId) {
    // Find source from this.sources (single source of truth)
    const source = this.sources?.find(s => s.id === sourceId);

    if (!source) {
      this._showToast('Source not found', 'error');
      return;
    }

    let exportData = null;
    let fileName = source.name.replace(/\.[^/.]+$/, '') + '_export.json';

    // PRIORITY 1: Source object already has records
    if (source.records && source.records.length > 0) {
      exportData = source.records;
    }
    // PRIORITY 2: Look up in sourceStore
    else if (this.sourceStore) {
      let sourceInStore = this.sourceStore.get(sourceId);
      if (!sourceInStore) {
        const allSources = this.sourceStore.getByStatus('active');
        sourceInStore = allSources.find(s => s.name.toLowerCase() === source.name.toLowerCase());
      }

      if (sourceInStore && sourceInStore.records && sourceInStore.records.length > 0) {
        exportData = sourceInStore.records;
      }
    }

    // Fallback: Find the primary set with this source's data
    if (!exportData) {
      const primarySet = this.sets.find(set => {
        const prov = set.datasetProvenance;
        if (!prov) return false;
        const sourceName = prov.originalFilename || this._getProvenanceValue(prov.provenance?.source);
        return sourceName?.toLowerCase() === source.name.toLowerCase();
      });

      if (primarySet?.records) {
        exportData = primarySet.records;
      }
    }

    if (exportData) {
      const json = JSON.stringify(exportData, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      a.click();
      URL.revokeObjectURL(url);
    } else {
      this._showToast('No source data available to export.', 'error');
    }
  }

  /**
   * Delete (toss) a source - moves to tossed items and becomes a ghost
   * Sources persist as ghosts so derived sets can track their provenance
   */
  _deleteSource(sourceId) {
    // Find source from this.sources
    const source = this.sources?.find(s => s.id === sourceId);
    const sourceName = source?.name || 'this source';

    if (!source) {
      this._showToast('Source not found', 'warning');
      return;
    }

    // Check for derived sets
    const derivedSets = this.sets.filter(set => {
      const prov = set.datasetProvenance;
      return prov?.sourceId === sourceId ||
             prov?.originalFilename?.toLowerCase() === source?.name?.toLowerCase();
    });

    const sourceIndex = this.sources?.findIndex(s => s.id === sourceId) ?? -1;

    // Add to tossed items (nothing is ever deleted per Rule 9)
    this.tossedItems.unshift({
      type: 'source',
      source: JSON.parse(JSON.stringify(source)), // Deep clone
      derivedSetIds: derivedSets.map(s => s.id),
      tossedAt: new Date().toISOString()
    });
    if (this.tossedItems.length > this.maxTossedItems) {
      this.tossedItems.pop();
    }

    // Register as ghost if ghost registry is available
    if (typeof getGhostRegistry === 'function') {
      const ghostRegistry = getGhostRegistry();
      const tombstoneEvent = {
        id: `tombstone_${Date.now().toString(36)}_${Math.random().toString(36).substr(2, 6)}`,
        timestamp: new Date().toISOString(),
        actor: 'user',
        payload: {
          action: 'tombstone',
          targetId: sourceId,
          reason: 'User tossed source',
          targetSnapshot: {
            type: 'source',
            payload: {
              name: source.name,
              recordCount: source.records?.length || source.recordCount || 0,
              derivedSetCount: derivedSets.length
            }
          }
        },
        context: { workspace: 'default' }
      };
      ghostRegistry.registerGhost(sourceId, tombstoneEvent, {
        entityType: 'source',
        workspace: 'default'
      });
    }

    // Remove from this.sources array
    if (this.sources && sourceIndex !== -1) {
      this.sources.splice(sourceIndex, 1);
    }

    // Also remove from sourceStore if present
    if (this.sourceStore) {
      this.sourceStore.sources.delete(sourceId);
    }

    // Record activity for source deletion
    this._recordActivity({
      action: 'delete',
      entityType: 'source',
      name: sourceName,
      details: `Tossed source "${sourceName}" (${derivedSets.length} derived set${derivedSets.length !== 1 ? 's' : ''})`,
      canReverse: true,
      reverseData: { sourceId, tossedIndex: 0 }
    });

    // Save changes
    this._saveData();

    // Update UI
    if (this.fileExplorerMode) {
      this.fileExplorerSelectedSource = null;
      this._renderFileExplorer();
    } else if (this.currentSourceId === sourceId || this.currentSourceId === 'sources-table') {
      this._showSourcesTableView();
    }

    // Update sidebar
    this._renderSidebar();
    this._updateTossedBadge();

    // Show undo toast with countdown
    this._showToast(`Tossed source "${sourceName}"`, 'info', {
      countdown: 5000,
      action: {
        label: 'Undo',
        callback: () => {
          // Restore the source using _restoreTossedItem (which also records activity)
          const tossedIndex = this.tossedItems.findIndex(
            t => t.type === 'source' && t.source.id === sourceId
          );
          if (tossedIndex !== -1) {
            this._restoreTossedItem(tossedIndex);
          }
        }
      }
    });
  }

  /**
   * Show a confirmation dialog
   */
  _showConfirmDialog({ title, message, confirmText = 'Confirm', confirmClass = 'btn-primary', onConfirm }) {
    // Remove any existing dialog
    document.querySelector('.confirm-dialog-overlay')?.remove();

    const overlay = document.createElement('div');
    overlay.className = 'confirm-dialog-overlay';
    overlay.innerHTML = `
      <div class="confirm-dialog">
        <div class="confirm-dialog-header">
          <h3>${this._escapeHtml(title)}</h3>
        </div>
        <div class="confirm-dialog-body">
          <p>${this._escapeHtml(message).replace(/\n/g, '<br>')}</p>
        </div>
        <div class="confirm-dialog-footer">
          <button class="btn-secondary" id="confirm-dialog-cancel">Cancel</button>
          <button class="${confirmClass}" id="confirm-dialog-confirm">${this._escapeHtml(confirmText)}</button>
        </div>
      </div>
    `;

    document.body.appendChild(overlay);

    // Event handlers
    const close = () => overlay.remove();

    overlay.querySelector('#confirm-dialog-cancel').addEventListener('click', close);
    overlay.querySelector('#confirm-dialog-confirm').addEventListener('click', () => {
      close();
      onConfirm();
    });

    // Close on overlay click
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) close();
    });

    // Close on escape
    const escHandler = (e) => {
      if (e.key === 'Escape') {
        close();
        document.removeEventListener('keydown', escHandler);
      }
    };
    document.addEventListener('keydown', escHandler);
  }

  // ==========================================================================
  // File Explorer - Full-featured source file browser
  // ==========================================================================

  /**
   * Show the File Explorer in the main content area
   */
  _showFileExplorer() {
    // Initialize stores if needed
    if (!this.sourceStore) {
      this._initSourceStore();
    }
    if (!this.folderStore && typeof FolderStore !== 'undefined') {
      this.folderStore = new FolderStore();
    }

    this.fileExplorerMode = true;
    this.currentSourceId = null;
    this.currentSetId = null;

    // Update breadcrumb
    this._updateBreadcrumb('File Explorer', 'ph-folder-open');

    // Render the file explorer
    this._renderFileExplorer();
  }

  /**
   * Close file explorer and return to normal view
   */
  _closeFileExplorer() {
    this.fileExplorerMode = false;
    this._renderSidebar();
    this._renderView();
  }

  // ==========================================================================
  // Sets Explorer - Full-featured sets browser
  // ==========================================================================

  /**
   * Show the Sets Explorer in the main content area
   */
  _showSetsExplorer() {
    this.currentSourceId = null;
    this.currentDefinitionId = null;
    this.currentExportId = null;
    this.fileExplorerMode = false;

    // Update breadcrumb
    this._updateBreadcrumb('Sets Explorer', 'ph-database');

    // Render the sets explorer
    this._renderSetsExplorer();
  }

  /**
   * Render Sets Explorer view
   */
  _renderSetsExplorer() {
    const contentArea = this.elements.contentArea;
    if (!contentArea) return;

    const sets = this.sets || [];

    contentArea.innerHTML = `
      <div class="file-explorer">
        <div class="file-explorer-toolbar">
          <div class="file-explorer-toolbar-left">
            <button class="file-explorer-close-btn" id="sets-explorer-close" title="Close Sets Explorer">
              <i class="ph ph-x"></i>
            </button>
            <div class="file-explorer-title">
              <i class="ph ph-database"></i>
              <span>Sets Explorer</span>
              <span class="file-explorer-badge schema-badge">SCHEMA</span>
            </div>
          </div>
          <div class="file-explorer-toolbar-center">
            <div class="file-explorer-search">
              <i class="ph ph-magnifying-glass"></i>
              <input type="text" id="sets-explorer-search" placeholder="Search sets...">
            </div>
          </div>
          <div class="file-explorer-toolbar-right">
            <button class="file-explorer-import-btn" id="sets-explorer-new">
              <i class="ph ph-plus"></i>
              <span>New Set</span>
            </button>
          </div>
        </div>

        <div class="file-explorer-content" style="padding: 20px;">
          <div class="fe-section-header">All Sets (${sets.length})</div>
          ${sets.length === 0 ? `
            <div class="nav-empty-state" style="padding: 40px;">
              <i class="ph ph-database"></i>
              <span>No sets yet</span>
              <button class="btn-link" id="sets-explorer-create">Create your first set</button>
            </div>
          ` : `
            <div class="file-explorer-grid">
              ${sets.map(set => `
                <div class="fe-grid-item" data-set-id="${set.id}">
                  <div class="fe-grid-icon">
                    <i class="ph ph-database"></i>
                  </div>
                  <div class="fe-grid-name">${this._escapeHtml(set.name)}</div>
                  <div class="fe-grid-meta">${set.records?.length || 0} records • ${set.views?.length || 0} views</div>
                </div>
              `).join('')}
            </div>
          `}
        </div>
      </div>
    `;

    // Attach event handlers
    contentArea.querySelector('#sets-explorer-close')?.addEventListener('click', () => {
      this._renderView();
    });

    contentArea.querySelector('#sets-explorer-new')?.addEventListener('click', () => {
      this._showNewSetModal();
    });

    contentArea.querySelector('#sets-explorer-create')?.addEventListener('click', () => {
      this._showNewSetModal();
    });

    contentArea.querySelectorAll('.fe-grid-item[data-set-id]').forEach(item => {
      item.addEventListener('click', () => {
        const setId = item.dataset.setId;
        this._selectSet(setId);
      });
    });
  }

  // ==========================================================================
  // Definitions Explorer - Full-featured definitions browser
  // ==========================================================================

  /**
   * Show the Definitions Explorer in the main content area
   */
  _showDefinitionsExplorer() {
    this.currentSourceId = null;
    this.currentSetId = null;
    this.currentExportId = null;
    this.fileExplorerMode = false;

    // Update breadcrumb
    this._updateBreadcrumb('Definitions Explorer', 'ph-book-open');

    // Render the definitions explorer
    this._renderDefinitionsExplorer();
  }

  /**
   * Render Definitions Explorer view
   */
  _renderDefinitionsExplorer() {
    const contentArea = this.elements.contentArea;
    if (!contentArea) return;

    const definitions = this.definitions || [];

    contentArea.innerHTML = `
      <div class="file-explorer">
        <div class="file-explorer-toolbar">
          <div class="file-explorer-toolbar-left">
            <button class="file-explorer-close-btn" id="defs-explorer-close" title="Close Definitions Explorer">
              <i class="ph ph-x"></i>
            </button>
            <div class="file-explorer-title">
              <i class="ph ph-book-open"></i>
              <span>Definitions Explorer</span>
              <span class="file-explorer-badge dictionary-badge">TERMS</span>
            </div>
          </div>
          <div class="file-explorer-toolbar-center">
            <div class="file-explorer-search">
              <i class="ph ph-magnifying-glass"></i>
              <input type="text" id="defs-explorer-search" placeholder="Search definitions...">
            </div>
          </div>
          <div class="file-explorer-toolbar-right">
            <button class="nav-panel-action" id="defs-explorer-import" title="Import from URI">
              <i class="ph ph-link"></i>
            </button>
            <button class="file-explorer-import-btn" id="defs-explorer-new">
              <i class="ph ph-plus"></i>
              <span>New</span>
            </button>
          </div>
        </div>

        <div class="file-explorer-content" style="padding: 20px;">
          <div class="fe-section-header">All Definitions (${definitions.length})</div>
          ${definitions.length === 0 ? `
            <div class="nav-empty-state" style="padding: 40px;">
              <i class="ph ph-book-open"></i>
              <span>No definitions yet</span>
              <button class="btn-link" id="defs-explorer-create">Import from URI or create</button>
            </div>
          ` : `
            <div class="file-explorer-grid">
              ${definitions.map(def => `
                <div class="fe-grid-item" data-definition-id="${def.id}">
                  <div class="fe-grid-icon">
                    <i class="ph ${this._getDefinitionIcon(def)}"></i>
                  </div>
                  <div class="fe-grid-name">${this._escapeHtml(def.name)}</div>
                  <div class="fe-grid-meta">${def.terms?.length || def.properties?.length || 0} terms • ${def.sourceUri ? 'URI' : 'local'}</div>
                </div>
              `).join('')}
            </div>
          `}
        </div>
      </div>
    `;

    // Attach event handlers
    contentArea.querySelector('#defs-explorer-close')?.addEventListener('click', () => {
      this._renderView();
    });

    contentArea.querySelector('#defs-explorer-new')?.addEventListener('click', () => {
      this._showNewDefinitionModal();
    });

    contentArea.querySelector('#defs-explorer-import')?.addEventListener('click', () => {
      this._showImportDefinitionModal();
    });

    contentArea.querySelector('#defs-explorer-create')?.addEventListener('click', () => {
      this._showImportDefinitionModal();
    });

    contentArea.querySelectorAll('.fe-grid-item[data-definition-id]').forEach(item => {
      item.addEventListener('click', () => {
        const definitionId = item.dataset.definitionId;
        this._showDefinitionDetail(definitionId);
      });
    });
  }

  // ==========================================================================
  // Definitions Tab View - File Explorer Style
  // ==========================================================================

  /**
   * Show definitions as a file explorer view in the main content area
   * Triggered when clicking the Definitions tab
   */
  _showDefinitionsTableView() {
    const contentArea = this.elements.contentArea;
    if (!contentArea) return;

    // Set state flags
    this.isViewingDefinitions = true;
    this.currentSourceId = null;
    this.currentSetId = null;
    this.currentDefinitionId = null;

    // Ensure all keys from project sets have stub definitions before displaying
    this._ensureAllKeysHaveDefinitions();

    // Get definitions for current project (filtered by project.definitionIds when a project is selected)
    const activeDefinitions = this._getProjectDefinitions();

    // Count definitions by status for stats bar
    const completeCount = activeDefinitions.filter(d =>
      d.status === 'complete' || d.status === 'verified' || d.term?.definitionText
    ).length;
    const partialCount = activeDefinitions.filter(d =>
      d.status === 'partial' && !d.term?.definitionText
    ).length;
    const stubCount = activeDefinitions.filter(d =>
      (d.status === 'stub' || d.populationMethod === 'pending') && !d.term?.definitionText
    ).length;
    const progressPercent = activeDefinitions.length > 0
      ? Math.round((completeCount / activeDefinitions.length) * 100)
      : 0;

    // Update breadcrumb
    this._updateBreadcrumb({
      workspace: this._getCurrentWorkspaceName(),
      set: 'Definitions',
      view: 'Explorer'
    });

    // Clear set/view selection in sidebar
    document.querySelectorAll('.set-item, .source-item, .definition-item').forEach(item => {
      item.classList.remove('active');
    });

    // Build the redesigned view HTML
    contentArea.innerHTML = `
      <div class="definitions-explorer-view definitions-redesign">
        <!-- Header -->
        <div class="definitions-explorer-header">
          <div class="definitions-explorer-title">
            <div class="definitions-explorer-icon">
              <i class="ph ph-book-open"></i>
            </div>
            <div class="definitions-explorer-info">
              <h2>
                <span>Definitions</span>
                <span class="dict-badge">
                  <i class="ph ph-book-bookmark"></i>
                  TERMS
                </span>
              </h2>
              <div class="definitions-explorer-meta">
                ${activeDefinitions.length} definition${activeDefinitions.length !== 1 ? 's' : ''}${this.currentProjectId ? ` in ${this._escapeHtml(this._getCurrentProjectName())}` : ' available'}
              </div>
            </div>
          </div>
          <div class="definitions-explorer-actions">
            <button class="source-action-btn" id="defs-table-import-btn" title="Import from URI">
              <i class="ph ph-link"></i>
              <span>Import URI</span>
            </button>
            <button class="source-action-btn primary" id="defs-table-new-btn" title="Create new definition">
              <i class="ph ph-plus"></i>
              <span>New</span>
            </button>
          </div>
        </div>

        <!-- Stats Bar -->
        <div class="definitions-stats-bar">
          <div class="definitions-stats-progress">
            <div class="stats-progress-bar">
              <div class="stats-progress-fill" style="width: ${progressPercent}%"></div>
            </div>
            <div class="stats-progress-labels">
              <span class="stat-item complete">
                <span class="stat-value">${completeCount}</span> complete
              </span>
              <span class="stat-divider">·</span>
              <span class="stat-item partial">
                <span class="stat-value">${partialCount}</span> partial
              </span>
              <span class="stat-divider">·</span>
              <span class="stat-item stub">
                <span class="stat-value">${stubCount}</span> stubs
              </span>
            </div>
          </div>
          <div class="definitions-stats-actions">
            <div class="definitions-explorer-search">
              <i class="ph ph-magnifying-glass"></i>
              <input type="text" id="defs-explorer-search-input" placeholder="Search definitions...">
            </div>
            <div class="definitions-explorer-view-toggle">
              <button class="view-toggle-btn" data-view="cards" title="Cards view">
                <i class="ph ph-squares-four"></i>
              </button>
              <button class="view-toggle-btn active" data-view="table" title="Table view">
                <i class="ph ph-list"></i>
              </button>
            </div>
          </div>
        </div>

        <!-- Main Content Area -->
        <div class="definitions-explorer-content">
          ${activeDefinitions.length > 0 ? `
            <!-- Table View (default) - EO-aligned columns -->
            <div class="definitions-table-wrapper" id="definitions-table-view">
              <table class="definitions-list-table eo-aligned">
                <thead>
                  <tr>
                    <th class="col-meaning">Meaning</th>
                    <th class="col-scope">Refers To</th>
                    <th class="col-stability">Stability</th>
                    <th class="col-time">Time</th>
                    <th class="col-authority">Authority</th>
                    <th class="col-interop">Interop</th>
                    <th class="col-usage">Usage</th>
                    <th class="col-risk">Risk</th>
                  </tr>
                </thead>
                <tbody>
                  ${activeDefinitions.map(def => this._renderDefinitionListRow(def)).join('')}
                </tbody>
              </table>
            </div>

            <!-- Cards View (hidden by default) -->
            <div class="definitions-cards-wrapper" id="definitions-cards-view" style="display: none;">
              <div class="definitions-cards-grid">
                ${activeDefinitions.map(def => this._renderDefinitionCard(def)).join('')}
              </div>
            </div>
          ` : `
            <div class="definitions-explorer-empty">
              <i class="ph ph-book-open"></i>
              <p>No definitions yet</p>
              <p class="empty-hint">Definitions help standardize your data columns and field types</p>
              <div class="empty-actions">
                <button class="btn-secondary" id="defs-explorer-import-empty">
                  <i class="ph ph-link"></i>
                  Import from URI
                </button>
                <button class="btn-primary" id="defs-explorer-create-empty">
                  <i class="ph ph-plus"></i>
                  Create Definition
                </button>
              </div>
            </div>
          `}
        </div>
      </div>
    `;

    // Attach event handlers
    this._attachDefinitionsExplorerHandlers(activeDefinitions);
  }

  /**
   * Render a definition row in EO-aligned table format
   * Columns: Meaning, Refers To, Stability, Time, Authority, Interop, Usage, Risk
   */
  _renderDefinitionListRow(def) {
    const isStub = def.status === 'stub' || def.populationMethod === 'pending';
    const hasDefinitionText = def.term?.definitionText;

    // Get EO-aligned metadata
    const kindInfo = this._getDefinitionKind(def);
    const stabilityInfo = this._getDefinitionStability(def);
    const timeSensitivity = this._getDefinitionTimeSensitivity(def);
    const authorityInfo = this._getDefinitionAuthority(def);
    const interopStatus = this._getDefinitionInteropStatus(def);
    const usageInfo = this._getDefinitionUsage(def);
    const riskInfo = this._getDefinitionRisk(def);

    // Build meaning column (primary anchor)
    const meaningName = def.name || def.term?.label || def.term?.term || 'Unnamed';
    const meaningDesc = hasDefinitionText
      ? def.term.definitionText.slice(0, 60) + (def.term.definitionText.length > 60 ? '…' : '')
      : '';

    // Scope/Refers To icons based on kind
    const scopeIcons = {
      'Identifier': { icon: 'ph-key', label: 'Identity', color: '#6366f1' },
      'Measure': { icon: 'ph-chart-bar', label: 'Metric', color: '#10b981' },
      'Temporal': { icon: 'ph-calendar', label: 'Time', color: '#f59e0b' },
      'Descriptive': { icon: 'ph-tag', label: 'Property', color: '#0ea5e9' },
      'Relational': { icon: 'ph-git-branch', label: 'Relation', color: '#8b5cf6' },
      'Administrative': { icon: 'ph-gear', label: 'Admin', color: '#64748b' }
    };
    const scopeInfo = scopeIcons[kindInfo.kind] || scopeIcons['Descriptive'];

    // Risk level icons
    const riskIcons = {
      'safe': { icon: 'ph-check-circle', class: 'risk-safe' },
      'review': { icon: 'ph-info', class: 'risk-review' },
      'attention': { icon: 'ph-warning-circle', class: 'risk-attention' }
    };
    const riskDisplay = riskIcons[riskInfo.level] || riskIcons['safe'];

    return `
      <tr class="def-list-row eo-row${isStub ? ' is-stub' : ''}${hasDefinitionText ? ' is-complete' : ''}" data-definition-id="${def.id}">
        <!-- Meaning (primary column) -->
        <td class="col-meaning">
          <div class="def-meaning-cell">
            <span class="def-meaning-name">${this._escapeHtml(meaningName)}</span>
            ${meaningDesc ? `<span class="def-meaning-desc">${this._escapeHtml(meaningDesc)}</span>` : ''}
          </div>
        </td>

        <!-- Refers To / Scope -->
        <td class="col-scope">
          <span class="def-scope-badge" style="background: ${scopeInfo.color}15; color: ${scopeInfo.color};" title="${scopeInfo.label}">
            <i class="ph ${scopeInfo.icon}"></i>
            <span class="scope-label">${scopeInfo.label}</span>
          </span>
        </td>

        <!-- Stability -->
        <td class="col-stability">
          <div class="def-stability-cell">
            <span class="def-stability-dot" style="background: ${stabilityInfo.color};" title="${stabilityInfo.stability}: ${stabilityInfo.description}"></span>
            <span class="def-stability-label" style="color: ${stabilityInfo.color};">${stabilityInfo.stability}</span>
          </div>
        </td>

        <!-- Time Sensitivity -->
        <td class="col-time">
          <span class="def-time-badge" title="${timeSensitivity.description}">
            <i class="ph ${timeSensitivity.icon}" style="color: ${timeSensitivity.color};"></i>
          </span>
        </td>

        <!-- Authority -->
        <td class="col-authority">
          <span class="def-authority-badge" title="${authorityInfo.description}">
            <i class="ph ${authorityInfo.icon}" style="color: ${authorityInfo.color};"></i>
            <span class="authority-type">${authorityInfo.type}</span>
          </span>
        </td>

        <!-- Interop Status -->
        <td class="col-interop">
          <span class="def-interop-badge ${interopStatus.status.toLowerCase()}" title="${interopStatus.description}">
            <i class="ph ${interopStatus.icon}" style="color: ${interopStatus.color};"></i>
          </span>
        </td>

        <!-- Usage (clickable) -->
        <td class="col-usage">
          <span class="def-usage-count${usageInfo.total > 0 ? ' has-usage' : ''}"
                title="${usageInfo.breakdown.fields} fields, ${usageInfo.breakdown.reports} views, ${usageInfo.breakdown.automations} automations"
                data-usage-details='${JSON.stringify(usageInfo.breakdown)}'>
            ${usageInfo.total}
          </span>
        </td>

        <!-- Risk / Attention -->
        <td class="col-risk">
          <span class="def-risk-indicator ${riskDisplay.class}" title="${riskInfo.reasons.join(', ')}">
            <i class="ph ${riskDisplay.icon}"></i>
          </span>
        </td>
      </tr>
    `;
  }

  /**
   * Render a definition card for the cards view
   */
  _renderDefinitionCard(def) {
    const discovered = def.discoveredFrom || {};
    const isStub = def.status === 'stub' || def.populationMethod === 'pending';
    const hasDefinitionText = def.term?.definitionText;

    // Get type info
    const fieldType = discovered.fieldType || def.term?.type || 'text';
    const typeLabel = this._getTypeLabel(fieldType);
    const typeIcon = this._getTypeIcon(fieldType);

    // Count linked fields
    let linkedFieldCount = 0;
    this.sets.forEach(set => {
      (set.fields || []).forEach(field => {
        if (field.definitionRef?.definitionId === def.id ||
            field.semanticBinding?.definitionId === def.id) {
          linkedFieldCount++;
        }
      });
    });

    // Status
    let statusClass = 'stub';
    let statusLabel = 'Stub';
    if (hasDefinitionText) {
      statusClass = 'complete';
      statusLabel = 'Complete';
    } else if (def.status === 'partial') {
      statusClass = 'partial';
      statusLabel = 'Partial';
    }

    // Description
    const description = hasDefinitionText
      ? def.term.definitionText.slice(0, 100) + (def.term.definitionText.length > 100 ? '…' : '')
      : 'No description yet';

    // Values or samples
    let valuesHtml = '';
    const values = discovered.fieldOptions?.choices || discovered.fieldUniqueValues || discovered.fieldSamples || [];
    if (values.length > 0) {
      valuesHtml = `
        <div class="card-values">
          ${values.slice(0, 4).map(v => `<span class="card-value-chip">${this._escapeHtml(String(v).slice(0, 15))}</span>`).join('')}
          ${values.length > 4 ? `<span class="card-values-more">+${values.length - 4}</span>` : ''}
        </div>
      `;
    }

    // URI
    const uriHtml = def.sourceUri
      ? `<code class="card-uri">${this._escapeHtml(def.sourceUri.slice(0, 25))}${def.sourceUri.length > 25 ? '…' : ''}</code>`
      : `<span class="card-no-uri">No URI</span>`;

    return `
      <div class="def-card${isStub ? ' is-stub' : ''}" data-definition-id="${def.id}">
        <div class="card-header">
          <div class="card-name-row">
            <i class="ph ${typeIcon} card-type-icon"></i>
            <span class="card-name">${this._escapeHtml(def.name || def.term?.label || 'Unnamed')}</span>
          </div>
          <span class="card-status ${statusClass}">${statusLabel}</span>
        </div>
        <div class="card-type-label">${typeLabel}</div>
        <p class="card-description${hasDefinitionText ? '' : ' placeholder'}">${this._escapeHtml(description)}</p>
        ${valuesHtml}
        <div class="card-footer">
          ${uriHtml}
          <span class="card-usage">${linkedFieldCount > 0 ? `${linkedFieldCount} field${linkedFieldCount !== 1 ? 's' : ''}` : 'Unused'}</span>
        </div>
        ${isStub ? `
          <button class="card-complete-btn" data-action="complete">
            <i class="ph ph-plus"></i> Complete this definition
          </button>
        ` : ''}
      </div>
    `;
  }

  /**
   * Get format label from definition format/type
   */
  _getDefinitionFormatLabel(format) {
    const formatLower = (format || '').toLowerCase();
    if (formatLower === 'local') return 'Local Keys';
    if (formatLower.includes('jsonld') || formatLower.includes('json-ld')) return 'JSON-LD';
    if (formatLower.includes('csvw') || formatLower.includes('csv')) return 'CSV Schema';
    if (formatLower.includes('rdf')) return 'RDF';
    if (formatLower.includes('xml')) return 'XML Schema';
    if (formatLower.includes('owl')) return 'OWL';
    return 'Other';
  }

  /**
   * Get icon for definition format
   */
  _getDefinitionFormatIcon(formatLabel) {
    switch (formatLabel) {
      case 'Local Keys': return 'ph-key';
      case 'JSON-LD': return 'ph-brackets-curly';
      case 'CSV Schema': return 'ph-file-csv';
      case 'RDF': return 'ph-graph';
      case 'XML Schema': return 'ph-file-code';
      case 'OWL': return 'ph-tree-structure';
      default: return 'ph-folder';
    }
  }

  /**
   * Render a single definition tree item with rich inline information
   * Shows: name, status, inferred type, sample values for stubs
   * Shows: name, authority, definition preview for populated definitions
   * @param {Object} def - The definition object
   * @returns {string} HTML string
   */
  _renderDefinitionTreeItem(def) {
    const defIcon = this._getDefinitionIcon(def);
    const isStub = def.status === 'stub' || def.populationMethod === 'pending';
    const hasDefinitionText = def.term?.definitionText;
    const discovered = def.discoveredFrom || {};

    // Count linked fields across all sets
    let linkedFieldCount = 0;
    this.sets.forEach(set => {
      (set.fields || []).forEach(field => {
        const key = (def.term?.term || '').toLowerCase();
        const fieldKey = (field.key || field.name || '').toLowerCase().replace(/[_\s-]+/g, '_');
        if (fieldKey === key || field.definitionId === def.id || field.semanticBinding?.definitionId === def.id) {
          linkedFieldCount++;
        }
      });
    });

    // Build inline preview based on definition status
    let inlinePreview = '';
    let expandedContent = '';

    if (isStub && discovered.fieldType) {
      // For stubs, show inferred type and samples
      const typeLabel = this._getTypeLabel(discovered.fieldType);
      const uniqueCount = discovered.fieldUniqueCount || 0;
      const sampleCount = discovered.fieldSampleCount || 0;
      const samples = discovered.fieldSamples || discovered.fieldUniqueValues || [];

      // Format sample preview (truncate long values)
      const samplePreview = samples.slice(0, 3).map(s => {
        const str = String(s);
        return str.length > 20 ? str.slice(0, 18) + '…' : str;
      });

      inlinePreview = `
        <div class="def-tree-item-preview stub-preview">
          <span class="preview-type" title="Inferred field type">
            <i class="ph ${this._getTypeIcon(discovered.fieldType)}"></i>
            ${typeLabel}
          </span>
          ${uniqueCount > 0 ? `
            <span class="preview-stat" title="${uniqueCount} unique values out of ${sampleCount} total">
              ${uniqueCount} unique
            </span>
          ` : ''}
          ${samplePreview.length > 0 ? `
            <span class="preview-samples" title="Sample values: ${samples.slice(0, 5).join(', ')}">
              "${samplePreview.join('", "')}"${samples.length > 3 ? '…' : ''}
            </span>
          ` : ''}
        </div>
      `;

      // Expanded content shows full samples and source info
      expandedContent = `
        <div class="def-tree-item-expanded">
          ${discovered.sourceName ? `
            <div class="expanded-row source-row">
              <span class="expanded-label">Source:</span>
              <span class="expanded-value">${this._escapeHtml(discovered.sourceName)} → ${this._escapeHtml(discovered.fieldName || 'unknown field')}</span>
            </div>
          ` : ''}
          ${uniqueCount > 0 ? `
            <div class="expanded-row stats-row">
              <span class="expanded-label">Statistics:</span>
              <span class="expanded-value">${uniqueCount} unique values from ${sampleCount} records</span>
            </div>
          ` : ''}
          ${samples.length > 0 ? `
            <div class="expanded-row samples-row">
              <span class="expanded-label">Sample values:</span>
              <div class="expanded-samples">
                ${samples.slice(0, 10).map(s => `<span class="sample-chip">${this._escapeHtml(String(s).slice(0, 50))}</span>`).join('')}
                ${samples.length > 10 ? `<span class="sample-more">+${samples.length - 10} more</span>` : ''}
              </div>
            </div>
          ` : ''}
          <div class="expanded-actions">
            <button class="expanded-action-btn primary" data-action="define" title="Define this term">
              <i class="ph ph-pencil-simple"></i>
              Define
            </button>
            <button class="expanded-action-btn" data-action="lookup" title="Lookup in external sources">
              <i class="ph ph-magnifying-glass"></i>
              Lookup
            </button>
          </div>
        </div>
      `;
    } else if (hasDefinitionText) {
      // For populated definitions, show definition text preview and authority
      const authority = def.authority?.shortName || def.authority?.name || '';
      const citation = def.source?.citation || '';
      const defText = def.term.definitionText;
      const truncatedDef = defText.length > 100 ? defText.slice(0, 97) + '…' : defText;

      inlinePreview = `
        <div class="def-tree-item-preview defined-preview">
          ${authority ? `
            <span class="preview-authority" title="Defining authority">
              <i class="ph ph-seal-check"></i>
              ${this._escapeHtml(authority)}
            </span>
          ` : ''}
          <span class="preview-definition" title="${this._escapeHtml(defText)}">
            ${this._escapeHtml(truncatedDef)}
          </span>
        </div>
      `;

      // Expanded content shows full definition, source, validity
      expandedContent = `
        <div class="def-tree-item-expanded defined-expanded">
          <div class="expanded-row definition-row">
            <div class="full-definition-text">${this._escapeHtml(defText)}</div>
          </div>
          ${citation ? `
            <div class="expanded-row citation-row">
              <span class="expanded-label">Citation:</span>
              <span class="expanded-value citation-value">${this._escapeHtml(citation)}</span>
              ${def.source?.url ? `<a href="${def.source.url}" target="_blank" class="citation-link" title="Open source"><i class="ph ph-arrow-square-out"></i></a>` : ''}
            </div>
          ` : ''}
          ${def.validity?.from ? `
            <div class="expanded-row validity-row">
              <span class="expanded-label">Effective:</span>
              <span class="expanded-value">${def.validity.from}${def.validity.to ? ` to ${def.validity.to}` : ''}</span>
            </div>
          ` : ''}
          ${def.jurisdiction?.programs?.length > 0 ? `
            <div class="expanded-row programs-row">
              <span class="expanded-label">Programs:</span>
              <span class="expanded-value">${def.jurisdiction.programs.join(', ')}</span>
            </div>
          ` : ''}
          <div class="expanded-actions">
            <button class="expanded-action-btn" data-action="edit" title="Edit definition">
              <i class="ph ph-pencil-simple"></i>
              Edit
            </button>
            <button class="expanded-action-btn" data-action="apply" title="Apply to fields">
              <i class="ph ph-arrow-right"></i>
              Apply
            </button>
          </div>
        </div>
      `;
    } else {
      // Partial definition - has some info but not complete
      inlinePreview = `
        <div class="def-tree-item-preview partial-preview">
          <span class="preview-partial-hint">Click to complete definition</span>
        </div>
      `;
    }

    // Status badge
    const statusBadge = isStub
      ? `<span class="def-tree-item-badge stub">STUB</span>`
      : hasDefinitionText
        ? `<span class="def-tree-item-badge defined"><i class="ph ph-check"></i></span>`
        : `<span class="def-tree-item-badge partial">PARTIAL</span>`;

    return `
      <div class="def-tree-item${isStub ? ' stub-definition' : ' defined-definition'}" data-definition-id="${def.id}">
        <div class="def-tree-item-header">
          <i class="ph ph-caret-right item-expand-icon"></i>
          <i class="ph ${defIcon} item-type-icon"></i>
          <span class="def-tree-item-name">${this._escapeHtml(def.name || def.term?.label || def.term?.term || 'Unnamed')}</span>
          ${statusBadge}
          <span class="def-tree-item-count" title="${linkedFieldCount} field${linkedFieldCount !== 1 ? 's' : ''} using this key">${linkedFieldCount}</span>
          <div class="def-tree-item-actions">
            <button class="def-tree-action-btn" data-action="view" title="View definition">
              <i class="ph ph-eye"></i>
            </button>
            <button class="def-tree-action-btn" data-action="apply" title="Apply to set">
              <i class="ph ph-arrow-right"></i>
            </button>
            <button class="def-tree-action-btn delete" data-action="delete" title="Delete">
              <i class="ph ph-trash"></i>
            </button>
          </div>
        </div>
        ${inlinePreview}
        <div class="def-tree-item-children">
          ${expandedContent}
        </div>
      </div>
    `;
  }

  /**
   * Get a human-readable label for a field type
   */
  _getTypeLabel(type) {
    const typeMap = {
      'string': 'Text',
      'text': 'Text',
      'number': 'Number',
      'integer': 'Integer',
      'float': 'Decimal',
      'boolean': 'Boolean',
      'date': 'Date',
      'datetime': 'Date/Time',
      'email': 'Email',
      'url': 'URL',
      'phone': 'Phone',
      'currency': 'Currency',
      'percentage': 'Percentage',
      'select': 'Select',
      'multiselect': 'Multi-select'
    };
    return typeMap[type?.toLowerCase()] || type || 'Unknown';
  }

  /**
   * Get an icon for a field type
   */
  _getTypeIcon(type) {
    const iconMap = {
      'string': 'ph-text-aa',
      'text': 'ph-text-aa',
      'number': 'ph-hash',
      'integer': 'ph-hash',
      'float': 'ph-hash',
      'boolean': 'ph-toggle-left',
      'date': 'ph-calendar',
      'datetime': 'ph-calendar-blank',
      'email': 'ph-envelope',
      'url': 'ph-link',
      'phone': 'ph-phone',
      'currency': 'ph-currency-dollar',
      'percentage': 'ph-percent',
      'select': 'ph-list',
      'multiselect': 'ph-list-checks'
    };
    return iconMap[type?.toLowerCase()] || 'ph-question';
  }

  /**
   * Attach event handlers for definitions explorer view
   */
  _attachDefinitionsExplorerHandlers(definitions) {
    // Import from URI button
    document.getElementById('defs-table-import-btn')?.addEventListener('click', () => {
      this._showImportDefinitionModal();
    });

    // New definition button
    document.getElementById('defs-table-new-btn')?.addEventListener('click', () => {
      this._showNewDefinitionModal();
    });

    // Empty state buttons
    document.getElementById('defs-explorer-import-empty')?.addEventListener('click', () => {
      this._showImportDefinitionModal();
    });

    document.getElementById('defs-explorer-create-empty')?.addEventListener('click', () => {
      this._showNewDefinitionModal();
    });

    // Search input
    const searchInput = document.getElementById('defs-explorer-search-input');
    searchInput?.addEventListener('input', (e) => {
      this._filterDefinitionsList(e.target.value);
    });

    // View toggle (cards vs table)
    document.querySelectorAll('.definitions-explorer-view-toggle .view-toggle-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const view = btn.dataset.view;
        document.querySelectorAll('.definitions-explorer-view-toggle .view-toggle-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');

        const tableView = document.getElementById('definitions-table-view');
        const cardsView = document.getElementById('definitions-cards-view');

        if (view === 'cards') {
          if (tableView) tableView.style.display = 'none';
          if (cardsView) cardsView.style.display = '';
        } else {
          if (tableView) tableView.style.display = '';
          if (cardsView) cardsView.style.display = 'none';
        }
      });
    });

    // Table row click to view definition detail
    document.querySelectorAll('.def-list-row').forEach(row => {
      row.addEventListener('click', () => {
        const definitionId = row.dataset.definitionId;
        this._showDefinitionDetail(definitionId);
      });
    });

    // Card click to view definition detail
    document.querySelectorAll('.def-card').forEach(card => {
      card.addEventListener('click', (e) => {
        // Don't trigger if clicking the complete button
        if (e.target.closest('.card-complete-btn')) return;
        const definitionId = card.dataset.definitionId;
        this._showDefinitionDetail(definitionId);
      });
    });

    // Card "Complete this definition" button
    document.querySelectorAll('.card-complete-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const card = btn.closest('.def-card');
        const definitionId = card?.dataset.definitionId;
        if (definitionId) {
          this._showDefinitionDetail(definitionId);
        }
      });
    });

    // Legacy: Folder expand/collapse (for backwards compatibility)
    document.querySelectorAll('.def-tree-folder-header').forEach(header => {
      header.addEventListener('click', (e) => {
        if (e.target.closest('.def-tree-action-btn')) return;
        const folder = header.closest('.def-tree-folder');
        folder.classList.toggle('expanded');
      });
    });

    // Legacy: Definition item expand/collapse
    document.querySelectorAll('.def-tree-item-header').forEach(header => {
      header.addEventListener('click', (e) => {
        if (e.target.closest('.def-tree-action-btn')) return;
        const item = header.closest('.def-tree-item');
        item.classList.toggle('expanded');
      });
    });

    // Legacy: Definition item double-click to view detail
    document.querySelectorAll('.def-tree-item').forEach(item => {
      item.addEventListener('dblclick', () => {
        const definitionId = item.dataset.definitionId;
        this._showDefinitionDetail(definitionId);
      });
    });

    // Legacy: Action buttons (header actions)
    document.querySelectorAll('.def-tree-action-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const item = btn.closest('.def-tree-item');
        const definitionId = item?.dataset.definitionId;
        const action = btn.dataset.action;

        if (!definitionId) return;

        switch (action) {
          case 'view':
            this._showDefinitionDetail(definitionId);
            break;
          case 'apply':
            this._showApplyDefinitionModal(definitionId);
            break;
          case 'delete':
            this._deleteDefinition(definitionId);
            break;
        }
      });
    });

    // Legacy: Expanded area action buttons (Define, Lookup, Edit, Apply)
    document.querySelectorAll('.expanded-action-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const item = btn.closest('.def-tree-item');
        const definitionId = item?.dataset.definitionId;
        const action = btn.dataset.action;

        if (!definitionId) return;

        switch (action) {
          case 'define':
          case 'edit':
            // Open the definition builder for this definition
            this._showDefinitionDetail(definitionId);
            break;
          case 'lookup':
            // Trigger API lookup for this definition
            this._lookupDefinitionFromAPIs(definitionId);
            break;
          case 'apply':
            this._showApplyDefinitionModal(definitionId);
            break;
        }
      });
    });
  }

  /**
   * Filter definitions list by search term (new table/cards view)
   */
  _filterDefinitionsList(searchTerm) {
    const term = searchTerm.toLowerCase().trim();

    // Filter table rows
    document.querySelectorAll('.def-list-row').forEach(row => {
      const definitionId = row.dataset.definitionId;
      const def = this.definitions.find(d => d.id === definitionId);
      if (!def) {
        row.style.display = 'none';
        return;
      }

      const searchFields = [
        def.name,
        def.term?.label,
        def.term?.definitionText,
        def.description
      ].filter(Boolean).join(' ').toLowerCase();

      row.style.display = (!term || searchFields.includes(term)) ? '' : 'none';
    });

    // Filter cards
    document.querySelectorAll('.def-card').forEach(card => {
      const definitionId = card.dataset.definitionId;
      const def = this.definitions.find(d => d.id === definitionId);
      if (!def) {
        card.style.display = 'none';
        return;
      }

      const searchFields = [
        def.name,
        def.term?.label,
        def.term?.definitionText,
        def.description
      ].filter(Boolean).join(' ').toLowerCase();

      card.style.display = (!term || searchFields.includes(term)) ? '' : 'none';
    });
  }

  /**
   * Filter definitions tree by search term
   */
  _filterDefinitionsTree(searchTerm) {
    const items = document.querySelectorAll('.def-tree-item');
    const folders = document.querySelectorAll('.def-tree-folder');
    const term = searchTerm.toLowerCase().trim();
    let visibleCount = 0;

    items.forEach(item => {
      const definitionId = item.dataset.definitionId;
      const def = this.definitions.find(d => d.id === definitionId);
      if (!def) {
        item.style.display = 'none';
        return;
      }

      // Search in name, description, and term names
      const searchFields = [
        def.name,
        def.description,
        ...(def.terms || def.properties || []).map(t => t.name || t.label)
      ].filter(Boolean).join(' ').toLowerCase();

      const matches = !term || searchFields.includes(term);
      item.style.display = matches ? '' : 'none';
      if (matches) visibleCount++;
    });

    // Show/hide folders based on whether they have visible items
    folders.forEach(folder => {
      const visibleItems = folder.querySelectorAll('.def-tree-item:not([style*="display: none"])');
      folder.style.display = visibleItems.length > 0 ? '' : 'none';
      if (term && visibleItems.length > 0) {
        folder.classList.add('expanded');
      }
    });

    // Update count display
    const countEl = document.querySelector('.definitions-explorer-count');
    if (countEl) {
      const total = this.definitions.filter(d => d.status !== 'archived').length;
      countEl.textContent = term
        ? `${visibleCount} of ${total} definition${total !== 1 ? 's' : ''}`
        : `${total} definition${total !== 1 ? 's' : ''}`;
    }
  }

  // ==========================================================================
  // Definitions Panel - Full Table View
  // ==========================================================================

  /**
   * Show the main definitions panel with all definitions in table form
   * Allows viewing, editing, and linking definitions to set keys
   * Table columns: Definition, Kind, Status, Usage, Scope
   */
  _showDefinitionsPanel() {
    const contentArea = this.elements.contentArea;
    if (!contentArea) return;

    // Set state flags
    this.isViewingDefinitions = true;
    this.currentSourceId = null;
    this.currentSetId = null;
    this.currentViewId = null;
    this.currentDefinitionId = null;
    this.showingSetFields = false;
    this.showingSetDetail = false;

    // Update tab bar to show Definitions tab as active
    this._renderTabBar();

    // Get all definitions (filtered by project if applicable)
    const activeDefinitions = this._getProjectDefinitions().filter(d => d.status !== 'archived');

    // Count pending definitions
    const pendingCount = activeDefinitions.filter(d => this._isDefinitionPending(d)).length;

    // Group definitions by kind for the grouped view
    const groupedDefinitions = this._groupDefinitionsByKind(activeDefinitions);

    // Update breadcrumb
    this._updateBreadcrumb({
      workspace: this._getCurrentWorkspaceName(),
      set: 'Definitions',
      view: 'All Definitions'
    });

    // Clear selection in sidebar
    document.querySelectorAll('.set-item, .source-item, .definition-item, .set-view-item').forEach(item => {
      item.classList.remove('active');
    });

    // Get all sets for linking
    const sets = this.sets.filter(s => s.status !== 'archived');

    // Build the panel HTML with new hierarchy-focused layout
    contentArea.innerHTML = `
      <div class="definitions-panel-view hierarchy-redesign">
        <!-- Header -->
        <div class="definitions-panel-header">
          <div class="definitions-panel-title-area">
            <div class="definitions-panel-icon">
              <i class="ph ph-book-open"></i>
            </div>
            <div class="definitions-panel-title-info">
              <h2>Definitions</h2>
              <p class="definitions-panel-subtitle">${activeDefinitions.length} definition${activeDefinitions.length !== 1 ? 's' : ''}${pendingCount > 0 ? ` • <span class="pending-count-badge">${pendingCount} pending approval</span>` : ''}</p>
            </div>
          </div>
          <div class="definitions-panel-actions">
            <button class="btn btn-secondary" id="def-panel-import-btn">
              <i class="ph ph-link"></i>
              Import URI
            </button>
            <button class="btn btn-primary" id="def-panel-new-btn">
              <i class="ph ph-plus"></i>
              + New
            </button>
          </div>
        </div>

        <!-- Toolbar with view toggle -->
        <div class="definitions-panel-toolbar">
          <div class="definitions-panel-search">
            <i class="ph ph-magnifying-glass"></i>
            <input type="text" id="def-panel-search" placeholder="Search definitions...">
          </div>
          <div class="definitions-panel-view-toggle">
            <button class="view-toggle-btn active" data-view="grouped" title="Group by kind">
              <i class="ph ph-squares-four"></i>
            </button>
            <button class="view-toggle-btn" data-view="table" title="Table view">
              <i class="ph ph-table"></i>
            </button>
          </div>
          <div class="definitions-panel-filters">
            <select id="def-panel-kind-filter" class="def-panel-filter-select">
              <option value="">All Kinds</option>
              <option value="Identifier">Identifiers</option>
              <option value="Measure">Measures</option>
              <option value="Temporal">Temporal</option>
              <option value="Descriptive">Descriptive</option>
              <option value="Relational">Relational</option>
              <option value="Administrative">Administrative</option>
            </select>
            <select id="def-panel-status-filter" class="def-panel-filter-select">
              <option value="">All Status</option>
              <option value="pending">Pending Approval</option>
              <option value="active">Active</option>
            </select>
            <select id="def-panel-scope-filter" class="def-panel-filter-select">
              <option value="">All Scopes</option>
              <option value="Global">Global</option>
              <option value="Project">Project</option>
              <option value="Dataset">Dataset</option>
              <option value="Local">Local</option>
            </select>
          </div>
          <span class="definitions-count">${activeDefinitions.length} definitions</span>
        </div>

        <!-- Main Content Area -->
        <div class="definitions-panel-content">
          ${activeDefinitions.length === 0 ? `
            <div class="definitions-panel-empty">
              <i class="ph ph-book-open"></i>
              <h3>No definitions yet</h3>
              <p>Definitions shape how data is interpreted, not what the data is.</p>
              <div class="definitions-panel-empty-actions">
                <button class="btn btn-secondary" id="def-panel-empty-import">
                  <i class="ph ph-link"></i>
                  Import from URI
                </button>
                <button class="btn btn-primary" id="def-panel-empty-create">
                  <i class="ph ph-plus"></i>
                  Create Definition
                </button>
              </div>
            </div>
          ` : `
            <!-- Grouped View (default) -->
            <div class="definitions-grouped-view" id="definitions-grouped-view">
              ${this._renderDefinitionsGroupedView(groupedDefinitions, sets)}
            </div>

            <!-- Table View (hidden by default) -->
            <div class="definitions-table-view" id="definitions-table-view" style="display: none;">
              <table class="definitions-panel-table new-hierarchy">
                <thead>
                  <tr>
                    <th class="col-expand"></th>
                    <th class="col-name">Definition</th>
                    <th class="col-kind">Kind</th>
                    <th class="col-status">Status</th>
                    <th class="col-usage">Usage</th>
                    <th class="col-scope">Scope</th>
                    <th class="col-actions"></th>
                  </tr>
                </thead>
                <tbody id="definitions-table-body">
                  ${activeDefinitions.map(def => this._renderDefinitionTableRow(def, sets)).join('')}
                </tbody>
              </table>
            </div>
          `}
        </div>
      </div>
    `;

    // Attach event handlers
    this._attachDefinitionsPanelHandlers(activeDefinitions, sets);
  }

  /**
   * Check if a definition is pending approval (stub or needs population)
   */
  _isDefinitionPending(definition) {
    // Check for stub status
    if (definition.status === 'stub' || definition.status === 'partial') {
      return true;
    }
    // Check for pending population method
    if (definition.populationMethod === 'pending') {
      return true;
    }
    // Check if it's a DefinitionSource instance with isStub method
    if (typeof definition.isStub === 'function' && definition.isStub()) {
      return true;
    }
    if (typeof definition.needsPopulation === 'function' && definition.needsPopulation()) {
      return true;
    }
    return false;
  }

  /**
   * Render definitions in a grouped view by semantic kind
   * @param {Object} groupedDefinitions - Definitions grouped by kind
   * @param {Array} sets - All available sets for linking
   * @returns {string} HTML string
   */
  _renderDefinitionsGroupedView(groupedDefinitions, sets) {
    const kindOrder = ['Identifier', 'Measure', 'Temporal', 'Descriptive', 'Relational', 'Administrative'];
    const kindInfo = {
      'Identifier': { icon: 'ph-key', color: '#6366f1', description: 'Keys, IDs, and unique references' },
      'Measure': { icon: 'ph-chart-bar', color: '#10b981', description: 'Quantities, amounts, and metrics' },
      'Temporal': { icon: 'ph-calendar', color: '#f59e0b', description: 'Dates, times, and durations' },
      'Descriptive': { icon: 'ph-tag', color: '#0ea5e9', description: 'Labels, names, and text fields' },
      'Relational': { icon: 'ph-git-branch', color: '#8b5cf6', description: 'Foreign keys and relationships' },
      'Administrative': { icon: 'ph-gear', color: '#64748b', description: 'Status flags and system fields' }
    };

    let html = '';

    for (const kind of kindOrder) {
      const definitions = groupedDefinitions[kind];
      if (!definitions || definitions.length === 0) continue;

      const info = kindInfo[kind] || { icon: 'ph-tag', color: '#64748b', description: '' };

      html += `
        <div class="definitions-kind-group" data-kind="${kind}">
          <div class="kind-group-header">
            <div class="kind-group-title">
              <i class="ph ${info.icon}" style="color: ${info.color};"></i>
              <span class="kind-name">${kind}</span>
              <span class="kind-count">${definitions.length}</span>
            </div>
            <span class="kind-description">${info.description}</span>
          </div>
          <div class="kind-group-items">
            ${definitions.map(def => this._renderDefinitionGroupedItem(def, sets, info)).join('')}
          </div>
        </div>
      `;
    }

    return html;
  }

  /**
   * Render a single definition item in the grouped view
   * @param {Object} definition - The definition object
   * @param {Array} sets - All available sets
   * @param {Object} kindInfo - Kind icon and color info
   * @returns {string} HTML string
   */
  _renderDefinitionGroupedItem(definition, sets, kindInfo) {
    const stabilityInfo = this._getDefinitionStability(definition);
    const scopeInfo = this._getDefinitionScope(definition);
    const terms = definition.terms || definition.properties || [];
    const termCount = terms.length;

    // Count linked fields
    let linkedFieldsCount = 0;
    sets.forEach(set => {
      (set.fields || []).forEach(field => {
        if (field.definitionRef?.definitionId === definition.id) {
          linkedFieldsCount++;
        }
      });
    });

    return `
      <div class="definition-grouped-item" data-definition-id="${definition.id}">
        <div class="grouped-item-main">
          <div class="grouped-item-icon">
            <i class="ph ${kindInfo.icon}" style="color: ${kindInfo.color};"></i>
          </div>
          <div class="grouped-item-content">
            <div class="grouped-item-header">
              <span class="grouped-item-name">${this._escapeHtml(definition.name)}</span>
              <span class="stability-pill" style="background: ${stabilityInfo.color}15; color: ${stabilityInfo.color};" title="${stabilityInfo.description}">
                ${stabilityInfo.stability}
              </span>
            </div>
            ${terms.length > 0 ? `
              <div class="grouped-item-terms">
                ${terms.slice(0, 3).map(t => `<span class="term-chip">${this._escapeHtml(t.name || t.label)}</span>`).join('')}
                ${terms.length > 3 ? `<span class="term-more">+${terms.length - 3} more</span>` : ''}
              </div>
            ` : ''}
          </div>
        </div>
        <div class="grouped-item-meta">
          <span class="scope-indicator" title="${scopeInfo.scopeDetail}">
            <i class="ph ${scopeInfo.icon}"></i>
            ${scopeInfo.scope}
          </span>
          <span class="usage-indicator" title="${linkedFieldsCount} field${linkedFieldsCount !== 1 ? 's' : ''} using this definition">
            ${linkedFieldsCount}
          </span>
        </div>
      </div>
    `;
  }

  /**
   * Render a single definition row in the table (new hierarchy columns)
   * Columns: Definition, Kind, Status, Usage, Scope
   */
  _renderDefinitionTableRow(definition, sets) {
    const terms = definition.terms || definition.properties || [];
    const termCount = terms.length;
    const kindInfo = this._getDefinitionKind(definition);
    const stabilityInfo = this._getDefinitionStability(definition);
    const scopeInfo = this._getDefinitionScope(definition);

    // Check if definition is pending approval
    const isPending = this._isDefinitionPending(definition);
    const rowClass = isPending ? 'definition-row pending-approval' : 'definition-row';

    // Count how many fields are linked to this definition
    let linkedFieldsCount = 0;
    const linkedFields = [];
    sets.forEach(set => {
      (set.fields || []).forEach(field => {
        if (field.definitionRef?.definitionId === definition.id) {
          linkedFieldsCount++;
          linkedFields.push({ setName: set.name, fieldName: field.name, fieldId: field.id, setId: set.id });
        }
      });
    });

    // Render status badge
    const statusBadge = isPending ? `
      <span class="def-status-badge pending" title="This definition needs approval">
        <i class="ph ph-clock"></i>
        Pending
      </span>
    ` : `
      <span class="def-status-badge active" title="This definition is active">
        <i class="ph ph-check-circle"></i>
        Active
      </span>
    `;

    // Render actions based on pending status
    const actionsHtml = isPending ? `
      <div class="def-row-actions pending-actions">
        <button class="def-action-btn approve" data-action="approve" title="Approve definition">
          <i class="ph ph-check"></i>
        </button>
        <button class="def-action-btn" data-action="edit" title="Edit before approving">
          <i class="ph ph-pencil-simple"></i>
        </button>
        <button class="def-action-btn danger" data-action="dismiss" title="Dismiss suggestion">
          <i class="ph ph-x"></i>
        </button>
      </div>
    ` : `
      <div class="def-row-actions">
        <button class="def-action-btn" data-action="edit" title="Edit definition">
          <i class="ph ph-pencil-simple"></i>
        </button>
        <button class="def-action-btn" data-action="link" title="Link to set field">
          <i class="ph ph-arrow-right"></i>
        </button>
        <button class="def-action-btn" data-action="refresh" title="Refresh from URI" ${!definition.sourceUri ? 'disabled' : ''}>
          <i class="ph ph-arrows-clockwise"></i>
        </button>
        <button class="def-action-btn danger" data-action="delete" title="Delete definition">
          <i class="ph ph-trash"></i>
        </button>
      </div>
    `;

    // New hierarchy columns: Definition, Kind, Status, Usage, Scope
    return `
      <tr class="${rowClass}" data-definition-id="${definition.id}" data-pending="${isPending}" data-kind="${kindInfo.kind}">
        <td class="col-expand">
          <button class="def-row-expand-btn" title="Expand details">
            <i class="ph ph-caret-right"></i>
          </button>
        </td>
        <td class="col-name">
          <div class="def-name-cell">
            <i class="ph ${kindInfo.icon} def-icon" style="color: ${kindInfo.color};"></i>
            <div class="def-name-content">
              <span class="def-name-text" data-field="name">${this._escapeHtml(definition.name)}</span>
              ${termCount > 0 ? `<span class="def-term-count">${termCount} term${termCount !== 1 ? 's' : ''}</span>` : ''}
            </div>
          </div>
        </td>
        <td class="col-kind">
          <span class="kind-badge" style="background: ${kindInfo.color}15; color: ${kindInfo.color};">
            <i class="ph ${kindInfo.icon}"></i>
            ${kindInfo.kind}
          </span>
        </td>
        <td class="col-status">
          <span class="stability-badge" style="background: ${stabilityInfo.color}15; color: ${stabilityInfo.color};" title="${stabilityInfo.description}">
            <i class="ph ${stabilityInfo.icon}"></i>
            ${stabilityInfo.stability}
          </span>
        </td>
        <td class="col-usage">
          <span class="usage-badge ${linkedFieldsCount > 0 ? 'has-usage' : 'no-usage'}" title="${linkedFieldsCount} field${linkedFieldsCount !== 1 ? 's' : ''} using this definition">
            ${linkedFieldsCount}
          </span>
        </td>
        <td class="col-scope">
          <span class="scope-badge" title="${scopeInfo.scopeDetail}">
            <i class="ph ${scopeInfo.icon}"></i>
            ${scopeInfo.scope}
          </span>
        </td>
        <td class="col-actions">
          ${actionsHtml}
        </td>
      </tr>
      <tr class="definition-expanded-row" data-definition-id="${definition.id}" style="display: none;">
        <td colspan="7">
          <div class="def-expanded-content">
            <!-- Meaning Contract Summary -->
            <div class="expanded-section contract-summary">
              <span class="expanded-label">Meaning Contract:</span>
              <span class="contract-text">${kindInfo.kind === 'Identifier' ? 'Unique per-record reference' : kindInfo.kind === 'Measure' ? 'Quantitative, aggregatable value' : kindInfo.kind === 'Temporal' ? 'Date/time, chronologically orderable' : kindInfo.kind === 'Relational' ? 'Reference to another entity' : kindInfo.kind === 'Administrative' ? 'Status or control field' : 'Descriptive attribute'}</span>
            </div>

            <!-- Impact Summary -->
            <div class="expanded-section impact-summary">
              <span class="expanded-label">Impact:</span>
              <span class="impact-text">${linkedFieldsCount > 0 ? `Used in ${linkedFieldsCount} field${linkedFieldsCount !== 1 ? 's' : ''}` : 'Not yet applied'}</span>
            </div>

            <!-- Quick Actions -->
            <div class="expanded-actions">
              <button class="expanded-action-btn" data-action="apply" title="Apply to fields">
                <i class="ph ph-plugs-connected"></i> Apply
              </button>
              <button class="expanded-action-btn" data-action="compare" title="Compare with similar">
                <i class="ph ph-git-diff"></i> Compare
              </button>
              <button class="expanded-action-btn" data-action="refine" title="Create refinement">
                <i class="ph ph-git-branch"></i> Refine
              </button>
            </div>

            <!-- Terms Preview -->
            ${terms.length > 0 ? `
              <div class="expanded-section terms-preview">
                <span class="expanded-label">Terms:</span>
                <div class="terms-chips">
                  ${terms.slice(0, 5).map(t => `<span class="term-chip">${this._escapeHtml(t.name || t.label)}</span>`).join('')}
                  ${terms.length > 5 ? `<span class="term-more">+${terms.length - 5} more</span>` : ''}
                </div>
              </div>
            ` : ''}
          </div>
        </td>
      </tr>
    `;
  }

  /**
   * Render a single term row within a definition
   */
  _renderTermRow(term, definition, sets) {
    const termId = term.id || term.name;
    const termUri = term.uri || term['@id'] || '';

    // Check if this term is linked to any field
    let linkedTo = null;
    sets.forEach(set => {
      (set.fields || []).forEach(field => {
        if (field.definitionRef?.definitionId === definition.id &&
            field.definitionRef?.termId === termId) {
          linkedTo = { setName: set.name, fieldName: field.name, setId: set.id, fieldId: field.id };
        }
      });
    });

    return `
      <tr class="term-row" data-term-id="${termId}" data-definition-id="${definition.id}">
        <td class="term-name">
          <i class="ph ph-tag"></i>
          <span>${this._escapeHtml(term.name || term.label)}</span>
        </td>
        <td class="term-type">
          <span class="type-badge">${this._escapeHtml(term.type || term.datatype || 'string')}</span>
        </td>
        <td class="term-description">${this._escapeHtml(term.description || term.comment || '—')}</td>
        <td class="term-uri">
          ${termUri ? `
            <a href="${this._escapeHtml(termUri)}" target="_blank" class="term-uri-link" title="${this._escapeHtml(termUri)}">
              ${this._escapeHtml(this._truncateName(termUri, 25))}
            </a>
          ` : '—'}
        </td>
        <td class="term-link-action">
          ${linkedTo ? `
            <span class="term-linked-to" title="Linked to ${linkedTo.setName}.${linkedTo.fieldName}">
              <i class="ph ph-check-circle"></i>
              ${this._escapeHtml(linkedTo.setName)}.${this._escapeHtml(linkedTo.fieldName)}
              <button class="term-unlink-btn" data-set-id="${linkedTo.setId}" data-field-id="${linkedTo.fieldId}" title="Unlink">
                <i class="ph ph-x"></i>
              </button>
            </span>
          ` : `
            <button class="term-link-btn" data-term-id="${termId}" data-definition-id="${definition.id}" title="Link to a set field">
              <i class="ph ph-arrow-right"></i>
              Link to field
            </button>
          `}
        </td>
      </tr>
    `;
  }

  /**
   * Attach event handlers for the definitions panel
   */
  _attachDefinitionsPanelHandlers(definitions, sets) {
    const contentArea = this.elements.contentArea;

    // Import button
    contentArea.querySelector('#def-panel-import-btn')?.addEventListener('click', () => {
      this._showImportDefinitionModal();
    });

    // New definition button
    contentArea.querySelector('#def-panel-new-btn')?.addEventListener('click', () => {
      this._showNewDefinitionModal();
    });

    // Empty state buttons
    contentArea.querySelector('#def-panel-empty-import')?.addEventListener('click', () => {
      this._showImportDefinitionModal();
    });
    contentArea.querySelector('#def-panel-empty-create')?.addEventListener('click', () => {
      this._showNewDefinitionModal();
    });

    // View toggle buttons
    contentArea.querySelectorAll('.view-toggle-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const view = btn.dataset.view;
        const groupedView = contentArea.querySelector('#definitions-grouped-view');
        const tableView = contentArea.querySelector('#definitions-table-view');

        // Update button states
        contentArea.querySelectorAll('.view-toggle-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');

        // Toggle views
        if (view === 'grouped') {
          if (groupedView) groupedView.style.display = '';
          if (tableView) tableView.style.display = 'none';
        } else {
          if (groupedView) groupedView.style.display = 'none';
          if (tableView) tableView.style.display = '';
        }
      });
    });

    // Search
    const searchInput = contentArea.querySelector('#def-panel-search');
    searchInput?.addEventListener('input', (e) => {
      this._filterDefinitionsPanel(e.target.value);
    });

    // Kind filter
    contentArea.querySelector('#def-panel-kind-filter')?.addEventListener('change', () => {
      this._applyDefinitionsPanelFilters();
    });

    // Status filter
    contentArea.querySelector('#def-panel-status-filter')?.addEventListener('change', () => {
      this._applyDefinitionsPanelFilters();
    });

    // Scope filter
    contentArea.querySelector('#def-panel-scope-filter')?.addEventListener('change', () => {
      this._applyDefinitionsPanelFilters();
    });

    // Grouped view item clicks - navigate to definition detail
    contentArea.querySelectorAll('.definition-grouped-item').forEach(item => {
      item.addEventListener('click', () => {
        const definitionId = item.dataset.definitionId;
        if (definitionId) {
          this._showDefinitionDetail(definitionId);
        }
      });
    });

    // Row expand buttons (table view)
    contentArea.querySelectorAll('.def-row-expand-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const row = btn.closest('.definition-row');
        const definitionId = row?.dataset.definitionId;
        const expandedRow = contentArea.querySelector(`.definition-expanded-row[data-definition-id="${definitionId}"]`);

        if (expandedRow) {
          const isExpanded = expandedRow.style.display !== 'none';
          expandedRow.style.display = isExpanded ? 'none' : 'table-row';
          row.classList.toggle('expanded', !isExpanded);
          btn.querySelector('i').className = isExpanded ? 'ph ph-caret-right' : 'ph ph-caret-down';
        }
      });
    });

    // Row click to navigate to detail (table view)
    contentArea.querySelectorAll('.definition-row').forEach(row => {
      row.addEventListener('click', (e) => {
        // Don't navigate if clicking on buttons or expand area
        if (e.target.closest('.def-row-expand-btn') || e.target.closest('.def-action-btn') || e.target.closest('.col-actions')) {
          return;
        }
        const definitionId = row.dataset.definitionId;
        if (definitionId) {
          this._showDefinitionDetail(definitionId);
        }
      });
    });

    // Expanded row action buttons
    contentArea.querySelectorAll('.expanded-action-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const expandedRow = btn.closest('.definition-expanded-row');
        const definitionId = expandedRow?.dataset.definitionId;
        const action = btn.dataset.action;

        if (!definitionId) return;

        switch (action) {
          case 'apply':
            this._showApplyToFieldsModal(definitionId);
            break;
          case 'compare':
            this._showCompareDefinitionsModal(definitionId);
            break;
          case 'refine':
            this._showCreateRefinementModal(definitionId);
            break;
        }
      });
    });

    // Row action buttons
    contentArea.querySelectorAll('.def-action-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const row = btn.closest('.definition-row');
        const definitionId = row?.dataset.definitionId;
        const action = btn.dataset.action;

        if (!definitionId) return;

        switch (action) {
          case 'edit':
            this._showEditDefinitionModal(definitionId);
            break;
          case 'link':
            this._showLinkDefinitionToFieldModal(definitionId);
            break;
          case 'refresh':
            this._refreshDefinitionFromUri(definitionId);
            break;
          case 'delete':
            this._deleteDefinition(definitionId);
            break;
          case 'approve':
            this._approveDefinition(definitionId);
            break;
          case 'dismiss':
            this._dismissDefinition(definitionId);
            break;
        }
      });
    });

    // Add term buttons
    contentArea.querySelectorAll('.def-add-term-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const definitionId = btn.dataset.definitionId;
        this._showAddTermModal(definitionId);
      });
    });

    // Term link buttons
    contentArea.querySelectorAll('.term-link-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const termId = btn.dataset.termId;
        const definitionId = btn.dataset.definitionId;
        this._showLinkTermToFieldModal(definitionId, termId);
      });
    });

    // Term unlink buttons
    contentArea.querySelectorAll('.term-unlink-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const setId = btn.dataset.setId;
        const fieldId = btn.dataset.fieldId;
        this._unlinkFieldFromDefinition(setId, fieldId);
      });
    });

    // Linked fields badge click
    contentArea.querySelectorAll('.def-linked-badge.has-links').forEach(badge => {
      badge.addEventListener('click', () => {
        const row = badge.closest('.definition-row');
        const definitionId = row?.dataset.definitionId;
        this._showLinkedFieldsModal(definitionId);
      });
    });

    // Double-click to edit name/description
    contentArea.querySelectorAll('.def-name-text, .def-description-text').forEach(cell => {
      cell.addEventListener('dblclick', (e) => {
        const row = cell.closest('.definition-row');
        const definitionId = row?.dataset.definitionId;
        const field = cell.dataset.field;
        this._startInlineEdit(definitionId, field, cell);
      });
    });
  }

  /**
   * Auto-import keys from all SET fields as stub definitions
   * Creates stub definitions for any SET fields that don't already have a matching definition
   */
  _autoImportKeysFromSets() {
    const sets = this.sets.filter(s => s.status !== 'archived');
    if (sets.length === 0) {
      this._showNotification('No sets available to import keys from', 'info');
      return;
    }

    // Build a map of existing definition terms (normalized) to avoid duplicates
    const existingTerms = new Set(
      this.definitions.map(d => {
        const term = d.term?.term || d.discoveredFrom?.fieldName || d.name || '';
        return term.toLowerCase().replace(/[\s_-]+/g, '_');
      })
    );

    const newDefinitions = [];
    const processedFields = new Set(); // Track field names to avoid duplicates across sets

    for (const set of sets) {
      const fields = set.fields || [];
      const records = set.records || [];

      for (const field of fields) {
        const fieldName = field.name;
        const normalizedName = fieldName.toLowerCase().replace(/[\s_-]+/g, '_');

        // Skip if we already have a definition for this term or already processed
        if (existingTerms.has(normalizedName) || processedFields.has(normalizedName)) {
          continue;
        }

        // Extract sample values from records for this field
        const samples = [];
        const uniqueValuesSet = new Set();
        for (const record of records.slice(0, 100)) { // Sample from first 100 records
          const value = record.values?.[field.id];
          if (value !== undefined && value !== null && value !== '') {
            if (samples.length < 10) {
              samples.push(String(value));
            }
            if (uniqueValuesSet.size < 50) {
              uniqueValuesSet.add(String(value));
            }
          }
        }

        // Get field options for SELECT types
        const fieldOptions = field.options?.choices ? { choices: field.options.choices } : null;

        // Use existing unique values from options if available (for SELECT fields)
        let fieldUniqueValues = Array.from(uniqueValuesSet);
        if (field.options?.choices?.length > 0) {
          fieldUniqueValues = field.options.choices.map(c => c.name);
        }

        // Create stub definition using the EO.createStubDefinition factory
        const stubDef = window.EO.createStubDefinition({
          term: fieldName,
          fieldType: field.type,
          fieldConfidence: field.confidence || 1.0,
          fieldIsPrimary: field.isPrimary || false,
          fieldSamples: samples.length > 0 ? samples : null,
          fieldOptions: fieldOptions,
          fieldUniqueValues: fieldUniqueValues.length > 0 ? fieldUniqueValues : null,
          discoveredFrom: {
            sourceId: set.id,
            sourceName: set.name,
            fieldId: field.id,
            fieldName: fieldName,
            fieldType: field.type,
            fieldConfidence: field.confidence || 1.0,
            fieldIsPrimary: field.isPrimary || false,
            fieldSamples: samples.length > 0 ? samples : null,
            fieldOptions: fieldOptions,
            fieldUniqueValues: fieldUniqueValues.length > 0 ? fieldUniqueValues : null,
            fieldSampleCount: samples.length,
            fieldUniqueCount: fieldUniqueValues.length,
            discoveredAt: new Date().toISOString()
          }
        });

        // Convert to internal format for workbench storage
        const internalDef = {
          id: stubDef.id,
          name: stubDef.term?.label || fieldName,
          description: `Auto-imported from SET: ${set.name}`,
          format: 'stub',
          status: stubDef.status || 'stub',
          populationMethod: stubDef.populationMethod || 'pending',
          term: stubDef.term,
          discoveredFrom: stubDef.discoveredFrom,
          apiSuggestions: [],
          terms: [{
            id: stubDef.id + '_term',
            name: fieldName,
            label: stubDef.term?.label || fieldName,
            type: field.type
          }],
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        };

        newDefinitions.push(internalDef);
        processedFields.add(normalizedName);
        existingTerms.add(normalizedName);
      }
    }

    if (newDefinitions.length === 0) {
      this._showNotification('All SET fields already have definitions', 'info');
      return;
    }

    // Add new definitions to the workbench
    this.definitions.push(...newDefinitions);

    // Add definitions to current project if applicable
    if (this.currentProjectId) {
      const project = this.projects.find(p => p.id === this.currentProjectId);
      if (project) {
        if (!project.definitionIds) project.definitionIds = [];
        for (const def of newDefinitions) {
          if (!project.definitionIds.includes(def.id)) {
            project.definitionIds.push(def.id);
          }
        }
      }
    }

    this._saveData();

    // Refresh the definitions panel to show new definitions
    this._showDefinitionsPanel();

    // Show success notification
    this._showNotification(
      `Imported ${newDefinitions.length} key${newDefinitions.length !== 1 ? 's' : ''} from ${sets.length} set${sets.length !== 1 ? 's' : ''}`,
      'success'
    );
  }

  /**
   * Filter definitions panel by search term
   */
  _filterDefinitionsPanel(searchTerm) {
    const term = searchTerm.toLowerCase().trim();
    const rows = document.querySelectorAll('.definition-row');

    rows.forEach(row => {
      const definitionId = row.dataset.definitionId;
      const def = this.definitions.find(d => d.id === definitionId);
      if (!def) {
        row.style.display = 'none';
        return;
      }

      const searchFields = [
        def.name,
        def.description,
        ...(def.terms || def.properties || []).map(t => t.name || t.label)
      ].filter(Boolean).join(' ').toLowerCase();

      const matches = !term || searchFields.includes(term);
      row.style.display = matches ? '' : 'none';

      // Also hide the terms row if definition is hidden
      const termsRow = document.querySelector(`.definition-terms-row[data-definition-id="${definitionId}"]`);
      if (termsRow && !matches) {
        termsRow.style.display = 'none';
      }
    });
  }

  /**
   * Apply filters to definitions panel
   */
  _applyDefinitionsPanelFilters() {
    const formatFilter = document.getElementById('def-panel-format-filter')?.value || '';
    const sourceFilter = document.getElementById('def-panel-source-filter')?.value || '';
    const statusFilter = document.getElementById('def-panel-status-filter')?.value || '';
    const rows = document.querySelectorAll('.definition-row');

    rows.forEach(row => {
      const definitionId = row.dataset.definitionId;
      const def = this.definitions.find(d => d.id === definitionId);
      if (!def) {
        row.style.display = 'none';
        return;
      }

      const defFormat = (def.format || def.type || '').toLowerCase();
      const defSource = def.sourceUri ? 'uri' : 'local';
      const isPending = this._isDefinitionPending(def);

      const formatMatch = !formatFilter || defFormat.includes(formatFilter);
      const sourceMatch = !sourceFilter || defSource === sourceFilter;
      const statusMatch = !statusFilter ||
        (statusFilter === 'pending' && isPending) ||
        (statusFilter === 'active' && !isPending);

      row.style.display = formatMatch && sourceMatch && statusMatch ? '' : 'none';

      // Also hide the terms row if definition is hidden
      const termsRow = document.querySelector(`.definition-terms-row[data-definition-id="${definitionId}"]`);
      if (termsRow && (!formatMatch || !sourceMatch || !statusMatch)) {
        termsRow.style.display = 'none';
      }
    });
  }

  /**
   * Start inline editing of a definition field
   */
  _startInlineEdit(definitionId, field, cell) {
    const definition = this.definitions.find(d => d.id === definitionId);
    if (!definition) return;

    const currentValue = field === 'name' ? definition.name : (definition.description || '');
    const originalContent = cell.innerHTML;

    cell.innerHTML = `
      <input type="text" class="inline-edit-input" value="${this._escapeHtml(currentValue)}" />
    `;

    const input = cell.querySelector('input');
    input.focus();
    input.select();

    const saveEdit = () => {
      const newValue = input.value.trim();
      if (newValue && newValue !== currentValue) {
        definition[field] = newValue;
        this._saveData();
        cell.textContent = newValue;
        this._showToast(`Definition ${field} updated`, 'success');
      } else {
        cell.innerHTML = originalContent;
      }
    };

    input.addEventListener('blur', saveEdit);
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        saveEdit();
      } else if (e.key === 'Escape') {
        cell.innerHTML = originalContent;
      }
    });
  }

  /**
   * Show modal to link a definition term to a set field
   */
  _showLinkTermToFieldModal(definitionId, termId) {
    const definition = this.definitions.find(d => d.id === definitionId);
    if (!definition) return;

    const term = (definition.terms || definition.properties || []).find(t => (t.id || t.name) === termId);
    if (!term) return;

    const sets = this.sets.filter(s => s.status !== 'archived');

    const html = `
      <div class="link-term-form">
        <p>Link term "<strong>${this._escapeHtml(term.name || term.label)}</strong>" to a set field:</p>
        <div class="link-term-sets">
          ${sets.length > 0 ? sets.map(set => `
            <div class="link-term-set-group" data-set-id="${set.id}">
              <div class="link-term-set-header">
                <i class="${set.icon || 'ph ph-table'}"></i>
                <span>${this._escapeHtml(set.name)}</span>
              </div>
              <div class="link-term-fields">
                ${(set.fields || []).map(field => {
                  const isLinked = field.definitionRef?.definitionId === definitionId &&
                                   field.definitionRef?.termId === termId;
                  return `
                    <label class="link-term-field-option ${isLinked ? 'already-linked' : ''}">
                      <input type="radio" name="target-field" value="${set.id}:${field.id}" ${isLinked ? 'checked' : ''}>
                      <i class="ph ph-text-columns"></i>
                      <span>${this._escapeHtml(field.name)}</span>
                      ${isLinked ? '<span class="linked-indicator"><i class="ph ph-check"></i></span>' : ''}
                    </label>
                  `;
                }).join('')}
              </div>
            </div>
          `).join('') : `
            <p class="no-sets-message">No sets available. Create a set first.</p>
          `}
        </div>
      </div>
    `;

    this._showModal('Link Term to Field', html, () => {
      const selected = document.querySelector('input[name="target-field"]:checked')?.value;
      if (selected) {
        const [setId, fieldId] = selected.split(':');
        this._linkTermToField(definitionId, termId, setId, fieldId);
      }
    });
  }

  /**
   * Link a term to a field
   */
  _linkTermToField(definitionId, termId, setId, fieldId) {
    const set = this.sets.find(s => s.id === setId);
    const definition = this.definitions.find(d => d.id === definitionId);
    const term = (definition?.terms || definition?.properties || []).find(t => (t.id || t.name) === termId);

    if (!set || !definition || !term) return;

    const field = set.fields.find(f => f.id === fieldId);
    if (!field) return;

    // Set the definition reference
    field.definitionRef = {
      definitionId: definitionId,
      termId: termId,
      uri: term.uri || term['@id'] || null,
      lastSyncedAt: new Date().toISOString()
    };

    this._saveData();
    this._closeModal();
    this._showDefinitionsPanel(); // Refresh the panel
    this._showToast(`Linked "${term.name || term.label}" to "${field.name}"`, 'success');
  }

  /**
   * Unlink a field from its definition
   */
  _unlinkFieldFromDefinition(setId, fieldId) {
    const set = this.sets.find(s => s.id === setId);
    if (!set) return;

    const field = set.fields.find(f => f.id === fieldId);
    if (!field) return;

    delete field.definitionRef;
    this._saveData();
    this._showDefinitionsPanel(); // Refresh the panel
    this._showToast('Field unlinked from definition', 'success');
  }

  /**
   * Show modal with all fields linked to a definition
   */
  _showLinkedFieldsModal(definitionId) {
    const definition = this.definitions.find(d => d.id === definitionId);
    if (!definition) return;

    const linkedFields = [];
    this.sets.forEach(set => {
      (set.fields || []).forEach(field => {
        if (field.definitionRef?.definitionId === definitionId) {
          const term = (definition.terms || definition.properties || []).find(t =>
            (t.id || t.name) === field.definitionRef.termId
          );
          linkedFields.push({
            setName: set.name,
            setId: set.id,
            fieldName: field.name,
            fieldId: field.id,
            termName: term?.name || term?.label || 'Unknown term'
          });
        }
      });
    });

    const html = `
      <div class="linked-fields-list">
        ${linkedFields.length === 0 ? `
          <p class="no-linked-fields">No fields are linked to this definition.</p>
        ` : `
          <table class="linked-fields-table">
            <thead>
              <tr>
                <th>Set</th>
                <th>Field</th>
                <th>Term</th>
                <th>Action</th>
              </tr>
            </thead>
            <tbody>
              ${linkedFields.map(lf => `
                <tr>
                  <td><i class="ph ph-table"></i> ${this._escapeHtml(lf.setName)}</td>
                  <td><i class="ph ph-text-columns"></i> ${this._escapeHtml(lf.fieldName)}</td>
                  <td><i class="ph ph-tag"></i> ${this._escapeHtml(lf.termName)}</td>
                  <td>
                    <button class="btn btn-sm btn-danger unlink-field-btn"
                            data-set-id="${lf.setId}" data-field-id="${lf.fieldId}">
                      <i class="ph ph-x"></i> Unlink
                    </button>
                  </td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        `}
      </div>
    `;

    this._showModal(`Linked Fields - ${definition.name}`, html);

    // Attach unlink button handlers
    document.querySelectorAll('.unlink-field-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const setId = btn.dataset.setId;
        const fieldId = btn.dataset.fieldId;
        this._unlinkFieldFromDefinition(setId, fieldId);
        this._closeModal();
        this._showLinkedFieldsModal(definitionId); // Refresh modal
      });
    });
  }

  /**
   * Show modal to link entire definition to set fields
   */
  _showLinkDefinitionToFieldModal(definitionId) {
    const definition = this.definitions.find(d => d.id === definitionId);
    if (!definition) return;

    const terms = definition.terms || definition.properties || [];
    const sets = this.sets.filter(s => s.status !== 'archived');

    if (terms.length === 0) {
      this._showNotification('This definition has no terms to link', 'warning');
      return;
    }

    const html = `
      <div class="link-definition-form">
        <p>Select a term from "<strong>${this._escapeHtml(definition.name)}</strong>" to link:</p>
        <div class="link-definition-terms">
          ${terms.map(term => `
            <label class="link-term-option">
              <input type="radio" name="selected-term" value="${term.id || term.name}">
              <i class="ph ph-tag"></i>
              <span class="term-name">${this._escapeHtml(term.name || term.label)}</span>
              <span class="term-type-badge">${this._escapeHtml(term.type || term.datatype || 'string')}</span>
            </label>
          `).join('')}
        </div>
        <hr class="form-divider">
        <p>Then select a field to link it to:</p>
        <div class="link-term-sets">
          ${sets.map(set => `
            <div class="link-term-set-group" data-set-id="${set.id}">
              <div class="link-term-set-header">
                <i class="${set.icon || 'ph ph-table'}"></i>
                <span>${this._escapeHtml(set.name)}</span>
              </div>
              <div class="link-term-fields">
                ${(set.fields || []).map(field => `
                  <label class="link-term-field-option">
                    <input type="radio" name="target-field" value="${set.id}:${field.id}">
                    <i class="ph ph-text-columns"></i>
                    <span>${this._escapeHtml(field.name)}</span>
                  </label>
                `).join('')}
              </div>
            </div>
          `).join('')}
        </div>
      </div>
    `;

    this._showModal('Link Definition to Field', html, () => {
      const selectedTerm = document.querySelector('input[name="selected-term"]:checked')?.value;
      const selectedField = document.querySelector('input[name="target-field"]:checked')?.value;

      if (selectedTerm && selectedField) {
        const [setId, fieldId] = selectedField.split(':');
        this._linkTermToField(definitionId, selectedTerm, setId, fieldId);
      } else {
        this._showNotification('Please select both a term and a field', 'warning');
      }
    });
  }

  /**
   * Show modal to apply definition to keys
   */
  _showApplyDefinitionModal(definitionId) {
    const definition = this.definitions.find(d => d.id === definitionId);
    if (!definition) return;

    const sets = this.sets.filter(s => s.status !== 'archived');

    // Collect all unique keys from all sets
    const keysMap = new Map(); // key name -> { sets: [setNames], count: number }
    sets.forEach(set => {
      const fields = set.fields || [];
      fields.forEach(field => {
        const keyName = field.name || field.id;
        if (!keysMap.has(keyName)) {
          keysMap.set(keyName, { sets: [], count: 0 });
        }
        const keyInfo = keysMap.get(keyName);
        keyInfo.sets.push(set.name);
        keyInfo.count += (set.records?.length || 0);
      });
    });

    const keys = Array.from(keysMap.entries())
      .map(([name, info]) => ({ name, sets: info.sets, count: info.count }))
      .sort((a, b) => a.name.localeCompare(b.name));

    const html = `
      <div class="apply-definition-form">
        <p>Apply "<strong>${this._escapeHtml(definition.name)}</strong>" to:</p>
        <div class="apply-definition-sets">
          ${keys.length > 0 ? keys.map(key => `
            <label class="apply-definition-set-option">
              <input type="radio" name="target-key" value="${this._escapeHtml(key.name)}">
              <i class="ph ph-key"></i>
              <span>${this._escapeHtml(key.name)}</span>
              <span class="set-record-count">${key.count} records</span>
            </label>
          `).join('') : `
            <p class="no-sets-message">No keys available. Create a set with fields first.</p>
          `}
        </div>
      </div>
    `;

    this._showModal('Apply Definition', html, () => {
      const selectedKey = document.querySelector('input[name="target-key"]:checked')?.value;
      if (selectedKey) {
        this._applyDefinitionToKey(definitionId, selectedKey);
      }
    }, {
      confirmText: 'Apply',
      confirmDisabled: keys.length === 0
    });
  }

  /**
   * Apply a definition to a set (map terms to fields)
   */
  _applyDefinitionToSet(definitionId, setId) {
    const definition = this.definitions.find(d => d.id === definitionId);
    const set = this.sets.find(s => s.id === setId);

    if (!definition || !set) {
      this._showToast('Definition or set not found', 'error');
      return;
    }

    const terms = definition.terms || definition.properties || [];

    // Map definition terms to set fields by name matching
    let mappedCount = 0;
    set.views?.forEach(view => {
      view.columns?.forEach(col => {
        const matchingTerm = terms.find(t =>
          (t.name || t.label)?.toLowerCase() === col.key?.toLowerCase() ||
          (t.name || t.label)?.toLowerCase() === col.name?.toLowerCase()
        );
        if (matchingTerm) {
          col.definitionTerm = {
            definitionId: definition.id,
            termId: matchingTerm.id || matchingTerm.name,
            termName: matchingTerm.name || matchingTerm.label,
            type: matchingTerm.type || matchingTerm.datatype,
            uri: matchingTerm.uri || matchingTerm['@id']
          };
          mappedCount++;
        }
      });
    });

    this._saveData();
    this._showToast(`Applied ${mappedCount} term${mappedCount !== 1 ? 's' : ''} to "${set.name}"`, 'success');
  }

  /**
   * Apply a definition to a key across all sets
   */
  _applyDefinitionToKey(definitionId, keyName) {
    const definition = this.definitions.find(d => d.id === definitionId);
    if (!definition) {
      this._showToast('Definition not found', 'error');
      return;
    }

    const sets = this.sets.filter(s => s.status !== 'archived');
    let updatedCount = 0;

    // Apply definition to all fields with matching key name across all sets
    sets.forEach(set => {
      const fields = set.fields || [];
      fields.forEach(field => {
        const fieldName = field.name || field.id;
        if (fieldName === keyName) {
          field.definition = {
            definitionId: definition.id,
            definitionName: definition.name,
            uri: definition.sourceUri || definition.uri
          };
          updatedCount++;
        }
      });
    });

    this._saveData();
    this._showToast(`Applied definition to "${keyName}" in ${updatedCount} set${updatedCount !== 1 ? 's' : ''}`, 'success');
  }

  // ==========================================================================
  // Exports Explorer - Full-featured exports browser
  // ==========================================================================

  /**
   * Show the Exports Explorer in the main content area
   */
  _showExportsExplorer() {
    this.currentSourceId = null;
    this.currentSetId = null;
    this.currentDefinitionId = null;
    this.fileExplorerMode = false;

    // Update breadcrumb
    this._updateBreadcrumb('Exports Explorer', 'ph-export');

    // Render the exports explorer
    this._renderExportsExplorer();
  }

  /**
   * Render Exports Explorer view
   */
  _renderExportsExplorer() {
    const contentArea = this.elements.contentArea;
    if (!contentArea) return;

    const exports = this.exports || [];

    contentArea.innerHTML = `
      <div class="file-explorer">
        <div class="file-explorer-toolbar">
          <div class="file-explorer-toolbar-left">
            <button class="file-explorer-close-btn" id="exports-explorer-close" title="Close Exports Explorer">
              <i class="ph ph-x"></i>
            </button>
            <div class="file-explorer-title">
              <i class="ph ph-export"></i>
              <span>Exports Explorer</span>
              <span class="file-explorer-badge export-badge">SNAPSHOT</span>
            </div>
          </div>
          <div class="file-explorer-toolbar-center">
            <div class="file-explorer-search">
              <i class="ph ph-magnifying-glass"></i>
              <input type="text" id="exports-explorer-search" placeholder="Search exports...">
            </div>
          </div>
          <div class="file-explorer-toolbar-right">
            <button class="file-explorer-import-btn" id="exports-explorer-new">
              <i class="ph ph-plus"></i>
              <span>New Export</span>
            </button>
          </div>
        </div>

        <div class="file-explorer-content" style="padding: 20px;">
          <div class="fe-section-header">All Exports (${exports.length})</div>
          ${exports.length === 0 ? `
            <div class="nav-empty-state" style="padding: 40px;">
              <i class="ph ph-export"></i>
              <span>No exports yet</span>
              <button class="btn-link" id="exports-explorer-create">Create your first export</button>
            </div>
          ` : `
            <div class="file-explorer-grid">
              ${exports.map(exp => `
                <div class="fe-grid-item" data-export-id="${exp.id}">
                  <div class="fe-grid-icon">
                    <i class="ph ${this._getExportIcon(exp)}"></i>
                  </div>
                  <div class="fe-grid-name">${this._escapeHtml(exp.name)}</div>
                  <div class="fe-grid-meta">${exp.createdAt ? new Date(exp.createdAt).toLocaleDateString() : 'Unknown'} • ${exp.purpose || 'export'}</div>
                </div>
              `).join('')}
            </div>
          `}
        </div>
      </div>
    `;

    // Attach event handlers
    contentArea.querySelector('#exports-explorer-close')?.addEventListener('click', () => {
      this._renderView();
    });

    contentArea.querySelector('#exports-explorer-new')?.addEventListener('click', () => {
      this._showNewExportModal();
    });

    contentArea.querySelector('#exports-explorer-create')?.addEventListener('click', () => {
      this._showNewExportModal();
    });

    contentArea.querySelectorAll('.fe-grid-item[data-export-id]').forEach(item => {
      item.addEventListener('click', () => {
        const exportId = item.dataset.exportId;
        this._showExportDetail(exportId);
      });
    });
  }

  // ==========================================================================
  // Table Views for each panel
  // ==========================================================================

  /**
   * Show sets as a table view in the main content area (alternate view)
   * Note: Primary implementation is above - this is a simplified fallback
   */
  _showSetsTableViewAlt() {
    const contentArea = this.elements.contentArea;
    if (!contentArea) return;

    // Get sets filtered by current project hierarchy
    const sets = this._getProjectSets();

    // Update breadcrumb
    this._updateBreadcrumb({
      workspace: this._getCurrentWorkspaceName(),
      set: 'Sets',
      view: 'Table View'
    });

    contentArea.innerHTML = `
      <div class="sources-table-view">
        <div class="sources-table-header">
          <div class="sources-table-title">
            <div class="sources-table-icon">
              <i class="ph ph-database"></i>
            </div>
            <div class="sources-table-info">
              <h2>
                <span>Sets</span>
                <span class="schema-badge" style="font-size: 10px; padding: 2px 6px; border-radius: 4px; background: rgba(59, 130, 246, 0.15); color: var(--primary-500);">
                  SCHEMA
                </span>
              </h2>
              <div class="sources-table-meta">
                ${sets.length} set${sets.length !== 1 ? 's' : ''}${this.currentProjectId ? ` in ${this._escapeHtml(this._getCurrentProjectName())}` : ''}
              </div>
            </div>
          </div>
          <div class="sources-table-actions">
            <button class="source-action-btn" id="sets-table-new-btn" title="Create new set">
              <i class="ph ph-plus"></i>
              <span>New Set</span>
            </button>
          </div>
        </div>

        <div class="sources-table-container">
          ${sets.length > 0 ? `
            <table class="sources-table">
              <thead>
                <tr>
                  <th class="col-icon"></th>
                  <th class="col-name">Name</th>
                  <th class="col-records">Records</th>
                  <th class="col-views">Views</th>
                  <th class="col-created">Created</th>
                  <th class="col-actions"></th>
                </tr>
              </thead>
              <tbody>
                ${sets.map(set => `
                  <tr class="sources-table-row" data-set-id="${set.id}">
                    <td class="col-icon">
                      <i class="ph ph-database"></i>
                    </td>
                    <td class="col-name">${this._escapeHtml(set.name)}</td>
                    <td class="col-records">${set.records?.length || 0}</td>
                    <td class="col-views">${set.views?.length || 0}</td>
                    <td class="col-created">${set.createdAt ? new Date(set.createdAt).toLocaleDateString() : 'Unknown'}</td>
                    <td class="col-actions">
                      <button class="sources-table-action-btn" data-action="view" title="View set">
                        <i class="ph ph-eye"></i>
                      </button>
                    </td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
          ` : `
            <div class="sources-table-empty">
              <i class="ph ph-database"></i>
              <span>No sets yet. Create your first set to get started.</span>
            </div>
          `}
        </div>
      </div>
    `;

    // Attach event handlers
    contentArea.querySelector('#sets-table-new-btn')?.addEventListener('click', () => {
      this._showNewSetModal();
    });

    contentArea.querySelectorAll('.sources-table-row[data-set-id]').forEach(row => {
      row.addEventListener('click', () => {
        const setId = row.dataset.setId;
        this._selectSet(setId);
      });
    });
  }

  /**
   * Show exports as a table view in the main content area
   */
  _showExportsTableView() {
    const contentArea = this.elements.contentArea;
    if (!contentArea) return;

    // Get exports filtered by current project hierarchy
    const exports = this._getProjectExports();

    // Update breadcrumb
    this._updateBreadcrumb({
      workspace: this._getCurrentWorkspaceName(),
      set: 'Exports',
      view: 'Table View'
    });

    contentArea.innerHTML = `
      <div class="sources-table-view">
        <div class="sources-table-header">
          <div class="sources-table-title">
            <div class="sources-table-icon">
              <i class="ph ph-export"></i>
            </div>
            <div class="sources-table-info">
              <h2>
                <span>Exports</span>
                <span class="export-badge" style="font-size: 10px; padding: 2px 6px; border-radius: 4px; background: rgba(34, 197, 94, 0.15); color: rgb(34, 197, 94);">
                  <i class="ph ph-snowflake"></i>
                  SNAPSHOT
                </span>
              </h2>
              <div class="sources-table-meta">
                ${exports.length} export${exports.length !== 1 ? 's' : ''}${this.currentProjectId ? ` in ${this._escapeHtml(this._getCurrentProjectName())}` : ''}
              </div>
            </div>
          </div>
          <div class="sources-table-actions">
            <button class="source-action-btn" id="exports-table-new-btn" title="Create new export">
              <i class="ph ph-plus"></i>
              <span>New Export</span>
            </button>
          </div>
        </div>

        <div class="sources-table-container">
          ${exports.length > 0 ? `
            <table class="sources-table">
              <thead>
                <tr>
                  <th class="col-icon"></th>
                  <th class="col-name">Name</th>
                  <th class="col-purpose">Purpose</th>
                  <th class="col-created">Created</th>
                  <th class="col-actions"></th>
                </tr>
              </thead>
              <tbody>
                ${exports.map(exp => `
                  <tr class="sources-table-row" data-export-id="${exp.id}">
                    <td class="col-icon">
                      <i class="ph ${this._getExportIcon(exp)}"></i>
                    </td>
                    <td class="col-name">${this._escapeHtml(exp.name)}</td>
                    <td class="col-purpose">${exp.purpose || 'export'}</td>
                    <td class="col-created">${exp.createdAt ? new Date(exp.createdAt).toLocaleDateString() : 'Unknown'}</td>
                    <td class="col-actions">
                      <button class="sources-table-action-btn" data-action="view" title="View export">
                        <i class="ph ph-eye"></i>
                      </button>
                      <button class="sources-table-action-btn" data-action="download" title="Download export">
                        <i class="ph ph-download-simple"></i>
                      </button>
                    </td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
          ` : `
            <div class="sources-table-empty">
              <i class="ph ph-export"></i>
              <span>No exports yet. Create an export to capture a snapshot.</span>
            </div>
          `}
        </div>
      </div>
    `;

    // Attach event handlers
    contentArea.querySelector('#exports-table-new-btn')?.addEventListener('click', () => {
      this._showNewExportModal();
    });

    contentArea.querySelectorAll('.sources-table-row[data-export-id]').forEach(row => {
      row.addEventListener('click', (e) => {
        const btn = e.target.closest('.sources-table-action-btn');
        const exportId = row.dataset.exportId;

        if (btn) {
          const action = btn.dataset.action;
          if (action === 'download') {
            this._downloadExport(exportId);
            return;
          }
        }
        this._showExportDetail(exportId);
      });
    });
  }

  /**
   * Main File Explorer renderer
   */
  _renderFileExplorer() {
    const contentArea = this.elements.contentArea;
    if (!contentArea) return;

    // Get all active sources and sets
    const allSources = this._getFileExplorerSources();
    const filteredSources = this._filterFileExplorerSources(allSources);
    const allSets = this._getFileExplorerSets();
    const filteredSets = this._filterFileExplorerSets(allSets);
    const folders = this.folderStore?.getAll() || [];
    const tags = this.folderStore?.getAllTags() || [];
    const smartFolders = this.fileExplorerContentMode === 'sources'
      ? (this.folderStore?.getSmartFolders() || [])
      : this._getSetSmartFolders();

    // Choose data based on content mode
    const allItems = this.fileExplorerContentMode === 'sources' ? allSources : allSets;
    const filteredItems = this.fileExplorerContentMode === 'sources' ? filteredSources : filteredSets;

    contentArea.innerHTML = `
      <div class="file-explorer">
        <!-- Toolbar -->
        <div class="file-explorer-toolbar">
          <div class="file-explorer-toolbar-left">
            <button class="file-explorer-close-btn" id="fe-close-btn" title="Close File Explorer">
              <i class="ph ph-x"></i>
            </button>
            <div class="file-explorer-title">
              <i class="ph ph-folder-open"></i>
              <span>File Explorer</span>
            </div>
            <div class="file-explorer-content-toggle">
              <button class="fe-content-tab ${this.fileExplorerContentMode === 'sources' ? 'active' : ''}"
                      data-content-mode="sources">
                <i class="ph ph-file-csv"></i>
                <span>Sources</span>
                <span class="fe-content-badge given">GIVEN</span>
              </button>
              <button class="fe-content-tab ${this.fileExplorerContentMode === 'sets' ? 'active' : ''}"
                      data-content-mode="sets">
                <i class="ph ph-database"></i>
                <span>Sets</span>
                <span class="fe-content-badge schema">SCHEMA</span>
              </button>
            </div>
          </div>
          <div class="file-explorer-toolbar-center">
            <div class="file-explorer-search">
              <i class="ph ph-magnifying-glass"></i>
              <input type="text" id="fe-search" placeholder="Search ${this.fileExplorerContentMode}..."
                     value="${this._escapeHtml(this.fileExplorerSearchTerm)}">
              ${this.fileExplorerSearchTerm ? '<button class="fe-search-clear" id="fe-search-clear"><i class="ph ph-x"></i></button>' : ''}
            </div>
          </div>
          <div class="file-explorer-toolbar-right">
            <div class="file-explorer-view-toggle">
              <button class="fe-view-btn ${this.fileExplorerViewMode === 'tree' ? 'active' : ''}"
                      data-view="tree" title="Tree View">
                <i class="ph ph-tree-structure"></i>
              </button>
              <button class="fe-view-btn ${this.fileExplorerViewMode === 'list' ? 'active' : ''}"
                      data-view="list" title="List View">
                <i class="ph ph-list"></i>
              </button>
              <button class="fe-view-btn ${this.fileExplorerViewMode === 'grid' ? 'active' : ''}"
                      data-view="grid" title="Grid View">
                <i class="ph ph-squares-four"></i>
              </button>
            </div>
            <button class="file-explorer-import-btn" id="fe-import-btn">
              <i class="ph ph-plus"></i>
              <span>${this.fileExplorerContentMode === 'sets' ? 'New Set' : 'Import'}</span>
            </button>
          </div>
        </div>

        <!-- Selection Toolbar (shown when items are selected) -->
        ${this.fileExplorerContentMode === 'sources' && this.fileExplorerSelectedSources.size > 0 ? `
          <div class="file-explorer-selection-bar">
            <div class="fe-selection-info">
              <button class="fe-selection-clear" id="fe-clear-selection" title="Clear selection">
                <i class="ph ph-x"></i>
              </button>
              <span class="fe-selection-count">${this.fileExplorerSelectedSources.size} source${this.fileExplorerSelectedSources.size !== 1 ? 's' : ''} selected</span>
            </div>
            <div class="fe-selection-actions">
              <button class="fe-selection-action" id="fe-create-set-from-selection">
                <i class="ph ph-table"></i>
                <span>Create Set</span>
              </button>
              <button class="fe-selection-action secondary" id="fe-export-selected">
                <i class="ph ph-export"></i>
                <span>Export</span>
              </button>
              <button class="fe-selection-action danger" id="fe-delete-selected">
                <i class="ph ph-trash"></i>
                <span>Delete</span>
              </button>
            </div>
          </div>
        ` : ''}
        ${this.fileExplorerContentMode === 'sets' && this.fileExplorerSelectedSets.size > 0 ? `
          <div class="file-explorer-selection-bar">
            <div class="fe-selection-info">
              <button class="fe-selection-clear" id="fe-clear-set-selection" title="Clear selection">
                <i class="ph ph-x"></i>
              </button>
              <span class="fe-selection-count">${this.fileExplorerSelectedSets.size} set${this.fileExplorerSelectedSets.size !== 1 ? 's' : ''} selected</span>
            </div>
            <div class="fe-selection-actions">
              <button class="fe-selection-action secondary" id="fe-export-selected-sets">
                <i class="ph ph-export"></i>
                <span>Export</span>
              </button>
              <button class="fe-selection-action danger" id="fe-delete-selected-sets">
                <i class="ph ph-trash"></i>
                <span>Delete</span>
              </button>
            </div>
          </div>
        ` : ''}

        <!-- Main Content -->
        <div class="file-explorer-main">
          <!-- Sidebar -->
          <div class="file-explorer-sidebar">
            <!-- Quick Access -->
            <div class="fe-sidebar-section">
              <div class="fe-sidebar-section-header">
                <span>Quick Access</span>
              </div>
              <div class="fe-sidebar-items">
                ${smartFolders.map(sf => {
                  const count = allItems.filter(sf.filter).length;
                  const isActive = this.fileExplorerActiveFilter === sf.id;
                  return `
                    <div class="fe-sidebar-item ${isActive ? 'active' : ''}"
                         data-filter-type="smart" data-filter-id="${sf.id}">
                      <i class="ph ${sf.icon}"></i>
                      <span class="fe-sidebar-item-name">${sf.name}</span>
                      <span class="fe-sidebar-item-count">${count}</span>
                    </div>
                  `;
                }).join('')}
              </div>
            </div>

            ${this.fileExplorerContentMode === 'sources' ? `
            <!-- Folders (only for sources) -->
            <div class="fe-sidebar-section">
              <div class="fe-sidebar-section-header">
                <span>Folders</span>
                <button class="fe-sidebar-add-btn" id="fe-add-folder-btn" title="New Folder">
                  <i class="ph ph-plus"></i>
                </button>
              </div>
              <div class="fe-sidebar-items" id="fe-folder-list">
                ${this._renderFileExplorerFolderTree(folders, null)}
                ${folders.length === 0 ? `
                  <div class="fe-sidebar-empty">
                    <span>No folders yet</span>
                  </div>
                ` : ''}
              </div>
            </div>
            ` : ''}

            <!-- Tags -->
            <div class="fe-sidebar-section">
              <div class="fe-sidebar-section-header">
                <span>Tags</span>
                <button class="fe-sidebar-add-btn" id="fe-add-tag-btn" title="New Tag">
                  <i class="ph ph-plus"></i>
                </button>
              </div>
              <div class="fe-sidebar-items" id="fe-tag-list">
                ${tags.map(tag => {
                  const count = allItems.filter(s => (s.tags || []).includes(tag.id)).length;
                  const isActive = this.fileExplorerActiveFilter === `tag_${tag.id}`;
                  return `
                    <div class="fe-sidebar-item ${isActive ? 'active' : ''}"
                         data-filter-type="tag" data-filter-id="${tag.id}">
                      <span class="fe-tag-dot" style="background: var(--tag-${tag.color}, var(--accent))"></span>
                      <span class="fe-sidebar-item-name">${this._escapeHtml(tag.name)}</span>
                      <span class="fe-sidebar-item-count">${count}</span>
                    </div>
                  `;
                }).join('')}
                ${tags.length === 0 ? `
                  <div class="fe-sidebar-empty">
                    <span>No tags yet</span>
                  </div>
                ` : ''}
              </div>
            </div>
          </div>

          <!-- Content Area -->
          <div class="file-explorer-content">
            <!-- Breadcrumb -->
            <div class="fe-content-breadcrumb">
              ${this._renderFileExplorerBreadcrumb()}
            </div>

            <!-- Items Display -->
            <div class="fe-content-sources" id="fe-sources-container">
              ${this.fileExplorerContentMode === 'sources'
                ? this._renderFileExplorerContent(filteredItems, folders)
                : this._renderFileExplorerSetsContent(filteredItems)}
            </div>
          </div>

          <!-- Preview Panel -->
          <div class="file-explorer-preview ${(this.fileExplorerContentMode === 'sources' ? this.fileExplorerSelectedSource : this.fileExplorerSelectedSet) ? 'visible' : ''}" id="fe-preview-panel">
            ${this.fileExplorerContentMode === 'sources' ?
              (this.fileExplorerSelectedSource ? this._renderFileExplorerPreview(this.fileExplorerSelectedSource) : `
                <div class="fe-preview-empty">
                  <i class="ph ph-file-magnifying-glass"></i>
                  <span>Select a source to preview</span>
                </div>`)
              :
              (this.fileExplorerSelectedSet ? this._renderFileExplorerSetPreview(this.fileExplorerSelectedSet) : `
                <div class="fe-preview-empty">
                  <i class="ph ph-database"></i>
                  <span>Select a set to preview</span>
                </div>`)
            }
          </div>
        </div>
      </div>
    `;

    this._attachFileExplorerEventHandlers();
  }

  /**
   * Get sources for file explorer
   */
  _getFileExplorerSources() {
    const sources = [];
    const seenIds = new Set();

    // PRIORITY 1: Get from main this.sources array (primary storage)
    const activeSources = (this.sources || []).filter(s => s.status !== 'archived');
    for (const source of activeSources) {
      seenIds.add(source.id);
      sources.push({
        id: source.id,
        name: source.name,
        recordCount: source.recordCount || source.records?.length || 0,
        importedAt: source.importedAt,
        folderId: source.folderId || null,
        tags: source.tags || [],
        isFavorite: source.isFavorite || false,
        fileType: this._getFileType(source.name),
        schema: source.schema,
        provenance: source.provenance,
        fileIdentity: source.fileIdentity,
        isPrimary: true
      });
    }

    // PRIORITY 2: Get from SourceStore (for any sources not in main array)
    if (this.sourceStore) {
      const storedSources = this.sourceStore.getByStatus('active');
      for (const source of storedSources) {
        if (!seenIds.has(source.id)) {
          seenIds.add(source.id);
          sources.push({
            id: source.id,
            name: source.name,
            recordCount: source.recordCount,
            importedAt: source.importedAt,
            folderId: source.folderId || null,
            tags: source.tags || [],
            isFavorite: source.isFavorite || false,
            fileType: this._getFileType(source.name),
            schema: source.schema,
            provenance: source.provenance,
            fileIdentity: source.fileIdentity,
            isSourceStore: true
          });
        }
      }
    }

    // PRIORITY 3: Get legacy sources from sets
    const registry = this._getSourceRegistry();
    for (const source of registry.values()) {
      if (!seenIds.has(source.id) && !sources.find(s => s.name.toLowerCase() === source.name.toLowerCase())) {
        sources.push({
          id: source.id,
          name: source.name,
          recordCount: source.recordCount,
          importedAt: source.importedAt,
          folderId: null,
          tags: [],
          isFavorite: false,
          fileType: this._getFileType(source.name),
          provenance: source.provenance,
          isLegacy: true
        });
      }
    }

    // Sort by import date (newest first)
    return sources.sort((a, b) => {
      if (!a.importedAt) return 1;
      if (!b.importedAt) return -1;
      return new Date(b.importedAt) - new Date(a.importedAt);
    });
  }

  /**
   * Filter sources based on current filter
   */
  _filterFileExplorerSources(sources) {
    let filtered = sources;

    // Apply smart folder or tag filter
    if (this.fileExplorerActiveFilter) {
      if (this.fileExplorerActiveFilter.startsWith('tag_')) {
        const tagId = this.fileExplorerActiveFilter.replace('tag_', '');
        filtered = sources.filter(s => (s.tags || []).includes(tagId));
      } else if (this.fileExplorerActiveFilter.startsWith('folder_')) {
        const folderId = this.fileExplorerActiveFilter.replace('folder_', '');
        filtered = sources.filter(s => s.folderId === folderId);
      } else {
        // Smart folder filter
        const smartFolder = this.folderStore?.getSmartFolders().find(sf => sf.id === this.fileExplorerActiveFilter);
        if (smartFolder) {
          filtered = sources.filter(smartFolder.filter);
        }
      }
    }

    // Apply search filter
    if (this.fileExplorerSearchTerm) {
      const term = this.fileExplorerSearchTerm.toLowerCase();
      filtered = filtered.filter(s =>
        s.name.toLowerCase().includes(term) ||
        (s.tags || []).some(t => t.toLowerCase().includes(term))
      );
    }

    // Apply current folder filter
    if (this.fileExplorerCurrentFolder) {
      filtered = filtered.filter(s => s.folderId === this.fileExplorerCurrentFolder);
    }

    return filtered;
  }

  /**
   * Get sets for file explorer
   */
  _getFileExplorerSets() {
    const sets = this._getProjectSets() || [];

    return sets.map(set => {
      const derivationInfo = this._getSetDerivationInfo(set);
      return {
        id: set.id,
        name: set.name,
        icon: set.icon || 'ph-database',
        recordCount: set.records?.length || 0,
        fieldCount: set.fields?.length || 0,
        viewCount: set.views?.length || 0,
        lensCount: set.lenses?.length || 0,
        createdAt: set.createdAt,
        updatedAt: set.updatedAt,
        tags: set.tags || [],
        isFavorite: set.isFavorite || false,
        operator: derivationInfo.operator,
        operatorIcon: derivationInfo.icon,
        operatorColor: derivationInfo.color,
        sourceName: this._getSetSourceName(set),
        stabilityLevel: set.stabilityLevel || 'instance'
      };
    }).sort((a, b) => {
      if (!a.createdAt) return 1;
      if (!b.createdAt) return -1;
      return new Date(b.createdAt) - new Date(a.createdAt);
    });
  }

  /**
   * Filter sets based on current filter
   */
  _filterFileExplorerSets(sets) {
    let filtered = sets;

    // Apply smart folder or tag filter
    if (this.fileExplorerActiveFilter) {
      if (this.fileExplorerActiveFilter.startsWith('tag_')) {
        const tagId = this.fileExplorerActiveFilter.replace('tag_', '');
        filtered = sets.filter(s => (s.tags || []).includes(tagId));
      } else {
        // Smart folder filter for sets
        const smartFolder = this._getSetSmartFolders().find(sf => sf.id === this.fileExplorerActiveFilter);
        if (smartFolder) {
          filtered = sets.filter(smartFolder.filter);
        }
      }
    }

    // Apply search filter
    if (this.fileExplorerSearchTerm) {
      const term = this.fileExplorerSearchTerm.toLowerCase();
      filtered = filtered.filter(s =>
        s.name.toLowerCase().includes(term) ||
        (s.sourceName && s.sourceName.toLowerCase().includes(term)) ||
        (s.tags || []).some(t => t.toLowerCase().includes(term))
      );
    }

    return filtered;
  }

  /**
   * Get smart folders for sets view
   */
  _getSetSmartFolders() {
    return [
      {
        id: 'smart_all',
        name: 'All Sets',
        icon: 'ph-database',
        type: 'smart',
        filter: () => true
      },
      {
        id: 'smart_recent',
        name: 'Recent',
        icon: 'ph-clock',
        type: 'smart',
        filter: (set) => {
          const weekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
          return new Date(set.createdAt).getTime() > weekAgo;
        }
      },
      {
        id: 'smart_favorites',
        name: 'Favorites',
        icon: 'ph-star',
        type: 'smart',
        filter: (set) => set.isFavorite === true
      },
      {
        id: 'smart_large',
        name: 'Large Sets',
        icon: 'ph-file-magnifying-glass',
        type: 'smart',
        filter: (set) => set.recordCount > 1000
      },
      {
        id: 'smart_with_views',
        name: 'With Views',
        icon: 'ph-layout',
        type: 'smart',
        filter: (set) => set.viewCount > 1
      },
      {
        id: 'smart_with_lenses',
        name: 'With Lenses',
        icon: 'ph-binoculars',
        type: 'smart',
        filter: (set) => set.lensCount > 0
      }
    ];
  }

  /**
   * Render sets content in file explorer
   */
  _renderFileExplorerSetsContent(sets) {
    if (sets.length === 0) {
      return `
        <div class="fe-empty-state">
          <i class="ph ph-database"></i>
          <h3>No Sets Found</h3>
          <p>${this.fileExplorerSearchTerm ? 'Try a different search term' : 'Create a set to get started'}</p>
          <button class="btn btn-primary" id="fe-empty-create-set-btn">
            <i class="ph ph-plus"></i> New Set
          </button>
        </div>
      `;
    }

    switch (this.fileExplorerViewMode) {
      case 'tree':
        return this._renderFileExplorerSetsTreeView(sets);
      case 'grid':
        return this._renderFileExplorerSetsGridView(sets);
      default:
        return this._renderFileExplorerSetsListView(sets);
    }
  }

  /**
   * Render sets list view
   */
  _renderFileExplorerSetsListView(sets) {
    const allSelected = sets.length > 0 && sets.every(s => this.fileExplorerSelectedSets.has(s.id));
    const someSelected = sets.some(s => this.fileExplorerSelectedSets.has(s.id));

    return `
      <div class="fe-list-view">
        <div class="fe-list-header">
          <div class="fe-list-col fe-list-col-checkbox">
            <input type="checkbox" class="fe-select-all-checkbox" id="fe-select-all-sets"
                   ${allSelected ? 'checked' : ''}
                   ${someSelected && !allSelected ? 'data-indeterminate="true"' : ''}>
          </div>
          <div class="fe-list-col fe-list-col-name">Name</div>
          <div class="fe-list-col fe-list-col-type">Operator</div>
          <div class="fe-list-col fe-list-col-rows">Records</div>
          <div class="fe-list-col fe-list-col-date">Created</div>
          <div class="fe-list-col fe-list-col-tags">Tags</div>
          <div class="fe-list-col fe-list-col-actions"></div>
        </div>
        <div class="fe-list-body">
          ${sets.map(set => this._renderFileExplorerSetListRow(set)).join('')}
        </div>
      </div>
    `;
  }

  /**
   * Render a set row in list view
   */
  _renderFileExplorerSetListRow(set) {
    const isSelected = this.fileExplorerSelectedSet?.id === set.id;
    const isChecked = this.fileExplorerSelectedSets.has(set.id);
    const createdDate = set.createdAt ? new Date(set.createdAt).toLocaleDateString() : 'Unknown';
    const tags = set.tags || [];

    return `
      <div class="fe-list-row ${isSelected ? 'selected' : ''} ${isChecked ? 'checked' : ''}"
           data-set-id="${set.id}" draggable="true">
        <div class="fe-list-col fe-list-col-checkbox">
          <input type="checkbox" class="fe-set-checkbox" data-set-id="${set.id}"
                 ${isChecked ? 'checked' : ''}>
        </div>
        <div class="fe-list-col fe-list-col-name">
          <i class="ph ${set.icon}"></i>
          <span class="fe-list-source-name">${this._escapeHtml(set.name)}</span>
          ${set.isFavorite ? '<i class="ph ph-star-fill fe-favorite-icon"></i>' : ''}
        </div>
        <div class="fe-list-col fe-list-col-type">
          <span class="fe-operator-badge" style="background: ${set.operatorColor || 'var(--accent)'}">${set.operator || 'SET'}</span>
        </div>
        <div class="fe-list-col fe-list-col-rows">${set.recordCount.toLocaleString()}</div>
        <div class="fe-list-col fe-list-col-date">${createdDate}</div>
        <div class="fe-list-col fe-list-col-tags">
          ${tags.slice(0, 3).map(tagId => {
            const tag = this.folderStore?.getTag(tagId);
            return tag ? `<span class="fe-tag-mini" style="background: var(--tag-${tag.color})">${this._escapeHtml(tag.name)}</span>` : '';
          }).join('')}
          ${tags.length > 3 ? `<span class="fe-tag-more">+${tags.length - 3}</span>` : ''}
        </div>
        <div class="fe-list-col fe-list-col-actions">
          <button class="fe-row-action" data-action="favorite" title="${set.isFavorite ? 'Remove from favorites' : 'Add to favorites'}">
            <i class="ph ${set.isFavorite ? 'ph-star-fill' : 'ph-star'}"></i>
          </button>
          <button class="fe-row-action" data-action="menu" title="More actions">
            <i class="ph ph-dots-three"></i>
          </button>
        </div>
      </div>
    `;
  }

  /**
   * Render sets grid view
   */
  _renderFileExplorerSetsGridView(sets) {
    return `
      <div class="fe-grid-view">
        ${sets.map(set => this._renderFileExplorerSetGridCard(set)).join('')}
      </div>
    `;
  }

  /**
   * Render a set card in grid view
   */
  _renderFileExplorerSetGridCard(set) {
    const isSelected = this.fileExplorerSelectedSet?.id === set.id;
    const isChecked = this.fileExplorerSelectedSets.has(set.id);
    const createdDate = set.createdAt ? new Date(set.createdAt).toLocaleDateString() : 'Unknown';
    const tags = set.tags || [];

    return `
      <div class="fe-grid-card ${isSelected ? 'selected' : ''} ${isChecked ? 'checked' : ''}"
           data-set-id="${set.id}" draggable="true">
        <div class="fe-grid-card-header">
          <input type="checkbox" class="fe-set-checkbox" data-set-id="${set.id}"
                 ${isChecked ? 'checked' : ''}>
          <button class="fe-grid-menu-btn" data-action="menu">
            <i class="ph ph-dots-three"></i>
          </button>
        </div>
        <div class="fe-grid-card-icon">
          <i class="ph ${set.icon}"></i>
        </div>
        <div class="fe-grid-card-name">${this._escapeHtml(set.name)}</div>
        <div class="fe-grid-card-meta">
          <span class="fe-operator-badge" style="background: ${set.operatorColor || 'var(--accent)'}">${set.operator || 'SET'}</span>
          <span>${set.recordCount.toLocaleString()} records</span>
        </div>
        <div class="fe-grid-card-stats">
          <span><i class="ph ph-columns"></i> ${set.fieldCount} fields</span>
          <span><i class="ph ph-layout"></i> ${set.viewCount} views</span>
          ${set.lensCount > 0 ? `<span><i class="ph ph-binoculars"></i> ${set.lensCount} lenses</span>` : ''}
        </div>
        <div class="fe-grid-card-footer">
          <span class="fe-grid-card-date">${createdDate}</span>
          ${tags.length > 0 ? `
            <div class="fe-grid-card-tags">
              ${tags.slice(0, 2).map(tagId => {
                const tag = this.folderStore?.getTag(tagId);
                return tag ? `<span class="fe-tag-mini" style="background: var(--tag-${tag.color})">${this._escapeHtml(tag.name)}</span>` : '';
              }).join('')}
              ${tags.length > 2 ? `<span class="fe-tag-more">+${tags.length - 2}</span>` : ''}
            </div>
          ` : ''}
        </div>
        ${set.isFavorite ? '<i class="ph ph-star-fill fe-grid-favorite-icon"></i>' : ''}
      </div>
    `;
  }

  /**
   * Render sets tree view (hierarchical by source)
   */
  _renderFileExplorerSetsTreeView(sets) {
    // Group sets by source name
    const groupedSets = {};
    const unorganizedSets = [];

    for (const set of sets) {
      if (set.sourceName) {
        if (!groupedSets[set.sourceName]) {
          groupedSets[set.sourceName] = [];
        }
        groupedSets[set.sourceName].push(set);
      } else {
        unorganizedSets.push(set);
      }
    }

    let html = '<div class="fe-tree-view">';

    // Render grouped sets by source
    for (const [sourceName, sourceSets] of Object.entries(groupedSets)) {
      const isExpanded = this.fileExplorerExpandedFolders.has(`source_${sourceName}`);
      html += `
        <div class="fe-tree-folder ${isExpanded ? 'expanded' : ''}">
          <div class="fe-tree-folder-header" data-folder-id="source_${sourceName}">
            <button class="fe-tree-toggle">
              <i class="ph ph-caret-right"></i>
            </button>
            <i class="ph ph-file-csv"></i>
            <span class="fe-tree-folder-name">${this._escapeHtml(sourceName)}</span>
            <span class="fe-tree-folder-count">${sourceSets.length}</span>
          </div>
          <div class="fe-tree-folder-content" style="${isExpanded ? '' : 'display: none'}">
            ${sourceSets.map(set => this._renderFileExplorerSetTreeItem(set)).join('')}
          </div>
        </div>
      `;
    }

    // Render unorganized sets
    if (unorganizedSets.length > 0) {
      html += '<div class="fe-tree-section">';
      for (const set of unorganizedSets) {
        html += this._renderFileExplorerSetTreeItem(set);
      }
      html += '</div>';
    }

    html += '</div>';
    return html;
  }

  /**
   * Render a set item in tree view
   */
  _renderFileExplorerSetTreeItem(set) {
    const isSelected = this.fileExplorerSelectedSet?.id === set.id;

    return `
      <div class="fe-tree-source ${isSelected ? 'selected' : ''}"
           data-set-id="${set.id}" draggable="true">
        <i class="ph ${set.icon}"></i>
        <span class="fe-tree-source-name">${this._escapeHtml(set.name)}</span>
        <span class="fe-operator-badge small" style="background: ${set.operatorColor || 'var(--accent)'}">${set.operator || 'SET'}</span>
        <span class="fe-tree-source-meta">${set.recordCount} rows</span>
        ${set.isFavorite ? '<i class="ph ph-star-fill fe-favorite-icon"></i>' : ''}
      </div>
    `;
  }

  /**
   * Render set preview in file explorer
   */
  _renderFileExplorerSetPreview(set) {
    const createdDate = set.createdAt ? new Date(set.createdAt).toLocaleString() : 'Unknown';
    const updatedDate = set.updatedAt ? new Date(set.updatedAt).toLocaleString() : createdDate;
    const tags = set.tags || [];
    const allTags = this.folderStore?.getAllTags() || [];

    // Get full set data for fields
    const fullSet = this.sets.find(s => s.id === set.id);
    const fields = fullSet?.fields || [];

    return `
      <div class="fe-preview-content">
        <div class="fe-preview-header">
          <div class="fe-preview-icon">
            <i class="ph ${set.icon}"></i>
          </div>
          <div class="fe-preview-title">
            <h3>${this._escapeHtml(set.name)}</h3>
            <span class="fe-preview-badge schema">SCHEMA</span>
          </div>
          <button class="fe-preview-close" id="fe-preview-close">
            <i class="ph ph-x"></i>
          </button>
        </div>

        <div class="fe-preview-stats">
          <div class="fe-preview-stat">
            <span class="fe-preview-stat-value">${set.recordCount.toLocaleString()}</span>
            <span class="fe-preview-stat-label">Records</span>
          </div>
          <div class="fe-preview-stat">
            <span class="fe-preview-stat-value">${set.fieldCount}</span>
            <span class="fe-preview-stat-label">Fields</span>
          </div>
          <div class="fe-preview-stat">
            <span class="fe-preview-stat-value">${set.viewCount}</span>
            <span class="fe-preview-stat-label">Views</span>
          </div>
          <div class="fe-preview-stat">
            <span class="fe-preview-stat-value">${set.lensCount}</span>
            <span class="fe-preview-stat-label">Lenses</span>
          </div>
        </div>

        <div class="fe-preview-section">
          <div class="fe-preview-section-header">
            <i class="ph ph-funnel"></i>
            <span>Operator</span>
          </div>
          <div class="fe-preview-section-content">
            <span class="fe-operator-badge" style="background: ${set.operatorColor || 'var(--accent)'}">${set.operator || 'SET'}</span>
            ${set.sourceName ? `<span class="fe-preview-source">from ${this._escapeHtml(set.sourceName)}</span>` : ''}
          </div>
        </div>

        <div class="fe-preview-section">
          <div class="fe-preview-section-header">
            <i class="ph ph-clock"></i>
            <span>Created</span>
          </div>
          <div class="fe-preview-section-content">
            ${createdDate}
          </div>
        </div>

        ${fields.length > 0 ? `
          <div class="fe-preview-section">
            <div class="fe-preview-section-header">
              <i class="ph ph-columns"></i>
              <span>Fields (${fields.length})</span>
            </div>
            <div class="fe-preview-fields">
              ${fields.slice(0, 10).map(f => `
                <div class="fe-preview-field">
                  <i class="ph ${this._getFieldTypeIcon(f.type)}"></i>
                  <span>${this._escapeHtml(f.name)}</span>
                  <span class="fe-preview-field-type">${f.type}</span>
                </div>
              `).join('')}
              ${fields.length > 10 ? `<div class="fe-preview-more">+${fields.length - 10} more fields</div>` : ''}
            </div>
          </div>
        ` : ''}

        <div class="fe-preview-section">
          <div class="fe-preview-section-header">
            <i class="ph ph-tag"></i>
            <span>Tags</span>
            <button class="fe-preview-add-tag-btn" id="fe-add-set-tag">
              <i class="ph ph-plus"></i>
            </button>
          </div>
          <div class="fe-preview-tags">
            ${tags.map(tagId => {
              const tag = this.folderStore?.getTag(tagId);
              return tag ? `
                <span class="fe-preview-tag" style="background: var(--tag-${tag.color})" data-tag-id="${tagId}">
                  ${this._escapeHtml(tag.name)}
                  <button class="fe-tag-remove" data-tag-id="${tagId}"><i class="ph ph-x"></i></button>
                </span>
              ` : '';
            }).join('')}
            ${tags.length === 0 ? '<span class="fe-no-tags">No tags assigned</span>' : ''}
          </div>
        </div>

        <div class="fe-preview-actions">
          <button class="fe-preview-action-btn primary" id="fe-open-set">
            <i class="ph ph-arrow-square-out"></i>
            <span>Open Set</span>
          </button>
          <button class="fe-preview-action-btn secondary" id="fe-export-set">
            <i class="ph ph-export"></i>
            <span>Export</span>
          </button>
        </div>
      </div>
    `;
  }

  /**
   * Get file type from filename
   */
  _getFileType(filename) {
    if (!filename) return 'unknown';
    const ext = filename.toLowerCase().split('.').pop();
    const typeMap = {
      csv: 'csv',
      json: 'json',
      xlsx: 'excel',
      xls: 'excel',
      ics: 'calendar',
      tsv: 'csv'
    };
    return typeMap[ext] || 'unknown';
  }

  /**
   * Render folder tree in sidebar
   */
  _renderFileExplorerFolderTree(folders, parentId, depth = 0) {
    const children = folders.filter(f => f.parentId === parentId);
    if (children.length === 0) return '';

    return children.map(folder => {
      const isExpanded = this.fileExplorerExpandedFolders.has(folder.id);
      const isActive = this.fileExplorerActiveFilter === `folder_${folder.id}`;
      const hasChildren = folders.some(f => f.parentId === folder.id);
      const sourceCount = this._getFileExplorerSources().filter(s => s.folderId === folder.id).length;

      return `
        <div class="fe-folder-item ${isActive ? 'active' : ''}"
             data-folder-id="${folder.id}" style="padding-left: ${depth * 16 + 8}px">
          ${hasChildren ? `
            <button class="fe-folder-toggle ${isExpanded ? 'expanded' : ''}" data-folder-id="${folder.id}">
              <i class="ph ph-caret-right"></i>
            </button>
          ` : '<span class="fe-folder-toggle-spacer"></span>'}
          <i class="ph ${folder.icon || 'ph-folder'}" style="${folder.color ? `color: var(--folder-${folder.color})` : ''}"></i>
          <span class="fe-sidebar-item-name">${this._escapeHtml(folder.name)}</span>
          <span class="fe-sidebar-item-count">${sourceCount}</span>
        </div>
        ${isExpanded ? this._renderFileExplorerFolderTree(folders, folder.id, depth + 1) : ''}
      `;
    }).join('');
  }

  /**
   * Render breadcrumb navigation
   */
  _renderFileExplorerBreadcrumb() {
    const parts = ['<span class="fe-breadcrumb-item root" data-folder-id="">All Sources</span>'];

    if (this.fileExplorerCurrentFolder && this.folderStore) {
      const path = this.folderStore.getPath(this.fileExplorerCurrentFolder);
      for (const folder of path) {
        parts.push(`
          <i class="ph ph-caret-right"></i>
          <span class="fe-breadcrumb-item" data-folder-id="${folder.id}">
            ${this._escapeHtml(folder.name)}
          </span>
        `);
      }
    }

    // Show active filter
    if (this.fileExplorerActiveFilter && !this.fileExplorerActiveFilter.startsWith('folder_')) {
      let filterName = '';
      if (this.fileExplorerActiveFilter.startsWith('tag_')) {
        const tagId = this.fileExplorerActiveFilter.replace('tag_', '');
        const tag = this.folderStore?.getTag(tagId);
        filterName = tag?.name || tagId;
      } else {
        const smartFolder = this.folderStore?.getSmartFolders().find(sf => sf.id === this.fileExplorerActiveFilter);
        filterName = smartFolder?.name || 'All Sources';
      }
      if (filterName && this.fileExplorerActiveFilter !== 'smart_all') {
        parts.push(`
          <i class="ph ph-caret-right"></i>
          <span class="fe-breadcrumb-item active">${this._escapeHtml(filterName)}</span>
        `);
      }
    }

    return parts.join('');
  }

  /**
   * Render main content area based on view mode
   */
  _renderFileExplorerContent(sources, folders) {
    if (sources.length === 0) {
      return `
        <div class="fe-empty-state">
          <i class="ph ph-folder-open"></i>
          <h3>No Sources Found</h3>
          <p>${this.fileExplorerSearchTerm ? 'Try a different search term' : 'Import data to get started'}</p>
          <button class="btn btn-primary" id="fe-empty-import-btn">
            <i class="ph ph-plus"></i> Import Data
          </button>
        </div>
      `;
    }

    switch (this.fileExplorerViewMode) {
      case 'tree':
        return this._renderFileExplorerTreeView(sources, folders);
      case 'grid':
        return this._renderFileExplorerGridView(sources);
      default:
        return this._renderFileExplorerListView(sources);
    }
  }

  /**
   * Render tree view
   */
  _renderFileExplorerTreeView(sources, folders) {
    const rootFolders = folders.filter(f => !f.parentId);
    const unorganizedSources = sources.filter(s => !s.folderId);

    let html = '<div class="fe-tree-view">';

    // Render folders first
    for (const folder of rootFolders) {
      html += this._renderFileExplorerTreeFolder(folder, sources, folders);
    }

    // Render unorganized sources
    if (unorganizedSources.length > 0) {
      html += '<div class="fe-tree-section">';
      for (const source of unorganizedSources) {
        html += this._renderFileExplorerTreeSource(source);
      }
      html += '</div>';
    }

    html += '</div>';
    return html;
  }

  /**
   * Render a folder in tree view
   */
  _renderFileExplorerTreeFolder(folder, sources, folders) {
    const isExpanded = this.fileExplorerExpandedFolders.has(folder.id);
    const folderSources = sources.filter(s => s.folderId === folder.id);
    const childFolders = folders.filter(f => f.parentId === folder.id);

    return `
      <div class="fe-tree-folder ${isExpanded ? 'expanded' : ''}">
        <div class="fe-tree-folder-header" data-folder-id="${folder.id}">
          <button class="fe-tree-toggle">
            <i class="ph ph-caret-right"></i>
          </button>
          <i class="ph ${isExpanded ? 'ph-folder-open' : 'ph-folder'}"></i>
          <span class="fe-tree-folder-name">${this._escapeHtml(folder.name)}</span>
          <span class="fe-tree-folder-count">${folderSources.length}</span>
        </div>
        <div class="fe-tree-folder-content" style="${isExpanded ? '' : 'display: none'}">
          ${childFolders.map(cf => this._renderFileExplorerTreeFolder(cf, sources, folders)).join('')}
          ${folderSources.map(s => this._renderFileExplorerTreeSource(s)).join('')}
        </div>
      </div>
    `;
  }

  /**
   * Render a source in tree view
   */
  _renderFileExplorerTreeSource(source) {
    const isSelected = this.fileExplorerSelectedSource?.id === source.id;
    const icon = this._getSourceIcon(source.name);
    const importDate = source.importedAt ? new Date(source.importedAt).toLocaleDateString() : '';

    return `
      <div class="fe-tree-source ${isSelected ? 'selected' : ''}"
           data-source-id="${source.id}" draggable="true">
        <i class="ph ${icon}"></i>
        <span class="fe-tree-source-name">${this._escapeHtml(source.name)}</span>
        <span class="fe-tree-source-meta">${source.recordCount} rows</span>
        ${source.isFavorite ? '<i class="ph ph-star-fill fe-favorite-icon"></i>' : ''}
      </div>
    `;
  }

  /**
   * Render list view
   */
  _renderFileExplorerListView(sources) {
    const allSelected = sources.length > 0 && sources.every(s => this.fileExplorerSelectedSources.has(s.id));
    const someSelected = sources.some(s => this.fileExplorerSelectedSources.has(s.id));

    return `
      <div class="fe-list-view">
        <div class="fe-list-header">
          <div class="fe-list-col fe-list-col-checkbox">
            <input type="checkbox" class="fe-select-all-checkbox" id="fe-select-all"
                   ${allSelected ? 'checked' : ''}
                   ${someSelected && !allSelected ? 'data-indeterminate="true"' : ''}>
          </div>
          <div class="fe-list-col fe-list-col-name">Name</div>
          <div class="fe-list-col fe-list-col-type">Type</div>
          <div class="fe-list-col fe-list-col-rows">Rows</div>
          <div class="fe-list-col fe-list-col-date">Imported</div>
          <div class="fe-list-col fe-list-col-tags">Tags</div>
          <div class="fe-list-col fe-list-col-actions"></div>
        </div>
        <div class="fe-list-body">
          ${sources.map(source => this._renderFileExplorerListRow(source)).join('')}
        </div>
      </div>
    `;
  }

  /**
   * Render a source row in list view
   */
  _renderFileExplorerListRow(source) {
    const isSelected = this.fileExplorerSelectedSource?.id === source.id;
    const isChecked = this.fileExplorerSelectedSources.has(source.id);
    const icon = this._getSourceIcon(source.name);
    const importDate = source.importedAt ? new Date(source.importedAt).toLocaleDateString() : 'Unknown';
    const fileType = source.fileType?.toUpperCase() || 'FILE';
    const tags = source.tags || [];

    return `
      <div class="fe-list-row ${isSelected ? 'selected' : ''} ${isChecked ? 'checked' : ''}"
           data-source-id="${source.id}" draggable="true">
        <div class="fe-list-col fe-list-col-checkbox">
          <input type="checkbox" class="fe-source-checkbox" data-source-id="${source.id}"
                 ${isChecked ? 'checked' : ''}>
        </div>
        <div class="fe-list-col fe-list-col-name">
          <i class="ph ${icon}"></i>
          <span class="fe-list-source-name">${this._escapeHtml(source.name)}</span>
          ${source.isFavorite ? '<i class="ph ph-star-fill fe-favorite-icon"></i>' : ''}
        </div>
        <div class="fe-list-col fe-list-col-type">
          <span class="fe-type-badge fe-type-${source.fileType}">${fileType}</span>
        </div>
        <div class="fe-list-col fe-list-col-rows">${source.recordCount.toLocaleString()}</div>
        <div class="fe-list-col fe-list-col-date">${importDate}</div>
        <div class="fe-list-col fe-list-col-tags">
          ${tags.slice(0, 3).map(tagId => {
            const tag = this.folderStore?.getTag(tagId);
            return tag ? `<span class="fe-tag-mini" style="background: var(--tag-${tag.color})">${this._escapeHtml(tag.name)}</span>` : '';
          }).join('')}
          ${tags.length > 3 ? `<span class="fe-tag-more">+${tags.length - 3}</span>` : ''}
        </div>
        <div class="fe-list-col fe-list-col-actions">
          <button class="fe-row-action" data-action="favorite" title="${source.isFavorite ? 'Remove from favorites' : 'Add to favorites'}">
            <i class="ph ${source.isFavorite ? 'ph-star-fill' : 'ph-star'}"></i>
          </button>
          <button class="fe-row-action" data-action="menu" title="More actions">
            <i class="ph ph-dots-three"></i>
          </button>
        </div>
      </div>
    `;
  }

  /**
   * Render grid view
   */
  _renderFileExplorerGridView(sources) {
    return `
      <div class="fe-grid-view">
        ${sources.map(source => this._renderFileExplorerGridCard(source)).join('')}
      </div>
    `;
  }

  /**
   * Render a source card in grid view
   */
  _renderFileExplorerGridCard(source) {
    const isSelected = this.fileExplorerSelectedSource?.id === source.id;
    const isChecked = this.fileExplorerSelectedSources.has(source.id);
    const icon = this._getSourceIcon(source.name);
    const importDate = source.importedAt ? new Date(source.importedAt).toLocaleDateString() : 'Unknown';
    const tags = source.tags || [];

    // Generate data preview visualization
    const fieldCount = source.schema?.fields?.length || 0;

    return `
      <div class="fe-grid-card ${isSelected ? 'selected' : ''} ${isChecked ? 'checked' : ''}"
           data-source-id="${source.id}" draggable="true">
        <div class="fe-grid-card-header">
          <input type="checkbox" class="fe-source-checkbox fe-grid-checkbox" data-source-id="${source.id}"
                 ${isChecked ? 'checked' : ''}>
          ${source.isFavorite ? '<i class="ph ph-star-fill fe-grid-favorite"></i>' : ''}
          <button class="fe-grid-menu-btn" data-action="menu">
            <i class="ph ph-dots-three"></i>
          </button>
        </div>
        <div class="fe-grid-card-preview">
          <div class="fe-grid-preview-visual">
            ${this._renderGridPreviewVisualization(source)}
          </div>
        </div>
        <div class="fe-grid-card-info">
          <div class="fe-grid-card-icon">
            <i class="ph ${icon}"></i>
          </div>
          <div class="fe-grid-card-name" title="${this._escapeHtml(source.name)}">
            ${this._escapeHtml(this._truncateName(source.name, 25))}
          </div>
          <div class="fe-grid-card-meta">
            <span>${source.recordCount.toLocaleString()} rows</span>
            <span class="fe-grid-sep">•</span>
            <span>${fieldCount} fields</span>
          </div>
          <div class="fe-grid-card-date">${importDate}</div>
          ${tags.length > 0 ? `
            <div class="fe-grid-card-tags">
              ${tags.slice(0, 2).map(tagId => {
                const tag = this.folderStore?.getTag(tagId);
                return tag ? `<span class="fe-tag-mini" style="background: var(--tag-${tag.color})">${this._escapeHtml(tag.name)}</span>` : '';
              }).join('')}
              ${tags.length > 2 ? `<span class="fe-tag-more">+${tags.length - 2}</span>` : ''}
            </div>
          ` : ''}
        </div>
      </div>
    `;
  }

  /**
   * Render preview visualization for grid cards
   */
  _renderGridPreviewVisualization(source) {
    const fields = source.schema?.fields || [];
    const cols = Math.min(fields.length, 6);
    const rows = 4;

    if (cols === 0) {
      return `<i class="ph ph-file"></i>`;
    }

    let html = '<div class="fe-preview-table">';
    for (let r = 0; r < rows; r++) {
      html += '<div class="fe-preview-row">';
      for (let c = 0; c < cols; c++) {
        const filled = Math.random() > 0.2;
        html += `<div class="fe-preview-cell ${filled ? 'filled' : ''}"></div>`;
      }
      html += '</div>';
    }
    html += '</div>';
    return html;
  }

  /**
   * Render preview panel for selected source
   */
  _renderFileExplorerPreview(source) {
    const icon = this._getSourceIcon(source.name);
    const importDate = source.importedAt ? new Date(source.importedAt).toLocaleString() : 'Unknown';
    const fields = source.schema?.fields || [];
    const tags = source.tags || [];
    const allTags = this.folderStore?.getAllTags() || [];

    return `
      <div class="fe-preview-content">
        <div class="fe-preview-header">
          <div class="fe-preview-icon">
            <i class="ph ${icon}"></i>
          </div>
          <div class="fe-preview-title">
            <h3>${this._escapeHtml(source.name)}</h3>
            <span class="fe-preview-badge">GIVEN</span>
          </div>
          <button class="fe-preview-close" id="fe-preview-close">
            <i class="ph ph-x"></i>
          </button>
        </div>

        <div class="fe-preview-stats">
          <div class="fe-preview-stat">
            <span class="fe-preview-stat-value">${source.recordCount.toLocaleString()}</span>
            <span class="fe-preview-stat-label">Records</span>
          </div>
          <div class="fe-preview-stat">
            <span class="fe-preview-stat-value">${fields.length}</span>
            <span class="fe-preview-stat-label">Fields</span>
          </div>
          <div class="fe-preview-stat">
            <span class="fe-preview-stat-value">${source.fileType?.toUpperCase() || 'FILE'}</span>
            <span class="fe-preview-stat-label">Type</span>
          </div>
        </div>

        <div class="fe-preview-section">
          <div class="fe-preview-section-header">
            <i class="ph ph-clock"></i>
            <span>Imported</span>
          </div>
          <div class="fe-preview-section-content">
            ${importDate}
          </div>
        </div>

        ${fields.length > 0 ? `
          <div class="fe-preview-section">
            <div class="fe-preview-section-header">
              <i class="ph ph-columns"></i>
              <span>Fields (${fields.length})</span>
            </div>
            <div class="fe-preview-fields">
              ${fields.slice(0, 10).map(f => `
                <div class="fe-preview-field">
                  <i class="ph ${this._getFieldTypeIcon(f.type)}"></i>
                  <span>${this._escapeHtml(f.name)}</span>
                  <span class="fe-preview-field-type">${f.type}</span>
                </div>
              `).join('')}
              ${fields.length > 10 ? `<div class="fe-preview-more">+${fields.length - 10} more fields</div>` : ''}
            </div>
          </div>
        ` : ''}

        <div class="fe-preview-section">
          <div class="fe-preview-section-header">
            <i class="ph ph-tag"></i>
            <span>Tags</span>
            <button class="fe-preview-add-tag-btn" id="fe-add-source-tag">
              <i class="ph ph-plus"></i>
            </button>
          </div>
          <div class="fe-preview-tags">
            ${tags.map(tagId => {
              const tag = this.folderStore?.getTag(tagId);
              return tag ? `
                <span class="fe-preview-tag" style="background: var(--tag-${tag.color})" data-tag-id="${tagId}">
                  ${this._escapeHtml(tag.name)}
                  <button class="fe-tag-remove" data-tag-id="${tagId}"><i class="ph ph-x"></i></button>
                </span>
              ` : '';
            }).join('')}
            ${tags.length === 0 ? '<span class="fe-preview-no-tags">No tags</span>' : ''}
          </div>
        </div>

        <div class="fe-preview-section">
          <div class="fe-preview-section-header">
            <i class="ph ph-fingerprint"></i>
            <span>Provenance</span>
            <button class="fe-preview-edit-prov-btn" id="fe-preview-edit-prov" title="Edit provenance">
              <i class="ph ph-pencil-simple"></i>
            </button>
          </div>
          ${this._renderFileExplorerProvenance(source)}
        </div>

        ${source.fileIdentity || source.parsingDecisions ? `
          <div class="fe-preview-section">
            <div class="fe-preview-section-header">
              <i class="ph ph-file-magnifying-glass"></i>
              <span>File Metadata</span>
            </div>
            ${this._renderFileExplorerMetadata(source)}
          </div>
        ` : ''}

        <div class="fe-preview-actions">
          <button class="btn btn-primary fe-preview-action" id="fe-preview-view-data">
            <i class="ph ph-table"></i>
            <span>View Data</span>
          </button>
          <button class="btn btn-secondary fe-preview-action" id="fe-preview-create-set">
            <i class="ph ph-plus-circle"></i>
            <span>Create Set</span>
          </button>
          <button class="btn btn-secondary fe-preview-action" id="fe-preview-export">
            <i class="ph ph-export"></i>
            <span>Export</span>
          </button>
        </div>
      </div>
    `;
  }

  /**
   * Get field type icon
   */
  _getFieldTypeIcon(type) {
    const icons = {
      text: 'ph-text-aa',
      number: 'ph-hash',
      integer: 'ph-hash',
      date: 'ph-calendar',
      boolean: 'ph-check-square',
      email: 'ph-envelope',
      url: 'ph-globe',
      phone: 'ph-phone',
      json: 'ph-brackets-curly'
    };
    return icons[type] || 'ph-text-aa';
  }

  /**
   * Truncate name for display
   */
  _truncateName(name, maxLen = 30) {
    if (!name || name.length <= maxLen) return name;
    const ext = name.includes('.') ? '.' + name.split('.').pop() : '';
    const baseName = name.slice(0, name.length - ext.length);
    const truncLen = maxLen - ext.length - 3;
    return truncLen > 0 ? baseName.slice(0, truncLen) + '...' + ext : name.slice(0, maxLen - 3) + '...';
  }

  /**
   * Render comprehensive provenance display for file explorer preview
   * Shows all 9 EO provenance categories grouped by triad
   */
  _renderFileExplorerProvenance(source) {
    const prov = source.provenance || {};

    // Define the 9 provenance elements grouped by triad
    const triads = [
      {
        name: 'Epistemic',
        subtitle: 'How was this produced?',
        icon: 'ph-brain',
        elements: [
          { key: 'agent', label: 'Agent', icon: 'ph-user', hint: 'Who provided this' },
          { key: 'method', label: 'Method', icon: 'ph-flask', hint: 'How it was produced' },
          { key: 'source', label: 'Source', icon: 'ph-file-text', hint: 'Where it came from' }
        ]
      },
      {
        name: 'Semantic',
        subtitle: 'What does it mean?',
        icon: 'ph-book-open',
        elements: [
          { key: 'term', label: 'Term', icon: 'ph-bookmark', hint: 'Key concept' },
          { key: 'definition', label: 'Definition', icon: 'ph-book-open', hint: 'What it means here' },
          { key: 'jurisdiction', label: 'Jurisdiction', icon: 'ph-map-pin', hint: 'Where it applies' }
        ]
      },
      {
        name: 'Situational',
        subtitle: 'When/where does it hold?',
        icon: 'ph-compass',
        elements: [
          { key: 'scale', label: 'Scale', icon: 'ph-arrows-out', hint: 'Operational level' },
          { key: 'timeframe', label: 'Timeframe', icon: 'ph-calendar', hint: 'Time period' },
          { key: 'background', label: 'Background', icon: 'ph-info', hint: 'Context/conditions' }
        ]
      }
    ];

    // Count filled elements
    const allKeys = ['agent', 'method', 'source', 'term', 'definition', 'jurisdiction', 'scale', 'timeframe', 'background'];
    const filledCount = allKeys.filter(k => this._getProvenanceValue(prov[k])).length;
    const statusClass = filledCount === 9 ? 'complete' : filledCount > 0 ? 'partial' : 'none';
    const statusText = filledCount === 9 ? 'Complete' : filledCount > 0 ? `${filledCount}/9` : 'Not set';

    return `
      <div class="fe-preview-provenance-full">
        <div class="fe-prov-status ${statusClass}">
          <span class="fe-prov-indicator">${filledCount === 9 ? '◉' : filledCount > 0 ? '◐' : '○'}</span>
          <span class="fe-prov-status-text">${statusText}</span>
        </div>
        ${triads.map(triad => {
          const hasAnyValue = triad.elements.some(el => this._getProvenanceValue(prov[el.key]));
          return `
            <div class="fe-prov-triad ${hasAnyValue ? '' : 'empty'}">
              <div class="fe-prov-triad-header">
                <i class="ph ${triad.icon}"></i>
                <span class="fe-prov-triad-name">${triad.name}</span>
                <span class="fe-prov-triad-subtitle">${triad.subtitle}</span>
              </div>
              <div class="fe-prov-triad-elements">
                ${triad.elements.map(el => {
                  const value = this._getProvenanceValue(prov[el.key]);
                  const hasValue = !!value;
                  return `
                    <div class="fe-prov-element ${hasValue ? 'filled' : 'empty'}" title="${el.hint}">
                      <i class="ph ${el.icon}"></i>
                      <span class="fe-prov-label">${el.label}</span>
                      <span class="fe-prov-value">${hasValue ? this._escapeHtml(String(value)) : '—'}</span>
                    </div>
                  `;
                }).join('')}
              </div>
            </div>
          `;
        }).join('')}
      </div>
    `;
  }

  /**
   * Render file metadata section for file explorer preview
   * Shows extracted file identity and parsing decisions
   */
  _renderFileExplorerMetadata(source) {
    const fileId = source.fileIdentity || {};
    const parsing = source.parsingDecisions || {};
    const schema = source.schema || {};

    const metadataItems = [];

    // File identity metadata
    if (fileId.originalFilename) {
      metadataItems.push({ label: 'Original Filename', value: fileId.originalFilename, icon: 'ph-file' });
    }
    if (fileId.rawSize) {
      const sizeStr = this._formatFileSize(fileId.rawSize);
      metadataItems.push({ label: 'File Size', value: sizeStr, icon: 'ph-hard-drive' });
    }
    if (fileId.mimeType) {
      metadataItems.push({ label: 'MIME Type', value: fileId.mimeType, icon: 'ph-file-code' });
    }
    if (fileId.encoding) {
      metadataItems.push({ label: 'Encoding', value: fileId.encoding, icon: 'ph-text-aa' });
    }
    if (fileId.contentHash) {
      const shortHash = fileId.contentHash.substring(0, 12) + '...';
      metadataItems.push({ label: 'Content Hash', value: shortHash, icon: 'ph-fingerprint', fullValue: fileId.contentHash });
    }
    if (fileId.lastModified) {
      metadataItems.push({ label: 'Last Modified', value: new Date(fileId.lastModified).toLocaleString(), icon: 'ph-clock' });
    }

    // Parsing decisions metadata
    if (parsing.delimiterDetected || parsing.delimiter) {
      const delim = parsing.delimiterDetected || parsing.delimiter;
      const delimDisplay = delim === ',' ? 'comma (,)' : delim === '\t' ? 'tab' : delim === ';' ? 'semicolon (;)' : delim === '|' ? 'pipe (|)' : `"${delim}"`;
      metadataItems.push({ label: 'Delimiter', value: delimDisplay, icon: 'ph-split-horizontal' });
    }
    if (parsing.delimiterConfidence) {
      metadataItems.push({ label: 'Delimiter Confidence', value: `${(parsing.delimiterConfidence * 100).toFixed(0)}%`, icon: 'ph-chart-bar' });
    }
    if (typeof parsing.headerDetected === 'boolean' || typeof parsing.hasHeaders === 'boolean') {
      const hasHeaders = parsing.headerDetected ?? parsing.hasHeaders;
      metadataItems.push({ label: 'Headers Detected', value: hasHeaders ? 'Yes' : 'No', icon: 'ph-rows' });
    }
    if (parsing.headerConfidence) {
      metadataItems.push({ label: 'Header Confidence', value: `${(parsing.headerConfidence * 100).toFixed(0)}%`, icon: 'ph-chart-bar' });
    }
    if (parsing.quotedFieldsFound) {
      metadataItems.push({ label: 'Quoted Fields', value: 'Yes', icon: 'ph-quotes' });
    }
    if (parsing.lineEndingNormalized) {
      const endingType = parsing.originalLineEnding === '\r\n' ? 'CRLF (Windows)' : parsing.originalLineEnding === '\r' ? 'CR (Mac)' : 'LF (Unix)';
      metadataItems.push({ label: 'Line Ending', value: endingType, icon: 'ph-arrow-line-down' });
    }
    if (parsing.processingTimeMs) {
      metadataItems.push({ label: 'Processing Time', value: `${parsing.processingTimeMs}ms`, icon: 'ph-timer' });
    }

    // Schema inference metadata
    if (schema.inferenceDecisions) {
      const inf = schema.inferenceDecisions;
      if (inf.fieldsInferred) {
        metadataItems.push({ label: 'Fields Inferred', value: inf.fieldsInferred, icon: 'ph-columns' });
      }
      if (inf.typesInferred) {
        const typeList = Object.entries(inf.typesInferred).map(([t, c]) => `${t}: ${c}`).join(', ');
        metadataItems.push({ label: 'Types Detected', value: typeList, icon: 'ph-code' });
      }
    }

    if (metadataItems.length === 0) {
      return '<div class="fe-metadata-empty">No file metadata available</div>';
    }

    return `
      <div class="fe-preview-metadata">
        ${metadataItems.map(item => `
          <div class="fe-metadata-item" ${item.fullValue ? `title="${this._escapeHtml(item.fullValue)}"` : ''}>
            <i class="ph ${item.icon}"></i>
            <span class="fe-metadata-label">${item.label}</span>
            <span class="fe-metadata-value">${this._escapeHtml(String(item.value))}</span>
          </div>
        `).join('')}
      </div>
    `;
  }

  /**
   * Format file size for display
   */
  _formatFileSize(bytes) {
    if (!bytes || bytes === 0) return '0 B';
    const units = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    return parseFloat((bytes / Math.pow(1024, i)).toFixed(1)) + ' ' + units[i];
  }

  /**
   * Attach File Explorer event handlers
   */
  _attachFileExplorerEventHandlers() {
    const container = document.querySelector('.file-explorer');
    if (!container) return;

    // Close button
    container.querySelector('#fe-close-btn')?.addEventListener('click', () => {
      this._closeFileExplorer();
    });

    // Content mode toggle (Sources/Sets)
    container.querySelectorAll('.fe-content-tab').forEach(btn => {
      btn.addEventListener('click', () => {
        const newMode = btn.dataset.contentMode;
        if (newMode !== this.fileExplorerContentMode) {
          this.fileExplorerContentMode = newMode;
          this.fileExplorerSearchTerm = '';
          this.fileExplorerActiveFilter = 'smart_all';
          this.fileExplorerSelectedSource = null;
          this.fileExplorerSelectedSet = null;
          this.fileExplorerSelectedSources.clear();
          this.fileExplorerSelectedSets.clear();
          this._renderFileExplorer();
        }
      });
    });

    // Import/New Set button
    container.querySelectorAll('#fe-import-btn, #fe-empty-import-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        if (this.fileExplorerContentMode === 'sets') {
          this._closeFileExplorer();
          this._showOperatorFirstCreationModal();
        } else {
          this._showImportModal();
        }
      });
    });

    // Empty state create set button (for sets mode)
    container.querySelector('#fe-empty-create-set-btn')?.addEventListener('click', () => {
      this._closeFileExplorer();
      this._showOperatorFirstCreationModal();
    });

    // View mode toggle
    container.querySelectorAll('.fe-view-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        this.fileExplorerViewMode = btn.dataset.view;
        this._renderFileExplorer();
      });
    });

    // Search
    const searchInput = container.querySelector('#fe-search');
    searchInput?.addEventListener('input', (e) => {
      this.fileExplorerSearchTerm = e.target.value;
      this._updateFileExplorerContent();
    });

    container.querySelector('#fe-search-clear')?.addEventListener('click', () => {
      this.fileExplorerSearchTerm = '';
      this._renderFileExplorer();
    });

    // Sidebar filters (smart folders and tags)
    container.querySelectorAll('.fe-sidebar-item[data-filter-type]').forEach(item => {
      item.addEventListener('click', () => {
        const type = item.dataset.filterType;
        const id = item.dataset.filterId;
        this.fileExplorerActiveFilter = type === 'tag' ? `tag_${id}` : id;
        this.fileExplorerCurrentFolder = null;
        this._renderFileExplorer();
      });
    });

    // Folder clicks
    container.querySelectorAll('.fe-folder-item').forEach(item => {
      item.addEventListener('click', (e) => {
        if (e.target.closest('.fe-folder-toggle')) return;
        const folderId = item.dataset.folderId;
        this.fileExplorerActiveFilter = `folder_${folderId}`;
        this.fileExplorerCurrentFolder = folderId;
        this._renderFileExplorer();
      });
    });

    // Folder toggles
    container.querySelectorAll('.fe-folder-toggle').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const folderId = btn.dataset.folderId;
        if (this.fileExplorerExpandedFolders.has(folderId)) {
          this.fileExplorerExpandedFolders.delete(folderId);
        } else {
          this.fileExplorerExpandedFolders.add(folderId);
        }
        this._renderFileExplorer();
      });
    });

    // Add folder button
    container.querySelector('#fe-add-folder-btn')?.addEventListener('click', () => {
      this._showCreateFolderModal();
    });

    // Add tag button
    container.querySelector('#fe-add-tag-btn')?.addEventListener('click', () => {
      this._showCreateTagModal();
    });

    // Breadcrumb navigation
    container.querySelectorAll('.fe-breadcrumb-item').forEach(item => {
      item.addEventListener('click', () => {
        const folderId = item.dataset.folderId;
        this.fileExplorerCurrentFolder = folderId || null;
        if (!folderId) {
          this.fileExplorerActiveFilter = 'smart_all';
        } else {
          this.fileExplorerActiveFilter = `folder_${folderId}`;
        }
        this._renderFileExplorer();
      });
    });

    // Source selection (only for source items)
    container.querySelectorAll('.fe-tree-source[data-source-id], .fe-list-row[data-source-id], .fe-grid-card[data-source-id]').forEach(item => {
      item.addEventListener('click', (e) => {
        if (e.target.closest('.fe-row-action, .fe-grid-menu-btn, .fe-source-checkbox')) return;
        const sourceId = item.dataset.sourceId;
        if (sourceId) {
          this._selectFileExplorerSource(sourceId);
        }
      });

      item.addEventListener('dblclick', (e) => {
        const sourceId = item.dataset.sourceId;
        if (sourceId) {
          this._closeFileExplorer();
          this._showSourceDetail(sourceId);
        }
      });
    });

    // Set selection (only for set items)
    container.querySelectorAll('.fe-tree-source[data-set-id], .fe-list-row[data-set-id], .fe-grid-card[data-set-id]').forEach(item => {
      item.addEventListener('click', (e) => {
        if (e.target.closest('.fe-row-action, .fe-grid-menu-btn, .fe-set-checkbox')) return;
        const setId = item.dataset.setId;
        if (setId) {
          this._selectFileExplorerSet(setId);
        }
      });

      item.addEventListener('dblclick', (e) => {
        const setId = item.dataset.setId;
        if (setId) {
          this._closeFileExplorer();
          this._showSet(setId);
        }
      });
    });

    // Row actions for sources
    container.querySelectorAll('[data-source-id] .fe-row-action, [data-source-id] .fe-grid-menu-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const action = btn.dataset.action;
        const row = btn.closest('[data-source-id]');
        const sourceId = row?.dataset.sourceId;

        if (action === 'favorite') {
          this._toggleSourceFavorite(sourceId);
        } else if (action === 'menu') {
          this._showFileExplorerSourceMenu(e, sourceId);
        }
      });
    });

    // Row actions for sets
    container.querySelectorAll('[data-set-id] .fe-row-action, [data-set-id] .fe-grid-menu-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const action = btn.dataset.action;
        const row = btn.closest('[data-set-id]');
        const setId = row?.dataset.setId;

        if (action === 'favorite') {
          this._toggleSetFavorite(setId);
        } else if (action === 'menu') {
          this._showFileExplorerSetMenu(e, setId);
        }
      });
    });

    // Tree view folder expansion
    container.querySelectorAll('.fe-tree-folder-header').forEach(header => {
      header.addEventListener('click', () => {
        const folderId = header.dataset.folderId;
        if (this.fileExplorerExpandedFolders.has(folderId)) {
          this.fileExplorerExpandedFolders.delete(folderId);
        } else {
          this.fileExplorerExpandedFolders.add(folderId);
        }
        this._updateFileExplorerContent();
      });
    });

    // Preview panel actions
    container.querySelector('#fe-preview-close')?.addEventListener('click', () => {
      if (this.fileExplorerContentMode === 'sources') {
        this.fileExplorerSelectedSource = null;
      } else {
        this.fileExplorerSelectedSet = null;
      }
      this._renderFileExplorer();
    });

    container.querySelector('#fe-preview-view-data')?.addEventListener('click', () => {
      const sourceId = this.fileExplorerSelectedSource?.id;
      if (sourceId) {
        this._closeFileExplorer();
        this._showSourceDetail(sourceId);
      }
    });

    container.querySelector('#fe-preview-create-set')?.addEventListener('click', () => {
      const sourceId = this.fileExplorerSelectedSource?.id;
      if (sourceId) {
        this._closeFileExplorer();
        this._showSetFromSourceUI(sourceId);
      }
    });

    container.querySelector('#fe-preview-export')?.addEventListener('click', () => {
      const sourceId = this.fileExplorerSelectedSource?.id;
      if (sourceId) {
        this._exportSource(sourceId);
      }
    });

    // Edit provenance button in preview
    container.querySelector('#fe-preview-edit-prov')?.addEventListener('click', () => {
      const sourceId = this.fileExplorerSelectedSource?.id;
      if (sourceId) {
        this._editSourceProvenance(sourceId);
      }
    });

    // Set preview actions
    container.querySelector('#fe-open-set')?.addEventListener('click', () => {
      const setId = this.fileExplorerSelectedSet?.id;
      if (setId) {
        this._closeFileExplorer();
        this._showSet(setId);
      }
    });

    container.querySelector('#fe-export-set')?.addEventListener('click', () => {
      const setId = this.fileExplorerSelectedSet?.id;
      if (setId) {
        const set = this.sets.find(s => s.id === setId);
        if (set) {
          this._showExportSetModal(set);
        }
      }
    });

    // Tag management in preview (sources)
    container.querySelector('#fe-add-source-tag')?.addEventListener('click', () => {
      this._showAddTagToSourceModal();
    });

    // Tag management in preview (sets)
    container.querySelector('#fe-add-set-tag')?.addEventListener('click', () => {
      this._showAddTagToSetModal();
    });

    container.querySelectorAll('.fe-tag-remove').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const tagId = btn.dataset.tagId;
        if (this.fileExplorerContentMode === 'sources' && this.fileExplorerSelectedSource && this.sourceStore) {
          this.sourceStore.removeSourceTag(this.fileExplorerSelectedSource.id, tagId);
          this._selectFileExplorerSource(this.fileExplorerSelectedSource.id);
        } else if (this.fileExplorerContentMode === 'sets' && this.fileExplorerSelectedSet) {
          this._removeTagFromSet(this.fileExplorerSelectedSet.id, tagId);
          this._selectFileExplorerSet(this.fileExplorerSelectedSet.id);
        }
      });
    });

    // Multi-select checkbox handling (sources)
    container.querySelectorAll('.fe-source-checkbox').forEach(checkbox => {
      checkbox.addEventListener('click', (e) => {
        e.stopPropagation();
        const sourceId = checkbox.dataset.sourceId;
        this._toggleFileExplorerSourceSelection(sourceId);
      });
    });

    // Multi-select checkbox handling (sets)
    container.querySelectorAll('.fe-set-checkbox').forEach(checkbox => {
      checkbox.addEventListener('click', (e) => {
        e.stopPropagation();
        const setId = checkbox.dataset.setId;
        this._toggleFileExplorerSetSelection(setId);
      });
    });

    // Select all checkbox (sources)
    const selectAllCheckbox = container.querySelector('#fe-select-all');
    if (selectAllCheckbox) {
      // Set indeterminate state via JS (can't be set via HTML attribute)
      if (selectAllCheckbox.dataset.indeterminate === 'true') {
        selectAllCheckbox.indeterminate = true;
      }
      selectAllCheckbox.addEventListener('click', (e) => {
        e.stopPropagation();
        const allSources = this._getFileExplorerSources();
        const filteredSources = this._filterFileExplorerSources(allSources);

        if (selectAllCheckbox.checked) {
          // Select all filtered sources
          filteredSources.forEach(s => this.fileExplorerSelectedSources.add(s.id));
        } else {
          // Deselect all
          this.fileExplorerSelectedSources.clear();
        }
        this._renderFileExplorer();
      });
    }

    // Select all checkbox (sets)
    const selectAllSetsCheckbox = container.querySelector('#fe-select-all-sets');
    if (selectAllSetsCheckbox) {
      if (selectAllSetsCheckbox.dataset.indeterminate === 'true') {
        selectAllSetsCheckbox.indeterminate = true;
      }
      selectAllSetsCheckbox.addEventListener('click', (e) => {
        e.stopPropagation();
        const allSets = this._getFileExplorerSets();
        const filteredSets = this._filterFileExplorerSets(allSets);

        if (selectAllSetsCheckbox.checked) {
          filteredSets.forEach(s => this.fileExplorerSelectedSets.add(s.id));
        } else {
          this.fileExplorerSelectedSets.clear();
        }
        this._renderFileExplorer();
      });
    }

    // Clear selection button (sources)
    container.querySelector('#fe-clear-selection')?.addEventListener('click', () => {
      this.fileExplorerSelectedSources.clear();
      this._renderFileExplorer();
    });

    // Clear selection button (sets)
    container.querySelector('#fe-clear-set-selection')?.addEventListener('click', () => {
      this.fileExplorerSelectedSets.clear();
      this._renderFileExplorer();
    });

    // Create Set from selection button
    container.querySelector('#fe-create-set-from-selection')?.addEventListener('click', () => {
      this._createSetFromSelectedSources();
    });

    // Export selected button (sources)
    container.querySelector('#fe-export-selected')?.addEventListener('click', () => {
      this._exportSelectedSources();
    });

    // Export selected button (sets)
    container.querySelector('#fe-export-selected-sets')?.addEventListener('click', () => {
      this._exportSelectedSets();
    });

    // Delete selected button (sources)
    container.querySelector('#fe-delete-selected')?.addEventListener('click', () => {
      this._deleteSelectedSources();
    });

    // Delete selected button (sets)
    container.querySelector('#fe-delete-selected-sets')?.addEventListener('click', () => {
      this._deleteSelectedSets();
    });

    // Drag and drop for organizing
    this._attachFileExplorerDragDrop(container);
  }

  /**
   * Update content area without full re-render
   */
  _updateFileExplorerContent() {
    const container = document.getElementById('fe-sources-container');
    if (!container) return;

    if (this.fileExplorerContentMode === 'sources') {
      const allSources = this._getFileExplorerSources();
      const filteredSources = this._filterFileExplorerSources(allSources);
      const folders = this.folderStore?.getAll() || [];
      container.innerHTML = this._renderFileExplorerContent(filteredSources, folders);
    } else {
      const allSets = this._getFileExplorerSets();
      const filteredSets = this._filterFileExplorerSets(allSets);
      container.innerHTML = this._renderFileExplorerSetsContent(filteredSets);
    }
    this._attachFileExplorerEventHandlers();
  }

  /**
   * Select a source in file explorer
   */
  _selectFileExplorerSource(sourceId) {
    const sources = this._getFileExplorerSources();
    this.fileExplorerSelectedSource = sources.find(s => s.id === sourceId) || null;
    this._renderFileExplorer();
  }

  /**
   * Toggle multi-selection of a source (checkbox selection)
   */
  _toggleFileExplorerSourceSelection(sourceId) {
    if (this.fileExplorerSelectedSources.has(sourceId)) {
      this.fileExplorerSelectedSources.delete(sourceId);
    } else {
      this.fileExplorerSelectedSources.add(sourceId);
    }
    this._renderFileExplorer();
  }

  /**
   * Select a set in file explorer
   */
  _selectFileExplorerSet(setId) {
    const sets = this._getFileExplorerSets();
    this.fileExplorerSelectedSet = sets.find(s => s.id === setId) || null;
    this._renderFileExplorer();
  }

  /**
   * Toggle multi-selection of a set (checkbox selection)
   */
  _toggleFileExplorerSetSelection(setId) {
    if (this.fileExplorerSelectedSets.has(setId)) {
      this.fileExplorerSelectedSets.delete(setId);
    } else {
      this.fileExplorerSelectedSets.add(setId);
    }
    this._renderFileExplorer();
  }

  /**
   * Toggle favorite status for a set in file explorer
   */
  _toggleSetFavorite(setId) {
    const set = this.sets.find(s => s.id === setId);
    if (set) {
      set.isFavorite = !set.isFavorite;
      this._saveData();
      this._renderFileExplorer();
    }
  }

  /**
   * Show context menu for a set in file explorer
   */
  _showFileExplorerSetMenu(e, setId) {
    const set = this.sets.find(s => s.id === setId);
    if (!set) return;

    const menuItems = [
      { label: 'Open Set', icon: 'ph-arrow-square-out', action: () => {
        this._closeFileExplorer();
        this._showSet(setId);
      }},
      { label: set.isFavorite ? 'Remove from Favorites' : 'Add to Favorites', icon: set.isFavorite ? 'ph-star-fill' : 'ph-star', action: () => {
        this._toggleSetFavorite(setId);
      }},
      { type: 'divider' },
      { label: 'Export...', icon: 'ph-export', action: () => {
        this._showExportSetModal(set);
      }},
      { label: 'Duplicate', icon: 'ph-copy', action: () => {
        this._duplicateSet(setId);
      }},
      { type: 'divider' },
      { label: 'Delete', icon: 'ph-trash', danger: true, action: () => {
        if (confirm(`Delete set "${set.name}"? This cannot be undone.`)) {
          this._deleteSet(setId);
          this._renderFileExplorer();
        }
      }}
    ];

    this._showContextMenu(e, menuItems);
  }

  /**
   * Export selected sets
   */
  _exportSelectedSets() {
    const selectedIds = Array.from(this.fileExplorerSelectedSets);
    if (selectedIds.length === 0) {
      this._showToast('No sets selected', 'warning');
      return;
    }

    // For now, export each set individually
    selectedIds.forEach(setId => {
      const set = this.sets.find(s => s.id === setId);
      if (set) {
        this._showExportSetModal(set);
      }
    });
  }

  /**
   * Delete selected sets
   */
  _deleteSelectedSets() {
    const selectedIds = Array.from(this.fileExplorerSelectedSets);
    if (selectedIds.length === 0) {
      this._showToast('No sets selected', 'warning');
      return;
    }

    if (confirm(`Delete ${selectedIds.length} set${selectedIds.length > 1 ? 's' : ''}? This cannot be undone.`)) {
      selectedIds.forEach(setId => {
        this._deleteSet(setId);
      });
      this.fileExplorerSelectedSets.clear();
      this._renderFileExplorer();
      this._showToast(`Deleted ${selectedIds.length} set${selectedIds.length > 1 ? 's' : ''}`, 'success');
    }
  }

  /**
   * Show modal to add tag to selected set in file explorer
   */
  _showAddTagToSetModal() {
    const setId = this.fileExplorerSelectedSet?.id;
    if (!setId) return;

    const set = this.sets.find(s => s.id === setId);
    if (!set) return;

    const allTags = this.folderStore?.getAllTags() || [];
    const currentTags = set.tags || [];

    // Simple implementation - just show available tags
    const availableTags = allTags.filter(t => !currentTags.includes(t.id));

    if (availableTags.length === 0) {
      this._showToast('No more tags available', 'info');
      return;
    }

    // Show a simple tag picker
    const tagId = availableTags[0].id; // For now, just add the first available tag
    this._addTagToSet(setId, tagId);
    this._selectFileExplorerSet(setId);
  }

  /**
   * Add a tag to a set
   */
  _addTagToSet(setId, tagId) {
    const set = this.sets.find(s => s.id === setId);
    if (set) {
      if (!set.tags) set.tags = [];
      if (!set.tags.includes(tagId)) {
        set.tags.push(tagId);
        this._saveData();
      }
    }
  }

  /**
   * Remove a tag from a set
   */
  _removeTagFromSet(setId, tagId) {
    const set = this.sets.find(s => s.id === setId);
    if (set && set.tags) {
      set.tags = set.tags.filter(t => t !== tagId);
      this._saveData();
    }
  }

  /**
   * Create a set from the currently selected sources
   */
  _createSetFromSelectedSources() {
    const selectedIds = Array.from(this.fileExplorerSelectedSources);
    if (selectedIds.length === 0) {
      this._showToast('No sources selected', 'warning');
      return;
    }

    // Close file explorer and proceed with set creation
    this._closeFileExplorer();

    if (selectedIds.length === 1) {
      // Single source - use SetFromSourceUI for field selection
      this._showSetFromSourceUI(selectedIds[0]);
    } else {
      // Multiple sources - show relational merge UI with 3 questions
      this._showRelationalMergeUI(selectedIds);
    }

    // Clear selection after creating set
    this.fileExplorerSelectedSources.clear();
  }

  /**
   * Export multiple selected sources
   */
  _exportSelectedSources() {
    const selectedIds = Array.from(this.fileExplorerSelectedSources);
    if (selectedIds.length === 0) {
      this._showToast('No sources selected', 'warning');
      return;
    }

    // Export each source
    selectedIds.forEach(id => this._exportSource(id));
    this._showToast(`Exporting ${selectedIds.length} source${selectedIds.length !== 1 ? 's' : ''}`, 'success');
  }

  /**
   * Delete multiple selected sources
   */
  _deleteSelectedSources() {
    const selectedIds = Array.from(this.fileExplorerSelectedSources);
    if (selectedIds.length === 0) {
      this._showToast('No sources selected', 'warning');
      return;
    }

    const deletedSources = [];
    selectedIds.forEach(id => {
      const source = this.sources?.find(s => s.id === id);
      if (!source) return;

      // Find derived sets for this source
      const derivedSets = this.sets.filter(set => {
        const prov = set.datasetProvenance;
        return prov?.sourceId === id ||
               prov?.originalFilename?.toLowerCase() === source?.name?.toLowerCase();
      });

      // Add to tossed items (nothing is ever deleted per Rule 9)
      this.tossedItems.unshift({
        type: 'source',
        source: JSON.parse(JSON.stringify(source)), // Deep clone
        derivedSetIds: derivedSets.map(s => s.id),
        tossedAt: new Date().toISOString()
      });
      if (this.tossedItems.length > this.maxTossedItems) {
        this.tossedItems.pop();
      }

      // Register as ghost if ghost registry is available
      if (typeof getGhostRegistry === 'function') {
        const ghostRegistry = getGhostRegistry();
        const tombstoneEvent = {
          id: `tombstone_${Date.now().toString(36)}_${Math.random().toString(36).substr(2, 6)}`,
          timestamp: new Date().toISOString(),
          actor: 'user',
          payload: {
            action: 'tombstone',
            targetId: id,
            reason: 'User deleted source (bulk)',
            targetSnapshot: {
              type: 'source',
              payload: {
                name: source.name,
                recordCount: source.records?.length || source.recordCount || 0,
                derivedSetCount: derivedSets.length
              }
            }
          },
          context: { workspace: 'default' }
        };
        ghostRegistry.registerGhost(id, tombstoneEvent, {
          entityType: 'source',
          workspace: 'default'
        });
      }

      // Remove from sources array
      const index = this.sources?.findIndex(s => s.id === id);
      if (index !== undefined && index >= 0) {
        this.sources.splice(index, 1);
        deletedSources.push(source);
      }
      // Also remove from source store if available
      if (this.sourceStore) {
        this.sourceStore.sources.delete(id);
      }
    });

    this.fileExplorerSelectedSources.clear();
    this.fileExplorerSelectedSource = null;
    this._saveData();
    this._renderFileExplorer();
    this._updateTossedBadge();
    this._showToast(`Tossed ${deletedSources.length} source${deletedSources.length !== 1 ? 's' : ''}`, 'info');
  }

  /**
   * Toggle favorite status for a source
   */
  _toggleSourceFavorite(sourceId) {
    if (!this.sourceStore) return;

    this.sourceStore.toggleFavorite(sourceId);

    // Refresh the selected source if it's the one we just toggled
    if (this.fileExplorerSelectedSource?.id === sourceId) {
      const sources = this._getFileExplorerSources();
      this.fileExplorerSelectedSource = sources.find(s => s.id === sourceId) || null;
    }

    this._renderFileExplorer();
  }

  /**
   * Show context menu for a source
   */
  _showFileExplorerSourceMenu(e, sourceId) {
    const source = this._getFileExplorerSources().find(s => s.id === sourceId);
    if (!source) return;

    const menu = [
      { icon: 'ph-info', label: 'View Details', action: () => { this._closeFileExplorer(); this._showSourceDetail(sourceId); } },
      { icon: 'ph-table', label: 'Create Set from Source...', action: () => { this._closeFileExplorer(); this._showSetFromSourceUI(sourceId); } },
      { icon: 'ph-code', label: 'Query Builder...', action: () => { this._closeFileExplorer(); this._showQueryBuilderUI(sourceId); } },
      { icon: 'ph-intersect', label: 'Join with Another Source...', action: () => { this._closeFileExplorer(); this._showJoinBuilderUI(sourceId); } },
      { divider: true },
      { icon: source.isFavorite ? 'ph-star' : 'ph-star-fill', label: source.isFavorite ? 'Remove from Favorites' : 'Add to Favorites', action: () => this._toggleSourceFavorite(sourceId) },
      { icon: 'ph-folder', label: 'Move to Folder...', action: () => this._showMoveToFolderModal(sourceId) },
      { icon: 'ph-tag', label: 'Add Tags...', action: () => { this._selectFileExplorerSource(sourceId); this._showAddTagToSourceModal(); } },
      { divider: true },
      { icon: 'ph-export', label: 'Export Source Data', action: () => this._exportSource(sourceId) },
      { divider: true },
      { icon: 'ph-trash', label: 'Delete Source', action: () => this._deleteSource(sourceId), class: 'danger' }
    ];

    this._showContextMenu(e.pageX, e.pageY, menu);
  }

  /**
   * Attach drag and drop handlers
   */
  _attachFileExplorerDragDrop(container) {
    let draggedSourceId = null;

    // Source drag start
    container.querySelectorAll('[draggable="true"]').forEach(item => {
      item.addEventListener('dragstart', (e) => {
        draggedSourceId = item.dataset.sourceId;
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', draggedSourceId);
        item.classList.add('dragging');
      });

      item.addEventListener('dragend', () => {
        draggedSourceId = null;
        item.classList.remove('dragging');
        container.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target'));
      });
    });

    // Folder drop targets
    container.querySelectorAll('.fe-folder-item, .fe-tree-folder-header').forEach(folder => {
      folder.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        folder.classList.add('drop-target');
      });

      folder.addEventListener('dragleave', () => {
        folder.classList.remove('drop-target');
      });

      folder.addEventListener('drop', (e) => {
        e.preventDefault();
        folder.classList.remove('drop-target');
        const folderId = folder.dataset.folderId;
        if (draggedSourceId && folderId && this.sourceStore) {
          this.sourceStore.updateSourceFolder(draggedSourceId, folderId);
          this._renderFileExplorer();
          this._showToast('Source moved to folder', 'success');
        }
      });
    });

    // Root drop target (remove from folder)
    const breadcrumbRoot = container.querySelector('.fe-breadcrumb-item.root');
    if (breadcrumbRoot) {
      breadcrumbRoot.addEventListener('dragover', (e) => {
        e.preventDefault();
        breadcrumbRoot.classList.add('drop-target');
      });

      breadcrumbRoot.addEventListener('dragleave', () => {
        breadcrumbRoot.classList.remove('drop-target');
      });

      breadcrumbRoot.addEventListener('drop', (e) => {
        e.preventDefault();
        breadcrumbRoot.classList.remove('drop-target');
        if (draggedSourceId && this.sourceStore) {
          this.sourceStore.updateSourceFolder(draggedSourceId, null);
          this._renderFileExplorer();
          this._showToast('Source moved to root', 'success');
        }
      });
    }
  }

  /**
   * Show modal to create a new folder
   */
  _showCreateFolderModal() {
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.innerHTML = `
      <div class="modal modal-sm">
        <div class="modal-header">
          <h3><i class="ph ph-folder-plus"></i> New Folder</h3>
          <button class="modal-close"><i class="ph ph-x"></i></button>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label>Folder Name</label>
            <input type="text" id="new-folder-name" placeholder="Enter folder name" autofocus>
          </div>
          <div class="form-group">
            <label>Parent Folder (optional)</label>
            <select id="new-folder-parent">
              <option value="">Root</option>
              ${(this.folderStore?.getAll() || []).map(f =>
                `<option value="${f.id}">${this._escapeHtml(f.name)}</option>`
              ).join('')}
            </select>
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary modal-cancel">Cancel</button>
          <button class="btn btn-primary" id="create-folder-btn">Create Folder</button>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    const closeModal = () => modal.remove();

    modal.querySelector('.modal-close').addEventListener('click', closeModal);
    modal.querySelector('.modal-cancel').addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });

    modal.querySelector('#create-folder-btn').addEventListener('click', () => {
      const name = modal.querySelector('#new-folder-name').value.trim();
      const parentId = modal.querySelector('#new-folder-parent').value || null;

      if (name && this.folderStore) {
        this.folderStore.createFolder({ name, parentId });
        closeModal();
        this._renderFileExplorer();
        this._showToast('Folder created', 'success');
      }
    });

    modal.querySelector('#new-folder-name').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') modal.querySelector('#create-folder-btn').click();
    });
  }

  /**
   * Show modal to create a new tag
   */
  _showCreateTagModal() {
    const colors = ['blue', 'green', 'yellow', 'red', 'purple', 'pink', 'orange', 'cyan', 'indigo', 'teal'];
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.innerHTML = `
      <div class="modal modal-sm">
        <div class="modal-header">
          <h3><i class="ph ph-tag"></i> New Tag</h3>
          <button class="modal-close"><i class="ph ph-x"></i></button>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label>Tag Name</label>
            <input type="text" id="new-tag-name" placeholder="Enter tag name" autofocus>
          </div>
          <div class="form-group">
            <label>Color</label>
            <div class="color-picker">
              ${colors.map((c, i) => `
                <button class="color-option ${i === 0 ? 'selected' : ''}"
                        data-color="${c}"
                        style="background: var(--tag-${c})"></button>
              `).join('')}
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary modal-cancel">Cancel</button>
          <button class="btn btn-primary" id="create-tag-btn">Create Tag</button>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    let selectedColor = colors[0];

    modal.querySelectorAll('.color-option').forEach(btn => {
      btn.addEventListener('click', () => {
        modal.querySelectorAll('.color-option').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        selectedColor = btn.dataset.color;
      });
    });

    const closeModal = () => modal.remove();

    modal.querySelector('.modal-close').addEventListener('click', closeModal);
    modal.querySelector('.modal-cancel').addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });

    modal.querySelector('#create-tag-btn').addEventListener('click', () => {
      const name = modal.querySelector('#new-tag-name').value.trim();

      if (name && this.folderStore) {
        this.folderStore.createTag(name, selectedColor);
        closeModal();
        this._renderFileExplorer();
        this._showToast('Tag created', 'success');
      }
    });

    modal.querySelector('#new-tag-name').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') modal.querySelector('#create-tag-btn').click();
    });
  }

  /**
   * Show modal to add tags to a source
   */
  _showAddTagToSourceModal() {
    if (!this.fileExplorerSelectedSource) return;

    const source = this.fileExplorerSelectedSource;
    const currentTags = source.tags || [];
    const allTags = this.folderStore?.getAllTags() || [];

    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.innerHTML = `
      <div class="modal modal-sm">
        <div class="modal-header">
          <h3><i class="ph ph-tag"></i> Add Tags</h3>
          <button class="modal-close"><i class="ph ph-x"></i></button>
        </div>
        <div class="modal-body">
          ${allTags.length > 0 ? `
            <div class="tag-selection">
              ${allTags.map(tag => `
                <label class="tag-checkbox">
                  <input type="checkbox" value="${tag.id}" ${currentTags.includes(tag.id) ? 'checked' : ''}>
                  <span class="tag-label" style="background: var(--tag-${tag.color})">${this._escapeHtml(tag.name)}</span>
                </label>
              `).join('')}
            </div>
          ` : '<p>No tags available. Create a tag first.</p>'}
          <div class="form-group" style="margin-top: 16px;">
            <input type="text" id="quick-add-tag" placeholder="Quick add new tag...">
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary modal-cancel">Cancel</button>
          <button class="btn btn-primary" id="save-tags-btn">Save</button>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    const closeModal = () => modal.remove();

    modal.querySelector('.modal-close').addEventListener('click', closeModal);
    modal.querySelector('.modal-cancel').addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });

    modal.querySelector('#save-tags-btn').addEventListener('click', () => {
      const selectedTags = Array.from(modal.querySelectorAll('.tag-checkbox input:checked'))
        .map(cb => cb.value);

      // Quick add new tag
      const quickAddInput = modal.querySelector('#quick-add-tag');
      const newTagName = quickAddInput?.value.trim();
      if (newTagName && this.folderStore) {
        const newTag = this.folderStore.createTag(newTagName);
        selectedTags.push(newTag.id);
      }

      if (this.sourceStore) {
        this.sourceStore.updateSourceTags(source.id, selectedTags);
      }

      closeModal();
      this._selectFileExplorerSource(source.id);
      this._showToast('Tags updated', 'success');
    });
  }

  /**
   * Show modal to move source to folder
   */
  _showMoveToFolderModal(sourceId) {
    const source = this._getFileExplorerSources().find(s => s.id === sourceId);
    if (!source) return;

    const folders = this.folderStore?.getAll() || [];

    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.innerHTML = `
      <div class="modal modal-sm">
        <div class="modal-header">
          <h3><i class="ph ph-folder"></i> Move to Folder</h3>
          <button class="modal-close"><i class="ph ph-x"></i></button>
        </div>
        <div class="modal-body">
          <p>Move "${this._escapeHtml(source.name)}" to:</p>
          <div class="folder-selection">
            <label class="folder-radio">
              <input type="radio" name="folder" value="" ${!source.folderId ? 'checked' : ''}>
              <span><i class="ph ph-house"></i> Root (No folder)</span>
            </label>
            ${folders.map(f => `
              <label class="folder-radio">
                <input type="radio" name="folder" value="${f.id}" ${source.folderId === f.id ? 'checked' : ''}>
                <span><i class="ph ph-folder"></i> ${this._escapeHtml(f.name)}</span>
              </label>
            `).join('')}
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary modal-cancel">Cancel</button>
          <button class="btn btn-primary" id="move-source-btn">Move</button>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    const closeModal = () => modal.remove();

    modal.querySelector('.modal-close').addEventListener('click', closeModal);
    modal.querySelector('.modal-cancel').addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });

    modal.querySelector('#move-source-btn').addEventListener('click', () => {
      const selectedFolder = modal.querySelector('input[name="folder"]:checked')?.value || null;

      if (this.sourceStore) {
        this.sourceStore.updateSourceFolder(sourceId, selectedFolder);
      }

      closeModal();
      this._renderFileExplorer();
      this._showToast('Source moved', 'success');
    });
  }

  /**
   * Update breadcrumb for file explorer
   */
  _updateBreadcrumb(name, icon) {
    const setName = document.getElementById('current-set-name');
    const viewName = document.getElementById('current-view-name');

    if (setName) {
      setName.innerHTML = `<i class="ph ${icon}"></i> ${this._escapeHtml(name)}`;
    }
    if (viewName) {
      viewName.style.display = 'none';
    }
  }

  // ==========================================================================
  // End File Explorer
  // ==========================================================================

  /**
   * Get source registry from sets
   */
  _getSourceRegistry() {
    const registry = new Map();
    for (const set of this.sets) {
      const prov = set.datasetProvenance;
      const provSourceValue = this._getProvenanceValue(prov?.provenance?.source);
      if (prov && (prov.originalFilename || provSourceValue)) {
        const sourceName = prov.originalFilename || provSourceValue;
        const sourceKey = sourceName.toLowerCase();
        if (!registry.has(sourceKey)) {
          registry.set(sourceKey, {
            id: `src_${sourceKey.replace(/[^a-z0-9]/g, '_')}`,
            name: sourceName,
            importedAt: prov.importedAt,
            provenance: prov.provenance,
            recordCount: 0
          });
        }
        registry.get(sourceKey).recordCount += (set.records?.length || 0);
      }
    }
    return registry;
  }

  /**
   * Show context menu for source
   */
  _showSourceContextMenu(e, sourceId) {
    const source = this.sources?.find(s => s.id === sourceId);
    const isSample = source?.isSample === true;

    const menu = [
      { icon: 'ph-info', label: 'View Details', action: () => this._showSourceDetail(sourceId) },
      { icon: 'ph-pencil', label: 'Rename Source...', action: () => this._renameSource(sourceId) },
      { icon: 'ph-fingerprint', label: 'Edit Provenance...', action: () => this._editSourceProvenance(sourceId) },
      { divider: true },
      { icon: 'ph-table', label: 'Create Set from Source...', action: () => this._showSetFromSourceUI(sourceId) },
      { icon: 'ph-code', label: 'Query Builder...', action: () => this._showQueryBuilderUI(sourceId) },
      { icon: 'ph-intersect', label: 'Join with Another Source...', action: () => this._showJoinBuilderUI(sourceId) },
      { divider: true },
      { icon: 'ph-export', label: 'Export Source Data', action: () => this._exportSource(sourceId) },
      { divider: true }
    ];

    // Sample data can only be cleared via Settings > Clear Sample Data
    if (isSample) {
      menu.push({
        icon: 'ph-flask',
        label: 'Sample Data (use Settings to clear)',
        disabled: true,
        action: () => this._showToast('Sample data can only be cleared via Settings → Clear Sample Data', 'info')
      });
    } else {
      menu.push({ icon: 'ph-archive', label: 'Archive Source', action: () => this._archiveSource(sourceId) });
      menu.push({ icon: 'ph-trash', label: 'Delete Source', action: () => this._deleteSource(sourceId), class: 'danger' });
    }

    this._showContextMenu(e.pageX, e.pageY, menu);
  }

  /**
   * Show the DataPipelineUI modal for creating a Set from Source(s)
   * Uses a visual pipeline flow: Sources → Transforms → Output
   * First shows a prompt asking if user wants to create new or merge with existing data
   */
  _showSetFromSourceUI(sourceId) {
    // Find the source from this.sources (single source of truth)
    const source = this.sources?.find(s => s.id === sourceId);

    if (!source) {
      this._showToast('Source not found. Please re-import the file to create a set.', 'error');
      return;
    }

    // Check if there are existing sets or sources to merge with
    const hasExistingSets = this.sets && this.sets.length > 0;
    const hasOtherSources = this.sources && this.sources.filter(s => s.id !== sourceId).length > 0;
    const canMerge = hasExistingSets || hasOtherSources;

    // If there's nothing to merge with, skip the prompt and go straight to create
    if (!canMerge) {
      this._proceedWithCreateSet(sourceId);
      return;
    }

    // Show the merge prompt
    this._showCreateSetMergePrompt(sourceId, source);
  }

  /**
   * Show prompt asking user whether to create a new set or merge with existing data
   */
  _showCreateSetMergePrompt(sourceId, source) {
    const intents = [
      {
        id: 'CREATE',
        icon: 'ph-plus-circle',
        label: 'Create New Set',
        description: 'Create a standalone set from this source data'
      },
      {
        id: 'MERGE',
        icon: 'ph-git-merge',
        label: 'Merge with Existing Data',
        description: 'Combine this source with existing sets or sources'
      }
    ];

    const html = `
      <div class="operator-creation-modal">
        <div class="source-preview-header" style="margin-bottom: 16px; padding: 12px; background: var(--bg-secondary); border-radius: 8px;">
          <div style="display: flex; align-items: center; gap: 8px;">
            <i class="ph ph-file-csv" style="font-size: 20px; color: var(--accent-primary);"></i>
            <div>
              <div style="font-weight: 500;">${source.name}</div>
              <div style="font-size: 12px; color: var(--text-secondary);">${source.records?.length || 0} records</div>
            </div>
          </div>
        </div>
        <p class="creation-prompt">What would you like to do with this data?</p>
        <div class="creation-intents">
          ${intents.map(intent => `
            <button class="creation-intent-btn" data-intent="${intent.id}">
              <i class="ph ${intent.icon}"></i>
              <div class="intent-content">
                <span class="intent-label">${intent.label}</span>
                <span class="intent-description">${intent.description}</span>
              </div>
            </button>
          `).join('')}
        </div>
      </div>
    `;

    this._showModal('Create Set from Data', html, null, { hideFooter: true });

    // Use event delegation on modal body for click handling
    const modalBody = document.getElementById('modal-body');
    if (modalBody) {
      const handleIntentClick = (e) => {
        const btn = e.target.closest('.creation-intent-btn');
        if (btn) {
          const intent = btn.dataset.intent;
          modalBody.removeEventListener('click', handleIntentClick);
          this._closeModal();

          if (intent === 'CREATE') {
            this._proceedWithCreateSet(sourceId);
          } else if (intent === 'MERGE') {
            this._showRelationalMergeUI(sourceId);
          }
        }
      };
      modalBody.addEventListener('click', handleIntentClick);
    }
  }

  /**
   * Proceed with creating a new set from source using DataPipelineUI
   */
  _proceedWithCreateSet(sourceId) {
    const source = this.sources?.find(s => s.id === sourceId);
    if (!source) {
      this._showToast('Source not found. Please re-import the file to create a set.', 'error');
      return;
    }

    // Ensure sourceStore has this source (for compatibility)
    if (!this.sourceStore) {
      this._initSourceStore();
    }

    // Add source to sourceStore if not already there
    if (!this.sourceStore.get(sourceId)) {
      this.sourceStore.sources.set(sourceId, source);
    }

    // Get or create the SetCreator
    if (!this._setCreator) {
      this._setCreator = new SetCreator(this.sourceStore, this.eoApp?.eventStore);
    }

    // Create and show the DataPipelineUI
    const ui = new DataPipelineUI({
      sourceStore: this.sourceStore,
      setCreator: this._setCreator
    });

    ui.show({
      sourceId: sourceId,
      allSources: this.sources || [],
      onComplete: (result) => {
        // Add the new set to our sets array
        this.sets.push(result.set);
        this._addSetToProject(result.set.id);

        // Auto-link fields to common definitions if available
        if (window.EO?.autoLinkSetToCommonDefinitions) {
          try {
            const linkResult = window.EO.autoLinkSetToCommonDefinitions(this, result.set.id, {
              minConfidence: 0.8,  // High confidence for auto-linking
              autoLink: true
            });
            if (linkResult.linked > 0) {
              console.log(`Auto-linked ${linkResult.linked} fields to common definitions in set "${result.set.name}"`);
            }
          } catch (error) {
            console.warn('Could not auto-link common definitions:', error);
          }
        }

        // Record activity for set creation from import
        const lensCount = result.set.lenses?.length || 0;
        const lensDetails = lensCount > 0 ? `, ${lensCount} lens${lensCount > 1 ? 'es' : ''}` : '';
        this._recordActivity({
          action: 'create',
          entityType: 'set',
          name: result.set.name,
          details: `${result.set.records.length} records, ${result.set.fields.length} fields${lensDetails} (from import)`
        });

        // Record activity for each lens created from the import
        if (result.set.lenses && result.set.lenses.length > 0) {
          for (const lens of result.set.lenses) {
            const memberCount = lens.memberRecordIds?.length || 0;
            this._recordActivity({
              action: 'create',
              entityType: 'lens',
              name: lens.name,
              details: `${memberCount} records in set "${result.set.name}" (from import)`
            });
          }
        }

        this._saveData();
        this._renderSidebar();
        this._selectSet(result.set.id);
        this._showToast(`Set "${result.set.name}" created with ${result.set.records.length} records`, 'success');
      },
      onCancel: () => {
        // Nothing to do on cancel
      }
    });
  }

  /**
   * Show the QueryBuilderUI modal for creating Sets with SQL/EOQL
   */
  _showQueryBuilderUI(sourceId) {
    // Find the source from this.sources
    const source = this.sources?.find(s => s.id === sourceId);

    if (!source) {
      this._showToast('Source not found. Please re-import the file.', 'error');
      return;
    }

    // Ensure sourceStore has this source
    if (!this.sourceStore) {
      this._initSourceStore();
    }

    if (!this.sourceStore.get(sourceId)) {
      this.sourceStore.sources.set(sourceId, source);
    }

    // Get or create the SetCreator
    if (!this._setCreator) {
      this._setCreator = new SetCreator(this.sourceStore, this.eoApp?.eventStore);
    }

    // Create container for the modal if it doesn't exist
    let container = document.getElementById('query-builder-container');
    if (!container) {
      container = document.createElement('div');
      container.id = 'query-builder-container';
      document.body.appendChild(container);
    }

    // Create and show the UI
    const ui = new QueryBuilderUI(this._setCreator, container);
    ui.show(sourceId, {
      onComplete: (result) => {
        // Add the new set to our sets array
        this.sets.push(result.set);
        this._addSetToProject(result.set.id);
        this._saveData();
        this._renderSidebar();
        this._selectSet(result.set.id);
        this._showToast(`Set "${result.set.name}" created with ${result.set.records.length} records`, 'success');
      },
      onCancel: () => {
        // Nothing to do on cancel
      }
    });
  }

  /**
   * Show the RelationalMergeUI modal for creating joined Sets
   * Uses the phase-space merge paradigm with Recognition/Boundary/Decision axes
   * @param {string|string[]|null} preSelectedSourceIds - Single source ID or array of source IDs to pre-select
   */
  _showRelationalMergeUI(preSelectedSourceIds = null) {
    // Ensure we have a source store
    if (!this.sourceStore) {
      this._initSourceStore();
    }

    // Sync all sources to sourceStore for merge compatibility
    // Ensure sources have status: 'active' so they appear in getByStatus('active')
    // Use string keys consistently to avoid type mismatch issues with HTML select values
    for (const source of (this.sources || [])) {
      const stringId = String(source.id);
      if (!this.sourceStore.get(stringId) && !this.sourceStore.get(source.id)) {
        // Ensure the source has an active status for filtering
        const sourceWithStatus = source.status ? source : { ...source, status: 'active' };
        // Store with string key for consistent lookup from HTML select values
        this.sourceStore.sources.set(stringId, sourceWithStatus);
      }
    }

    // Create container for the modal if it doesn't exist
    let container = document.getElementById('relational-merge-container');
    if (!container) {
      container = document.createElement('div');
      container.id = 'relational-merge-container';
      document.body.appendChild(container);
    }

    // Normalize preSelectedSourceIds to an array
    const sourceIdsArray = preSelectedSourceIds
      ? (Array.isArray(preSelectedSourceIds) ? preSelectedSourceIds : [preSelectedSourceIds])
      : [];

    // Create and show the RelationalMergeUI
    const ui = new RelationalMergeUI(this.sourceStore, container);
    ui.show({
      preSelectedSources: sourceIdsArray,
      onComplete: async (result) => {
        // Add the new virtual set to our sets array
        this.sets.push(result.set);
        this._addSetToProject(result.set.id);

        // For virtual sets, we need to compute records lazily when viewed
        // The set stores only the derivation spec, not the actual records
        if (result.isVirtual) {
          // Show toast with pending message since records aren't computed yet
          this._showToast(
            `Merged set "${result.set.name}" created (records computed on view)`,
            'success'
          );
        } else {
          this._showToast(
            `Merged set "${result.set.name}" created with ${result.stats.resultRecords} records`,
            'success'
          );
        }

        this._saveData();
        this._renderSidebar();
        this._selectSet(result.set.id);
      },
      onCancel: () => {
        // Nothing to do on cancel
      }
    });
  }

  /**
   * Show the JoinBuilderUI modal for creating joined Sets (Legacy)
   * @deprecated Use _showRelationalMergeUI instead
   */
  _showJoinBuilderUI(preSelectedSourceIds = null) {
    // Redirect to the new RelationalMergeUI
    return this._showRelationalMergeUI(preSelectedSourceIds);
  }

  /**
   * Initialize the SourceStore if not already done
   */
  _initSourceStore() {
    if (this.sourceStore) return;

    // Create new SourceStore
    const eventStore = this.eoApp?.eventStore || null;
    this.sourceStore = new SourceStore(eventStore);

    // Create FolderStore for file organization
    if (typeof FolderStore !== 'undefined' && !this.folderStore) {
      this.folderStore = new FolderStore();
    }

    // Migrate existing sources from legacy format
    this._migrateLegacySourcesToStore();
  }

  /**
   * Migrate legacy sources (derived from sets) to the new SourceStore
   */
  _migrateLegacySourcesToStore() {
    if (!this.sourceStore) return;

    // Find all unique sources from sets with provenance
    const seenSources = new Set();

    for (const set of this.sets) {
      const prov = set.datasetProvenance;
      if (!prov) continue;

      const sourceName = prov.originalFilename || this._getProvenanceValue(prov.provenance?.source);
      if (!sourceName || seenSources.has(sourceName.toLowerCase())) continue;

      seenSources.add(sourceName.toLowerCase());

      // Create a source from this set's data (if it has records)
      if (set.records && set.records.length > 0) {
        // Extract raw records (remove field ID mapping)
        const rawRecords = set.records.map(record => {
          const raw = {};
          for (const field of set.fields) {
            raw[field.name] = record.values?.[field.id] ?? null;
          }
          return raw;
        });

        // Create the source
        this.sourceStore.createSource({
          name: sourceName,
          records: rawRecords,
          schema: { fields: set.fields.map(f => ({ name: f.name, type: f.type })) },
          provenance: prov.provenance || {},
          fileMetadata: {
            originalFilename: sourceName,
            importedAt: prov.importedAt
          }
        });
      }
    }
  }

  /**
   * Get icon for source based on sourceType or file extension
   * @param {string|Object} source - Filename string or source object
   * @returns {string} Phosphor icon class
   */
  _getSourceIcon(source) {
    // If passed a source object, check sourceType first
    if (typeof source === 'object' && source !== null) {
      // Live source types get distinctive icons
      if (source.sourceType === 'rss') return 'ph-rss';
      if (source.sourceType === 'api') return 'ph-plugs-connected';
      if (source.sourceType === 'scrape') return 'ph-globe';
      if (source.sourceType === 'null') return 'ph-table';

      // Fall through to file extension check
      source = source.name || '';
    }

    // File extension based icons
    const filename = typeof source === 'string' ? source : '';
    const ext = filename.split('.').pop()?.toLowerCase();
    switch (ext) {
      case 'csv': return 'ph-file-csv';
      case 'json': return 'ph-file-code';
      case 'xlsx':
      case 'xls': return 'ph-file-xls';
      case 'ics': return 'ph-calendar-blank';
      default: return 'ph-file';
    }
  }

  /**
   * Truncate source name for display
   */
  _truncateSourceName(name) {
    if (name.length > 20) {
      return name.slice(0, 17) + '...';
    }
    return name;
  }

  /**
   * Get sync status info for live sources (API/RSS)
   * @param {Object} source - Source object
   * @returns {Object} { label, tooltip, status }
   */
  _getLiveSyncInfo(source) {
    const liveSource = source.liveSource;
    const sourceType = source.sourceType?.toUpperCase() || 'LIVE';

    if (!liveSource?.lastSyncAt) {
      return {
        label: 'Never synced',
        tooltip: `${sourceType}: Never synchronized`,
        status: 'never'
      };
    }

    const lastSync = new Date(liveSource.lastSyncAt);
    const now = new Date();
    const diffMs = now - lastSync;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);

    let timeAgo;
    if (diffMins < 1) {
      timeAgo = 'just now';
    } else if (diffMins < 60) {
      timeAgo = `${diffMins}m ago`;
    } else if (diffHours < 24) {
      timeAgo = `${diffHours}h ago`;
    } else {
      timeAgo = `${diffDays}d ago`;
    }

    // Determine freshness status
    let status = 'fresh';
    if (diffMins > 30) {
      status = 'stale';
    }
    if (diffMins > 60 * 24) { // More than a day
      status = 'old';
    }

    const endpoint = liveSource.endpoint || 'unknown endpoint';
    const truncatedEndpoint = endpoint.length > 50 ? endpoint.slice(0, 47) + '...' : endpoint;

    return {
      label: timeAgo,
      tooltip: `${sourceType}: Synced ${timeAgo}\nEndpoint: ${truncatedEndpoint}\nClick to refresh`,
      status: status
    };
  }

  /**
   * Format provenance info for tooltip
   */
  _formatSourceProvenance(source) {
    const parts = [];
    if (source.importedAt) {
      parts.push(`Imported: ${new Date(source.importedAt).toLocaleDateString()}`);
    }
    const agentValue = this._getProvenanceValue(source.provenance?.agent);
    if (agentValue) {
      parts.push(`From: ${agentValue}`);
    }
    const methodValue = this._getProvenanceValue(source.provenance?.method);
    if (methodValue) {
      parts.push(`Via: ${methodValue}`);
    }
    return parts.join('\n') || source.name;
  }

  /**
   * Render workspaces navigation
   */
  _renderWorkspacesNav() {
    const container = document.getElementById('workspaces-nav');
    if (!container) return;

    const workspaces = this.viewRegistry?.getAllWorkspaces?.() || [];

    if (workspaces.length === 0) {
      container.innerHTML = `
        <div class="nav-item empty-hint" id="create-first-workspace">
          <i class="ph ph-plus-circle"></i>
          <span>Create Workspace</span>
        </div>
      `;
      container.querySelector('#create-first-workspace')?.addEventListener('click', () => {
        this._showNewWorkspaceModal();
      });
      return;
    }

    container.innerHTML = workspaces.map(workspace => `
      <div class="nav-item ${workspace.id === this.currentWorkspaceId ? 'active' : ''}"
           data-workspace-id="${workspace.id}">
        <i class="ph ${workspace.icon || 'ph-folder-simple'}"></i>
        <span>${this._escapeHtml(workspace.name)}</span>
        <span class="nav-item-badge" title="Horizon: ${workspace.epistemicStatus}">
          <i class="ph ph-eye"></i>
        </span>
      </div>
    `).join('');

    // Attach click handlers
    container.querySelectorAll('.nav-item[data-workspace-id]').forEach(item => {
      item.addEventListener('click', () => {
        this._selectWorkspace(item.dataset.workspaceId);
      });

      item.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        this._showWorkspaceContextMenu(e, item.dataset.workspaceId);
      });
    });
  }

  /**
   * Render focuses navigation (filtered views)
   */
  _renderFocusesNav() {
    const container = document.getElementById('focuses-nav');
    if (!container) return;

    // Get focuses for current lens
    const focuses = this.viewRegistry?.getFocusesForLens?.(this.currentLensId || this.currentViewId) || [];

    if (focuses.length === 0) {
      container.innerHTML = '';
      return;
    }

    // Calculate restriction ratios for each focus (Rule 5 visibility)
    const set = this.getCurrentSet();
    const totalRecords = set?.records?.length || 0;

    container.innerHTML = `
      <div class="nav-section-header">
        <span class="nav-section-title">Focuses</span>
        <span class="nav-section-hint" title="Rule 5: Focuses can only restrict, never expand">↓ Restrict</span>
        <button class="nav-section-action" id="btn-new-focus" title="Add Focus (Rule 5: Restrict only)">
          <i class="ph ph-funnel"></i>
        </button>
      </div>
      ${focuses.map(focus => {
        const focusRecords = this._getFilteredRecordCountForFocus(focus, set);
        const restrictionPercent = totalRecords > 0 ? Math.round((focusRecords / totalRecords) * 100) : 100;
        return `
        <div class="nav-item focus-item ${focus.id === this.currentFocusId ? 'active' : ''}"
             data-focus-id="${focus.id}"
             title="Rule 5: Restricts to ${focusRecords} of ${totalRecords} (${restrictionPercent}%)">
          <i class="ph ph-funnel"></i>
          <span>${this._escapeHtml(focus.name)}</span>
          <span class="focus-restriction-ratio">(${focusRecords}/${totalRecords})</span>
          <div class="focus-restriction-bar">
            <div class="focus-restriction-fill" style="width: ${restrictionPercent}%"></div>
          </div>
        </div>
      `;}).join('')}
    `;

    // Attach click handlers
    container.querySelectorAll('.nav-item[data-focus-id]').forEach(item => {
      item.addEventListener('click', () => {
        this._selectFocus(item.dataset.focusId);
      });
    });

    document.getElementById('btn-new-focus')?.addEventListener('click', () => {
      this._showNewFocusModal();
    });
  }

  /**
   * Select a workspace
   */
  _selectWorkspace(workspaceId) {
    this.currentWorkspaceId = workspaceId;
    this.viewRegistry?.setActiveWorkspace?.(workspaceId);

    // Get sets for this workspace
    const sets = this.viewRegistry?.getSetsForWorkspace?.(workspaceId) || [];
    if (sets.length > 0) {
      this._selectSet(sets[0].id);
    }

    this._renderSidebar();
    this._updateBreadcrumb();
    this._saveData();
  }

  /**
   * Select a focus
   */
  _selectFocus(focusId) {
    this.currentFocusId = focusId;
    this.viewRegistry?.setActiveFocus?.(focusId);
    this._renderView();
    this._renderFocusesNav();
    this._updateBreadcrumb();
  }

  /**
   * Clear focus (back to lens view)
   */
  _clearFocus() {
    this.currentFocusId = null;
    this.viewRegistry?.setActiveFocus?.(null);
    this._renderView();
    this._renderFocusesNav();
    this._updateBreadcrumb();
  }

  /**
   * Show notification
   */
  _showNotification(message) {
    // Simple notification - could be enhanced
    console.log('Notification:', message);
  }

  _renderSetsNav() {
    const container = this.elements.setsNav;
    if (!container) return;

    container.innerHTML = this.sets.map(set => `
      <div class="nav-item ${set.id === this.currentSetId ? 'active' : ''}"
           data-set-id="${set.id}">
        <i class="${set.icon || 'ph ph-table'}"></i>
        <span>${this._escapeHtml(set.name)}</span>
        <span class="nav-item-count">${set.records.length}</span>
      </div>
    `).join('');

    // Attach click handlers
    container.querySelectorAll('.nav-item').forEach(item => {
      item.addEventListener('click', () => {
        const setId = item.dataset.setId;
        this._selectSet(setId);
      });

      item.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        this._showSetContextMenu(e, item.dataset.setId);
      });
    });
  }

  /**
   * Render navigation elements for views
   * Since sidebar VIEWS panel is removed, this now just renders the tab bar (Sets)
   * and the view disclosure panel
   */
  _renderViewsNav() {
    // Render the tab bar (now shows Sets)
    this._renderTabBar();
    // Render the view disclosure (shows Views for current Set)
    this._renderViewDisclosure();
  }

  // --------------------------------------------------------------------------
  // Browser-Style Tab Bar
  // --------------------------------------------------------------------------

  /**
   * Render the browser-style tab bar - now uses the unified browser tab system
   * All tabs (sets, sources, definitions, settings, etc.) are closeable like Chrome
   */
  _renderTabBar() {
    // Delegate to the new browser tab rendering
    this._renderBrowserTabBar();
    this._checkTabOverflow();
  }

  /**
   * Show context menu for set tab
   */
  _showSetTabContextMenu(e, setId) {
    const existing = document.querySelector('.tab-context-menu');
    if (existing) existing.remove();

    const set = this.sets.find(s => s.id === setId);
    if (!set) return;

    const menu = document.createElement('div');
    menu.className = 'tab-context-menu';
    menu.style.left = `${e.clientX}px`;
    menu.style.top = `${e.clientY}px`;
    menu.innerHTML = `
      <div class="tab-context-item" data-action="rename">
        <i class="ph ph-pencil-simple"></i>
        <span>Rename Set</span>
      </div>
      <div class="tab-context-item" data-action="duplicate">
        <i class="ph ph-copy"></i>
        <span>Duplicate Set</span>
      </div>
      <div class="tab-context-divider"></div>
      <div class="tab-context-item danger" data-action="delete">
        <i class="ph ph-trash"></i>
        <span>Delete Set</span>
      </div>
    `;

    document.body.appendChild(menu);

    menu.querySelectorAll('.tab-context-item').forEach(item => {
      item.addEventListener('click', () => {
        const action = item.dataset.action;
        if (action === 'rename') {
          this._renameSetTab(setId);
        } else if (action === 'duplicate') {
          this._duplicateSet(setId);
        } else if (action === 'delete') {
          this._deleteSet(setId);
        }
        menu.remove();
      });
    });

    const closeMenu = (evt) => {
      if (!menu.contains(evt.target)) {
        menu.remove();
        document.removeEventListener('click', closeMenu);
      }
    };
    setTimeout(() => document.addEventListener('click', closeMenu), 0);
  }

  /**
   * Reorder set tabs via drag and drop
   */
  _reorderSetTabs(draggedSetId, targetSetId, insertAfter) {
    const draggedIndex = this.sets.findIndex(s => s.id === draggedSetId);
    const targetIndex = this.sets.findIndex(s => s.id === targetSetId);

    if (draggedIndex === -1 || targetIndex === -1) return;

    const [draggedSet] = this.sets.splice(draggedIndex, 1);
    let newIndex = targetIndex;
    if (insertAfter) newIndex++;
    if (draggedIndex < targetIndex) newIndex--;

    this.sets.splice(newIndex, 0, draggedSet);
    this._renderTabBar();
    this._renderSetsNavFlat();
    this._saveData();
  }

  /**
   * Rename a set from the tab bar
   */
  _renameSetTab(setId) {
    const set = this.sets.find(s => s.id === setId);
    if (!set) return;

    const newName = prompt('Rename set:', set.name);
    if (newName && newName.trim() && newName !== set.name) {
      const oldName = set.name;
      set.name = newName.trim();

      // Record activity for the rename
      this._recordActivity({
        action: 'update',
        entityType: 'set',
        name: set.name,
        details: `Renamed from "${oldName}" to "${newName.trim()}"`,
        canReverse: false
      });

      this._renderTabBar();
      this._renderSetsNavFlat();
      this._updateBreadcrumb();
      this._saveData();
      this._showToast(`Set renamed to "${set.name}"`, 'success');
    }
  }

  /**
   * Confirm and delete a set
   * Wrapper method that calls _deleteSet
   */
  _confirmDeleteSet(setId) {
    this._deleteSet(setId);
  }

  /**
   * Delete (toss) a set - removes from view but nothing is ever deleted
   * Tossed items can be picked back up from the tossed items list
   */
  _deleteSet(setId) {
    // Can't delete the last set
    if (this.sets.length <= 1) {
      this._showToast('Cannot delete the last set', 'warning');
      return;
    }

    const setIndex = this.sets.findIndex(s => s.id === setId);
    if (setIndex === -1) return;

    const set = this.sets[setIndex];

    // Can't delete the Tossed/Trash set (the toss bin is a permanent feature)
    const protectedNames = ['tossed', 'trash', 'toss bin', 'trash bin', 'deleted', 'recycle bin'];
    if (protectedNames.includes(set.name.toLowerCase().trim())) {
      this._showToast('Cannot delete the toss bin', 'warning');
      return;
    }
    const wasCurrentSet = this.currentSetId === setId;

    // Add to tossed items (nothing is ever deleted per Rule 9)
    this.tossedItems.unshift({
      type: 'set',
      set: JSON.parse(JSON.stringify(set)), // Deep clone
      tossedAt: new Date().toISOString()
    });
    if (this.tossedItems.length > this.maxTossedItems) {
      this.tossedItems.pop();
    }

    // Register as ghost if ghost registry is available
    if (typeof getGhostRegistry === 'function') {
      const ghostRegistry = getGhostRegistry();
      const tombstoneEvent = {
        id: `tombstone_${Date.now().toString(36)}_${Math.random().toString(36).substr(2, 6)}`,
        timestamp: new Date().toISOString(),
        actor: 'user',
        payload: {
          action: 'tombstone',
          targetId: setId,
          reason: 'User tossed set',
          targetSnapshot: {
            type: 'set',
            payload: { name: set.name, fieldCount: set.fields.length, recordCount: set.records.length }
          }
        },
        context: { workspace: 'default' }
      };
      ghostRegistry.registerGhost(setId, tombstoneEvent, {
        entityType: 'set',
        workspace: 'default'
      });
    }

    // Record activity for the deletion
    this._recordActivity({
      action: 'delete',
      entityType: 'set',
      name: set.name,
      details: `Tossed set with ${set.records.length} records and ${set.fields.length} fields`,
      canReverse: true,
      reverseData: { type: 'restore_tossed', item: { type: 'set', set } }
    });

    // Remove from sets array
    this.sets.splice(setIndex, 1);

    // If we're deleting the current set, switch to adjacent set
    if (wasCurrentSet) {
      const newIndex = Math.min(setIndex, this.sets.length - 1);
      this.currentSetId = this.sets[newIndex]?.id;
      this.currentViewId = this.sets[newIndex]?.views[0]?.id;
      // Update lastViewPerSet
      if (this.currentSetId && this.currentViewId) {
        this.lastViewPerSet[this.currentSetId] = this.currentViewId;
      }
    }

    // Clean up lastViewPerSet for deleted set
    delete this.lastViewPerSet[setId];

    this._renderTabBar();
    this._renderSetsNavFlat();
    this._renderSidebar();
    this._renderView();
    this._updateBreadcrumb();
    this._saveData();
    this._updateTossedBadge();

    // Show undo toast with countdown
    this._showToast(`Tossed set "${set.name}"`, 'info', {
      countdown: 5000,
      action: {
        label: 'Undo',
        callback: () => {
          // Restore the set using _restoreTossedItem (which also records activity)
          const tossedIndex = this.tossedItems.findIndex(
            t => t.type === 'set' && t.set.id === set.id
          );
          if (tossedIndex !== -1) {
            this._restoreTossedItem(tossedIndex);
          }
        }
      }
    });
  }

  /**
   * Duplicate a set with all its fields, views, and records
   */
  _duplicateSet(setId) {
    const sourceSet = this.sets.find(s => s.id === setId);
    if (!sourceSet) return;

    // Create a deep clone of the set with new IDs
    const newSet = JSON.parse(JSON.stringify(sourceSet));
    newSet.id = generateId();
    newSet.name = `${sourceSet.name} (Copy)`;
    newSet.createdAt = new Date().toISOString();
    newSet.updatedAt = new Date().toISOString();

    // Generate new IDs for all fields and create a mapping
    const fieldIdMap = {};
    newSet.fields.forEach(field => {
      const oldId = field.id;
      field.id = generateId();
      fieldIdMap[oldId] = field.id;
    });

    // Update record values to use new field IDs
    newSet.records.forEach(record => {
      record.id = generateId();
      record.setId = newSet.id;
      const newValues = {};
      Object.entries(record.values).forEach(([oldFieldId, value]) => {
        const newFieldId = fieldIdMap[oldFieldId];
        if (newFieldId) {
          newValues[newFieldId] = value;
        }
      });
      record.values = newValues;
    });

    // Generate new IDs for views and update their configs
    newSet.views.forEach(view => {
      view.id = generateId();
      // Update field references in view config
      if (view.config) {
        if (view.config.hiddenFields) {
          view.config.hiddenFields = view.config.hiddenFields.map(
            fId => fieldIdMap[fId] || fId
          );
        }
        if (view.config.fieldOrder) {
          view.config.fieldOrder = view.config.fieldOrder.map(
            fId => fieldIdMap[fId] || fId
          );
        }
        if (view.config.sorts) {
          view.config.sorts = view.config.sorts.map(sort => ({
            ...sort,
            fieldId: fieldIdMap[sort.fieldId] || sort.fieldId
          }));
        }
        if (view.config.filters) {
          view.config.filters = view.config.filters.map(filter => ({
            ...filter,
            fieldId: fieldIdMap[filter.fieldId] || filter.fieldId
          }));
        }
        if (view.config.groups) {
          view.config.groups = view.config.groups.map(group => ({
            ...group,
            fieldId: fieldIdMap[group.fieldId] || group.fieldId
          }));
        }
      }
    });

    // Add the new set after the source set
    const sourceIndex = this.sets.findIndex(s => s.id === setId);
    this.sets.splice(sourceIndex + 1, 0, newSet);

    // Record activity for the duplication
    this._recordActivity({
      action: 'duplicate',
      entityType: 'set',
      name: newSet.name,
      details: `Duplicated from "${sourceSet.name}" with ${newSet.records.length} records`
    });

    // Switch to the new set
    this.currentSetId = newSet.id;
    this.currentViewId = newSet.views[0]?.id;
    this.lastViewPerSet[newSet.id] = this.currentViewId;

    // Record activity for activity stream
    this._recordActivity({
      action: 'create',
      entityType: 'set',
      name: newSet.name,
      details: `Duplicated from "${sourceSet.name}" (${newSet.records.length} records, ${newSet.fields.length} fields)`,
      canReverse: false
    });

    this._renderTabBar();
    this._renderSetsNavFlat();
    this._renderSidebar();
    this._renderView();
    this._updateBreadcrumb();
    this._saveData();

    this._showToast(`Duplicated set as "${newSet.name}"`, 'success');
  }

  /**
   * Create a new tab (opens the New Tab page like Chrome)
   */
  _createNewTab() {
    this.openTab('newTab');
  }

  /**
   * Add a new tab of specific type
   */
  _addNewTabOfType(viewType) {
    const set = this.getCurrentSet();
    if (!set) return;

    const viewCount = set.views.filter(v => v.type === viewType).length;
    const name = viewCount > 0
      ? `${viewType.charAt(0).toUpperCase() + viewType.slice(1)} View ${viewCount + 1}`
      : `${viewType.charAt(0).toUpperCase() + viewType.slice(1)} View`;

    const view = createView(name, viewType);
    set.views.push(view);
    this.currentViewId = view.id;

    // Remember this view for the current set
    if (this.currentSetId) {
      this.lastViewPerSet[this.currentSetId] = view.id;
    }

    this._renderViewsNav();
    this._renderView();
    this._updateBreadcrumb();
    this._saveData();
  }

  /**
   * Toss a tab - removes from view but nothing is ever deleted
   * Tossed items can be picked back up from the tossed items list
   * Shows undo toast for 5 seconds to allow recovery
   */
  _tossTab(viewId) {
    const set = this.getCurrentSet();
    if (!set || set.views.length <= 1) {
      // Can't toss the last tab
      this._showToast('Cannot toss the last tab', 'warning');
      return;
    }

    const viewIndex = set.views.findIndex(v => v.id === viewId);
    if (viewIndex === -1) return;

    const view = set.views[viewIndex];
    const wasCurrentView = this.currentViewId === viewId;

    // Toss to the tossed items pile (nothing is ever deleted)
    this.tossedItems.unshift({
      type: 'view',
      view: { ...view },
      setId: set.id,
      tossedAt: new Date().toISOString()
    });
    if (this.tossedItems.length > this.maxTossedItems) {
      this.tossedItems.pop();
    }

    // Remove the view from current set
    set.views.splice(viewIndex, 1);

    // If we're tossing the current view, switch to adjacent tab
    if (wasCurrentView) {
      const newIndex = Math.min(viewIndex, set.views.length - 1);
      this.currentViewId = set.views[newIndex]?.id;
      // Remember this view for the current set
      if (this.currentSetId && this.currentViewId) {
        this.lastViewPerSet[this.currentSetId] = this.currentViewId;
      }
    }

    this._renderViewsNav();
    this._renderView();
    this._updateBreadcrumb();
    this._saveData();
    this._updateTossedBadge();

    // Show undo toast with countdown
    this._showToast(`Tossed "${view.name}"`, 'info', {
      countdown: 5000,
      action: {
        label: 'Undo',
        callback: () => {
          // Restore the view using _restoreTossedItem (which also records activity)
          const tossedIndex = this.tossedItems.findIndex(
            t => t.type === 'view' && t.view.id === view.id
          );
          if (tossedIndex !== -1) {
            this._restoreTossedItem(tossedIndex);
          }
        }
      }
    });
  }

  /**
   * Pick up the last tossed item (restore it)
   */
  _pickUpLastTossed() {
    if (this.tossedItems.length === 0) {
      this._showToast('Nothing in the tossed pile to pick up', 'info');
      return;
    }

    // Use _restoreTossedItem which handles all restore logic and records activity
    this._restoreTossedItem(0);
  }

  /**
   * Pick up data from various sources (field, column, record, view)
   * This allows users to "grab" data and move/copy it elsewhere
   */
  _pickUp(type, data, source) {
    this.pickedUp = {
      type,      // 'field', 'column', 'record', 'view', 'selection'
      data,      // The actual data being picked up
      source,    // Where it came from { setId, viewId, recordId?, fieldId? }
      pickedAt: new Date().toISOString()
    };

    // Update UI to show something is picked up
    this._updatePickedUpIndicator();
    this._showToast(`Picked up ${type}`, 'info');
  }

  /**
   * Put down (drop) the currently picked up item
   */
  _putDown(targetType, target) {
    if (!this.pickedUp) {
      this._showToast('Nothing picked up to put down', 'warning');
      return;
    }

    const { type, data, source } = this.pickedUp;

    // Handle different put down scenarios
    switch (targetType) {
      case 'field':
        // Put field value into another field
        if (type === 'field') {
          this._putFieldIntoField(data, target);
        }
        break;
      case 'record':
        // Put data into a record
        if (type === 'record') {
          this._mergeRecords(data, target);
        }
        break;
      case 'view':
        // Add record(s) to a view's set
        if (type === 'record' || type === 'selection') {
          this._addToSet(data, target);
        }
        break;
    }

    this._clearPickedUp();
  }

  /**
   * Clear the picked up state
   */
  _clearPickedUp() {
    this.pickedUp = null;
    this._updatePickedUpIndicator();
  }

  /**
   * Update the UI to show what's currently picked up
   */
  _updatePickedUpIndicator() {
    let indicator = document.getElementById('picked-up-indicator');

    if (!this.pickedUp) {
      if (indicator) indicator.remove();
      document.body.classList.remove('has-picked-up');
      return;
    }

    document.body.classList.add('has-picked-up');

    if (!indicator) {
      indicator = document.createElement('div');
      indicator.id = 'picked-up-indicator';
      indicator.className = 'picked-up-indicator';
      document.body.appendChild(indicator);
    }

    const typeIcons = {
      field: 'ph-text-aa',
      column: 'ph-columns',
      record: 'ph-rows',
      view: 'ph-table',
      selection: 'ph-selection'
    };

    const typeLabels = {
      field: 'cell value',
      column: 'column',
      record: 'record',
      view: 'view',
      selection: `${this.selectedRecords?.size || 0} records`
    };

    indicator.innerHTML = `
      <div class="picked-up-content">
        <i class="ph ${typeIcons[this.pickedUp.type] || 'ph-hand-grabbing'}"></i>
        <span>Holding ${typeLabels[this.pickedUp.type] || this.pickedUp.type}</span>
        <button class="picked-up-drop" title="Put down (Esc)">
          <i class="ph ph-x"></i>
        </button>
      </div>
    `;

    indicator.querySelector('.picked-up-drop')?.addEventListener('click', () => {
      this._clearPickedUp();
      this._showToast('Dropped picked up item', 'info');
    });
  }

  /**
   * Reorder tabs via drag and drop
   */
  _reorderTabs(draggedViewId, targetViewId, insertAfter) {
    const set = this.getCurrentSet();
    if (!set) return;

    const draggedIndex = set.views.findIndex(v => v.id === draggedViewId);
    const targetIndex = set.views.findIndex(v => v.id === targetViewId);

    if (draggedIndex === -1 || targetIndex === -1) return;

    const [draggedView] = set.views.splice(draggedIndex, 1);
    let insertIndex = targetIndex;
    if (draggedIndex < targetIndex) insertIndex--;
    if (insertAfter) insertIndex++;

    set.views.splice(insertIndex, 0, draggedView);

    this._renderViewsNav();
    this._saveData();
  }

  /**
   * Rename a tab
   */
  _renameTab(viewId) {
    const set = this.getCurrentSet();
    const view = set?.views.find(v => v.id === viewId);
    if (!view) return;

    const tab = this.elements.tabBarTabs?.querySelector(`[data-view-id="${viewId}"]`);
    if (!tab) return;

    const titleEl = tab.querySelector('.tab-title');
    const currentName = view.name;

    // Create inline input
    const input = document.createElement('input');
    input.type = 'text';
    input.value = currentName;
    input.className = 'tab-rename-input';
    input.style.cssText = `
      flex: 1;
      background: var(--bg-tertiary);
      border: 1px solid var(--primary-500);
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 13px;
      color: var(--text-primary);
      outline: none;
    `;

    titleEl.replaceWith(input);
    input.focus();
    input.select();

    const finishRename = () => {
      const newName = input.value.trim() || currentName;
      view.name = newName;

      const newTitle = document.createElement('span');
      newTitle.className = 'tab-title';
      newTitle.textContent = newName;
      input.replaceWith(newTitle);

      this._renderViewsNav();
      this._saveData();
    };

    input.addEventListener('blur', finishRename);
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        input.blur();
      } else if (e.key === 'Escape') {
        input.value = currentName;
        input.blur();
      }
    });
  }

  /**
   * Check if tabs overflow and show scroll buttons
   */
  _checkTabOverflow() {
    const container = this.elements.tabBarTabs;
    if (!container) return;

    const hasOverflow = container.scrollWidth > container.clientWidth;
    const scrollLeft = this.elements.tabScrollLeft;
    const scrollRight = this.elements.tabScrollRight;

    if (hasOverflow) {
      scrollLeft.style.display = container.scrollLeft > 0 ? 'flex' : 'none';
      scrollRight.style.display =
        container.scrollLeft < container.scrollWidth - container.clientWidth
          ? 'flex'
          : 'none';
    } else {
      scrollLeft.style.display = 'none';
      scrollRight.style.display = 'none';
    }
  }

  /**
   * Scroll tabs in direction
   */
  _scrollTabs(direction) {
    const container = this.elements.tabBarTabs;
    if (!container) return;

    const scrollAmount = 200;
    container.scrollBy({
      left: direction === 'left' ? -scrollAmount : scrollAmount,
      behavior: 'smooth'
    });

    setTimeout(() => this._checkTabOverflow(), 300);
  }

  /**
   * Toggle tab list dropdown
   */
  _toggleTabListDropdown() {
    if (this.tabListDropdownOpen) {
      this._closeTabListDropdown();
    } else {
      this._openTabListDropdown();
    }
  }

  /**
   * Open tab list dropdown
   */
  _openTabListDropdown() {
    this._closeTabListDropdown(); // Remove any existing

    const set = this.getCurrentSet();
    if (!set) return;

    const btn = this.elements.tabListBtn;
    const tabBar = this.elements.tabBar;

    const dropdown = document.createElement('div');
    dropdown.className = 'tab-list-dropdown';
    dropdown.innerHTML = `
      <div class="tab-list-header">
        <h4>Open Tabs</h4>
        <span>${set.views.length} tabs</span>
      </div>
      <div class="tab-list-body">
        <div class="tab-list-section">
          ${set.views.map(view => `
            <div class="tab-list-item ${view.id === this.currentViewId ? 'active' : ''}"
                 data-view-id="${view.id}">
              <div class="tab-list-item-icon">
                <i class="ph ${this._getViewIcon(view.type)}"></i>
              </div>
              <span class="tab-list-item-title">${this._escapeHtml(view.name)}</span>
              ${set.views.length > 1 ? `
                <div class="tab-list-item-toss" data-view-id="${view.id}" title="Toss">
                  <i class="ph ph-arrow-bend-up-right"></i>
                </div>
              ` : ''}
            </div>
          `).join('')}
        </div>
        ${this.tossedItems.length > 0 ? `
          <div class="tab-list-section tossed-pile">
            <div class="tab-list-section-title">
              <i class="ph ph-hand-grabbing"></i>
              Tossed (Pick Up)
            </div>
            ${this.tossedItems.slice(0, 5).map((item, index) => {
              if (item.type === 'view') {
                return `
                  <div class="tab-list-item" data-pickup-index="${index}">
                    <div class="tab-list-item-icon">
                      <i class="ph ${this._getViewIcon(item.view.type)}"></i>
                    </div>
                    <span class="tab-list-item-title">${this._escapeHtml(item.view.name)}</span>
                    <span class="tab-list-item-hint">view</span>
                  </div>
                `;
              } else if (item.type === 'record') {
                const primaryValue = Object.values(item.record.values)[0] || 'Untitled';
                return `
                  <div class="tab-list-item" data-pickup-index="${index}">
                    <div class="tab-list-item-icon">
                      <i class="ph ph-rows"></i>
                    </div>
                    <span class="tab-list-item-title">${this._escapeHtml(String(primaryValue).slice(0, 30))}</span>
                    <span class="tab-list-item-hint">record</span>
                  </div>
                `;
              }
              return '';
            }).join('')}
          </div>
        ` : ''}
      </div>
    `;

    tabBar.appendChild(dropdown);
    this.tabListDropdownOpen = true;

    // Attach handlers
    dropdown.querySelectorAll('.tab-list-item[data-view-id]').forEach(item => {
      item.addEventListener('click', (e) => {
        if (!e.target.closest('.tab-list-item-toss')) {
          this._selectView(item.dataset.viewId);
          this._closeTabListDropdown();
        }
      });
    });

    dropdown.querySelectorAll('.tab-list-item-toss').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        this._tossTab(btn.dataset.viewId);
        // Re-render dropdown
        this._closeTabListDropdown();
        this._openTabListDropdown();
      });
    });

    dropdown.querySelectorAll('.tab-list-item[data-pickup-index]').forEach(item => {
      item.addEventListener('click', () => {
        const index = parseInt(item.dataset.pickupIndex, 10);
        if (index >= 0 && index < this.tossedItems.length) {
          // Use _restoreTossedItem which handles all restore logic and records activity
          this._restoreTossedItem(index);
        }
        this._closeTabListDropdown();
      });
    });
  }

  /**
   * Close tab list dropdown
   */
  _closeTabListDropdown() {
    const dropdown = document.querySelector('.tab-list-dropdown');
    if (dropdown) dropdown.remove();
    this.tabListDropdownOpen = false;
  }

  /**
   * Show tab context menu
   */
  _showTabContextMenu(e, viewId) {
    this._closeTabContextMenu();

    const set = this.getCurrentSet();
    const view = set?.views.find(v => v.id === viewId);
    if (!view) return;

    const viewIndex = set.views.findIndex(v => v.id === viewId);
    const isFirst = viewIndex === 0;
    const isLast = viewIndex === set.views.length - 1;
    const canClose = set.views.length > 1;

    const menu = document.createElement('div');
    menu.className = 'tab-context-menu';
    menu.style.left = `${e.clientX}px`;
    menu.style.top = `${e.clientY}px`;
    menu.innerHTML = `
      <div class="tab-context-item" data-action="duplicate">
        <i class="ph ph-copy"></i>
        <span>Duplicate Tab</span>
      </div>
      <div class="tab-context-item" data-action="rename">
        <i class="ph ph-pencil"></i>
        <span>Rename Tab</span>
      </div>
      <div class="tab-context-separator"></div>
      <div class="tab-context-item ${isFirst ? 'disabled' : ''}" data-action="move-left">
        <i class="ph ph-arrow-left"></i>
        <span>Move Left</span>
      </div>
      <div class="tab-context-item ${isLast ? 'disabled' : ''}" data-action="move-right">
        <i class="ph ph-arrow-right"></i>
        <span>Move Right</span>
      </div>
      <div class="tab-context-separator"></div>
      <div class="tab-context-item ${canClose ? '' : 'disabled'}" data-action="toss">
        <i class="ph ph-arrow-bend-up-right"></i>
        <span>Toss Tab</span>
        <span class="shortcut">Ctrl+W</span>
      </div>
      <div class="tab-context-item ${canClose && set.views.length > 1 ? '' : 'disabled'}" data-action="toss-others">
        <i class="ph ph-arrows-out-line-horizontal"></i>
        <span>Toss Other Tabs</span>
      </div>
      <div class="tab-context-item ${canClose && !isLast ? '' : 'disabled'}" data-action="toss-right">
        <i class="ph ph-arrow-line-right"></i>
        <span>Toss Tabs to the Right</span>
      </div>
      <div class="tab-context-separator"></div>
      <div class="tab-context-item" data-action="toggle-provenance">
        <i class="ph ${view.config.showProvenance ? 'ph-check-square' : 'ph-square'}"></i>
        <span>Show Provenance</span>
      </div>
    `;

    document.body.appendChild(menu);
    this.tabContextMenuOpen = true;

    // Position adjustment if off-screen
    const rect = menu.getBoundingClientRect();
    if (rect.right > window.innerWidth) {
      menu.style.left = `${window.innerWidth - rect.width - 8}px`;
    }
    if (rect.bottom > window.innerHeight) {
      menu.style.top = `${window.innerHeight - rect.height - 8}px`;
    }

    // Attach handlers
    menu.querySelectorAll('.tab-context-item:not(.disabled)').forEach(item => {
      item.addEventListener('click', () => {
        const action = item.dataset.action;
        this._handleTabContextAction(action, viewId);
        this._closeTabContextMenu();
      });
    });
  }

  /**
   * Handle tab context menu action
   */
  _handleTabContextAction(action, viewId) {
    const set = this.getCurrentSet();
    if (!set) return;

    const viewIndex = set.views.findIndex(v => v.id === viewId);
    const view = set.views[viewIndex];

    switch (action) {
      case 'duplicate':
        const dupView = createView(`${view.name} (Copy)`, view.type, { ...view.config });
        set.views.splice(viewIndex + 1, 0, dupView);
        this.currentViewId = dupView.id;
        // Remember this view for the current set
        if (this.currentSetId) {
          this.lastViewPerSet[this.currentSetId] = dupView.id;
        }
        this._renderViewsNav();
        this._renderView();
        this._saveData();
        break;

      case 'rename':
        this._renameTab(viewId);
        break;

      case 'move-left':
        if (viewIndex > 0) {
          [set.views[viewIndex - 1], set.views[viewIndex]] = [set.views[viewIndex], set.views[viewIndex - 1]];
          this._renderViewsNav();
          this._saveData();
        }
        break;

      case 'move-right':
        if (viewIndex < set.views.length - 1) {
          [set.views[viewIndex], set.views[viewIndex + 1]] = [set.views[viewIndex + 1], set.views[viewIndex]];
          this._renderViewsNav();
          this._saveData();
        }
        break;

      case 'toss':
        this._tossTab(viewId);
        break;

      case 'toss-others':
        const viewsToToss = set.views.filter(v => v.id !== viewId);
        viewsToToss.forEach(v => {
          this.tossedItems.unshift({
            type: 'view',
            view: { ...v },
            setId: set.id,
            tossedAt: new Date().toISOString()
          });
        });
        set.views = [view];
        this.currentViewId = viewId;
        // Remember this view for the current set
        if (this.currentSetId) {
          this.lastViewPerSet[this.currentSetId] = viewId;
        }
        this._renderViewsNav();
        this._renderView();
        this._saveData();
        this._showToast(`Tossed ${viewsToToss.length} tabs`, 'info');
        break;

      case 'toss-right':
        const rightViews = set.views.slice(viewIndex + 1);
        rightViews.forEach(v => {
          this.tossedItems.unshift({
            type: 'view',
            view: { ...v },
            setId: set.id,
            tossedAt: new Date().toISOString()
          });
        });
        set.views = set.views.slice(0, viewIndex + 1);
        if (!set.views.find(v => v.id === this.currentViewId)) {
          this.currentViewId = viewId;
          // Remember this view for the current set
          if (this.currentSetId) {
            this.lastViewPerSet[this.currentSetId] = viewId;
          }
        }
        this._renderViewsNav();
        this._renderView();
        this._saveData();
        this._showToast(`Tossed ${rightViews.length} tabs`, 'info');
        break;

      case 'toggle-provenance':
        view.config.showProvenance = !view.config.showProvenance;
        // Record activity for provenance visibility toggle
        this._recordActivity({
          action: 'filter',
          entityType: 'view',
          name: view.name,
          details: `${view.config.showProvenance ? 'Enabled' : 'Disabled'} provenance visibility for view "${view.name}"`,
          canReverse: false
        });
        this._renderView();
        this._saveData();
        this._showToast(view.config.showProvenance ? 'Provenance visible' : 'Provenance hidden', 'info');
        break;
    }
  }

  /**
   * Close tab context menu
   */
  _closeTabContextMenu() {
    const menu = document.querySelector('.tab-context-menu:not(.tab-new-menu)');
    if (menu) menu.remove();
    this.tabContextMenuOpen = false;
  }

  /**
   * Get view type icon class
   */
  _getViewIcon(viewType) {
    const icons = {
      table: 'ph-table',
      cards: 'ph-cards',
      kanban: 'ph-kanban',
      calendar: 'ph-calendar-blank',
      graph: 'ph-graph'
    };
    return icons[viewType] || 'ph-table';
  }

  /**
   * Navigate to next tab
   */
  _nextTab() {
    const set = this.getCurrentSet();
    if (!set || set.views.length <= 1) return;

    const currentIndex = set.views.findIndex(v => v.id === this.currentViewId);
    const nextIndex = (currentIndex + 1) % set.views.length;
    this._selectView(set.views[nextIndex].id);
  }

  /**
   * Navigate to previous tab
   */
  _prevTab() {
    const set = this.getCurrentSet();
    if (!set || set.views.length <= 1) return;

    const currentIndex = set.views.findIndex(v => v.id === this.currentViewId);
    const prevIndex = (currentIndex - 1 + set.views.length) % set.views.length;
    this._selectView(set.views[prevIndex].id);
  }

  /**
   * Toss current tab
   */
  _tossCurrentTab() {
    if (this.currentViewId) {
      this._tossTab(this.currentViewId);
    }
  }

  async _selectSet(setId, panelMode = 'detail') {
    const set = this.sets.find(s => s.id === setId);
    if (!set) return;

    // Clear selection when switching sets to prevent stale selection state
    if (this.currentSetId !== setId) {
      this.selectedRecords.clear();
      this._updateBulkActionsToolbar();
    }

    // Clear search when switching sets
    this.viewSearchTerm = '';
    const searchInput = document.getElementById('view-search-input');
    if (searchInput) searchInput.value = '';

    // CRITICAL: Ensure records are loaded BEFORE any UI updates or saves
    // This prevents data loss from empty records being rendered/saved
    if (set.isVirtual || set._recordsInIndexedDB || set.derivation?.operator === 'relational_merge') {
      await this._ensureSetRecords(set);
    } else if (this._useLazyLoading) {
      // Legacy lazy loading for other sets
      this._loadSetRecords(setId);
    }

    // Build view state based on panel mode
    let viewState = {};
    if (panelMode === 'detail') {
      viewState = { showDetail: true, showFields: false };
    } else if (panelMode === 'fields') {
      viewState = { showDetail: false, showFields: true };
    } else {
      // Use remembered view for this set
      const rememberedViewId = this.lastViewPerSet[setId];
      const rememberedView = rememberedViewId && set?.views.find(v => v.id === rememberedViewId);
      viewState = {
        showDetail: false,
        showFields: false,
        viewId: rememberedView ? rememberedViewId : set?.views[0]?.id
      };
    }

    // Open as a browser tab (records now guaranteed to be loaded)
    this.openTab('set', {
      contentId: setId,
      title: set.name,
      icon: set.icon || 'ph-table',
      viewState: viewState
    });

    this._renderSidebar();
    this._updateBreadcrumb();
    this._saveData();
  }

  /**
   * Select and open a source by its ID
   * Opens the source in a browser tab similar to _selectSet
   */
  _selectSource(sourceId) {
    const source = this.sources?.find(s => s.id === sourceId);
    if (!source) return;

    // Open as a browser tab
    this.openTab('source', {
      contentId: sourceId,
      title: source.name,
      icon: 'ph-file-csv'
    });

    this._renderSidebar();
    this._updateBreadcrumb();
    this._saveData();
  }

  _selectView(viewId) {
    this.currentViewId = viewId;

    // Turn off detail and fields panel mode when selecting a view
    this.showingSetDetail = false;
    this.showingSetFields = false;

    // Clear search when switching views to avoid confusion
    this.viewSearchTerm = '';
    const searchInput = document.getElementById('view-search-input');
    if (searchInput) searchInput.value = '';

    // Remember this view for the current set
    if (this.currentSetId) {
      this.lastViewPerSet[this.currentSetId] = viewId;
    }

    // Update view switcher
    const view = this.getCurrentView();
    document.querySelectorAll('.view-switch-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.view === view?.type);
    });

    this._renderViewsNav();
    this._renderViewDisclosure();
    this._renderView();
    this._updateBreadcrumb();
    this._saveData();
  }

  /**
   * Close a view tab (switch away from it without removing it from the set)
   */
  _closeView(viewId) {
    const set = this.getCurrentSet();
    if (!set || set.views.length <= 1) {
      // Can't close the last tab - nothing to switch to
      return;
    }

    const viewIndex = set.views.findIndex(v => v.id === viewId);
    if (viewIndex === -1) return;

    // Only need to switch if closing the current view
    if (this.currentViewId === viewId) {
      // Switch to adjacent tab (prefer next, fallback to previous)
      const newIndex = viewIndex < set.views.length - 1 ? viewIndex + 1 : viewIndex - 1;
      this._selectView(set.views[newIndex].id);
    }
  }

  /**
   * Move a view tab to a new position within the current set
   */
  _moveView(viewId, newIndex) {
    const set = this.getCurrentSet();
    if (!set) return;

    const currentIndex = set.views.findIndex(v => v.id === viewId);
    if (currentIndex === -1) return;

    // Don't move if already at the target position
    if (currentIndex === newIndex) return;

    // Adjust for removal when moving forward
    if (currentIndex < newIndex) {
      newIndex--;
    }

    // Move the view
    const [view] = set.views.splice(currentIndex, 1);
    set.views.splice(newIndex, 0, view);

    // Re-render and save
    this._injectViewTabsHeader();
    this._saveData();
  }

  _switchViewType(viewType) {
    const set = this.getCurrentSet();
    if (!set) return;

    // Find or create a view of this type
    let view = set.views.find(v => v.type === viewType);
    if (!view) {
      view = createView(`${viewType.charAt(0).toUpperCase() + viewType.slice(1)} View`, viewType);
      set.views.push(view);
      this._renderViewsNav();
    }

    this.currentViewId = view.id;

    // Clear search when switching view types to avoid confusion
    this.viewSearchTerm = '';
    const searchInputSwitchType = document.getElementById('view-search-input');
    if (searchInputSwitchType) searchInputSwitchType.value = '';

    // Remember this view for the current set
    if (this.currentSetId) {
      this.lastViewPerSet[this.currentSetId] = view.id;
    }

    // Update view switcher buttons
    document.querySelectorAll('.view-switch-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.view === viewType);
    });

    this._renderViewDisclosure();
    this._renderView();
    this._updateBreadcrumb();
    this._saveData();
  }

  _updateBreadcrumb() {
    const project = this.projects?.find(p => p.id === this.currentProjectId);
    const workspace = this.viewRegistry?.getWorkspace?.(this.currentWorkspaceId);
    const set = this.getCurrentSet();
    const view = this.getCurrentView();
    const focus = this.viewRegistry?.getFocus?.(this.currentFocusId);

    // Calculate restriction ratio for EO Rule 5 visibility
    const totalRecords = set?.records?.length || 0;
    const visibleRecords = focus ? this._getFilteredRecordCount(focus) : totalRecords;
    const restrictionRatio = totalRecords > 0 ? `${visibleRecords} of ${totalRecords}` : '';

    // Project breadcrumb - CLICKABLE (switch projects)
    const projectBreadcrumb = document.getElementById('current-project-name');
    const projectSeparator = document.querySelector('.breadcrumb-separator.project-separator');
    if (projectBreadcrumb) {
      if (project) {
        projectBreadcrumb.innerHTML = `
          <span class="project-color-dot" style="background-color: ${project.color || '#3B82F6'}; width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 4px;"></span>
          <i class="ph ${project.icon || 'ph-folder-simple-dashed'}"></i>
          ${this._escapeHtml(project.name)}
          <i class="ph ph-caret-down breadcrumb-dropdown-icon"></i>
        `;
      } else {
        projectBreadcrumb.innerHTML = `
          <i class="ph ph-stack"></i>
          All Items
          <i class="ph ph-caret-down breadcrumb-dropdown-icon"></i>
        `;
      }
      projectBreadcrumb.classList.add('breadcrumb-clickable');
      projectBreadcrumb.onclick = () => this._showProjectBreadcrumbMenu(projectBreadcrumb);
    }

    // Source breadcrumb - CLICKABLE - Shows source in data-flow chain (GIVEN)
    const sourceBreadcrumb = document.getElementById('current-source-name');
    const sourceSeparator = document.querySelector('.breadcrumb-separator.source-separator');
    if (sourceBreadcrumb && sourceSeparator) {
      // Get source from current selection or from set provenance
      const currentSource = this.sources?.find(s => s.id === this.currentSourceId);
      const setProvenance = set?.datasetProvenance;
      const sourceFromProvenance = setProvenance?.sourceId ?
        this.sources?.find(s => s.id === setProvenance.sourceId) : null;
      const effectiveSource = currentSource || sourceFromProvenance;

      if (effectiveSource || this.currentSourceId) {
        const sourceName = effectiveSource?.name ||
          setProvenance?.originalFilename ||
          'Source';
        sourceBreadcrumb.innerHTML = `
          <span class="breadcrumb-epistemic-dot given-dot"></span>
          <i class="ph ph-download-simple"></i>
          <span class="breadcrumb-source-text">${this._escapeHtml(this._truncateName(sourceName, 15))}</span>
          <i class="ph ph-caret-down breadcrumb-dropdown-icon"></i>
        `;
        sourceBreadcrumb.style.display = 'inline-flex';
        sourceSeparator.style.display = '';
        sourceBreadcrumb.classList.add('breadcrumb-clickable');
        sourceBreadcrumb.onclick = () => this._showSourceBreadcrumbMenu(sourceBreadcrumb);
      } else {
        sourceBreadcrumb.style.display = 'none';
        sourceSeparator.style.display = 'none';
      }
    }

    // Set breadcrumb - CLICKABLE (shows sibling sets) - SCHEMA
    if (this.elements.currentSetName) {
      const provenanceIcon = this._getProvenanceStatusIcon(set);
      this.elements.currentSetName.innerHTML = `
        <span class="breadcrumb-epistemic-dot schema-dot"></span>
        <span class="breadcrumb-provenance-icon" title="Provenance: ${this._getProvenanceTooltip(set)}">${provenanceIcon}</span>
        ${this._escapeHtml(set?.name || 'No Set')}
        <i class="ph ph-caret-down breadcrumb-dropdown-icon"></i>
      `;
      this.elements.currentSetName.classList.add('breadcrumb-clickable');
      this.elements.currentSetName.onclick = () => this._showSetBreadcrumbMenu(this.elements.currentSetName);
    }

    // View/Lens breadcrumb - CLICKABLE (shows sibling lenses)
    if (this.elements.currentViewName) {
      // Show "Detail" when viewing the detail panel
      if (this.showingSetDetail) {
        this.elements.currentViewName.innerHTML = `
          <i class="ph ph-flow-arrow"></i>
          Detail
          <i class="ph ph-caret-down breadcrumb-dropdown-icon"></i>
        `;
      // Show "Fields" when viewing the fields panel
      } else if (this.showingSetFields) {
        this.elements.currentViewName.innerHTML = `
          <i class="ph ph-columns"></i>
          Fields
          <i class="ph ph-caret-down breadcrumb-dropdown-icon"></i>
        `;
      } else {
        const epistemicBadge = this._getEpistemicStatusBadge(view);
        this.elements.currentViewName.innerHTML = `
          <i class="ph ${this._getLensIcon(view?.type)}"></i>
          ${this._escapeHtml(view?.name || 'No Lens')}
          ${epistemicBadge}
          <i class="ph ph-caret-down breadcrumb-dropdown-icon"></i>
        `;
      }
      this.elements.currentViewName.classList.add('breadcrumb-clickable');
      this.elements.currentViewName.onclick = () => this._showLensBreadcrumbMenu(this.elements.currentViewName);
    }

    // Focus breadcrumb (only show if a focus is active) - shows RESTRICTION RATIO (Rule 5)
    const focusBreadcrumb = document.getElementById('current-focus-name');
    if (focusBreadcrumb) {
      if (focus) {
        focusBreadcrumb.innerHTML = `
          <i class="ph ph-caret-right"></i>
          <i class="ph ph-funnel"></i>
          ${this._escapeHtml(focus.name)}
          <span class="breadcrumb-restriction-ratio" title="Rule 5: Focus restricts to ${restrictionRatio}">(${restrictionRatio})</span>
          <button class="breadcrumb-clear" title="Clear focus (expand horizon)" onclick="getDataWorkbench()?._clearFocus()">
            <i class="ph ph-x"></i>
          </button>
        `;
        focusBreadcrumb.style.display = 'inline-flex';
      } else {
        focusBreadcrumb.style.display = 'none';
      }
    }

    // Update the architecture chain header (SOURCE → SET → LENS → VIEW)
    this._updateArchitectureChain();
  }

  /**
   * Get filtered record count for a focus (Rule 5 restriction calculation)
   */
  _getFilteredRecordCount(focus) {
    const set = this.getCurrentSet();
    return this._getFilteredRecordCountForFocus(focus, set);
  }

  /**
   * Get filtered record count for a focus with explicit set (Rule 5)
   */
  _getFilteredRecordCountForFocus(focus, set) {
    if (!set || !focus?.restrictions?.filters) return set?.records?.length || 0;

    let records = set.records || [];
    for (const filter of focus.restrictions.filters) {
      records = records.filter(r => this._matchesFilter(r, filter));
    }
    return records.length;
  }

  /**
   * Get provenance status icon (◉ full, ◐ partial, ○ none)
   */
  _getProvenanceStatusIcon(set) {
    if (!set) return '○';
    const prov = set.datasetProvenance;
    if (!prov) return '○';

    // Count filled provenance elements
    let filled = 0;
    if (prov.originalFilename) filled++;
    if (prov.importedAt) filled++;
    if (this._getProvenanceValue(prov.provenance?.agent)) filled++;
    if (this._getProvenanceValue(prov.provenance?.method)) filled++;
    if (this._getProvenanceValue(prov.provenance?.source)) filled++;

    if (filled >= 4) return '◉'; // Full provenance
    if (filled >= 1) return '◐'; // Partial provenance
    return '○'; // No provenance
  }

  /**
   * Update the architecture chain header (SOURCE → SET → LENS → VIEW)
   * This makes the data derivation chain visible at all times
   */
  _updateArchitectureChain() {
    const set = this.getCurrentSet();
    const view = this.getCurrentView();
    const lens = this.viewRegistry?.getLens?.(this.currentLensId);

    // Get source info from set provenance
    const prov = set?.datasetProvenance;
    const sourceName = prov?.originalFilename || this._getProvenanceValue(prov?.provenance?.source) || 'Manual Entry';
    const isNullSource = !prov?.originalFilename && !this._getProvenanceValue(prov?.provenance?.source);

    // Update chain steps
    const sourceStep = document.getElementById('chain-step-source');
    const setStep = document.getElementById('chain-step-set');
    const lensStep = document.getElementById('chain-step-lens');
    const viewStep = document.getElementById('chain-step-view');

    // Source step
    if (sourceStep) {
      const sourceNameEl = document.getElementById('chain-source-name');
      if (sourceNameEl) {
        sourceNameEl.textContent = isNullSource ? 'Manual Entry' : this._escapeHtml(this._truncate(sourceName, 20));
      }
      sourceStep.classList.toggle('active', this.currentSourceId !== null);
      sourceStep.title = isNullSource
        ? 'Source: Manual Entry (Null Source)\nAll rows added here become immutable history.'
        : `Source: ${sourceName}`;
    }

    // Set step
    if (setStep) {
      const setNameEl = document.getElementById('chain-set-name');
      if (setNameEl) {
        setNameEl.textContent = set ? this._escapeHtml(this._truncate(set.name, 20)) : 'No Set';
      }
      setStep.classList.toggle('active', set !== null && !this.currentViewId);
      setStep.title = set ? `Set: ${set.name}\n${set.records?.length || 0} records` : 'No set selected';
    }

    // Lens step
    if (lensStep) {
      const lensNameEl = document.getElementById('chain-lens-name');
      if (lensNameEl) {
        lensNameEl.textContent = lens ? this._escapeHtml(this._truncate(lens.name, 20)) : 'All Records';
      }
      lensStep.classList.toggle('active', lens !== null);
      lensStep.title = lens ? `Lens: ${lens.name}\nFilters applied to restrict view` : 'All Records (no filter)';
    }

    // View step
    if (viewStep) {
      const viewNameEl = document.getElementById('chain-view-name');
      if (viewNameEl) {
        let viewDisplayName = 'Grid';
        if (this.showingSetDetail) {
          viewDisplayName = 'Detail';
        } else if (this.showingSetFields) {
          viewDisplayName = 'Schema';
        } else if (view) {
          viewDisplayName = view.name || view.type;
        }
        viewNameEl.textContent = this._escapeHtml(this._truncate(viewDisplayName, 20));
      }
      viewStep.classList.toggle('active', this.currentViewId !== null || this.showingSetDetail || this.showingSetFields);
      viewStep.title = 'View: Where work happens\nAll edits tracked back to source';
    }

    // Update mini-map as well
    this._updateArchitectureMinimap();
  }

  /**
   * Update the architecture mini-map to reflect current navigation layer
   */
  _updateArchitectureMinimap() {
    const set = this.getCurrentSet();
    const view = this.getCurrentView();
    const lens = this.viewRegistry?.getLens?.(this.currentLensId);

    // Determine current layer
    let currentLayer = 'view'; // default

    if (this.currentSourceId) {
      currentLayer = 'source';
    } else if (this.currentLensId && !this.currentViewId) {
      currentLayer = 'lens';
    } else if (this.currentSetId && !this.currentViewId && !this.showingSetDetail && !this.showingSetFields) {
      currentLayer = 'set';
    }

    // Update minimap items
    const layers = ['source', 'set', 'lens', 'view'];
    layers.forEach(layer => {
      const el = document.getElementById(`minimap-${layer}`);
      if (el) {
        el.classList.toggle('active', layer === currentLayer);
      }
    });
  }

  /**
   * Helper to truncate text
   */
  _truncate(text, maxLength) {
    if (!text) return '';
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength - 1) + '…';
  }

  /**
   * Format a field value for display (handles SELECT/MULTI_SELECT by looking up choice names)
   * @param {*} value - The raw value
   * @param {Object} field - The field definition
   * @param {number} maxLength - Maximum length before truncation
   * @returns {string} - Formatted display value
   */
  _formatFieldValueForDisplay(value, field, maxLength = 100) {
    if (value === null || value === undefined || value === '') {
      return 'Empty';
    }

    if (!field) {
      return this._truncate(String(value), maxLength);
    }

    switch (field.type) {
      case FieldTypes.SELECT:
        const choice = field.options?.choices?.find(c => c.id === value);
        return choice ? choice.name : String(value);

      case FieldTypes.MULTI_SELECT:
        if (Array.isArray(value)) {
          const names = value.map(v => {
            const c = field.options?.choices?.find(ch => ch.id === v);
            return c ? c.name : String(v);
          });
          return names.join(', ');
        }
        return String(value);

      case FieldTypes.CHECKBOX:
        return value ? 'Yes' : 'No';

      case FieldTypes.DATE:
        return this._formatDate(value, field) || String(value);

      default:
        if (typeof value === 'object') {
          return this._truncate(JSON.stringify(value), maxLength);
        }
        return this._truncate(String(value), maxLength);
    }
  }

  /**
   * Get provenance tooltip text
   */
  _getProvenanceTooltip(set) {
    if (!set?.datasetProvenance) return 'No provenance (MEANT without GIVEN chain)';
    const prov = set.datasetProvenance;
    const parts = [];
    if (prov.originalFilename) parts.push(`Source: ${prov.originalFilename}`);
    if (prov.importedAt) parts.push(`Imported: ${new Date(prov.importedAt).toLocaleDateString()}`);
    const methodValue = this._getProvenanceValue(prov.provenance?.method);
    if (methodValue) parts.push(`Method: ${methodValue}`);
    const agentValue = this._getProvenanceValue(prov.provenance?.agent);
    if (agentValue) parts.push(`Agent: ${agentValue}`);
    return parts.join(' | ') || 'Partial provenance';
  }

  /**
   * Get epistemic status badge for view (Rule 8)
   */
  _getEpistemicStatusBadge(view) {
    const status = view?.epistemicStatus || 'preliminary';
    const badges = {
      'preliminary': '<span class="epistemic-badge preliminary" title="Preliminary interpretation">○</span>',
      'reviewed': '<span class="epistemic-badge reviewed" title="Reviewed interpretation">✓</span>',
      'contested': '<span class="epistemic-badge contested" title="Contested interpretation">⚠</span>',
      'superseded': '<span class="epistemic-badge superseded" title="Superseded (see newer version)">⊘</span>'
    };
    return badges[status] || badges['preliminary'];
  }

  /**
   * Show project breadcrumb dropdown menu (switch projects)
   */
  _showProjectBreadcrumbMenu(element) {
    const projects = (this.projects || []).filter(p => p.status !== 'archived');

    // Build items list with "All Items" at the top
    const items = [
      {
        id: null,
        name: 'All Items',
        icon: 'ph-stack',
        active: !this.currentProjectId,
        onClick: () => this._selectProject(null)
      },
      ...projects.map(p => ({
        id: p.id,
        name: p.name,
        icon: p.icon || 'ph-folder-simple-dashed',
        color: p.color,
        active: p.id === this.currentProjectId,
        onClick: () => this._selectProject(p.id)
      }))
    ];

    this._showBreadcrumbDropdown(element, items, 'Projects');
  }

  /**
   * Show workspace breadcrumb dropdown menu (sibling workspaces)
   */
  _showWorkspaceBreadcrumbMenu(element) {
    const workspaces = this.viewRegistry?.getAllWorkspaces?.() || [];
    this._showBreadcrumbDropdown(element, workspaces.map(ws => ({
      id: ws.id,
      name: ws.name,
      icon: ws.icon || 'ph-folder-simple',
      active: ws.id === this.currentWorkspaceId,
      onClick: () => this._selectWorkspace(ws.id)
    })), 'Workspaces (Horizons)');
  }

  /**
   * Show set breadcrumb dropdown menu (sibling sets)
   */
  /**
   * Show source breadcrumb dropdown menu (available sources)
   */
  _showSourceBreadcrumbMenu(element) {
    const sources = (this.sources || []).filter(s => s.status !== 'archived');
    this._showBreadcrumbDropdown(element, sources.map(s => ({
      id: s.id,
      name: s.name,
      icon: 'ph-file-text',
      badge: `<span class="epistemic-mini-badge given-mini">GIVEN</span>`,
      active: s.id === this.currentSourceId,
      onClick: () => this._selectSource(s.id)
    })), 'Sources (GIVEN)');
  }

  _showSetBreadcrumbMenu(element) {
    const sets = this.sets || [];
    this._showBreadcrumbDropdown(element, sets.map(s => ({
      id: s.id,
      name: s.name,
      icon: s.icon || 'ph-table',
      badge: this._getProvenanceStatusIcon(s),
      active: s.id === this.currentSetId,
      onClick: () => {
        // Special handling for Definitions set - open definitions panel
        if (s.id === 'set_definitions') {
          this._showDefinitionsPanel();
        } else {
          this._selectSet(s.id);
        }
      }
    })), 'Sets (Data Collections)');
  }

  /**
   * Show lens breadcrumb dropdown menu (sibling lenses)
   */
  _showLensBreadcrumbMenu(element) {
    const set = this.getCurrentSet();
    const views = set?.views || [];
    this._showBreadcrumbDropdown(element, views.map(v => ({
      id: v.id,
      name: v.name,
      icon: this._getLensIcon(v.type),
      badge: this._getEpistemicStatusBadge(v),
      active: v.id === this.currentViewId,
      onClick: () => this._selectView(v.id)
    })), 'Lenses (Interpretations)');
  }

  /**
   * Show breadcrumb dropdown menu
   */
  _showBreadcrumbDropdown(anchor, items, title) {
    // Remove existing dropdown
    document.querySelector('.breadcrumb-dropdown')?.remove();

    const rect = anchor.getBoundingClientRect();
    const dropdown = document.createElement('div');
    dropdown.className = 'breadcrumb-dropdown';
    dropdown.innerHTML = `
      <div class="breadcrumb-dropdown-header">${title}</div>
      ${items.map(item => `
        <div class="breadcrumb-dropdown-item ${item.active ? 'active' : ''}" data-id="${item.id}">
          <i class="ph ${item.icon}"></i>
          <span>${this._escapeHtml(item.name)}</span>
          ${item.badge ? `<span class="breadcrumb-dropdown-badge">${item.badge}</span>` : ''}
        </div>
      `).join('')}
    `;
    dropdown.style.top = `${rect.bottom + 4}px`;
    dropdown.style.left = `${rect.left}px`;
    document.body.appendChild(dropdown);

    // Attach click handlers
    items.forEach((item, idx) => {
      dropdown.querySelectorAll('.breadcrumb-dropdown-item')[idx]?.addEventListener('click', () => {
        item.onClick();
        dropdown.remove();
      });
    });

    // Close on outside click
    const closeHandler = (e) => {
      if (!dropdown.contains(e.target) && !anchor.contains(e.target)) {
        dropdown.remove();
        document.removeEventListener('click', closeHandler);
      }
    };
    setTimeout(() => document.addEventListener('click', closeHandler), 0);
  }

  /**
   * Log navigation activity with EO operator (Rule 6, 7)
   */
  _logNavigationActivity(operator, targetType, targetId) {
    if (!this.navigationLog) this.navigationLog = [];

    const operators = {
      'SEG': '｜', // Segment: restrict scope
      'ALT': '∿', // Alternate: switch interpretation
      'DES': '⊡', // Designate: reveal/name
      'NUL': '∅'  // Recognition: search
    };

    this.navigationLog.push({
      timestamp: new Date().toISOString(),
      operator: operator,
      operatorSymbol: operators[operator] || operator,
      targetType: targetType,
      targetId: targetId,
      context: {
        workspaceId: this.currentWorkspaceId,
        setId: this.currentSetId,
        viewId: this.currentViewId,
        focusId: this.currentFocusId
      }
    });

    // Keep last 50 navigation actions
    if (this.navigationLog.length > 50) {
      this.navigationLog = this.navigationLog.slice(-50);
    }
  }

  /**
   * Get icon for lens type
   */
  _getLensIcon(viewType) {
    const icons = {
      'table': 'ph-table',
      'grid': 'ph-table',
      'cards': 'ph-cards',
      'kanban': 'ph-kanban',
      'calendar': 'ph-calendar-blank',
      'graph': 'ph-graph',
      'timeline': 'ph-timeline'
    };
    return icons[viewType] || 'ph-table';
  }

  // --------------------------------------------------------------------------
  // View Rendering
  // --------------------------------------------------------------------------

  /**
   * Update work zone banner to indicate if this is a structural layer or editable view
   * Only shows banner text when switching between layer types (given/meant)
   */
  _updateWorkZoneBanner() {
    // Find or create the work zone banner
    let banner = document.getElementById('work-zone-banner');
    const contentArea = this.elements.contentArea;

    if (!contentArea) return;

    // Create banner if it doesn't exist
    if (!banner) {
      banner = document.createElement('div');
      banner.id = 'work-zone-banner';
      banner.className = 'work-zone-banner';
      contentArea.parentNode.insertBefore(banner, contentArea);
    }

    // Determine the current layer type
    let currentLayerType = null;
    if (this.currentSourceId || this.showingSetFields || this.showingSetDetail) {
      currentLayerType = 'given';
    } else if (this.currentViewId) {
      currentLayerType = 'meant';
    }

    // Check if we're switching between layer types
    const isLayerSwitch = this._previousLayerType !== null &&
                          currentLayerType !== null &&
                          this._previousLayerType !== currentLayerType;

    // Clear any existing timeout
    if (this._layerSwitchBannerTimeout) {
      clearTimeout(this._layerSwitchBannerTimeout);
      this._layerSwitchBannerTimeout = null;
    }

    // Only show banner on layer type switches
    if (isLayerSwitch) {
      if (currentLayerType === 'given') {
        // Switching TO structural layer (GIVEN)
        banner.className = 'work-zone-banner structural';
        if (this.currentSourceId) {
          banner.innerHTML = `
            <i class="ph ph-lock-simple"></i>
            <span><strong>Source View</strong> — This is GIVEN data. You cannot edit source records here.</span>
            <button class="work-zone-action" onclick="getDataWorkbench()?._showSetFromSourceUI('${this.currentSourceId}')">
              Create Set from Source
            </button>
          `;
        } else if (this.showingSetFields) {
          banner.innerHTML = `
            <i class="ph ph-blueprint"></i>
            <span><strong>Schema View</strong> — Structure is GIVEN, Meaning is MEANT. Configure field definitions.</span>
          `;
        } else if (this.showingSetDetail) {
          banner.innerHTML = `
            <i class="ph ph-flow-arrow"></i>
            <span><strong>Set Overview</strong> — This shows the data flow. Open a View to work with records.</span>
            <button class="work-zone-action" onclick="getDataWorkbench()?._selectView(getDataWorkbench()?.getCurrentSet()?.views[0]?.id)">
              Open Default View
            </button>
          `;
        }
        banner.style.display = 'flex';
      } else if (currentLayerType === 'meant') {
        // Switching TO editable layer (MEANT)
        banner.className = 'work-zone-banner editable';
        banner.innerHTML = `
          <i class="ph ph-pencil-simple"></i>
          <span><strong>View</strong> — You are editing live data. All changes are tracked back to the Source.</span>
        `;
        banner.style.display = 'flex';
      }

      // Auto-hide after 3 seconds
      this._layerSwitchBannerTimeout = setTimeout(() => {
        banner.style.display = 'none';
      }, 3000);
    } else {
      // No layer switch, hide banner
      banner.style.display = 'none';
    }

    // Update previous layer type for next comparison
    this._previousLayerType = currentLayerType;
  }

  _renderView() {
    // Update work zone banner
    this._updateWorkZoneBanner();

    // If showing set detail view (Input → Transformation → Output)
    if (this.showingSetDetail && this.currentSetId) {
      this._renderSetDetailView();
      return;
    }

    // If showing set fields panel (like Airtable's "Manage Fields")
    if (this.showingSetFields && this.currentSetId) {
      this._renderSetFieldsPanel();
      return;
    }

    const view = this.getCurrentView();
    if (!view) {
      this._renderEmptyState();
      return;
    }

    // Reset displayed record count when switching views
    // Use smaller initial batch for faster first paint
    this.displayedRecordCount = this.initialBatchSize;

    // Check if we need to show loading for large datasets
    const records = this.getFilteredRecords();
    const needsLoading = records.length > this.loadingThreshold;

    if (needsLoading) {
      this._showLoadingOverlay('Loading view...', {
        showProgress: records.length > 200,
        progress: 0,
        progressText: `Preparing ${records.length.toLocaleString()} records...`
      });

      // Use requestAnimationFrame to allow the loading UI to render
      requestAnimationFrame(() => {
        this._doRenderView(view);
        this._hideLoadingOverlay();
        this._updateStatus();
      });
    } else {
      this._doRenderView(view);
      this._updateStatus();
    }
  }

  /**
   * Actually perform the view rendering (called after loading indicator is shown)
   */
  _doRenderView(view) {
    switch (view.type) {
      case 'table':
        this._renderTableView();
        break;
      case 'cards':
        this._renderCardsView();
        break;
      case 'kanban':
        this._renderKanbanView();
        break;
      case 'calendar':
        this._renderCalendarView();
        break;
      case 'graph':
        this._renderGraphView();
        break;
      case 'pipeline':
        this._renderPipelineView();
        break;
      case 'flow':
        this._renderFlowView();
        break;
      case 'filesystem':
        this._renderFilesystemView();
        break;
      default:
        this._renderTableView();
    }

    // Inject view tabs header at the top of the content area
    this._injectViewTabsHeader();

    // Refresh detail panel if it's open to keep it in sync with the view
    if (this.currentDetailRecordId && this.elements.detailPanel?.classList.contains('open')) {
      this._showRecordDetail(this.currentDetailRecordId);
    }
  }

  /**
   * Render the Set Detail View (Input → Transformation → Output)
   * Now uses a tabbed interface where each panel is a closeable tab
   */
  _renderSetDetailView() {
    const set = this.getCurrentSet();
    if (!set) {
      this._renderEmptyState();
      return;
    }

    const content = this.elements.contentArea;
    if (!content) return;

    const fields = set.fields || [];
    const records = set.records || [];
    const views = set.views || [];
    const derivation = this._getSetDerivationInfo(set);
    const prov = set.datasetProvenance || {};

    // Format last updated time
    const lastUpdated = prov.importedAt || prov.createdAt || set.createdAt;
    const lastUpdatedDisplay = lastUpdated ? this._formatRelativeTime(lastUpdated) : 'Unknown';

    content.innerHTML = `
      <div class="set-dashboard tabbed">
        <!-- Header -->
        <div class="set-dashboard-header">
          <div class="set-dashboard-title-section">
            <div class="set-dashboard-title-row">
              <i class="${set.icon || 'ph ph-table'}"></i>
              <h2>${this._escapeHtml(set.name)}</h2>
              ${derivation.badge}
            </div>
            <div class="set-dashboard-meta">
              <span class="set-dashboard-meta-item">
                <i class="ph ph-rows"></i>
                ${records.length.toLocaleString()} records
              </span>
              <span class="set-dashboard-meta-divider"></span>
              <span class="set-dashboard-meta-item">
                <i class="ph ph-columns"></i>
                ${fields.length} fields
              </span>
              <span class="set-dashboard-meta-divider"></span>
              <span class="set-dashboard-meta-item">
                <i class="ph ph-eye"></i>
                ${views.length} views
              </span>
              <span class="set-dashboard-meta-divider"></span>
              <span class="set-dashboard-meta-item">
                <i class="ph ph-clock"></i>
                Updated ${lastUpdatedDisplay}
              </span>
            </div>
          </div>
          <div class="set-dashboard-actions">
            <button class="set-dashboard-action-btn" id="set-dashboard-export-btn">
              <i class="ph ph-export"></i> Export
            </button>
            <button class="set-dashboard-action-btn" id="set-dashboard-edit-btn">
              <i class="ph ph-pencil-simple"></i> Edit
            </button>
            <button class="set-dashboard-action-btn danger" id="set-dashboard-delete-btn">
              <i class="ph ph-trash"></i> Delete
            </button>
          </div>
        </div>

        <!-- Panel Tab Bar -->
        <div class="panel-tab-bar" id="panel-tab-bar">
          <!-- Tabs rendered dynamically -->
        </div>

        <!-- Panel Tab Content -->
        <div class="panel-tab-content" id="panel-tab-content">
          <!-- Content rendered dynamically -->
        </div>
      </div>
    `;

    // Attach header event handlers
    this._attachSetDashboardHeaderHandlers(set);

    // Initialize panel tabs if none are open
    if (this.panelTabs.length === 0) {
      // Open default tabs: Overview and Source
      this._openPanelTab('overview');
      this._openPanelTab('source');
    } else {
      // Just render the existing tabs
      this._renderPanelTabs();
      this._renderPanelTabContent();
    }
  }

  /**
   * Attach event handlers for set dashboard header only
   */
  _attachSetDashboardHeaderHandlers(set) {
    // Export button
    document.getElementById('set-dashboard-export-btn')?.addEventListener('click', () => {
      this._showExportDialog(set.id);
    });

    // Edit button - go to fields
    document.getElementById('set-dashboard-edit-btn')?.addEventListener('click', () => {
      this._selectSet(set.id, 'schema');
    });

    // Delete button
    document.getElementById('set-dashboard-delete-btn')?.addEventListener('click', () => {
      this._confirmDeleteSet(set.id);
    });
  }

  /**
   * Calculate field statistics for dashboard display
   */
  _calculateFieldStats(set) {
    const fields = set.fields || [];
    const records = set.records || [];
    const totalRecords = records.length;

    return fields.map(field => {
      let filledCount = 0;
      records.forEach(r => {
        const val = r.values?.[field.id];
        if (val !== null && val !== undefined && val !== '') {
          filledCount++;
        }
      });

      return {
        id: field.id,
        name: field.name,
        type: field.type || 'text',
        completeness: totalRecords > 0 ? Math.round((filledCount / totalRecords) * 100) : 0
      };
    });
  }

  /**
   * Calculate overall set completeness
   */
  _calculateSetCompleteness(set) {
    const fields = set.fields || [];
    const records = set.records || [];
    const totalCells = fields.length * records.length;

    if (totalCells === 0) return 100;

    let filledCells = 0;
    records.forEach(r => {
      fields.forEach(f => {
        const val = r.values?.[f.id];
        if (val !== null && val !== undefined && val !== '') {
          filledCells++;
        }
      });
    });

    return Math.round((filledCells / totalCells) * 100);
  }

  /**
   * Get the count of records that match a lens's filter criteria
   */
  _getLensRecordCount(set, lens) {
    if (!set || !lens) return 0;
    const records = set.records || [];
    const pivotFieldId = lens.pivotFieldId;
    const pivotValue = lens.pivotValue;

    return records.filter(r => {
      const val = r.values?.[pivotFieldId];
      if (Array.isArray(val)) {
        return val.includes(pivotValue);
      }
      return val === pivotValue;
    }).length;
  }

  /**
   * Get source display info
   */
  _getSourceDisplayInfo(set) {
    const prov = set.datasetProvenance || {};
    let type = '';

    if (prov.originalFilename) {
      const ext = prov.originalFilename.split('.').pop()?.toUpperCase();
      if (ext) type = ext;
    } else if (prov.createdVia) {
      type = prov.createdVia.toUpperCase();
    }

    return { type };
  }

  /**
   * Format relative time
   */
  _formatRelativeTime(timestamp) {
    if (!timestamp) return 'Unknown';

    const date = typeof timestamp === 'string' ? new Date(timestamp) : new Date(timestamp);
    const now = new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);

    if (diffMins < 1) return 'just now';
    if (diffMins < 60) return `${diffMins} min ago`;
    if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
    if (diffDays < 7) return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;

    return date.toLocaleDateString();
  }

  /**
   * Get icon for field type
   */
  _getFieldTypeIcon(type) {
    const icons = {
      text: 'ph-text-aa',
      number: 'ph-hash',
      date: 'ph-calendar',
      datetime: 'ph-calendar',
      checkbox: 'ph-check-square',
      select: 'ph-list',
      multiselect: 'ph-list-checks',
      email: 'ph-envelope',
      url: 'ph-link',
      phone: 'ph-phone',
      currency: 'ph-currency-dollar',
      percent: 'ph-percent',
      rating: 'ph-star',
      user: 'ph-user',
      attachment: 'ph-paperclip',
      formula: 'ph-function',
      rollup: 'ph-arrows-in',
      count: 'ph-hash',
      lookup: 'ph-magnifying-glass',
      link: 'ph-link-simple',
      autonumber: 'ph-number-circle-one',
      barcode: 'ph-barcode',
      button: 'ph-cursor-click'
    };
    return icons[type] || 'ph-text-aa';
  }

  /**
   * Attach event handlers for set dashboard view
   */
  _attachSetDashboardEventHandlers(set, recordTypeAnalysis) {
    // Export button
    document.getElementById('set-dashboard-export-btn')?.addEventListener('click', () => {
      this._showExportDialog(set.id);
    });

    // Edit button - go to fields
    document.getElementById('set-dashboard-edit-btn')?.addEventListener('click', () => {
      this._selectSet(set.id, 'schema');
    });

    // Delete button
    document.getElementById('set-dashboard-delete-btn')?.addEventListener('click', () => {
      this._confirmDeleteSet(set.id);
    });

    // View fields links
    document.getElementById('set-dashboard-view-fields')?.addEventListener('click', () => {
      this._selectSet(set.id, 'schema');
    });

    document.getElementById('set-dashboard-manage-fields')?.addEventListener('click', () => {
      this._selectSet(set.id, 'schema');
    });

    document.getElementById('set-dashboard-show-all-fields')?.addEventListener('click', () => {
      this._selectSet(set.id, 'schema');
    });

    // Add source button - show modal to add/merge another source into this set
    document.getElementById('set-dashboard-add-source')?.addEventListener('click', () => {
      this._showAddSourceToSetModal(set.id);
    });

    // Export now button
    document.getElementById('set-dashboard-export-now')?.addEventListener('click', () => {
      this._showExportDialog(set.id);
    });

    // Create lens button
    document.getElementById('set-dashboard-create-derived')?.addEventListener('click', () => {
      this._showLensCreationFlow();
    });

    // Source item clicks
    document.querySelectorAll('.set-dashboard-source-item').forEach(item => {
      item.addEventListener('click', () => {
        const sourceId = item.dataset.sourceId;
        const setId = item.dataset.setId;

        if (sourceId && this.sources?.find(s => s.id === sourceId)) {
          this._selectSource(sourceId);
        } else if (setId && this.sets?.find(s => s.id === setId)) {
          this._selectSet(setId, 'detail');
        }
      });
    });

    // Derived set clicks
    document.querySelectorAll('.set-dashboard-list-item[data-set-id]').forEach(item => {
      item.addEventListener('click', () => {
        const setId = item.dataset.setId;
        if (setId) {
          this._selectSet(setId, 'detail');
        }
      });
    });

    // Field item clicks
    document.querySelectorAll('.set-dashboard-field-item').forEach(item => {
      item.addEventListener('click', () => {
        this._selectSet(set.id, 'schema');
      });
    });

    // Record type view buttons
    document.querySelectorAll('.set-dashboard-record-type-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const typeValue = btn.dataset.typeValue;
        if (typeValue && recordTypeAnalysis) {
          this._createRecordTypeView(set, recordTypeAnalysis, typeValue);
        }
      });
    });

    // Record type item clicks
    document.querySelectorAll('.set-dashboard-record-type-item').forEach(item => {
      item.addEventListener('click', () => {
        const typeValue = item.dataset.typeValue;
        if (typeValue && recordTypeAnalysis) {
          this._createRecordTypeView(set, recordTypeAnalysis, typeValue);
        }
      });
    });

    // Split all types button
    document.getElementById('set-dashboard-split-all')?.addEventListener('click', () => {
      if (recordTypeAnalysis) {
        this._createAllRecordTypeViews(set, recordTypeAnalysis);
      }
    });
  }

  // --------------------------------------------------------------------------
  // Panel Tab Management - Convert panels to closeable tabs
  // --------------------------------------------------------------------------

  /**
   * Open a panel tab
   * @param {string} type - The panel type (overview, source, transforms, fields, exports, lenses, recordTypes)
   * @param {Object} options - Additional options like context data
   */
  _openPanelTab(type, options = {}) {
    const tabType = this.panelTabTypes[type];
    if (!tabType) return;

    // Check if tab already exists (singletons)
    const existingTab = this.panelTabs.find(t => t.type === type);
    if (existingTab && tabType.singleton) {
      // Just activate the existing tab
      this._activatePanelTab(existingTab.id);
      return;
    }

    // Create new tab
    const tabId = `panel-${type}-${Date.now()}`;
    const newTab = {
      id: tabId,
      type: type,
      label: tabType.label,
      icon: tabType.icon,
      context: options.context || {},
      isPinned: false,
      openedAt: Date.now()
    };

    this.panelTabs.push(newTab);
    this._activatePanelTab(tabId);
    this._renderPanelTabs();
  }

  /**
   * Close a panel tab
   * @param {string} tabId - The tab ID to close
   */
  _closePanelTab(tabId) {
    const tabIndex = this.panelTabs.findIndex(t => t.id === tabId);
    if (tabIndex === -1) return;

    const tab = this.panelTabs[tabIndex];
    if (tab.isPinned) return; // Can't close pinned tabs

    // Add to history for potential "reopen" feature
    this.panelTabHistory.push(tab);
    if (this.panelTabHistory.length > 10) {
      this.panelTabHistory.shift();
    }

    // Remove the tab
    this.panelTabs.splice(tabIndex, 1);

    // If we closed the active tab, activate another
    if (this.activePanelTabId === tabId) {
      if (this.panelTabs.length > 0) {
        // Activate the tab to the right, or the last tab if we closed the rightmost
        const newIndex = Math.min(tabIndex, this.panelTabs.length - 1);
        this._activatePanelTab(this.panelTabs[newIndex].id);
      } else {
        this.activePanelTabId = null;
        this._renderPanelTabContent();
      }
    }

    this._renderPanelTabs();
  }

  /**
   * Close all panel tabs
   */
  _closeAllPanelTabs() {
    const unpinnedTabs = this.panelTabs.filter(t => !t.isPinned);
    unpinnedTabs.forEach(tab => {
      this.panelTabHistory.push(tab);
    });
    if (this.panelTabHistory.length > 10) {
      this.panelTabHistory = this.panelTabHistory.slice(-10);
    }

    this.panelTabs = this.panelTabs.filter(t => t.isPinned);
    this.activePanelTabId = this.panelTabs.length > 0 ? this.panelTabs[0].id : null;
    this._renderPanelTabs();
    this._renderPanelTabContent();
  }

  /**
   * Activate a panel tab
   * @param {string} tabId - The tab ID to activate
   */
  _activatePanelTab(tabId) {
    const tab = this.panelTabs.find(t => t.id === tabId);
    if (!tab) return;

    this.activePanelTabId = tabId;
    this._renderPanelTabs();
    this._renderPanelTabContent();
  }

  /**
   * Toggle pin status of a panel tab
   * @param {string} tabId - The tab ID to toggle
   */
  _togglePanelTabPin(tabId) {
    const tab = this.panelTabs.find(t => t.id === tabId);
    if (!tab) return;

    tab.isPinned = !tab.isPinned;

    // Move pinned tabs to the front
    this.panelTabs.sort((a, b) => {
      if (a.isPinned && !b.isPinned) return -1;
      if (!a.isPinned && b.isPinned) return 1;
      return 0;
    });

    this._renderPanelTabs();
  }

  /**
   * Render the panel tab bar
   */
  _renderPanelTabs() {
    const container = document.getElementById('panel-tab-bar');
    if (!container) return;

    const tabsHtml = this.panelTabs.map(tab => {
      const isActive = tab.id === this.activePanelTabId;
      return `
        <div class="panel-tab ${isActive ? 'active' : ''} ${tab.isPinned ? 'pinned' : ''}"
             data-panel-tab-id="${tab.id}"
             data-panel-type="${tab.type}">
          <div class="panel-tab-icon">
            <i class="ph ${tab.icon}"></i>
          </div>
          ${!tab.isPinned ? `<span class="panel-tab-title">${this._escapeHtml(tab.label)}</span>` : ''}
          ${!tab.isPinned ? `
            <button class="panel-tab-close" data-panel-tab-id="${tab.id}">
              <i class="ph ph-x"></i>
            </button>
          ` : ''}
        </div>
      `;
    }).join('');

    // Panel types available to open
    const availableTypes = Object.values(this.panelTabTypes)
      .filter(type => !this.panelTabs.find(t => t.type === type.id && type.singleton))
      .map(type => `
        <div class="panel-tab-menu-item" data-panel-type="${type.id}">
          <i class="ph ${type.icon}"></i>
          ${type.label}
        </div>
      `).join('');

    container.innerHTML = `
      <div class="panel-tabs-scroll">
        ${tabsHtml}
      </div>
      <div class="panel-tabs-actions">
        <button class="panel-tab-add" id="panel-tab-add" title="Open panel">
          <i class="ph ph-plus"></i>
        </button>
        ${this.panelTabs.length > 0 ? `
          <button class="panel-tab-close-all" id="panel-tab-close-all" title="Close all tabs">
            <i class="ph ph-x-circle"></i>
          </button>
        ` : ''}
      </div>
      <div class="panel-tab-menu" id="panel-tab-menu" style="display: none;">
        ${availableTypes || '<div class="panel-tab-menu-empty">All panels open</div>'}
      </div>
    `;

    this._attachPanelTabEventHandlers();
  }

  /**
   * Attach event handlers for panel tabs
   */
  _attachPanelTabEventHandlers() {
    const container = document.getElementById('panel-tab-bar');
    if (!container) return;

    // Tab clicks
    container.querySelectorAll('.panel-tab').forEach(tab => {
      tab.addEventListener('click', (e) => {
        if (e.target.closest('.panel-tab-close')) return;
        this._activatePanelTab(tab.dataset.panelTabId);
      });

      // Middle click to close
      tab.addEventListener('auxclick', (e) => {
        if (e.button === 1) {
          e.preventDefault();
          this._closePanelTab(tab.dataset.panelTabId);
        }
      });

      // Right click for context menu
      tab.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        this._showPanelTabContextMenu(e, tab.dataset.panelTabId);
      });
    });

    // Close button clicks
    container.querySelectorAll('.panel-tab-close').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        this._closePanelTab(btn.dataset.panelTabId);
      });
    });

    // Add button
    const addBtn = document.getElementById('panel-tab-add');
    if (addBtn) {
      addBtn.addEventListener('click', () => {
        const menu = document.getElementById('panel-tab-menu');
        if (menu) {
          menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
        }
      });
    }

    // Close all button
    const closeAllBtn = document.getElementById('panel-tab-close-all');
    if (closeAllBtn) {
      closeAllBtn.addEventListener('click', () => {
        this._closeAllPanelTabs();
      });
    }

    // Menu item clicks
    container.querySelectorAll('.panel-tab-menu-item').forEach(item => {
      item.addEventListener('click', () => {
        this._openPanelTab(item.dataset.panelType);
        const menu = document.getElementById('panel-tab-menu');
        if (menu) menu.style.display = 'none';
      });
    });

    // Close menu when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('#panel-tab-add') && !e.target.closest('#panel-tab-menu')) {
        const menu = document.getElementById('panel-tab-menu');
        if (menu) menu.style.display = 'none';
      }
    }, { once: true });
  }

  /**
   * Show context menu for a panel tab
   */
  _showPanelTabContextMenu(e, tabId) {
    const tab = this.panelTabs.find(t => t.id === tabId);
    if (!tab) return;

    // Remove existing context menu
    document.querySelectorAll('.panel-tab-context-menu').forEach(m => m.remove());

    const menu = document.createElement('div');
    menu.className = 'panel-tab-context-menu';
    menu.innerHTML = `
      <div class="context-menu-item" data-action="pin">
        <i class="ph ${tab.isPinned ? 'ph-push-pin-slash' : 'ph-push-pin'}"></i>
        ${tab.isPinned ? 'Unpin Tab' : 'Pin Tab'}
      </div>
      <div class="context-menu-divider"></div>
      <div class="context-menu-item" data-action="close">
        <i class="ph ph-x"></i>
        Close
      </div>
      <div class="context-menu-item" data-action="close-others">
        <i class="ph ph-x-square"></i>
        Close Others
      </div>
      <div class="context-menu-item" data-action="close-all">
        <i class="ph ph-x-circle"></i>
        Close All
      </div>
    `;

    menu.style.position = 'fixed';
    menu.style.left = `${e.clientX}px`;
    menu.style.top = `${e.clientY}px`;
    menu.style.zIndex = '10000';

    document.body.appendChild(menu);

    // Handle menu actions
    menu.querySelectorAll('.context-menu-item').forEach(item => {
      item.addEventListener('click', () => {
        const action = item.dataset.action;
        switch (action) {
          case 'pin':
            this._togglePanelTabPin(tabId);
            break;
          case 'close':
            this._closePanelTab(tabId);
            break;
          case 'close-others':
            this.panelTabs.forEach(t => {
              if (t.id !== tabId && !t.isPinned) {
                this._closePanelTab(t.id);
              }
            });
            break;
          case 'close-all':
            this._closeAllPanelTabs();
            break;
        }
        menu.remove();
      });
    });

    // Close menu on click outside
    setTimeout(() => {
      document.addEventListener('click', () => menu.remove(), { once: true });
    }, 0);
  }

  /**
   * Render the content for the active panel tab
   */
  _renderPanelTabContent() {
    const container = document.getElementById('panel-tab-content');
    if (!container) return;

    if (!this.activePanelTabId || this.panelTabs.length === 0) {
      container.innerHTML = `
        <div class="panel-tab-empty">
          <i class="ph ph-browser"></i>
          <h3>No panels open</h3>
          <p>Click the + button to open a panel, or choose from the quick actions below:</p>
          <div class="panel-tab-quick-actions">
            ${Object.values(this.panelTabTypes).map(type => `
              <button class="panel-tab-quick-action" data-panel-type="${type.id}">
                <i class="ph ${type.icon}"></i>
                ${type.label}
              </button>
            `).join('')}
          </div>
        </div>
      `;

      // Attach quick action handlers
      container.querySelectorAll('.panel-tab-quick-action').forEach(btn => {
        btn.addEventListener('click', () => {
          this._openPanelTab(btn.dataset.panelType);
        });
      });
      return;
    }

    const activeTab = this.panelTabs.find(t => t.id === this.activePanelTabId);
    if (!activeTab) return;

    // Render content based on tab type
    switch (activeTab.type) {
      case 'overview':
        this._renderOverviewPanelContent(container);
        break;
      case 'source':
        this._renderSourcePanelContent(container);
        break;
      case 'transforms':
        this._renderTransformsPanelContent(container);
        break;
      case 'definitions':
        this._renderDefinitionsPanelContent(container);
        break;
      case 'exports':
        this._renderExportsPanelContent(container);
        break;
      case 'lenses':
        this._renderLensesPanelContent(container);
        break;
      case 'recordTypes':
        this._renderRecordTypesPanelContent(container);
        break;
      default:
        container.innerHTML = '<div class="panel-tab-unknown">Unknown panel type</div>';
    }
  }

  /**
   * Render Data Overview panel content
   */
  _renderOverviewPanelContent(container) {
    const set = this.getCurrentSet();
    if (!set) {
      container.innerHTML = '<div class="panel-tab-error">No set selected</div>';
      return;
    }

    const fields = set.fields || [];
    const records = set.records || [];
    const views = set.views || [];
    const recordTypeAnalysis = this._analyzeRecordTypesForSet(set);
    const completeness = this._calculateSetCompleteness(set);

    // Generate the history section
    const historySection = this._renderSetHistorySection(set.id);

    container.innerHTML = `
      <div class="panel-content overview-panel">
        <div class="panel-content-header">
          <h3><i class="ph ph-chart-bar"></i> Data Overview</h3>
        </div>
        <div class="panel-content-body">
          <div class="overview-stats-grid">
            <div class="overview-stat-card">
              <div class="overview-stat-value">${records.length.toLocaleString()}</div>
              <div class="overview-stat-label">Records</div>
            </div>
            <div class="overview-stat-card">
              <div class="overview-stat-value">${fields.length}</div>
              <div class="overview-stat-label">Fields</div>
            </div>
            <div class="overview-stat-card">
              <div class="overview-stat-value">${views.length}</div>
              <div class="overview-stat-label">Views</div>
            </div>
            <div class="overview-stat-card ${recordTypeAnalysis ? 'highlight' : ''}">
              <div class="overview-stat-value">${recordTypeAnalysis ? recordTypeAnalysis.types.length : 1}</div>
              <div class="overview-stat-label">Record Types</div>
            </div>
          </div>
          <div class="overview-completeness">
            <div class="overview-completeness-header">
              <span>Data Completeness</span>
              <span class="overview-completeness-value">${completeness}%</span>
            </div>
            <div class="overview-completeness-bar">
              <div class="overview-completeness-fill" style="width: ${completeness}%"></div>
            </div>
          </div>
          ${historySection}
        </div>
      </div>
    `;

    // Attach event listener for "View All" history button
    const viewAllBtn = container.querySelector('.set-history-view-all');
    if (viewAllBtn) {
      viewAllBtn.addEventListener('click', () => {
        const setId = viewAllBtn.dataset.setId;
        this._showSetHistoryModal(setId);
      });
    }
  }

  /**
   * Render Source panel content
   */
  _renderSourcePanelContent(container) {
    const set = this.getCurrentSet();
    if (!set) {
      container.innerHTML = '<div class="panel-tab-error">No set selected</div>';
      return;
    }

    const inputSources = this._getSetInputSources(set);
    const sourceInfo = this._getSourceDisplayInfo(set);

    container.innerHTML = `
      <div class="panel-content source-panel">
        <div class="panel-content-header">
          <h3><i class="ph ph-download-simple"></i> Source</h3>
          ${inputSources.length > 0 ? `
            <button class="panel-action-btn" id="source-panel-view">View</button>
          ` : ''}
        </div>
        <div class="panel-content-body">
          ${inputSources.length > 0 ? inputSources.map(source => `
            <div class="source-item" data-source-id="${source.id || ''}" data-set-id="${source.setId || ''}">
              <div class="source-item-icon">
                <i class="ph ${source.icon}"></i>
              </div>
              <div class="source-item-details">
                <div class="source-item-name">${this._escapeHtml(source.name)}</div>
                <div class="source-item-meta">
                  ${sourceInfo.type ? `<span class="source-badge">${sourceInfo.type}</span>` : ''}
                  <span>${source.meta}</span>
                </div>
              </div>
            </div>
          `).join('') : `
            <div class="panel-empty-state">
              <i class="ph ph-file-dashed"></i>
              <span>No source tracked</span>
            </div>
          `}
          <button class="panel-add-btn" id="source-panel-add">
            <i class="ph ph-plus"></i> Add Source
          </button>
        </div>
      </div>
    `;

    // Attach event handlers
    document.getElementById('source-panel-view')?.addEventListener('click', () => {
      const source = inputSources[0];
      if (!source) {
        this._showToast('No source available', 'info');
        return;
      }
      // Try to navigate to source first, then set
      if (source.id) {
        const foundSource = this.sources?.find(s => s.id === source.id);
        if (foundSource) {
          this._selectSource(source.id);
          return;
        }
      }
      if (source.setId) {
        const foundSet = this.sets?.find(s => s.id === source.setId);
        if (foundSet) {
          this._selectSet(source.setId, 'detail');
          return;
        }
      }
      // Neither source nor set found
      this._showToast('Source is no longer available', 'info');
    });

    document.getElementById('source-panel-add')?.addEventListener('click', () => {
      const set = this.getCurrentSet();
      if (set) {
        this._showAddSourceToSetModal(set.id);
      } else {
        this._showImportDialog();
      }
    });

    container.querySelectorAll('.source-item').forEach(item => {
      item.addEventListener('click', () => {
        const sourceId = item.dataset.sourceId;
        const setId = item.dataset.setId;
        // Try to navigate to source first, then set
        if (sourceId) {
          const source = this.sources?.find(s => s.id === sourceId);
          if (source) {
            this._selectSource(sourceId);
            return;
          }
        }
        if (setId) {
          const set = this.sets?.find(s => s.id === setId);
          if (set) {
            this._selectSet(setId, 'detail');
            return;
          }
        }
        // Neither source nor set found - show feedback
        this._showToast('Source is no longer available', 'info');
      });
    });
  }

  /**
   * Render Transformations panel content
   */
  _renderTransformsPanelContent(container) {
    const set = this.getCurrentSet();
    if (!set) {
      container.innerHTML = '<div class="panel-tab-error">No set selected</div>';
      return;
    }

    const transformations = this._getSetTransformations(set);
    const fields = set.fields || [];

    container.innerHTML = `
      <div class="panel-content transforms-panel">
        <div class="panel-content-header">
          <h3><i class="ph ph-gear"></i> Transformations</h3>
        </div>
        <div class="panel-content-body">
          ${transformations.length > 0 ? `
            <div class="transforms-list">
              ${transformations.map(t => `
                <div class="transform-item">
                  ${t.badge}
                  <div class="transform-text">
                    <strong>${this._escapeHtml(t.name)}</strong>
                    <small>${this._escapeHtml(t.description)}</small>
                  </div>
                </div>
              `).join('')}
            </div>
          ` : `
            <div class="transform-item">
              <span class="op-badge direct">INS</span>
              <div class="transform-text">
                <strong>Direct Import</strong>
                <small>No transformations applied</small>
              </div>
            </div>
          `}
          <div class="transforms-schema-link">
            <span>Schema: <strong>${fields.length} fields</strong></span>
            <button class="panel-action-btn" id="transforms-view-fields">
              View Fields →
            </button>
          </div>
        </div>
      </div>
    `;

    document.getElementById('transforms-view-fields')?.addEventListener('click', () => {
      this._selectSet(set.id, 'schema');
    });
  }

  /**
   * Render Definitions panel content - shows all field keys and their definition bindings
   */
  _renderDefinitionsPanelContent(container) {
    const set = this.getCurrentSet();
    if (!set) {
      container.innerHTML = '<div class="panel-tab-error">No set selected</div>';
      return;
    }

    const fields = set.fields || [];
    const keyDefinitions = this._getSetKeyDefinitions(set);
    const boundCount = keyDefinitions.filter(k => k.isBound).length;
    const unboundCount = keyDefinitions.length - boundCount;

    container.innerHTML = `
      <div class="panel-content definitions-panel">
        <div class="panel-content-header">
          <h3><i class="ph ph-book-open"></i> Key Definitions</h3>
          <div class="panel-header-stats">
            <span class="stat-bound" title="Keys with definitions">${boundCount} bound</span>
            <span class="stat-unbound" title="Keys without definitions">${unboundCount} unbound</span>
          </div>
        </div>
        <div class="panel-content-body">
          ${keyDefinitions.length > 0 ? `
            <div class="key-definitions-list">
              ${keyDefinitions.map(keyDef => `
                <div class="key-definition-item ${keyDef.isBound ? 'bound' : 'unbound'}"
                     data-field-id="${keyDef.fieldId}">
                  <div class="key-definition-status">
                    <i class="ph ${keyDef.isBound ? 'ph-check-circle' : 'ph-circle-dashed'}"></i>
                  </div>
                  <div class="key-definition-info">
                    <div class="key-definition-name">${this._escapeHtml(keyDef.fieldName)}</div>
                    ${keyDef.isBound ? `
                      <div class="key-definition-binding">
                        <i class="ph ph-link"></i>
                        ${this._escapeHtml(keyDef.definitionName || 'Linked')}
                      </div>
                    ` : `
                      <div class="key-definition-unbound">No definition</div>
                    `}
                  </div>
                  <div class="key-definition-type">
                    <i class="ph ${this._getFieldTypeIcon(keyDef.fieldType)}"></i>
                  </div>
                </div>
              `).join('')}
            </div>
          ` : `
            <div class="panel-empty-state">
              <i class="ph ph-book-open"></i>
              <span>No fields in this set</span>
            </div>
          `}
          ${unboundCount > 0 ? `
            <button class="panel-add-btn panel-import-keys-btn" id="definitions-panel-import-all">
              <i class="ph ph-download-simple"></i> Import All Keys (${unboundCount})
            </button>
          ` : `
            <div class="panel-complete-state">
              <i class="ph ph-check-circle"></i>
              <span>All keys have definitions</span>
            </div>
          `}
        </div>
      </div>
    `;

    // Attach import all keys handler
    document.getElementById('definitions-panel-import-all')?.addEventListener('click', () => {
      this._importAllKeysAsDefinitions(set);
    });

    // Attach individual key click handlers
    container.querySelectorAll('.key-definition-item').forEach(item => {
      item.addEventListener('click', () => {
        const fieldId = item.dataset.fieldId;
        const field = fields.find(f => f.id === fieldId);
        if (field) {
          if (field.semanticBinding?.definitionId) {
            // Show the linked definition
            this._showDefinitionDetail(field.semanticBinding.definitionId);
          } else {
            // Offer to create/link a definition for this key
            this._importKeyAsDefinition(set, field);
          }
        }
      });
    });
  }

  /**
   * Get key definitions status for all fields in a set
   */
  _getSetKeyDefinitions(set) {
    const fields = set.fields || [];
    return fields.map(field => {
      const binding = field.semanticBinding;
      const isBound = !!(binding?.definitionId);
      let definitionName = null;

      if (isBound) {
        const definition = this.definitions.find(d => d.id === binding.definitionId);
        definitionName = definition?.name || binding.termId || 'Linked Definition';
      }

      return {
        fieldId: field.id,
        fieldName: field.name,
        fieldType: field.type,
        isBound,
        definitionId: binding?.definitionId || null,
        termId: binding?.termId || null,
        definitionName
      };
    });
  }

  /**
   * Import all unbound keys as definitions for a set
   */
  _importAllKeysAsDefinitions(set) {
    const fields = set.fields || [];
    const unboundFields = fields.filter(f => !f.semanticBinding?.definitionId);

    if (unboundFields.length === 0) {
      this._showNotification('All keys already have definitions', 'info');
      return;
    }

    // Create a definition that contains all the keys as terms
    const timestamp = new Date().toISOString();
    const definition = {
      id: `def_${Date.now()}`,
      name: `${set.name} Keys`,
      description: `Auto-imported key definitions from set "${set.name}"`,
      sourceUri: null,
      format: 'local',
      importedAt: timestamp,
      status: 'active',
      terms: unboundFields.map(field => ({
        id: `term_${field.id}`,
        name: field.name,
        label: this._humanizeFieldName(field.name),
        type: field.type,
        description: `Field "${field.name}" from set "${set.name}"`
      }))
    };

    // Add the definition
    this.definitions.push(definition);

    // Bind each field to the definition
    unboundFields.forEach(field => {
      field.semanticBinding = {
        definitionId: definition.id,
        termId: `term_${field.id}`
      };
    });

    // Add definition to current project if applicable
    if (this.currentProjectId) {
      const project = this.projects.find(p => p.id === this.currentProjectId);
      if (project && !project.definitionIds.includes(definition.id)) {
        project.definitionIds.push(definition.id);
      }
    }

    this._saveData();
    this._renderDefinitionsPanelContent(document.getElementById('panel-tab-content'));
    this._renderDefinitionsNav();
    this._showNotification(`Imported ${unboundFields.length} key definitions`, 'success');
  }

  /**
   * Import a single key as a definition
   */
  _importKeyAsDefinition(set, field) {
    const timestamp = new Date().toISOString();
    const definition = {
      id: `def_${Date.now()}`,
      name: this._humanizeFieldName(field.name),
      description: `Key definition for "${field.name}" from set "${set.name}"`,
      sourceUri: null,
      format: 'local',
      importedAt: timestamp,
      status: 'active',
      terms: [{
        id: `term_${field.id}`,
        name: field.name,
        label: this._humanizeFieldName(field.name),
        type: field.type,
        description: `Field "${field.name}" from set "${set.name}"`
      }]
    };

    // Add the definition
    this.definitions.push(definition);

    // Bind the field to the definition
    field.semanticBinding = {
      definitionId: definition.id,
      termId: `term_${field.id}`
    };

    // Add definition to current project if applicable
    if (this.currentProjectId) {
      const project = this.projects.find(p => p.id === this.currentProjectId);
      if (project && !project.definitionIds.includes(definition.id)) {
        project.definitionIds.push(definition.id);
      }
    }

    this._saveData();
    this._renderDefinitionsPanelContent(document.getElementById('panel-tab-content'));
    this._renderDefinitionsNav();
    this._showNotification(`Created definition for "${field.name}"`, 'success');
  }

  /**
   * Ensure all keys from all sets in the current project have stub definitions
   * This auto-creates definitions for fields that don't have semantic bindings
   * Called when viewing the Definitions tab to ensure all keys appear
   */
  _ensureAllKeysHaveDefinitions() {
    const projectSets = this._getProjectSets();
    if (!projectSets || projectSets.length === 0) return;

    const project = this.currentProjectId
      ? this.projects.find(p => p.id === this.currentProjectId)
      : null;

    let definitionsCreated = 0;

    projectSets.forEach(set => {
      const fields = set.fields || [];
      const unboundFields = fields.filter(f => !f.semanticBinding?.definitionId);

      if (unboundFields.length === 0) return;

      // Create individual stub definitions for each unbound field
      unboundFields.forEach(field => {
        const timestamp = new Date().toISOString();
        const definition = {
          id: `def_stub_${field.id}_${Date.now()}`,
          name: this._humanizeFieldName(field.name),
          description: `Stub definition for key "${field.name}" from set "${set.name}"`,
          sourceUri: null,
          format: 'local',
          importedAt: timestamp,
          status: 'stub',
          populationMethod: 'pending',
          sourceSetId: set.id,
          sourceFieldId: field.id,
          terms: [{
            id: `term_${field.id}`,
            name: field.name,
            label: this._humanizeFieldName(field.name),
            type: field.type,
            description: `Field "${field.name}" from set "${set.name}"`
          }]
        };

        // Add the definition
        this.definitions.push(definition);
        definitionsCreated++;

        // Bind the field to the definition
        field.semanticBinding = {
          definitionId: definition.id,
          termId: `term_${field.id}`
        };

        // Add definition to current project if applicable
        if (project) {
          if (!project.definitionIds) project.definitionIds = [];
          if (!project.definitionIds.includes(definition.id)) {
            project.definitionIds.push(definition.id);
          }
        }
      });
    });

    if (definitionsCreated > 0) {
      this._saveData();
    }
  }

  /**
   * Convert a field name to a human-readable label
   */
  _humanizeFieldName(name) {
    return name
      .replace(/([a-z])([A-Z])/g, '$1 $2')  // camelCase to spaces
      .replace(/[_-]/g, ' ')                 // underscores/dashes to spaces
      .replace(/\s+/g, ' ')                  // normalize spaces
      .trim()
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join(' ');
  }

  /**
   * Render Exports panel content
   */
  _renderExportsPanelContent(container) {
    const set = this.getCurrentSet();
    if (!set) {
      container.innerHTML = '<div class="panel-tab-error">No set selected</div>';
      return;
    }

    const outputs = this._getSetOutputs(set);

    container.innerHTML = `
      <div class="panel-content exports-panel">
        <div class="panel-content-header">
          <h3><i class="ph ph-export"></i> Exports</h3>
        </div>
        <div class="panel-content-body">
          ${outputs.exports.length > 0 ? `
            <div class="exports-list">
              ${outputs.exports.map(exp => `
                <div class="export-item">
                  <i class="ph ${exp.icon}"></i>
                  <div class="export-item-info">
                    <div class="export-item-name">${this._escapeHtml(exp.name)}</div>
                    <div class="export-item-meta">${exp.date}</div>
                  </div>
                </div>
              `).join('')}
            </div>
          ` : `
            <div class="panel-empty-state">
              <i class="ph ph-export"></i>
              <span>No exports yet</span>
            </div>
          `}
          <button class="panel-add-btn" id="exports-panel-export">
            <i class="ph ph-export"></i> Export Now
          </button>
        </div>
      </div>
    `;

    document.getElementById('exports-panel-export')?.addEventListener('click', () => {
      this._showExportDialog(set.id);
    });
  }

  /**
   * Render Lenses panel content
   */
  _renderLensesPanelContent(container) {
    const set = this.getCurrentSet();
    if (!set) {
      container.innerHTML = '<div class="panel-tab-error">No set selected</div>';
      return;
    }

    const outputs = this._getSetOutputs(set);

    container.innerHTML = `
      <div class="panel-content lenses-panel">
        <div class="panel-content-header">
          <h3><i class="ph ph-git-branch"></i> Lenses</h3>
        </div>
        <div class="panel-content-body">
          ${outputs.derivedSets.length > 0 ? `
            <div class="lenses-list">
              ${outputs.derivedSets.map(ds => `
                <div class="lens-item" data-set-id="${ds.id}">
                  <i class="ph ${ds.icon}"></i>
                  <div class="lens-item-info">
                    <div class="lens-item-name">${this._escapeHtml(ds.name)}</div>
                    <div class="lens-item-meta">${ds.relation}</div>
                  </div>
                </div>
              `).join('')}
            </div>
          ` : `
            <div class="panel-empty-state">
              <i class="ph ph-git-branch"></i>
              <span>No lenses</span>
            </div>
          `}
          <button class="panel-add-btn" id="lenses-panel-create">
            <i class="ph ph-git-branch"></i> Create Lens
          </button>
        </div>
      </div>
    `;

    document.getElementById('lenses-panel-create')?.addEventListener('click', () => {
      this._showLensCreationFlow();
    });

    container.querySelectorAll('.lens-item').forEach(item => {
      item.addEventListener('click', () => {
        const setId = item.dataset.setId;
        if (setId) {
          this._selectSet(setId, 'detail');
        }
      });
    });
  }

  /**
   * Render Record Types panel content
   */
  _renderRecordTypesPanelContent(container) {
    const set = this.getCurrentSet();
    if (!set) {
      container.innerHTML = '<div class="panel-tab-error">No set selected</div>';
      return;
    }

    const recordTypeAnalysis = this._analyzeRecordTypesForSet(set);

    if (!recordTypeAnalysis) {
      container.innerHTML = `
        <div class="panel-content record-types-panel">
          <div class="panel-content-header">
            <h3><i class="ph ph-stack"></i> Record Types</h3>
          </div>
          <div class="panel-content-body">
            <div class="panel-empty-state">
              <i class="ph ph-stack"></i>
              <span>Single record type detected</span>
              <small>This set contains uniform records</small>
            </div>
          </div>
        </div>
      `;
      return;
    }

    container.innerHTML = `
      <div class="panel-content record-types-panel">
        <div class="panel-content-header">
          <h3><i class="ph ph-stack"></i> Record Types</h3>
          <button class="panel-action-btn" id="record-types-split-all">
            Create All Views
          </button>
        </div>
        <div class="panel-content-body">
          <div class="record-types-info">
            This set contains <strong>${recordTypeAnalysis.types.length}</strong> different record types
            based on the <code>${this._escapeHtml(recordTypeAnalysis.typeField)}</code> field.
          </div>
          <div class="record-types-grid">
            ${recordTypeAnalysis.types.map(type => `
              <div class="record-type-item" data-type-value="${this._escapeHtml(type.value)}">
                <div class="record-type-name">${this._escapeHtml(type.label)}</div>
                <div class="record-type-count">${type.count} records</div>
                <button class="record-type-view-btn" data-type-value="${this._escapeHtml(type.value)}">
                  <i class="ph ph-eye"></i> View
                </button>
              </div>
            `).join('')}
          </div>
        </div>
      </div>
    `;

    document.getElementById('record-types-split-all')?.addEventListener('click', () => {
      this._createAllRecordTypeViews(set, recordTypeAnalysis);
    });

    container.querySelectorAll('.record-type-view-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const typeValue = btn.dataset.typeValue;
        if (typeValue) {
          this._createRecordTypeView(set, recordTypeAnalysis, typeValue);
        }
      });
    });

    container.querySelectorAll('.record-type-item').forEach(item => {
      item.addEventListener('click', () => {
        const typeValue = item.dataset.typeValue;
        if (typeValue) {
          this._createRecordTypeView(set, recordTypeAnalysis, typeValue);
        }
      });
    });
  }

  /**
   * Get input sources for a set
   */
  _getSetInputSources(set) {
    const sources = [];
    const prov = set.datasetProvenance || {};
    const derivation = set.derivation || {};

    // Direct source import
    if (prov.sourceId) {
      const source = this.sources?.find(s => s.id === prov.sourceId);
      sources.push({
        id: prov.sourceId,
        name: source?.name || prov.originalFilename || 'Unknown source',
        icon: 'ph-file-csv',
        meta: prov.createdVia ? `Imported via ${prov.createdVia}` : 'Imported file',
        canView: !!source
      });
    } else if (prov.originalFilename) {
      sources.push({
        name: prov.originalFilename,
        icon: 'ph-file',
        meta: 'Original import file',
        canView: false
      });
    }

    // Parent set (for SEG/filtered sets)
    if (derivation.parentSetId) {
      const parentSet = this.sets?.find(s => s.id === derivation.parentSetId);
      sources.push({
        setId: derivation.parentSetId,
        name: parentSet?.name || 'Parent set',
        icon: parentSet?.icon || 'ph-table',
        meta: 'Filtered from parent set',
        canView: !!parentSet
      });
    }

    // Source items (for CON/joined sets)
    if (derivation.sourceItems?.length > 0) {
      derivation.sourceItems.forEach(item => {
        const itemSet = this.sets?.find(s => s.id === item.setId);
        const itemSource = this.sources?.find(s => s.id === item.sourceId);
        sources.push({
          setId: item.setId,
          id: item.sourceId,
          name: itemSet?.name || itemSource?.name || item.name || 'Source',
          icon: itemSet?.icon || 'ph-table',
          meta: item.alias ? `As "${item.alias}"` : 'Joined source',
          canView: !!(itemSet || itemSource)
        });
      });
    }

    // Multiple source IDs (from derivation)
    if (derivation.sourceIds?.length > 0) {
      derivation.sourceIds.forEach(sourceId => {
        const source = this.sources?.find(s => s.id === sourceId);
        if (source && !sources.find(s => s.id === sourceId)) {
          sources.push({
            id: sourceId,
            name: source.name,
            icon: 'ph-file-csv',
            meta: 'Source file',
            canView: true
          });
        }
      });
    }

    // Multiple source IDs (from provenance - for multi-source sets)
    if (prov.sourceIds?.length > 0) {
      prov.sourceIds.forEach(sourceId => {
        const source = this.sources?.find(s => s.id === sourceId);
        if (source && !sources.find(s => s.id === sourceId)) {
          sources.push({
            id: sourceId,
            name: source.name,
            icon: 'ph-file-csv',
            meta: 'Source file',
            canView: true
          });
        }
      });
    }

    // Joined sources (from join operations)
    if (prov.joinedFrom?.length > 0) {
      prov.joinedFrom.forEach(joined => {
        const source = this.sources?.find(s => s.id === joined.sourceId);
        if (!sources.find(s => s.id === joined.sourceId)) {
          sources.push({
            id: joined.sourceId,
            name: source?.name || joined.name || 'Joined source',
            icon: 'ph-file-csv',
            meta: 'Joined source',
            canView: !!source
          });
        }
      });
    }

    // Chain operation sources
    if (prov.sources?.length > 0) {
      prov.sources.forEach(src => {
        const source = this.sources?.find(s => s.id === src.id);
        if (!sources.find(s => s.id === src.id)) {
          sources.push({
            id: src.id,
            name: source?.name || src.name || src.originalFilename || 'Source',
            icon: 'ph-file-csv',
            meta: 'Chain source',
            canView: !!source
          });
        }
      });
    }

    return sources;
  }

  /**
   * Get transformations applied to a set
   */
  _getSetTransformations(set) {
    const transforms = [];
    const derivation = set.derivation || {};

    // Check derivation strategy
    if (derivation.strategy === 'seg') {
      transforms.push({
        type: 'filter',
        badge: '<span class="op-badge seg">SEG ｜</span>',
        name: 'Segmented',
        description: derivation.constraint?.filters?.length > 0
          ? `${derivation.constraint.filters.length} filter(s) applied`
          : 'Filtered subset'
      });
    }

    if (derivation.strategy === 'con') {
      transforms.push({
        type: 'join',
        badge: '<span class="op-badge con">CON ⋈</span>',
        name: 'Connected',
        description: derivation.joinConfig
          ? `Joined on ${derivation.joinConfig.leftField || 'key'}`
          : 'Joined from multiple sources'
      });
    }

    if (derivation.strategy === 'alt') {
      transforms.push({
        type: 'transform',
        badge: '<span class="op-badge alt">ALT ∿</span>',
        name: 'Alternated',
        description: 'Data transformed'
      });
    }

    if (derivation.strategy === 'sql' || derivation.queryEventId) {
      transforms.push({
        type: 'query',
        badge: '<span class="op-badge query">SQL</span>',
        name: 'SQL Query',
        description: 'Created via SQL/EOQL query'
      });
    }

    // Check for computed fields
    const formulaFields = set.fields?.filter(f => f.type === 'formula' || f.type === 'rollup' || f.type === 'count');
    if (formulaFields?.length > 0) {
      transforms.push({
        type: 'computed',
        badge: '<span class="op-badge computed">ƒx</span>',
        name: 'Computed Fields',
        description: `${formulaFields.length} computed field(s)`
      });
    }

    return transforms;
  }

  /**
   * Get outputs from a set (exports, derived sets)
   */
  _getSetOutputs(set) {
    const outputs = {
      exports: [],
      derivedSets: []
    };

    // Find derived sets (sets that use this set as parent or source)
    this.sets?.forEach(s => {
      if (s.id === set.id) return;

      const deriv = s.derivation || {};
      const prov = s.datasetProvenance || {};

      // Check if derived from this set
      if (deriv.parentSetId === set.id) {
        outputs.derivedSets.push({
          id: s.id,
          name: s.name,
          icon: s.icon || 'ph-table',
          relation: 'SEG (filtered)'
        });
      } else if (deriv.sourceItems?.some(item => item.setId === set.id)) {
        outputs.derivedSets.push({
          id: s.id,
          name: s.name,
          icon: s.icon || 'ph-table',
          relation: 'CON (joined)'
        });
      }
    });

    // Note: Export history would need to be tracked separately
    // For now, show empty state with action button

    return outputs;
  }

  /**
   * Analyze record types in a set for splitting
   */
  _analyzeRecordTypesForSet(set) {
    const records = set.records || [];
    const fields = set.fields || [];

    if (records.length < 2) return null;

    // Look for a type field
    const typeFieldCandidates = ['type', '_type', 'recordType', 'record_type', '_recordType', 'kind', 'category'];

    let typeField = null;
    let typeFieldObj = null;

    for (const candidate of typeFieldCandidates) {
      typeFieldObj = fields.find(f => f.name.toLowerCase() === candidate.toLowerCase());
      if (typeFieldObj) {
        typeField = typeFieldObj.name;
        break;
      }
    }

    if (!typeField || !typeFieldObj) return null;

    // Get unique type values
    const typeValues = new Map();
    const typeFieldId = typeFieldObj.id;

    records.forEach(r => {
      const val = r.values?.[typeFieldId];
      if (val !== null && val !== undefined && val !== '') {
        if (!typeValues.has(val)) {
          typeValues.set(val, { count: 0, fieldsWithValues: new Set() });
        }
        typeValues.get(val).count++;

        // Track which fields have values for this type
        for (const field of fields) {
          const fieldVal = r.values?.[field.id];
          if (fieldVal !== null && fieldVal !== undefined && fieldVal !== '') {
            typeValues.get(val).fieldsWithValues.add(field.id);
          }
        }
      }
    });

    // Need at least 2 types for this to be relevant
    if (typeValues.size < 2) return null;

    // Calculate common and type-specific fields
    const types = Array.from(typeValues.keys());
    const allFieldIds = new Set(fields.map(f => f.id));

    // Find fields common to all types
    const commonFields = new Set(allFieldIds);
    types.forEach(type => {
      const typeData = typeValues.get(type);
      for (const fieldId of allFieldIds) {
        if (!typeData.fieldsWithValues.has(fieldId)) {
          commonFields.delete(fieldId);
        }
      }
    });

    // Build type info with specific fields
    const typeInfo = types.map(typeVal => {
      const data = typeValues.get(typeVal);
      const specificFields = [];

      for (const fieldId of data.fieldsWithValues) {
        if (!commonFields.has(fieldId) && fieldId !== typeFieldId) {
          const field = fields.find(f => f.id === fieldId);
          if (field) specificFields.push(field.name);
        }
      }

      // Look up pretty name from definitions if the type value is a definition ID
      let label = typeVal;
      if (typeof typeVal === 'string' && typeVal.startsWith('id_')) {
        const definition = this.definitions?.find(d => d.id === typeVal);
        if (definition?.name) {
          label = definition.name;
        }
      }

      return {
        value: typeVal,
        label: label,
        count: data.count,
        specificFields: specificFields
      };
    }).sort((a, b) => b.count - a.count);

    return {
      typeField: typeField,
      typeFieldId: typeFieldId,
      types: typeInfo
    };
  }

  /**
   * Create a view filtered by record type
   */
  _createRecordTypeView(set, analysis, typeValue) {
    const typeInfo = analysis.types.find(t => t.value === typeValue);
    if (!typeInfo) return;

    // Check if view already exists
    const existingView = set.views.find(v =>
      v.metadata?.isRecordTypeView && v.metadata?.recordType === typeValue
    );

    if (existingView) {
      this._showToast(`View for "${typeInfo.label}" already exists`, 'info');
      this._selectView(existingView.id);
      return;
    }

    // Create filter for this record type
    const filter = {
      fieldId: analysis.typeFieldId,
      operator: 'equals',
      value: typeValue
    };

    // Determine which fields to hide (fields not used by this type)
    const hiddenFields = [];
    const allFieldIds = set.fields.map(f => f.id);

    // Find fields that are specific to OTHER types (not this one)
    analysis.types.forEach(t => {
      if (t.value !== typeValue && t.specificFields.length > 0) {
        t.specificFields.forEach(fieldName => {
          const field = set.fields.find(f => f.name === fieldName);
          if (field && !hiddenFields.includes(field.id)) {
            // Only hide if this field is NOT used by current type
            if (!typeInfo.specificFields.includes(fieldName)) {
              hiddenFields.push(field.id);
            }
          }
        });
      }
    });

    // Create the view
    const view = createView(typeInfo.label, 'table', {
      filters: [filter],
      hiddenFields: hiddenFields
    }, {
      isRecordTypeView: true,
      recordType: typeValue,
      recordCount: typeInfo.count,
      icon: 'ph-stack'
    });

    set.views.push(view);
    this._saveData();
    this._renderSidebar();
    this._selectView(view.id);
    this._showToast(`Created view for "${typeValue}"`, 'success');
  }

  /**
   * Create views for all record types
   */
  _createAllRecordTypeViews(set, analysis) {
    let created = 0;

    analysis.types.forEach(typeInfo => {
      // Check if view already exists
      const existingView = set.views.find(v =>
        v.metadata?.isRecordTypeView && v.metadata?.recordType === typeInfo.value
      );

      if (!existingView) {
        this._createRecordTypeView(set, analysis, typeInfo.value);
        created++;
      }
    });

    if (created > 0) {
      this._showToast(`Created ${created} record type views`, 'success');
    } else {
      this._showToast('All record type views already exist', 'info');
    }
  }

  /**
   * Render the Set Fields Panel (like Airtable's "Manage Fields")
   * Full-width table view with comprehensive field management
   */
  _renderSetFieldsPanel() {
    const set = this.getCurrentSet();
    if (!set) {
      this._renderEmptyState();
      return;
    }

    const content = this.elements.contentArea;
    if (!content) return;

    const fields = set.fields || [];
    const recordCount = set.records?.length || 0;

    // Initialize event stream if not present
    if (!set.eventStream) {
      set.eventStream = [];
    }

    // Field type icons mapping
    const fieldTypeIcons = {
      'text': 'ph-text-t',
      'long_text': 'ph-text-aa',
      'number': 'ph-hash',
      'select': 'ph-list-bullets',
      'multi_select': 'ph-checks',
      'date': 'ph-calendar',
      'checkbox': 'ph-check-square',
      'link': 'ph-link',
      'attachment': 'ph-paperclip',
      'url': 'ph-globe',
      'email': 'ph-envelope',
      'phone': 'ph-phone',
      'formula': 'ph-function',
      'rollup': 'ph-sigma',
      'count': 'ph-number-circle-one',
      'autonumber': 'ph-number-square-one',
      'json': 'ph-brackets-curly'
    };

    // Field type display names
    const fieldTypeNames = {
      'text': 'Single line text',
      'long_text': 'Long text',
      'number': 'Number',
      'select': 'Single select',
      'multi_select': 'Multiple select',
      'date': 'Date',
      'checkbox': 'Checkbox',
      'link': 'Link to another record',
      'attachment': 'Attachment',
      'url': 'URL',
      'email': 'Email',
      'phone': 'Phone',
      'formula': 'Formula',
      'rollup': 'Rollup',
      'count': 'Count',
      'autonumber': 'Auto number',
      'json': 'JSON'
    };

    // Calculate field usage statistics
    const views = set.views || [];
    const fieldUsage = this._calculateFieldUsage(set);

    // Get last modification info for each field
    const fieldLastModified = this._getFieldLastModified(set);

    // Build table rows HTML
    const tableRowsHtml = fields.map((field, index) => {
      const icon = fieldTypeIcons[field.type] || 'ph-question';
      const typeName = fieldTypeNames[field.type] || field.type;
      const isPrimary = field.isPrimary || index === 0;
      const usage = fieldUsage[field.id] || { views: 0, formulas: 0, total: 0 };
      const lastMod = fieldLastModified[field.id];
      const definitionRef = field.definitionRef;

      // Format last modified
      const lastModText = lastMod ? this._formatRelativeTime(lastMod.timestamp) : '—';
      const lastModActor = lastMod?.actor?.name || '';

      // Usage summary
      const usageParts = [];
      if (usage.views > 0) usageParts.push(`${usage.views} View${usage.views > 1 ? 's' : ''}`);
      if (usage.formulas > 0) usageParts.push(`${usage.formulas} Formula${usage.formulas > 1 ? 's' : ''}`);
      const usageText = usageParts.length > 0 ? usageParts.join(' · ') : '—';

      // Definition info: check both definitionRef and semanticBinding/definitionId
      const defInfo = this._getFieldDefinitionInfo(field);

      return `
        <tr data-field-id="${field.id}" class="field-row">
          <td class="col-checkbox">
            <input type="checkbox" class="field-checkbox" data-field-id="${field.id}" ${isPrimary ? 'disabled' : ''}>
          </td>
          <td class="col-name">
            <div class="field-name-cell">
              <div class="field-type-icon">
                <i class="ph ${icon}"></i>
              </div>
              <span class="field-name-text">${this._escapeHtml(field.name)}</span>
              ${isPrimary ? '<span class="field-primary-badge">Primary</span>' : ''}
            </div>
          </td>
          <td class="col-type">
            <div class="field-type-cell">
              <i class="ph ${icon}"></i>
              <span>${typeName}</span>
            </div>
          </td>
          <td class="col-description">
            <div class="field-description-cell ${!field.description ? 'empty' : ''}" data-field-id="${field.id}">
              ${field.description ? this._escapeHtml(field.description) : '<span class="add-description">Add description</span>'}
            </div>
          </td>
          <td class="col-definition">
            <div class="field-definition-cell">
              ${defInfo.hasDefinition ? `
                <span class="field-definition-badge ${defInfo.isStub ? 'stub' : 'linked'}"
                      data-field-id="${field.id}"
                      data-definition-id="${defInfo.definitionId}"
                      title="${defInfo.isStub ? 'Stub - needs definition text or URI' : this._escapeHtml(defInfo.uri || defInfo.name || '')}">
                  <i class="ph ${defInfo.isStub ? 'ph-note-blank' : 'ph-link'}"></i>
                  ${defInfo.isStub ? 'Stub' : this._escapeHtml(defInfo.name || 'Linked')}
                </span>
              ` : `
                <button class="link-definition-btn" data-field-id="${field.id}">
                  <i class="ph ph-plus"></i> Link
                </button>
              `}
            </div>
          </td>
          <td class="col-field-id">
            <div class="field-id-cell">
              <span>${field.id}</span>
              <button class="field-id-copy" data-field-id="${field.id}" title="Copy field ID">
                <i class="ph ph-copy"></i>
              </button>
            </div>
          </td>
          <td class="col-used-by">
            <div class="field-used-by-cell" data-field-id="${field.id}">
              ${usage.total > 0 ? `
                <span class="usage-badge" data-field-id="${field.id}">
                  <i class="ph ph-stack"></i>
                  ${usageText}
                </span>
              ` : '<span style="color: var(--text-muted);">—</span>'}
            </div>
          </td>
          <td class="col-modified">
            <div class="field-modified-cell">
              <span class="modified-time">${lastModText}</span>
              ${lastModActor ? `<span class="modified-actor">${this._escapeHtml(lastModActor)}</span>` : ''}
            </div>
          </td>
          <td class="col-actions">
            <div class="field-actions-cell">
              <button class="field-actions-menu-btn" data-field-id="${field.id}">
                <i class="ph ph-dots-three"></i>
              </button>
            </div>
          </td>
        </tr>
      `;
    }).join('');

    content.innerHTML = `
      <div class="fields-panel-container">
        <!-- Header -->
        <div class="fields-panel-header">
          <div class="fields-panel-header-left">
            <button class="fields-panel-back-btn" id="fields-panel-back">
              <i class="ph ph-arrow-left"></i>
              Back
            </button>
            <div class="fields-panel-title">
              <span class="fields-panel-title-set">${this._escapeHtml(set.name)}</span>
              <span class="fields-panel-title-divider">›</span>
              <span>Fields</span>
            </div>
          </div>
          <div class="fields-panel-header-right">
            <span class="fields-panel-count">${fields.length} fields</span>
            <button class="fields-panel-add-btn" id="fields-panel-add-field">
              <i class="ph ph-plus"></i>
              <span>Add field</span>
            </button>
          </div>
        </div>

        <!-- Toolbar -->
        <div class="fields-panel-toolbar">
          <div class="fields-panel-search">
            <i class="ph ph-magnifying-glass"></i>
            <input type="text" placeholder="Find a field..." id="fields-panel-search-input">
          </div>
          <div class="fields-panel-filters">
            <button class="fields-panel-filter" id="filter-type" data-filter="type">
              Type: All
              <i class="ph ph-caret-down"></i>
            </button>
            <button class="fields-panel-filter" id="filter-definition" data-filter="definition">
              Definition: All
              <i class="ph ph-caret-down"></i>
            </button>
          </div>
        </div>

        <!-- Bulk actions bar (hidden by default) -->
        <div class="fields-panel-bulk-bar" id="fields-panel-bulk-bar">
          <span class="fields-panel-bulk-count" id="bulk-count">0 selected</span>
          <div class="fields-panel-bulk-actions">
            <button class="fields-panel-bulk-btn" id="bulk-link-definition">
              <i class="ph ph-link"></i>
              Link definition
            </button>
            <button type="button" class="fields-panel-bulk-btn danger" id="fields-bulk-delete">
              <i class="ph ph-trash"></i>
              Delete
            </button>
          </div>
        </div>

        <!-- Table -->
        <div class="fields-panel-table-wrapper">
          ${fields.length > 0 ? `
            <table class="fields-panel-table">
              <thead>
                <tr>
                  <th class="col-checkbox">
                    <input type="checkbox" class="field-checkbox" id="select-all-fields">
                  </th>
                  <th class="col-name sortable" data-sort="name">
                    Name
                    <i class="ph ph-caret-up-down sort-icon"></i>
                  </th>
                  <th class="col-type sortable" data-sort="type">
                    Field type
                    <i class="ph ph-caret-up-down sort-icon"></i>
                  </th>
                  <th class="col-description">Description</th>
                  <th class="col-definition">Definition</th>
                  <th class="col-field-id">Field ID</th>
                  <th class="col-used-by">Used by</th>
                  <th class="col-modified sortable" data-sort="modified">
                    Last modified
                    <i class="ph ph-caret-up-down sort-icon"></i>
                  </th>
                  <th class="col-actions"></th>
                </tr>
              </thead>
              <tbody id="fields-table-body">
                ${tableRowsHtml}
              </tbody>
            </table>
          ` : `
            <div class="fields-panel-empty">
              <i class="ph ph-columns"></i>
              <p>No fields yet</p>
              <button class="fields-panel-empty-add-btn" id="fields-panel-empty-add">
                <i class="ph ph-plus"></i>
                Add your first field
              </button>
            </div>
          `}
        </div>
      </div>

      <!-- Actions dropdown (positioned dynamically) -->
      <div class="field-actions-dropdown" id="field-actions-dropdown">
        <button class="field-action-item" data-action="edit">
          <i class="ph ph-pencil-simple"></i>
          Edit field
        </button>
        <button class="field-action-item" data-action="duplicate">
          <i class="ph ph-copy"></i>
          Duplicate
        </button>
        <button class="field-action-item" data-action="link-definition">
          <i class="ph ph-link"></i>
          Link definition
        </button>
        <div class="field-action-divider"></div>
        <button class="field-action-item" data-action="history">
          <i class="ph ph-clock-counter-clockwise"></i>
          View history
        </button>
        <button class="field-action-item" data-action="copy-id">
          <i class="ph ph-clipboard"></i>
          Copy field ID
        </button>
        <div class="field-action-divider"></div>
        <button class="field-action-item danger" data-action="delete">
          <i class="ph ph-trash"></i>
          Delete field
        </button>
      </div>

      <!-- Filter dropdowns -->
      <div class="filter-dropdown" id="filter-type-dropdown">
        <div class="filter-dropdown-item selected" data-value="all">
          All types
          <i class="ph ph-check"></i>
        </div>
        ${Object.entries(fieldTypeNames).map(([type, name]) => `
          <div class="filter-dropdown-item" data-value="${type}">
            <i class="ph ${fieldTypeIcons[type]}"></i>
            ${name}
            <i class="ph ph-check"></i>
          </div>
        `).join('')}
      </div>

      <div class="filter-dropdown" id="filter-definition-dropdown">
        <div class="filter-dropdown-item selected" data-value="all">
          All
          <i class="ph ph-check"></i>
        </div>
        <div class="filter-dropdown-item" data-value="linked">
          <i class="ph ph-link"></i>
          Has definition
          <i class="ph ph-check"></i>
        </div>
        <div class="filter-dropdown-item" data-value="unlinked">
          <i class="ph ph-link-break"></i>
          No definition
          <i class="ph ph-check"></i>
        </div>
      </div>

      <!-- History panel (slide-out) -->
      <div class="field-history-overlay" id="field-history-overlay"></div>
      <div class="field-history-panel" id="field-history-panel">
        <div class="field-history-header">
          <div class="field-history-header-left">
            <div>
              <div class="field-history-title" id="history-field-name">Field History</div>
              <div class="field-history-subtitle" id="history-field-type">—</div>
            </div>
          </div>
          <button class="field-history-close-btn" id="close-history-panel">
            <i class="ph ph-x"></i>
          </button>
        </div>
        <div class="field-history-toolbar">
          <button class="field-history-filter active" data-filter="all">All changes</button>
          <button class="field-history-filter" data-filter="rename">Renames</button>
          <button class="field-history-filter" data-filter="type">Type changes</button>
        </div>
        <div class="field-history-content" id="field-history-content">
          <!-- History timeline will be rendered here -->
        </div>
      </div>

      <!-- Definition link modal -->
      <div class="definition-link-modal" id="definition-link-modal">
        <div class="definition-link-modal-overlay"></div>
        <div class="definition-link-modal-content">
          <div class="definition-link-header">
            <span class="definition-link-title">Link to Definition</span>
            <button class="definition-link-close" id="close-definition-modal">
              <i class="ph ph-x"></i>
            </button>
          </div>
          <div class="definition-link-search">
            <input type="text" placeholder="Search definitions and terms..." id="definition-search-input">
          </div>
          <div class="definition-link-list" id="definition-link-list">
            <!-- Definition items will be rendered here -->
          </div>
          <div class="definition-link-footer">
            <div class="definition-link-footer-left">
              <button class="definition-link-unlink-btn" id="unlink-definition-btn" style="display: none;">
                <i class="ph ph-link-break"></i>
                Unlink
              </button>
            </div>
            <div class="definition-link-footer-right">
              <button class="definition-link-cancel-btn" id="cancel-definition-link">Cancel</button>
              <button class="definition-link-save-btn" id="save-definition-link" disabled>Link</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Usage popover -->
      <div class="usage-popover" id="usage-popover">
        <div class="usage-popover-header">Field Usage</div>
        <div class="usage-popover-content" id="usage-popover-content">
          <!-- Usage details will be rendered here -->
        </div>
      </div>
    `;

    // Attach event handlers
    this._attachFieldsPanelEventHandlers();
  }

  /**
   * Calculate comprehensive field usage statistics
   */
  _calculateFieldUsage(set) {
    const usage = {};
    const fields = set.fields || [];
    const views = set.views || [];

    fields.forEach(field => {
      const fieldUsage = {
        views: 0,
        viewsList: [],
        formulas: 0,
        formulasList: [],
        rollups: 0,
        rollupsList: [],
        filters: 0,
        filtersList: [],
        sorts: 0,
        sortsList: [],
        total: 0
      };

      // Count views where field is visible
      views.forEach(view => {
        const hiddenFields = view.config?.hiddenFields || [];
        if (!hiddenFields.includes(field.id)) {
          fieldUsage.views++;
          fieldUsage.viewsList.push({ id: view.id, name: view.name });
        }

        // Check if used in filters
        const filters = view.config?.filters || [];
        filters.forEach(filter => {
          if (filter.fieldId === field.id) {
            fieldUsage.filters++;
            fieldUsage.filtersList.push({ viewId: view.id, viewName: view.name });
          }
        });

        // Check if used in sorts
        const sorts = view.config?.sorts || [];
        sorts.forEach(sort => {
          if (sort.fieldId === field.id) {
            fieldUsage.sorts++;
            fieldUsage.sortsList.push({ viewId: view.id, viewName: view.name });
          }
        });
      });

      // Check if referenced in formula fields
      fields.forEach(f => {
        if (f.type === 'formula' && f.options?.formula) {
          // Simple check for field reference in formula
          if (f.options.formula.includes(field.id) || f.options.formula.includes(field.name)) {
            fieldUsage.formulas++;
            fieldUsage.formulasList.push({ id: f.id, name: f.name });
          }
        }
        if (f.type === 'rollup' && f.options?.rollupFieldId === field.id) {
          fieldUsage.rollups++;
          fieldUsage.rollupsList.push({ id: f.id, name: f.name });
        }
      });

      fieldUsage.total = fieldUsage.views + fieldUsage.formulas + fieldUsage.rollups;
      usage[field.id] = fieldUsage;
    });

    return usage;
  }

  /**
   * Get last modification info for each field from event stream
   */
  _getFieldLastModified(set) {
    const lastMod = {};
    const events = set.eventStream || [];

    // Process events in reverse to get most recent first
    const fieldEvents = events
      .filter(e => e.type?.startsWith('field.'))
      .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

    fieldEvents.forEach(event => {
      const fieldId = event.target?.fieldId;
      if (fieldId && !lastMod[fieldId]) {
        lastMod[fieldId] = {
          timestamp: event.timestamp,
          type: event.type,
          actor: event.actor
        };
      }
    });

    return lastMod;
  }

  /**
   * Get definition name by ID
   */
  _getDefinitionName(definitionId) {
    const definitions = this.definitions || [];
    const def = definitions.find(d => d.id === definitionId);
    return def?.name || null;
  }

  /**
   * Format relative time (e.g., "2 hours ago", "Yesterday")
   */
  _formatRelativeTime(timestamp) {
    if (!timestamp) return '—';

    const date = new Date(timestamp);
    const now = new Date();
    const diffMs = now - date;
    const diffSecs = Math.floor(diffMs / 1000);
    const diffMins = Math.floor(diffSecs / 60);
    const diffHours = Math.floor(diffMins / 60);
    const diffDays = Math.floor(diffHours / 24);

    if (diffSecs < 60) return 'Just now';
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    if (diffDays === 1) return 'Yesterday';
    if (diffDays < 7) return `${diffDays}d ago`;

    // Format as date
    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  }

  /**
   * Attach event handlers for the fields panel
   */
  _attachFieldsPanelEventHandlers() {
    // Track selected fields for bulk operations
    this._selectedFieldIds = new Set();
    this._currentFieldsFilter = { type: 'all', definition: 'all' };

    // Back button
    document.getElementById('fields-panel-back')?.addEventListener('click', () => {
      this._navigateToSetView();
    });

    // Add field button
    document.getElementById('fields-panel-add-field')?.addEventListener('click', () => {
      this._showAddFieldModal();
    });

    document.getElementById('fields-panel-empty-add')?.addEventListener('click', () => {
      this._showAddFieldModal();
    });

    // Search input
    document.getElementById('fields-panel-search-input')?.addEventListener('input', (e) => {
      this._filterFieldsTable();
    });

    // Select all checkbox
    document.getElementById('select-all-fields')?.addEventListener('change', (e) => {
      const checked = e.target.checked;
      document.querySelectorAll('.field-row .field-checkbox:not(:disabled)').forEach(cb => {
        cb.checked = checked;
        const fieldId = cb.dataset.fieldId;
        if (checked) {
          this._selectedFieldIds.add(fieldId);
        } else {
          this._selectedFieldIds.delete(fieldId);
        }
        cb.closest('tr')?.classList.toggle('selected', checked);
      });
      this._updateBulkBar();
    });

    // Individual field checkboxes
    document.querySelectorAll('.field-row .field-checkbox').forEach(cb => {
      cb.addEventListener('change', (e) => {
        e.stopPropagation();
        const fieldId = cb.dataset.fieldId;
        if (cb.checked) {
          this._selectedFieldIds.add(fieldId);
        } else {
          this._selectedFieldIds.delete(fieldId);
        }
        cb.closest('tr')?.classList.toggle('selected', cb.checked);
        this._updateBulkBar();
        this._updateSelectAllCheckbox();
      });
    });

    // Field row click - edit field
    document.querySelectorAll('.field-row').forEach(row => {
      row.addEventListener('click', (e) => {
        // Don't trigger if clicking on interactive elements
        if (e.target.closest('.field-checkbox') ||
            e.target.closest('.field-actions-menu-btn') ||
            e.target.closest('.field-id-copy') ||
            e.target.closest('.link-definition-btn') ||
            e.target.closest('.field-definition-badge') ||
            e.target.closest('.usage-badge') ||
            e.target.closest('.add-description')) {
          return;
        }
        const fieldId = row.dataset.fieldId;
        this._showEditFieldModal(fieldId);
      });
    });

    // Actions menu buttons
    document.querySelectorAll('.field-actions-menu-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const fieldId = btn.dataset.fieldId;
        this._showFieldActionsMenu(fieldId, btn);
      });
    });

    // Actions dropdown items
    const actionsDropdown = document.getElementById('field-actions-dropdown');
    actionsDropdown?.querySelectorAll('.field-action-item').forEach(item => {
      item.addEventListener('click', (e) => {
        const action = item.dataset.action;
        const fieldId = actionsDropdown.dataset.fieldId;
        this._hideFieldActionsMenu();
        this._handleFieldAction(action, fieldId);
      });
    });

    // Copy field ID buttons
    document.querySelectorAll('.field-id-copy').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const fieldId = btn.dataset.fieldId;
        this._copyToClipboard(fieldId);
        this._showToast('Field ID copied to clipboard');
      });
    });

    // Link definition buttons
    document.querySelectorAll('.link-definition-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const fieldId = btn.dataset.fieldId;
        this._showDefinitionLinkModal(fieldId);
      });
    });

    // Definition badges (view linked definition or edit stub)
    document.querySelectorAll('.field-definition-badge').forEach(badge => {
      badge.addEventListener('click', (e) => {
        e.stopPropagation();
        const fieldId = badge.dataset.fieldId;
        const definitionId = badge.dataset.definitionId;

        // If we have a definition ID, navigate to the definition detail view
        // This allows users to write a definition or link to a URI
        if (definitionId) {
          this._showDefinitionDetail(definitionId);
        } else {
          // No definition yet - show link modal
          this._showDefinitionLinkModal(fieldId);
        }
      });
    });

    // Add description
    document.querySelectorAll('.add-description').forEach(el => {
      el.addEventListener('click', (e) => {
        e.stopPropagation();
        const cell = el.closest('.field-description-cell');
        const fieldId = cell?.dataset.fieldId;
        if (fieldId) {
          this._showEditDescriptionInline(fieldId, cell);
        }
      });
    });

    // Description cells (edit on click)
    document.querySelectorAll('.field-description-cell:not(.empty)').forEach(cell => {
      cell.addEventListener('click', (e) => {
        e.stopPropagation();
        const fieldId = cell.dataset.fieldId;
        this._showEditDescriptionInline(fieldId, cell);
      });
    });

    // Usage badges (show popover)
    document.querySelectorAll('.usage-badge').forEach(badge => {
      badge.addEventListener('click', (e) => {
        e.stopPropagation();
        const fieldId = badge.dataset.fieldId;
        this._showUsagePopover(fieldId, badge);
      });
    });

    // Filter buttons
    document.getElementById('filter-type')?.addEventListener('click', (e) => {
      this._showFilterDropdown('type', e.target.closest('.fields-panel-filter'));
    });

    document.getElementById('filter-definition')?.addEventListener('click', (e) => {
      this._showFilterDropdown('definition', e.target.closest('.fields-panel-filter'));
    });

    // Filter dropdown items
    document.querySelectorAll('.filter-dropdown .filter-dropdown-item').forEach(item => {
      item.addEventListener('click', (e) => {
        const dropdown = item.closest('.filter-dropdown');
        const filterType = dropdown.id.replace('filter-', '').replace('-dropdown', '');
        const value = item.dataset.value;
        this._applyFilter(filterType, value);
        this._hideAllDropdowns();
      });
    });

    // Bulk actions
    document.getElementById('fields-bulk-delete')?.addEventListener('click', () => {
      this._bulkDeleteFields();
    });

    document.getElementById('bulk-link-definition')?.addEventListener('click', () => {
      this._showDefinitionLinkModal(Array.from(this._selectedFieldIds));
    });

    // History panel
    document.getElementById('close-history-panel')?.addEventListener('click', () => {
      this._hideHistoryPanel();
    });

    document.getElementById('field-history-overlay')?.addEventListener('click', () => {
      this._hideHistoryPanel();
    });

    // History filter buttons
    document.querySelectorAll('.field-history-filter').forEach(btn => {
      btn.addEventListener('click', (e) => {
        document.querySelectorAll('.field-history-filter').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        const filter = btn.dataset.filter;
        this._filterHistoryEvents(filter);
      });
    });

    // Definition link modal
    document.getElementById('close-definition-modal')?.addEventListener('click', () => {
      this._hideDefinitionLinkModal();
    });

    document.getElementById('cancel-definition-link')?.addEventListener('click', () => {
      this._hideDefinitionLinkModal();
    });

    document.querySelector('.definition-link-modal-overlay')?.addEventListener('click', () => {
      this._hideDefinitionLinkModal();
    });

    document.getElementById('save-definition-link')?.addEventListener('click', () => {
      this._saveDefinitionLink();
    });

    document.getElementById('unlink-definition-btn')?.addEventListener('click', () => {
      this._unlinkDefinition();
    });

    document.getElementById('definition-search-input')?.addEventListener('input', (e) => {
      this._filterDefinitionsList(e.target.value);
    });

    // Close dropdowns when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.field-actions-dropdown') && !e.target.closest('.field-actions-menu-btn')) {
        this._hideFieldActionsMenu();
      }
      if (!e.target.closest('.filter-dropdown') && !e.target.closest('.fields-panel-filter')) {
        this._hideAllDropdowns();
      }
      if (!e.target.closest('.usage-popover') && !e.target.closest('.usage-badge')) {
        this._hideUsagePopover();
      }
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        this._hideFieldActionsMenu();
        this._hideAllDropdowns();
        this._hideUsagePopover();
        this._hideHistoryPanel();
        this._hideDefinitionLinkModal();
      }
    });
  }

  /**
   * Navigate back to set view
   */
  _navigateToSetView() {
    const set = this.getCurrentSet();
    if (set) {
      this.currentView = 'table';
      this._renderView();
    }
  }

  /**
   * Filter fields table based on search and filters
   */
  _filterFieldsTable() {
    const searchTerm = document.getElementById('fields-panel-search-input')?.value.toLowerCase() || '';
    const typeFilter = this._currentFieldsFilter?.type || 'all';
    const defFilter = this._currentFieldsFilter?.definition || 'all';
    const set = this.getCurrentSet();

    document.querySelectorAll('.field-row').forEach(row => {
      const fieldId = row.dataset.fieldId;
      const field = set?.fields?.find(f => f.id === fieldId);
      if (!field) return;

      // Search filter
      const name = field.name?.toLowerCase() || '';
      const type = field.type?.toLowerCase() || '';
      const description = field.description?.toLowerCase() || '';
      const matchesSearch = !searchTerm ||
        name.includes(searchTerm) ||
        type.includes(searchTerm) ||
        description.includes(searchTerm);

      // Type filter
      const matchesType = typeFilter === 'all' || field.type === typeFilter;

      // Definition filter
      let matchesDef = true;
      if (defFilter === 'linked') {
        matchesDef = !!field.definitionRef;
      } else if (defFilter === 'unlinked') {
        matchesDef = !field.definitionRef;
      }

      row.style.display = (matchesSearch && matchesType && matchesDef) ? '' : 'none';
    });
  }

  /**
   * Update bulk actions bar visibility and count
   */
  _updateBulkBar() {
    const bulkBar = document.getElementById('fields-panel-bulk-bar');
    const countEl = document.getElementById('bulk-count');
    const count = this._selectedFieldIds?.size || 0;

    if (bulkBar) {
      bulkBar.classList.toggle('visible', count > 0);
    }
    if (countEl) {
      countEl.textContent = `${count} selected`;
    }
  }

  /**
   * Update select all checkbox state
   */
  _updateSelectAllCheckbox() {
    const selectAll = document.getElementById('select-all-fields');
    if (!selectAll) return;

    const allCheckboxes = document.querySelectorAll('.field-row .field-checkbox:not(:disabled)');
    const checkedCount = document.querySelectorAll('.field-row .field-checkbox:checked').length;

    selectAll.checked = checkedCount > 0 && checkedCount === allCheckboxes.length;
    selectAll.indeterminate = checkedCount > 0 && checkedCount < allCheckboxes.length;
  }

  /**
   * Show field actions dropdown menu
   */
  _showFieldActionsMenu(fieldId, buttonEl) {
    const dropdown = document.getElementById('field-actions-dropdown');
    if (!dropdown || !buttonEl) return;

    // Store current field ID
    dropdown.dataset.fieldId = fieldId;

    // Check if this is the primary field
    const set = this.getCurrentSet();
    const field = set?.fields?.find(f => f.id === fieldId);
    const isPrimary = field?.isPrimary || set?.fields?.[0]?.id === fieldId;

    // Hide delete option for primary field
    const deleteBtn = dropdown.querySelector('[data-action="delete"]');
    if (deleteBtn) {
      deleteBtn.style.display = isPrimary ? 'none' : '';
    }

    // Position dropdown
    const rect = buttonEl.getBoundingClientRect();
    dropdown.style.top = `${rect.bottom + 4}px`;
    dropdown.style.left = `${rect.right - dropdown.offsetWidth}px`;

    // Show dropdown
    dropdown.classList.add('visible');
  }

  /**
   * Hide field actions menu
   */
  _hideFieldActionsMenu() {
    document.getElementById('field-actions-dropdown')?.classList.remove('visible');
  }

  /**
   * Handle field action from dropdown menu
   */
  _handleFieldAction(action, fieldId) {
    switch (action) {
      case 'edit':
        this._showEditFieldModal(fieldId);
        break;
      case 'duplicate':
        this._duplicateFieldWithHistory(fieldId);
        break;
      case 'link-definition':
        this._showDefinitionLinkModal(fieldId);
        break;
      case 'history':
        this._showFieldHistory(fieldId);
        break;
      case 'copy-id':
        this._copyToClipboard(fieldId);
        this._showToast('Field ID copied to clipboard');
        break;
      case 'delete':
        this._confirmDeleteField(fieldId);
        break;
    }
  }

  /**
   * Show filter dropdown
   */
  _showFilterDropdown(filterType, buttonEl) {
    this._hideAllDropdowns();

    const dropdown = document.getElementById(`filter-${filterType}-dropdown`);
    if (!dropdown || !buttonEl) return;

    const rect = buttonEl.getBoundingClientRect();
    dropdown.style.top = `${rect.bottom + 4}px`;
    dropdown.style.left = `${rect.left}px`;
    dropdown.classList.add('visible');
  }

  /**
   * Hide all dropdowns
   */
  _hideAllDropdowns() {
    document.querySelectorAll('.filter-dropdown').forEach(d => d.classList.remove('visible'));
  }

  /**
   * Apply filter
   */
  _applyFilter(filterType, value) {
    if (!this._currentFieldsFilter) {
      this._currentFieldsFilter = { type: 'all', definition: 'all' };
    }
    this._currentFieldsFilter[filterType] = value;

    // Update button text
    const btn = document.getElementById(`filter-${filterType}`);
    if (btn) {
      const labels = {
        type: { all: 'Type: All' },
        definition: { all: 'Definition: All', linked: 'Has definition', unlinked: 'No definition' }
      };

      let label = labels[filterType]?.[value];
      if (!label && filterType === 'type') {
        const typeNames = {
          'text': 'Text', 'long_text': 'Long text', 'number': 'Number',
          'select': 'Select', 'multi_select': 'Multi-select', 'date': 'Date',
          'checkbox': 'Checkbox', 'link': 'Link', 'attachment': 'Attachment',
          'url': 'URL', 'email': 'Email', 'phone': 'Phone', 'formula': 'Formula',
          'rollup': 'Rollup', 'count': 'Count', 'autonumber': 'Auto #', 'json': 'JSON'
        };
        label = `Type: ${typeNames[value] || value}`;
      }

      btn.innerHTML = `${label} <i class="ph ph-caret-down"></i>`;
      btn.classList.toggle('active', value !== 'all');
    }

    // Update dropdown selection
    const dropdown = document.getElementById(`filter-${filterType}-dropdown`);
    dropdown?.querySelectorAll('.filter-dropdown-item').forEach(item => {
      item.classList.toggle('selected', item.dataset.value === value);
    });

    // Apply filter
    this._filterFieldsTable();
  }

  /**
   * Copy text to clipboard
   */
  _copyToClipboard(text) {
    navigator.clipboard.writeText(text).catch(() => {
      // Fallback for older browsers
      const textarea = document.createElement('textarea');
      textarea.value = text;
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand('copy');
      document.body.removeChild(textarea);
    });
  }

  /**
   * Show usage popover
   */
  _showUsagePopover(fieldId, anchorEl) {
    const popover = document.getElementById('usage-popover');
    const content = document.getElementById('usage-popover-content');
    if (!popover || !content || !anchorEl) return;

    const set = this.getCurrentSet();
    const usage = this._calculateFieldUsage(set)[fieldId];
    if (!usage) return;

    // Build usage content
    let html = '';

    if (usage.viewsList.length > 0) {
      html += `<div class="usage-popover-section">
        <div class="usage-popover-section-title">Views (${usage.views})</div>
        ${usage.viewsList.map(v => `
          <div class="usage-popover-item">
            <i class="ph ph-table"></i>
            ${this._escapeHtml(v.name)}
          </div>
        `).join('')}
      </div>`;
    }

    if (usage.formulasList.length > 0) {
      html += `<div class="usage-popover-section">
        <div class="usage-popover-section-title">Formulas (${usage.formulas})</div>
        ${usage.formulasList.map(f => `
          <div class="usage-popover-item">
            <i class="ph ph-function"></i>
            ${this._escapeHtml(f.name)}
          </div>
        `).join('')}
      </div>`;
    }

    if (usage.rollupsList.length > 0) {
      html += `<div class="usage-popover-section">
        <div class="usage-popover-section-title">Rollups (${usage.rollups})</div>
        ${usage.rollupsList.map(r => `
          <div class="usage-popover-item">
            <i class="ph ph-sigma"></i>
            ${this._escapeHtml(r.name)}
          </div>
        `).join('')}
      </div>`;
    }

    if (usage.filtersList.length > 0) {
      html += `<div class="usage-popover-section">
        <div class="usage-popover-section-title">Filters (${usage.filters})</div>
        ${usage.filtersList.map(f => `
          <div class="usage-popover-item">
            <i class="ph ph-funnel"></i>
            ${this._escapeHtml(f.viewName)}
          </div>
        `).join('')}
      </div>`;
    }

    content.innerHTML = html || '<p style="padding: 16px; text-align: center; color: var(--text-muted);">Not used anywhere</p>';

    // Position popover
    const rect = anchorEl.getBoundingClientRect();
    popover.style.top = `${rect.bottom + 8}px`;
    popover.style.left = `${Math.max(8, rect.left - 100)}px`;
    popover.classList.add('visible');
  }

  /**
   * Hide usage popover
   */
  _hideUsagePopover() {
    document.getElementById('usage-popover')?.classList.remove('visible');
  }

  /**
   * Show inline description editor
   */
  _showEditDescriptionInline(fieldId, cell) {
    const set = this.getCurrentSet();
    const field = set?.fields?.find(f => f.id === fieldId);
    if (!field || !cell) return;

    const currentDesc = field.description || '';

    // Create inline input
    const input = document.createElement('input');
    input.type = 'text';
    input.value = currentDesc;
    input.placeholder = 'Add description...';
    input.style.cssText = `
      width: 100%;
      padding: 4px 8px;
      border: 1px solid var(--primary-400);
      border-radius: 4px;
      font-size: 13px;
      background: var(--bg-primary);
      color: var(--text-primary);
      outline: none;
    `;

    cell.innerHTML = '';
    cell.appendChild(input);
    input.focus();
    input.select();

    const saveDescription = () => {
      const newDesc = input.value.trim();
      if (newDesc !== currentDesc) {
        this._updateFieldDescription(fieldId, newDesc);
      }
      // Re-render the cell
      cell.innerHTML = newDesc
        ? this._escapeHtml(newDesc)
        : '<span class="add-description">Add description</span>';
      cell.classList.toggle('empty', !newDesc);

      // Re-attach click handler
      if (!newDesc) {
        cell.querySelector('.add-description')?.addEventListener('click', (e) => {
          e.stopPropagation();
          this._showEditDescriptionInline(fieldId, cell);
        });
      }
    };

    input.addEventListener('blur', saveDescription);
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        input.blur();
      }
      if (e.key === 'Escape') {
        input.value = currentDesc;
        input.blur();
      }
    });
  }

  /**
   * Update field description
   */
  _updateFieldDescription(fieldId, description) {
    const set = this.getCurrentSet();
    const field = set?.fields?.find(f => f.id === fieldId);
    if (!field) return;

    const oldDescription = field.description;
    field.description = description;

    // Record event
    this._recordFieldEvent(fieldId, 'field.description_changed', {
      description: { from: oldDescription || '', to: description }
    });

    // Record activity for field description update
    this._recordActivity({
      action: 'update',
      entityType: 'field',
      name: field.name,
      details: `Updated description for field "${field.name}" in "${set.name}"`,
      canReverse: false
    });

    this._saveData();
  }

  /**
   * Bulk delete fields
   */
  _bulkDeleteFields() {
    const count = this._selectedFieldIds?.size || 0;
    if (count === 0) return;

    const fieldIds = Array.from(this._selectedFieldIds);
    fieldIds.forEach(fieldId => {
      this._deleteField(fieldId);
    });

    this._selectedFieldIds.clear();
    this._renderSetFieldsPanel();
    this._showToast(`${count} field${count > 1 ? 's' : ''} deleted`);
  }

  /**
   * Record a field event to the event stream
   */
  _recordFieldEvent(fieldId, eventType, changes, metadata = {}) {
    const set = this.getCurrentSet();
    if (!set) return null;

    const field = set.fields?.find(f => f.id === fieldId);

    // Initialize event stream if needed
    if (!set.eventStream) {
      set.eventStream = [];
    }

    const event = {
      id: `evt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: eventType,
      timestamp: new Date().toISOString(),
      actor: {
        type: 'user',
        name: 'User' // In a real app, this would be the current user
      },
      target: {
        setId: set.id,
        fieldId: fieldId,
        fieldName: field?.name || 'Unknown'
      },
      changes: changes,
      metadata: {
        source: 'field_manager',
        ...metadata
      }
    };

    set.eventStream.push(event);
    return event;
  }

  /**
   * Get current actor (user info)
   */
  _getCurrentActor() {
    return {
      type: 'user',
      name: 'User'
    };
  }

  /**
   * Show field history panel
   */
  _showFieldHistory(fieldId) {
    const set = this.getCurrentSet();
    const field = set?.fields?.find(f => f.id === fieldId);
    if (!field) return;

    // Store current field for history panel
    this._currentHistoryFieldId = fieldId;

    // Update header
    document.getElementById('history-field-name').textContent = field.name;
    document.getElementById('history-field-type').textContent = this._getFieldTypeName(field.type);

    // Render history
    this._renderFieldHistory(fieldId);

    // Show panel
    document.getElementById('field-history-overlay')?.classList.add('visible');
    document.getElementById('field-history-panel')?.classList.add('visible');
  }

  /**
   * Hide field history panel
   */
  _hideHistoryPanel() {
    document.getElementById('field-history-overlay')?.classList.remove('visible');
    document.getElementById('field-history-panel')?.classList.remove('visible');
    this._currentHistoryFieldId = null;
  }

  /**
   * Render field history timeline
   */
  _renderFieldHistory(fieldId, filter = 'all') {
    const set = this.getCurrentSet();
    const content = document.getElementById('field-history-content');
    if (!content || !set) return;

    // Get events for this field
    let events = (set.eventStream || [])
      .filter(e => e.target?.fieldId === fieldId)
      .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

    // Apply filter
    if (filter !== 'all') {
      const filterMap = {
        'rename': ['field.renamed'],
        'type': ['field.type_changed'],
        'definition': ['field.definition_linked', 'field.definition_unlinked']
      };
      const allowedTypes = filterMap[filter] || [];
      events = events.filter(e => allowedTypes.includes(e.type));
    }

    if (events.length === 0) {
      content.innerHTML = `
        <div class="history-empty">
          <i class="ph ph-clock-counter-clockwise"></i>
          <p>No history recorded yet</p>
        </div>
      `;
      return;
    }

    // Group events by date
    const groupedEvents = {};
    events.forEach(event => {
      const date = new Date(event.timestamp);
      const dateKey = this._formatDateKey(date);
      if (!groupedEvents[dateKey]) {
        groupedEvents[dateKey] = [];
      }
      groupedEvents[dateKey].push(event);
    });

    // Build timeline HTML
    let html = '<div class="history-timeline">';

    for (const [dateKey, dateEvents] of Object.entries(groupedEvents)) {
      html += `
        <div class="history-date-group">
          <div class="history-date-header">
            <div class="history-date-dot"></div>
            <span class="history-date-text">${dateKey}</span>
          </div>
          <div class="history-events">
      `;

      dateEvents.forEach(event => {
        const eventInfo = this._getEventDisplayInfo(event);
        const time = new Date(event.timestamp).toLocaleTimeString('en-US', {
          hour: 'numeric',
          minute: '2-digit',
          hour12: true
        });

        html += `
          <div class="history-event" data-event-type="${event.type}">
            <div class="history-event-header">
              <div class="history-event-icon ${eventInfo.iconClass}">
                <i class="ph ${eventInfo.icon}"></i>
              </div>
              <span class="history-event-type">${eventInfo.label}</span>
              <span class="history-event-time">${time}</span>
            </div>
            <div class="history-event-actor">${event.actor?.name || 'System'}</div>
            ${eventInfo.changesHtml ? `
              <div class="history-event-changes">
                ${eventInfo.changesHtml}
              </div>
            ` : ''}
          </div>
        `;
      });

      html += '</div></div>';
    }

    html += '</div>';
    content.innerHTML = html;
  }

  /**
   * Format date for grouping
   */
  _formatDateKey(date) {
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);

    const eventDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());

    if (eventDate.getTime() === today.getTime()) {
      return 'Today';
    } else if (eventDate.getTime() === yesterday.getTime()) {
      return 'Yesterday';
    } else {
      return date.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
    }
  }

  /**
   * Get display info for an event
   */
  _getEventDisplayInfo(event) {
    const info = {
      icon: 'ph-clock',
      iconClass: '',
      label: 'Changed',
      changesHtml: ''
    };

    switch (event.type) {
      case 'field.created':
        info.icon = 'ph-plus-circle';
        info.iconClass = 'created';
        info.label = 'Field created';
        if (event.changes?.type) {
          info.changesHtml = `<div class="history-change-row">
            <span class="history-change-label">Type:</span>
            <span class="history-change-to">${this._getFieldTypeName(event.changes.type)}</span>
          </div>`;
        }
        break;

      case 'field.renamed':
        info.icon = 'ph-pencil-simple';
        info.iconClass = 'renamed';
        info.label = 'Renamed';
        if (event.changes?.name) {
          info.changesHtml = `<div class="history-change-row">
            <span class="history-change-from">${this._escapeHtml(event.changes.name.from)}</span>
            <span class="history-change-arrow">→</span>
            <span class="history-change-to">${this._escapeHtml(event.changes.name.to)}</span>
          </div>`;
        }
        break;

      case 'field.type_changed':
        info.icon = 'ph-swap';
        info.iconClass = 'type-changed';
        info.label = 'Type changed';
        if (event.changes?.type) {
          info.changesHtml = `<div class="history-change-row">
            <span class="history-change-from">${this._getFieldTypeName(event.changes.type.from)}</span>
            <span class="history-change-arrow">→</span>
            <span class="history-change-to">${this._getFieldTypeName(event.changes.type.to)}</span>
          </div>`;
        }
        break;

      case 'field.description_changed':
        info.icon = 'ph-text-aa';
        info.iconClass = 'renamed';
        info.label = 'Description updated';
        if (event.changes?.description) {
          const from = event.changes.description.from || '(empty)';
          const to = event.changes.description.to || '(empty)';
          info.changesHtml = `<div class="history-change-row">
            <span class="history-change-from">${this._escapeHtml(from)}</span>
            <span class="history-change-arrow">→</span>
            <span class="history-change-to">${this._escapeHtml(to)}</span>
          </div>`;
        }
        break;

      case 'field.definition_linked':
        info.icon = 'ph-link';
        info.iconClass = 'definition';
        info.label = 'Linked to definition';
        if (event.changes?.definition) {
          info.changesHtml = `<div class="history-change-row">
            <span class="history-change-label">Definition:</span>
            <span class="history-change-to">${this._escapeHtml(event.changes.definition.name || 'Unknown')}</span>
          </div>`;
          if (event.changes.definition.uri) {
            info.changesHtml += `<div class="history-change-row">
              <span class="history-change-label">URI:</span>
              <span style="font-family: var(--font-mono); font-size: 11px;">${this._escapeHtml(event.changes.definition.uri)}</span>
            </div>`;
          }
        }
        break;

      case 'field.definition_unlinked':
        info.icon = 'ph-link-break';
        info.iconClass = 'deleted';
        info.label = 'Definition unlinked';
        break;

      case 'field.options_changed':
        info.icon = 'ph-sliders';
        info.iconClass = 'options';
        info.label = 'Options updated';
        break;

      case 'field.deleted':
        info.icon = 'ph-trash';
        info.iconClass = 'deleted';
        info.label = 'Field deleted';
        break;

      case 'field.restored':
        info.icon = 'ph-arrow-counter-clockwise';
        info.iconClass = 'restored';
        info.label = 'Field restored';
        break;

      case 'field.duplicated':
        info.icon = 'ph-copy';
        info.iconClass = 'created';
        info.label = 'Field duplicated';
        if (event.changes?.sourceField) {
          info.changesHtml = `<div class="history-change-row">
            <span class="history-change-label">From:</span>
            <span class="history-change-to">${this._escapeHtml(event.changes.sourceField)}</span>
          </div>`;
        }
        break;
    }

    return info;
  }

  /**
   * Get field type display name
   */
  _getFieldTypeName(type) {
    const typeNames = {
      'text': 'Single line text',
      'long_text': 'Long text',
      'number': 'Number',
      'select': 'Single select',
      'multi_select': 'Multiple select',
      'date': 'Date',
      'checkbox': 'Checkbox',
      'link': 'Link to another record',
      'attachment': 'Attachment',
      'url': 'URL',
      'email': 'Email',
      'phone': 'Phone',
      'formula': 'Formula',
      'rollup': 'Rollup',
      'count': 'Count',
      'autonumber': 'Auto number',
      'json': 'JSON'
    };
    return typeNames[type] || type || 'Unknown';
  }

  /**
   * Filter history events
   */
  _filterHistoryEvents(filter) {
    if (this._currentHistoryFieldId) {
      this._renderFieldHistory(this._currentHistoryFieldId, filter);
    }
  }

  /**
   * Duplicate a field with history tracking
   */
  _duplicateFieldWithHistory(fieldId) {
    const set = this.getCurrentSet();
    const field = set?.fields?.find(f => f.id === fieldId);
    if (!field) return;

    const newField = createField(`${field.name} (copy)`, field.type, { ...field.options });
    if (field.description) {
      newField.description = field.description;
    }
    set.fields.push(newField);

    // Copy values to new field
    set.records?.forEach(record => {
      if (record.values[fieldId] !== undefined) {
        record.values[newField.id] = JSON.parse(JSON.stringify(record.values[fieldId]));
      }
    });

    // Record event for the new field
    this._recordFieldEvent(newField.id, 'field.duplicated', {
      sourceField: field.name,
      sourceFieldId: fieldId,
      type: field.type
    });

    this._saveData();
    this._renderSetFieldsPanel();
    this._showToast(`Duplicated field "${field.name}"`, 'success');
  }

  /**
   * Show definition link modal
   */
  _showDefinitionLinkModal(fieldIdOrIds) {
    const fieldIds = Array.isArray(fieldIdOrIds) ? fieldIdOrIds : [fieldIdOrIds];
    this._definitionLinkFieldIds = fieldIds;
    this._selectedDefinitionTerm = null;

    const set = this.getCurrentSet();
    const field = fieldIds.length === 1 ? set?.fields?.find(f => f.id === fieldIds[0]) : null;

    // Update unlink button visibility
    const unlinkBtn = document.getElementById('unlink-definition-btn');
    if (unlinkBtn) {
      unlinkBtn.style.display = (field?.definitionRef) ? '' : 'none';
    }

    // Render definitions list
    this._renderDefinitionsList();

    // Show modal
    document.getElementById('definition-link-modal')?.classList.add('visible');

    // Focus search
    setTimeout(() => {
      document.getElementById('definition-search-input')?.focus();
    }, 100);
  }

  /**
   * Hide definition link modal
   */
  _hideDefinitionLinkModal() {
    document.getElementById('definition-link-modal')?.classList.remove('visible');
    this._definitionLinkFieldIds = null;
    this._selectedDefinitionTerm = null;
  }

  /**
   * Render definitions list in modal
   */
  _renderDefinitionsList(searchTerm = '') {
    const list = document.getElementById('definition-link-list');
    if (!list) return;

    const definitions = this.definitions || [];
    const search = searchTerm.toLowerCase();

    if (definitions.length === 0) {
      list.innerHTML = `
        <div class="definition-link-empty">
          <i class="ph ph-books"></i>
          <p>No definitions available</p>
          <p style="font-size: 12px; margin-top: 4px;">Import a definition from the TERMS panel first</p>
        </div>
      `;
      return;
    }

    let html = '';

    definitions.forEach(def => {
      const terms = def.terms || [];
      const matchingTerms = terms.filter(term =>
        !search ||
        term.name?.toLowerCase().includes(search) ||
        term.description?.toLowerCase().includes(search) ||
        def.name?.toLowerCase().includes(search)
      );

      if (matchingTerms.length === 0 && search) return;

      html += `
        <div class="definition-link-section">
          <div class="definition-link-section-title">${this._escapeHtml(def.name)} (${terms.length} terms)</div>
          ${(search ? matchingTerms : terms).map(term => `
            <div class="definition-link-item" data-definition-id="${def.id}" data-term-id="${term.id}">
              <div class="definition-link-item-icon">
                <i class="ph ph-tag"></i>
              </div>
              <div class="definition-link-item-info">
                <div class="definition-link-item-name">${this._escapeHtml(term.name)}</div>
                ${term.description ? `<div class="definition-link-item-meta">${this._escapeHtml(term.description)}</div>` : ''}
                ${term.uri ? `<div class="definition-link-item-uri">${this._escapeHtml(term.uri)}</div>` : ''}
              </div>
            </div>
          `).join('')}
        </div>
      `;
    });

    if (!html) {
      html = `
        <div class="definition-link-empty">
          <i class="ph ph-magnifying-glass"></i>
          <p>No matching terms found</p>
        </div>
      `;
    }

    list.innerHTML = html;

    // Attach click handlers
    list.querySelectorAll('.definition-link-item').forEach(item => {
      item.addEventListener('click', () => {
        // Toggle selection
        list.querySelectorAll('.definition-link-item').forEach(i => i.classList.remove('selected'));
        item.classList.add('selected');

        this._selectedDefinitionTerm = {
          definitionId: item.dataset.definitionId,
          termId: item.dataset.termId
        };

        // Enable save button
        document.getElementById('save-definition-link').disabled = false;
      });
    });
  }

  /**
   * Filter definitions list
   */
  _filterDefinitionsList(searchTerm) {
    this._renderDefinitionsList(searchTerm);
  }

  /**
   * Save definition link
   */
  _saveDefinitionLink() {
    if (!this._selectedDefinitionTerm || !this._definitionLinkFieldIds) return;

    const { definitionId, termId } = this._selectedDefinitionTerm;
    const definitions = this.definitions || [];
    const definition = definitions.find(d => d.id === definitionId);
    const term = definition?.terms?.find(t => t.id === termId);

    if (!definition || !term) return;

    const set = this.getCurrentSet();
    if (!set) return;

    // Apply to all selected fields
    this._definitionLinkFieldIds.forEach(fieldId => {
      const field = set.fields?.find(f => f.id === fieldId);
      if (!field) return;

      const oldRef = field.definitionRef;

      // Update field
      field.definitionRef = {
        definitionId: definitionId,
        termId: termId,
        uri: term.uri || null,
        lastSyncedAt: new Date().toISOString()
      };

      // Record event
      this._recordFieldEvent(fieldId, 'field.definition_linked', {
        definition: {
          id: definitionId,
          name: definition.name,
          termId: termId,
          termName: term.name,
          uri: term.uri
        },
        previousDefinition: oldRef ? {
          id: oldRef.definitionId,
          termId: oldRef.termId
        } : null
      });
    });

    this._saveData();
    this._hideDefinitionLinkModal();
    this._renderSetFieldsPanel();

    const count = this._definitionLinkFieldIds.length;
    this._showToast(`Linked ${count} field${count > 1 ? 's' : ''} to "${term.name}"`);
  }

  /**
   * Unlink definition from field
   */
  _unlinkDefinition() {
    if (!this._definitionLinkFieldIds) return;

    const set = this.getCurrentSet();
    if (!set) return;

    this._definitionLinkFieldIds.forEach(fieldId => {
      const field = set.fields?.find(f => f.id === fieldId);
      if (!field || !field.definitionRef) return;

      // Record event before removing
      this._recordFieldEvent(fieldId, 'field.definition_unlinked', {
        previousDefinition: {
          definitionId: field.definitionRef.definitionId,
          termId: field.definitionRef.termId,
          uri: field.definitionRef.uri
        }
      });

      // Remove definition ref
      delete field.definitionRef;
    });

    this._saveData();
    this._hideDefinitionLinkModal();
    this._renderSetFieldsPanel();

    const count = this._definitionLinkFieldIds.length;
    this._showToast(`Unlinked definition from ${count} field${count > 1 ? 's' : ''}`);
  }

  /**
   * Show modal to add a new field
   */
  _showAddFieldModal() {
    // Create a fake button element to position the field type picker
    const container = document.querySelector('.fields-panel-toolbar') || document.querySelector('.fields-panel-container');
    if (container) {
      const rect = container.getBoundingClientRect();
      this._showFieldTypePicker({ clientX: rect.left + 10, clientY: rect.top + 50 }, null, {
        left: rect.left + 10,
        top: rect.top + 50
      });
    } else {
      // Fallback: center of screen
      this._showFieldTypePicker({ clientX: window.innerWidth / 2, clientY: 200 }, null, {
        left: window.innerWidth / 2 - 120,
        top: 200
      });
    }
  }

  /**
   * Show modal to configure/edit a field
   */
  _showFieldConfigModal(field) {
    // For formula fields, use the dedicated formula editor
    if (field.type === FieldTypes.FORMULA) {
      this._showFormulaEditor(field);
      return;
    }

    // For other field types, use the rename field modal for now
    // In the future, this could be expanded to show more field options
    this._showRenameFieldModal(field.id);
  }

  /**
   * Show modal to edit a field
   */
  _showEditFieldModal(fieldId) {
    const set = this.getCurrentSet();
    const field = set?.fields.find(f => f.id === fieldId);
    if (!field) return;

    // Use existing field modal if available, or show simple rename
    this._showFieldConfigModal(field);
  }

  /**
   * Duplicate a field
   */
  _duplicateField(fieldId) {
    const set = this.getCurrentSet();
    const field = set?.fields.find(f => f.id === fieldId);
    if (!field) return;

    const newField = createField(`${field.name} (copy)`, field.type, { ...field.options });
    set.fields.push(newField);

    // Copy values to new field
    set.records.forEach(record => {
      if (record.values[fieldId] !== undefined) {
        record.values[newField.id] = JSON.parse(JSON.stringify(record.values[fieldId]));
      }
    });

    this._saveData();
    this._renderView();
    this._showToast(`Duplicated field "${field.name}"`, 'success');
  }

  /**
   * Confirm and delete a field
   */
  _confirmDeleteField(fieldId) {
    this._deleteField(fieldId);
  }

  /**
   * Get HTML for compact view tabs header (Airtable-style)
   * Shows tabs for existing views with add button
   */
  _getViewTabsHeaderHTML() {
    const set = this.getCurrentSet();
    if (!set) return '';

    const views = set.views || [];
    const currentViewId = this.currentViewId;

    const viewTypeIcons = {
      'grid': 'ph-table',
      'table': 'ph-table',
      'cards': 'ph-cards',
      'kanban': 'ph-kanban',
      'calendar': 'ph-calendar-blank',
      'graph': 'ph-graph',
      'filesystem': 'ph-folder-open',
      'timeline': 'ph-clock-countdown',
      'pipeline': 'ph-cooking-pot',
      'flow': 'ph-flow-arrow'
    };

    const viewTabs = views.map(view => {
      const isActive = view.id === currentViewId;
      const icon = viewTypeIcons[view.type] || 'ph-table';
      return `
        <button class="view-tab ${isActive ? 'active' : ''}"
                data-view-id="${view.id}"
                draggable="true"
                title="${this._escapeHtml(view.name)} (${view.type})">
          <i class="ph ${icon}"></i>
          <span class="view-tab-name">${this._escapeHtml(view.name)}</span>
        </button>
      `;
    }).join('');

    return `
      <div class="view-tabs-header">
        <div class="view-tabs-scroll">
          ${viewTabs}
        </div>
        <button class="view-tabs-add" id="view-tabs-add-btn" title="Add view">
          <i class="ph ph-plus"></i>
        </button>
        <div class="view-search-container">
          <i class="ph ph-magnifying-glass view-search-icon"></i>
          <input type="text"
                 class="view-search-input"
                 id="view-search-input"
                 placeholder="Search in view..."
                 value="${this._escapeHtml(this.viewSearchTerm)}"
                 autocomplete="off">
          ${this.viewSearchTerm ? `<button class="view-search-clear" id="view-search-clear" title="Clear search">
            <i class="ph ph-x"></i>
          </button>` : ''}
        </div>
      </div>
    `;
  }

  /**
   * Inject view tabs header above the tab toolbar
   * Views come first (what you're looking at), then actions (how you manipulate it)
   */
  _injectViewTabsHeader() {
    const tabToolbar = document.getElementById('tab-toolbar');
    if (!tabToolbar) return;

    // Don't inject if we're in file explorer mode
    if (this.fileExplorerMode) return;

    // Don't inject if we're on empty state or no current set
    const set = this.getCurrentSet();
    if (!set) return;

    // Check if header already exists (now at document level, before tab-toolbar)
    const existingHeader = document.querySelector('.view-tabs-header');
    if (existingHeader) {
      existingHeader.remove();
    }

    // Inject before tab-toolbar (views first, then actions)
    const headerHTML = this._getViewTabsHeaderHTML();
    tabToolbar.insertAdjacentHTML('beforebegin', headerHTML);

    // Attach event handlers
    this._attachViewTabsHandlers();
  }

  /**
   * Attach event handlers for view tabs
   */
  _attachViewTabsHandlers() {
    const header = document.querySelector('.view-tabs-header');
    if (!header) return;

    const scrollContainer = header.querySelector('.view-tabs-scroll');

    // View tab clicks and drag-and-drop
    header.querySelectorAll('.view-tab').forEach(tab => {
      const viewId = tab.dataset.viewId;

      // Click to activate
      tab.addEventListener('click', (e) => {
        if (viewId && viewId !== this.currentViewId) {
          this._selectView(viewId);
        }
      });

      // Drag and drop for reordering
      tab.addEventListener('dragstart', (e) => {
        e.dataTransfer.setData('text/plain', viewId);
        tab.classList.add('dragging');
      });

      tab.addEventListener('dragend', () => {
        tab.classList.remove('dragging');
        header.querySelectorAll('.view-tab').forEach(t => {
          t.classList.remove('drag-over', 'drag-over-right');
        });
      });

      tab.addEventListener('dragover', (e) => {
        e.preventDefault();
        const draggingTab = header.querySelector('.view-tab.dragging');
        if (draggingTab && draggingTab !== tab) {
          const rect = tab.getBoundingClientRect();
          const midpoint = rect.left + rect.width / 2;
          tab.classList.remove('drag-over', 'drag-over-right');
          if (e.clientX < midpoint) {
            tab.classList.add('drag-over');
          } else {
            tab.classList.add('drag-over-right');
          }
        }
      });

      tab.addEventListener('dragleave', () => {
        tab.classList.remove('drag-over', 'drag-over-right');
      });

      tab.addEventListener('drop', (e) => {
        e.preventDefault();
        const draggedViewId = e.dataTransfer.getData('text/plain');
        const set = this.getCurrentSet();
        if (!set) return;
        const targetIndex = set.views.findIndex(v => v.id === viewId);
        const rect = tab.getBoundingClientRect();
        const insertAfter = e.clientX >= rect.left + rect.width / 2;
        this._moveView(draggedViewId, insertAfter ? targetIndex + 1 : targetIndex);
        tab.classList.remove('drag-over', 'drag-over-right');
      });
    });

    // Add view button
    const addBtn = header.querySelector('#view-tabs-add-btn');
    addBtn?.addEventListener('click', (e) => {
      e.stopPropagation();
      this._showCreateViewModal();
    });

    // Search input
    const searchInput = header.querySelector('#view-search-input');
    searchInput?.addEventListener('input', (e) => {
      this._handleViewSearch(e.target.value);
    });

    // Search clear button
    const clearBtn = header.querySelector('#view-search-clear');
    clearBtn?.addEventListener('click', (e) => {
      e.stopPropagation();
      this._clearViewSearch();
    });

    // Handle keyboard shortcuts in search input
    searchInput?.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        this._clearViewSearch();
        searchInput.blur();
      }
    });
  }

  _renderEmptyState() {
    this.elements.contentArea.innerHTML = `
      <div class="data-import-landing">
        <div class="import-section import-section-secondary">
          <button class="btn btn-secondary" id="empty-import-data">
            <i class="ph ph-download"></i>
            Import CSV, JSON, or Excel
          </button>
          <button class="btn btn-secondary" id="empty-create-set">
            <i class="ph ph-plus"></i>
            Create Empty Set
          </button>
        </div>
      </div>
    `;

    document.getElementById('empty-create-set')?.addEventListener('click', () => {
      this._showNewSetModal();
    });

    document.getElementById('empty-import-data')?.addEventListener('click', () => {
      this._showImportModal();
    });
  }

  // --------------------------------------------------------------------------
  // Table View
  // --------------------------------------------------------------------------

  _renderTableView() {
    const set = this.getCurrentSet();
    const baseRecords = this.getFilteredRecords();
    const view = this.getCurrentView();
    const searchTerm = this.viewSearchTerm;

    // TABLE RULE 1 & 3: Validate all fields before rendering to guarantee width and required properties
    const fields = ensureValidFields(this._getVisibleFields());

    // Apply search filter
    let allRecords = baseRecords;
    if (searchTerm) {
      allRecords = baseRecords.filter(record => {
        const { matches } = this._recordMatchesSearch(record, searchTerm, set?.fields || []);
        return matches;
      });
    }

    // TABLE RULE 2: Ensure all records have values for all fields
    allRecords = allRecords.map(record => ensureRecordValues(record, fields));

    // Always show provenance column for data with sources
    const hasProvenance = set?.datasetProvenance?.originalFilename || allRecords.some(r => r.provenance);
    const showProvenance = view?.config.showProvenance !== false && hasProvenance;

    // Implement chunked loading for large datasets
    const totalRecords = allRecords.length;
    const displayCount = Math.min(this.displayedRecordCount, totalRecords);
    const records = allRecords.slice(0, displayCount);
    const hasMoreRecords = displayCount < totalRecords;
    const remainingRecords = totalRecords - displayCount;

    // Determine if all records are selected for the select-all checkbox
    const allSelected = records.length > 0 && records.every(r => this.selectedRecords.has(r.id));
    const someSelected = records.some(r => this.selectedRecords.has(r.id));

    let html = `
      <div class="data-table-container">
        <table class="data-table">
          <thead>
            <tr>
              <th class="col-row-number">
                <input type="checkbox" class="row-checkbox" id="select-all"
                       ${allSelected ? 'checked' : ''}
                       ${someSelected && !allSelected ? 'data-indeterminate="true"' : ''}>
              </th>
              ${showProvenance ? `
                <th class="col-provenance col-source" style="width: ${view?.config?.sourceColumnWidth || 120}px; position: relative;" title="Data source and provenance">
                  <div class="th-content">
                    <i class="ph ph-git-branch"></i>
                    <span class="field-name">Source</span>
                  </div>
                  <div class="th-resize-handle" data-column-type="source"></div>
                </th>
              ` : ''}
              ${fields.map(field => `
                <th style="width: ${field.width}px; position: relative;"
                    data-field-id="${field.id}">
                  <div class="th-content">
                    <i class="ph ${FieldTypeIcons[field.type] || 'ph-text-aa'}"></i>
                    <span class="field-name">${this._escapeHtml(field.name)}</span>
                    <button class="th-dropdown">
                      <i class="ph ph-caret-down"></i>
                    </button>
                  </div>
                  <div class="th-resize-handle"></div>
                </th>
              `).join('')}
              <th class="col-add" id="add-column-btn" title="Add a new field/column">
                <div class="add-column-content">
                  <i class="ph ph-columns-plus-right"></i>
                  <span class="add-column-label">Add field</span>
                </div>
              </th>
            </tr>
          </thead>
          <tbody>
    `;

    if (allRecords.length === 0 && !searchTerm) {
      html += `
        <tr>
          <td colspan="${fields.length + (showProvenance ? 3 : 2)}" class="add-row-cell" id="add-first-record" title="Add a new record/row (Ctrl+N)" onclick="getDataWorkbench()?.addRecord()">
            <div class="add-row-content">
              <i class="ph ph-rows-plus-bottom"></i>
              <span>Add your first record</span>
            </div>
          </td>
        </tr>
      `;
    } else if (allRecords.length === 0 && searchTerm) {
      html += `
        <tr>
          <td colspan="${fields.length + (showProvenance ? 3 : 2)}" class="search-no-results">
            <div class="search-no-results-content">
              <i class="ph ph-magnifying-glass"></i>
              <span>No records match "${this._escapeHtml(searchTerm)}"</span>
              <button class="btn btn-secondary btn-sm" id="clear-search-btn">Clear search</button>
            </div>
          </td>
        </tr>
      `;
    } else {
      // Check for grouping configuration
      const groupFieldId = view?.config?.groupByFieldId;
      const groupField = groupFieldId ? set?.fields?.find(f => f.id === groupFieldId) : null;
      const colspanAll = fields.length + (showProvenance ? 3 : 2);

      if (groupField) {
        // Grouped table rendering (Airtable-style)
        const groupedRecords = this._groupRecordsByField(records, groupField);

        groupedRecords.forEach((group, groupIndex) => {
          const isCollapsed = this.collapsedTableGroups.has(group.key);
          const groupRecordCount = group.records.length;

          // Render group header row
          html += `
            <tr class="table-group-header-row" data-group-key="${this._escapeHtml(group.key)}">
              <td colspan="${colspanAll}" class="table-group-header-cell">
                <div class="table-group-header">
                  <button class="table-group-toggle" data-group-key="${this._escapeHtml(group.key)}">
                    <i class="ph ${isCollapsed ? 'ph-caret-right' : 'ph-caret-down'}"></i>
                  </button>
                  ${group.color ? `<span class="select-tag color-${group.color}">${this._escapeHtml(group.displayName)}</span>` : `<span class="table-group-name">${this._escapeHtml(group.displayName)}</span>`}
                  <span class="table-group-count">${groupRecordCount}</span>
                </div>
              </td>
            </tr>
          `;

          // Render records in this group (if not collapsed)
          if (!isCollapsed) {
            group.records.forEach((record, index) => {
              const isSelected = this.selectedRecords.has(record.id);
              const sourceInfo = showProvenance ? this._getRecordSourceInfo(record, set) : null;
              html += `
                <tr data-record-id="${record.id}" data-group-key="${this._escapeHtml(group.key)}" class="${isSelected ? 'selected' : ''}">
                  <td class="col-row-number">
                    <input type="checkbox" class="row-checkbox"
                           data-record-id="${record.id}"
                           ${isSelected ? 'checked' : ''}>
                  </td>
                  ${showProvenance ? `
                    <td class="col-provenance col-source"
                        style="width: ${view?.config?.sourceColumnWidth || 120}px;"
                        data-record-id="${record.id}"
                        data-source-id="${this._escapeHtml(sourceInfo.sourceId)}"
                        title="${this._escapeHtml(sourceInfo.tooltip)}">
                      <div class="provenance-cell">
                        <span class="provenance-icon ${sourceInfo.type}">${sourceInfo.icon}</span>
                        <span class="provenance-source-name" data-source="${this._escapeHtml(sourceInfo.source)}" data-source-id="${this._escapeHtml(sourceInfo.sourceId)}">${this._escapeHtml(sourceInfo.shortName)}</span>
                      </div>
                    </td>
                  ` : ''}
                  ${fields.map(field => this._renderCell(record, field, searchTerm)).join('')}
                  <td class="col-add"></td>
                </tr>
              `;
            });
          }
        });
      } else {
        // Flat table rendering (no grouping)
        records.forEach((record, index) => {
          const isSelected = this.selectedRecords.has(record.id);
          const sourceInfo = showProvenance ? this._getRecordSourceInfo(record, set) : null;
          html += `
            <tr data-record-id="${record.id}" class="${isSelected ? 'selected' : ''}">
              <td class="col-row-number">
                <input type="checkbox" class="row-checkbox"
                       data-record-id="${record.id}"
                       ${isSelected ? 'checked' : ''}>
              </td>
              ${showProvenance ? `
                <td class="col-provenance col-source"
                    style="width: ${view?.config?.sourceColumnWidth || 120}px;"
                    data-record-id="${record.id}"
                    data-source-id="${this._escapeHtml(sourceInfo.sourceId)}"
                    title="${this._escapeHtml(sourceInfo.tooltip)}">
                  <div class="provenance-cell">
                    <span class="provenance-icon ${sourceInfo.type}">${sourceInfo.icon}</span>
                    <span class="provenance-source-name" data-source="${this._escapeHtml(sourceInfo.source)}" data-source-id="${this._escapeHtml(sourceInfo.sourceId)}">${this._escapeHtml(sourceInfo.shortName)}</span>
                  </div>
                </td>
              ` : ''}
              ${fields.map(field => this._renderCell(record, field, searchTerm)).join('')}
              <td class="col-add"></td>
            </tr>
          `;
        });
      }

      // Load More button if there are more records
      if (hasMoreRecords) {
        const loadMoreCount = Math.min(this.recordBatchSize, remainingRecords);
        html += `
          <tr class="load-more-row">
            <td colspan="${colspanAll}" class="load-more-cell">
              <button class="load-more-btn" id="load-more-records">
                <i class="ph ph-caret-down"></i>
                <span>Load ${loadMoreCount.toLocaleString()} more</span>
                <span class="load-more-remaining">(${remainingRecords.toLocaleString()} remaining)</span>
              </button>
              <button class="load-all-btn" id="load-all-records">
                <i class="ph ph-list"></i>
                <span>Load all ${totalRecords.toLocaleString()}</span>
              </button>
            </td>
          </tr>
        `;
      }

      // Add row button at the end
      html += `
        <tr>
          <td class="col-row-number add-row-cell" id="add-row-btn" title="Add a new record/row (Ctrl+N)" onclick="getDataWorkbench()?.addRecord()">
            <i class="ph ph-rows-plus-bottom"></i>
          </td>
          <td colspan="${fields.length + (showProvenance ? 2 : 1)}" class="add-row-cell" id="add-row-cell" title="Add a new record/row (Ctrl+N)" onclick="getDataWorkbench()?.addRecord()">
            <div class="add-row-content">
              <i class="ph ph-rows-plus-bottom"></i>
              <span>Add record</span>
            </div>
          </td>
        </tr>
      `;
    }

    html += '</tbody></table></div>';

    this.elements.contentArea.innerHTML = html;
    this._attachTableEventListeners();
    this._attachProvenanceClickHandlers();
    this._attachLoadMoreHandlers();
    this._attachAddRecordHandlers();

    // Update select-all checkbox indeterminate state
    const selectAllCheckbox = document.getElementById('select-all');
    if (selectAllCheckbox && someSelected && !allSelected) {
      selectAllCheckbox.indeterminate = true;
    }
  }

  /**
   * Attach direct click handlers for add record elements
   * This provides a fallback in case delegated handlers don't work
   */
  _attachAddRecordHandlers() {
    const addRowBtn = document.getElementById('add-row-btn');
    const addRowCell = document.getElementById('add-row-cell');
    const addFirstRecord = document.getElementById('add-first-record');

    const handleAddRecord = (e) => {
      e.preventDefault();
      e.stopPropagation();
      const record = this.addRecord();
      if (record) {
        // Optionally show the new record's detail panel
        this._showRecordDetail(record.id);
      }
    };

    // Ensure handlers are attached with high priority
    if (addRowBtn) {
      addRowBtn.style.cursor = 'pointer';
      addRowBtn.addEventListener('click', handleAddRecord, { capture: true });
    }
    if (addRowCell) {
      addRowCell.style.cursor = 'pointer';
      addRowCell.addEventListener('click', handleAddRecord, { capture: true });
    }
    if (addFirstRecord) {
      addFirstRecord.style.cursor = 'pointer';
      addFirstRecord.addEventListener('click', handleAddRecord, { capture: true });
    }
  }

  /**
   * Attach event handlers for load more buttons
   */
  _attachLoadMoreHandlers() {
    const loadMoreBtn = document.getElementById('load-more-records');
    const loadAllBtn = document.getElementById('load-all-records');

    loadMoreBtn?.addEventListener('click', () => {
      this._loadMoreRecords(false);
    });

    loadAllBtn?.addEventListener('click', () => {
      this._loadMoreRecords(true);
    });
  }

  /**
   * Load more records into the table view
   * @param {boolean} loadAll - If true, loads all remaining records
   */
  _loadMoreRecords(loadAll = false) {
    const allRecords = this.getFilteredRecords();
    const totalRecords = allRecords.length;
    // Maximum records to display at once for performance (prevent browser freeze)
    const maxDisplayableRecords = 5000;

    if (loadAll) {
      // Warn user about very large datasets and cap display
      if (totalRecords > maxDisplayableRecords) {
        this._showToast(`Displaying first ${maxDisplayableRecords.toLocaleString()} of ${totalRecords.toLocaleString()} records for performance. Use filters or search to narrow results.`, 'warning', 8000);
        this.displayedRecordCount = maxDisplayableRecords;
      } else {
        this.displayedRecordCount = totalRecords;
      }

      // Show loading indicator for large datasets
      if (this.displayedRecordCount > 500) {
        this._showLoadingOverlay('Loading records...', {
          showProgress: true,
          progress: 0,
          progressText: `Loading ${this.displayedRecordCount.toLocaleString()} records...`
        });

        // Use multiple animation frames to not block UI
        requestAnimationFrame(() => {
          this._renderTableView();
          this._hideLoadingOverlay();
        });
      } else {
        this._renderTableView();
      }
    } else {
      // Load next batch (smaller batches for large datasets)
      const batchSize = totalRecords > 10000 ? 100 : this.recordBatchSize;
      this.displayedRecordCount = Math.min(
        this.displayedRecordCount + batchSize,
        Math.min(totalRecords, maxDisplayableRecords)
      );
      this._renderTableView();
    }
  }

  /**
   * Group records by a field's values (for grouped table view)
   * Returns array of groups with { key, displayName, color, records }
   */
  _groupRecordsByField(records, groupField) {
    const groups = new Map();

    // For SELECT fields, use the choices order
    if (groupField.type === FieldTypes.SELECT && groupField.options?.choices) {
      // Pre-populate groups in choice order
      groupField.options.choices.forEach(choice => {
        groups.set(choice.id, {
          key: choice.id,
          displayName: choice.name,
          color: choice.color || 'gray',
          records: []
        });
      });
    }

    // Add uncategorized group
    const uncategorizedKey = '__uncategorized__';
    groups.set(uncategorizedKey, {
      key: uncategorizedKey,
      displayName: 'Uncategorized',
      color: null,
      records: []
    });

    // Group records
    records.forEach(record => {
      const value = record.values[groupField.id];

      if (value == null || value === '') {
        groups.get(uncategorizedKey).records.push(record);
      } else if (groupField.type === FieldTypes.SELECT) {
        // For SELECT fields, value is the choice ID
        if (groups.has(value)) {
          groups.get(value).records.push(record);
        } else {
          // Unknown choice - add to uncategorized
          groups.get(uncategorizedKey).records.push(record);
        }
      } else {
        // For other field types, use the value as the key
        const key = String(value);
        if (!groups.has(key)) {
          groups.set(key, {
            key: key,
            displayName: key,
            color: null,
            records: []
          });
        }
        groups.get(key).records.push(record);
      }
    });

    // Convert to array and filter out empty groups (except uncategorized if it has records)
    const result = [];
    groups.forEach((group, key) => {
      if (group.records.length > 0 || key !== uncategorizedKey) {
        if (group.records.length > 0) {
          result.push(group);
        }
      }
    });

    return result;
  }

  /**
   * Get source info for a record (for provenance column)
   */
  _getRecordSourceInfo(record, set) {
    const datasetProv = set?.datasetProvenance;
    const recordProv = record?.provenance;

    // Determine source type and info
    let type = 'given';
    let icon = '◉';
    let source = '';
    let sourceId = '';
    let shortName = '';
    let tooltip = '';

    if (datasetProv?.originalFilename) {
      source = datasetProv.originalFilename;
      // Generate sourceId matching the format used in _renderSourcesPanel
      const sourceKey = source.toLowerCase();
      sourceId = `src_${sourceKey.replace(/[^a-z0-9]/g, '_')}`;
      shortName = this._truncateSourceName(source, 15);
      tooltip = `Source: ${source}\nClick to view source details`;

      if (datasetProv.importedAt) {
        tooltip += `\nImported: ${new Date(datasetProv.importedAt).toLocaleDateString()}`;
      }
      const methodValue = this._getProvenanceValue(datasetProv.provenance?.method);
      if (methodValue) {
        tooltip += `\nMethod: ${methodValue}`;
      }

      // Get file type icon
      const ext = source.split('.').pop()?.toLowerCase();
      if (ext === 'csv') icon = '📄';
      else if (ext === 'json') icon = '{ }';
      else if (ext === 'ics') icon = '📅';
      else icon = '◉';
    } else if (recordProv) {
      type = 'derived';
      icon = '⚙️';
      source = recordProv.source || recordProv.method || 'Derived';
      shortName = this._truncateSourceName(source, 15);
      tooltip = `Derived record\nMethod: ${recordProv.method || 'unknown'}`;
    } else {
      type = 'manual';
      icon = '✏️';
      source = 'Manual';
      shortName = 'Manual';
      tooltip = 'Manually created record';
    }

    return { type, icon, source, sourceId, shortName, tooltip };
  }

  /**
   * Truncate source name for column display
   */
  _truncateSourceName(name, maxLen = 15) {
    if (!name) return '';
    if (name.length <= maxLen) return name;
    return name.slice(0, maxLen - 3) + '...';
  }

  /**
   * Attach click handlers for provenance column
   */
  _attachProvenanceClickHandlers() {
    // Make the entire provenance cell clickable
    this.container.querySelectorAll('td.col-provenance').forEach(el => {
      el.addEventListener('click', (e) => {
        e.stopPropagation();
        const sourceId = el.dataset.sourceId;
        if (sourceId) {
          // Show source detail panel
          this._showSourceDetail(sourceId);

          // Also highlight the source in sidebar
          const sourceItem = document.querySelector(`.source-item[data-source-id="${sourceId}"]`);
          if (sourceItem) {
            sourceItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
            // Highlight briefly
            sourceItem.classList.add('highlighted');
            setTimeout(() => sourceItem.classList.remove('highlighted'), 2000);
          }
        }
      });
    });
  }

  _getVisibleFields() {
    const set = this.getCurrentSet();
    const view = this.getCurrentView();
    if (!set) return [];

    let fields = [...set.fields];

    // Apply field order from view config
    if (view?.config.fieldOrder?.length > 0) {
      fields.sort((a, b) => {
        const aIndex = view.config.fieldOrder.indexOf(a.id);
        const bIndex = view.config.fieldOrder.indexOf(b.id);
        if (aIndex === -1) return 1;
        if (bIndex === -1) return -1;
        return aIndex - bIndex;
      });
    }

    // Filter out hidden fields
    if (view?.config.hiddenFields?.length > 0) {
      fields = fields.filter(f => !view.config.hiddenFields.includes(f.id));
    }

    return fields;
  }

  _renderCell(record, field, searchTerm = '') {
    try {
      const value = record.values[field.id];
      // Optimization: skip expensive history lookup for large datasets (>1000 records)
      // History indicators will be loaded on-demand when needed
      const set = this.getCurrentSet();
      const isLargeDataset = set?.records?.length > 1000;
      let historyCount = 0;
      let hasHistory = false;
      if (!isLargeDataset) {
        // Use cached history if available (set by batch pre-computation)
        if (record._historyCache && record._historyCache[field.id] !== undefined) {
          historyCount = record._historyCache[field.id];
        } else {
          historyCount = this._getFieldHistoryChangeCount(record.id, field.id);
        }
        hasHistory = historyCount > 0;
      }
      const cellClass = `cell-${field.type} cell-editable${hasHistory ? ' has-history' : ''}`;

      let content = '';

    switch (field.type) {
      case FieldTypes.TEXT:
        if (value) {
          const escapedValue = this._escapeHtml(String(value));
          const truncatedTitle = value.length > 50 ? escapedValue : ''; // Only show tooltip if content is long
          content = `<span class="cell-text-content" ${truncatedTitle ? `title="${truncatedTitle}"` : ''}>${this._highlightText(value, searchTerm)}</span>`;
        } else {
          content = '<span class="cell-empty">Empty</span>';
        }
        break;
      case FieldTypes.LONG_TEXT:
        if (value) {
          const escapedLongText = this._escapeHtml(String(value));
          const truncatedLongTitle = value.length > 100 ? escapedLongText.substring(0, 200) + '...' : ''; // Show preview in tooltip
          content = `<span class="cell-longtext-content" ${truncatedLongTitle ? `title="${truncatedLongTitle}"` : ''}>${this._highlightText(value, searchTerm)}</span>`;
        } else {
          content = '<span class="cell-empty">Empty</span>';
        }
        break;

      case FieldTypes.NUMBER:
        content = value != null ? `<span class="cell-number">${this._formatNumber(value, field)}</span>` : '<span class="cell-empty">-</span>';
        break;

      case FieldTypes.CHECKBOX:
        content = `
          <div class="cell-checkbox">
            <i class="ph ${value ? 'ph-check-square checked' : 'ph-square unchecked'}"></i>
          </div>
        `;
        break;

      case FieldTypes.SELECT:
        if (value) {
          const choice = field.options.choices?.find(c => c.id === value);
          if (choice) {
            content = `<span class="select-tag color-${choice.color || 'gray'}">${this._highlightText(choice.name, searchTerm)}</span>`;
          } else {
            // Value exists but no matching choice - show raw value with visual indicator
            content = `<span class="cell-empty" title="No matching choice">${this._escapeHtml(String(value))}</span>`;
          }
        } else {
          content = '<span class="cell-empty">-</span>';
        }
        break;

      case FieldTypes.MULTI_SELECT:
        if (Array.isArray(value) && value.length > 0) {
          content = '<div class="cell-select">';
          value.forEach(v => {
            const choice = field.options.choices?.find(c => c.id === v);
            if (choice) {
              content += `<span class="select-tag color-${choice.color || 'gray'}">${this._highlightText(choice.name, searchTerm)}</span>`;
            }
          });
          content += '</div>';
        } else {
          content = '<span class="cell-empty">-</span>';
        }
        break;

      case FieldTypes.DATE:
        content = value ? `<span class="cell-date">${this._formatDate(value, field)}</span>` : '<span class="cell-empty">-</span>';
        break;

      case FieldTypes.URL:
        content = value ? `<span class="cell-url"><a href="${this._escapeHtml(value)}" target="_blank">${this._highlightText(value, searchTerm)}</a></span>` : '<span class="cell-empty">-</span>';
        break;

      case FieldTypes.EMAIL:
        content = value ? `<span class="cell-url"><a href="mailto:${this._escapeHtml(value)}">${this._highlightText(value, searchTerm)}</a></span>` : '<span class="cell-empty">-</span>';
        break;

      case FieldTypes.LINK:
        const normalizedLinks = this._normalizeLinkValue(value);
        if (normalizedLinks.length > 0) {
          const linkedSet = this.sets.find(s => s.id === field.options?.linkedSetId);
          // Use linkedFieldId if set, otherwise fall back to primary field
          const displayField = field.options?.linkedFieldId
            ? linkedSet?.fields.find(f => f.id === field.options.linkedFieldId)
            : (linkedSet?.fields.find(f => f.isPrimary) || linkedSet?.fields?.[0]);
          const hasEdgeFields = field.options?.enableEdgeData && field.options?.edgeFields?.length > 0;
          content = '<div class="cell-link">';
          normalizedLinks.forEach(link => {
            const linkedRecord = linkedSet?.records.find(r => r.id === link.recordId);
            const name = linkedRecord?.values[displayField?.id] || link.recordId;
            const hasEdgeData = hasEdgeFields && link.edgeData && Object.keys(link.edgeData).length > 0;
            const edgeIndicator = hasEdgeData ? '<i class="ph ph-arrows-horizontal edge-indicator" title="Has edge data"></i>' : '';
            content += `<span class="link-chip${hasEdgeData ? ' has-edge-data' : ''}" data-linked-id="${link.recordId}"><i class="ph ph-link"></i>${this._highlightText(name, searchTerm)}${edgeIndicator}</span>`;
          });
          content += '</div>';
        } else {
          content = '<span class="cell-empty">-</span>';
        }
        break;

      case FieldTypes.FORMULA:
        const result = this._evaluateFormula(field.options?.formula, record);
        content = `<span class="cell-formula">${result}</span>`;
        break;

      case FieldTypes.AUTONUMBER:
        // Use cached index if available, otherwise compute (much faster than findIndex every time)
        let autoIndex = 0;
        if (record._autoIndex !== undefined) {
          autoIndex = record._autoIndex;
        } else {
          const currentSet = this.getCurrentSet();
          if (currentSet?.records) {
            // Build index map once if not exists
            if (!currentSet._recordIndexMap) {
              currentSet._recordIndexMap = new Map();
              currentSet.records.forEach((r, i) => currentSet._recordIndexMap.set(r.id, i));
            }
            autoIndex = currentSet._recordIndexMap.get(record.id) ?? 0;
          }
        }
        content = `<span class="cell-number">${autoIndex + 1}</span>`;
        break;

      case FieldTypes.JSON:
        if (value !== null && value !== undefined) {
          const displayMode = field.options?.displayMode || 'keyValue';
          if (displayMode === 'raw') {
            // Raw mode: show JSON string
            const jsonStr = typeof value === 'object' ? JSON.stringify(value) : String(value);
            content = `<span class="cell-json-raw">${this._highlightText(jsonStr, searchTerm)}</span>`;
          } else {
            // Key-value mode (default): use nested object rendering with search
            content = this._renderJsonKeyValue(value, field, searchTerm);
          }
        } else {
          content = '<span class="cell-empty">-</span>';
        }
        break;

      default:
        // Handle nested objects and arrays properly
        if (value !== null && value !== undefined) {
          if (typeof value === 'object') {
            content = this._renderNestedValue(value, searchTerm);
          } else {
            content = this._highlightText(String(value), searchTerm);
          }
        } else {
          content = '<span class="cell-empty">-</span>';
        }
    }

      // Add history indicator if cell has changes
      const historyIndicator = hasHistory ? `
        <button class="cell-history-indicator"
                data-record-id="${record.id}"
                data-field-id="${field.id}"
                data-history-count="${historyCount}"
                title="${historyCount} change${historyCount !== 1 ? 's' : ''}">
          <span class="history-dot${historyCount > 1 ? ' multiple' : ''}"></span>
        </button>
      ` : '';

      return `<td class="${cellClass}" data-field-id="${field.id}">${content}${historyIndicator}</td>`;
    } catch (error) {
      console.error('[RenderCell Error]', { fieldId: field?.id, fieldName: field?.name, fieldType: field?.type, recordId: record?.id, error });
      return `<td class="cell-${field?.type || 'unknown'} cell-editable cell-error" data-field-id="${field?.id || 'unknown'}"><span class="cell-empty cell-render-error" title="Error rendering field">Error</span></td>`;
    }
  }

  _formatNumber(value, field) {
    const num = Number(value);
    if (isNaN(num)) return value;

    const precision = field.options?.precision || 0;

    switch (field.options?.format) {
      case 'currency':
        return num.toLocaleString('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: precision });
      case 'percent':
        return (num * 100).toFixed(precision) + '%';
      default:
        return num.toLocaleString('en-US', { minimumFractionDigits: precision, maximumFractionDigits: precision });
    }
  }

  _formatDate(value, field) {
    try {
      const date = new Date(value);
      if (field.options?.includeTime) {
        return date.toLocaleString();
      }
      return date.toLocaleDateString();
    } catch (e) {
      return value;
    }
  }

  /**
   * Initialize the formula engine with data access hooks
   */
  _initFormulaEngine() {
    // Only initialize if EOFormulaEngine is available
    if (typeof EOFormulaEngine === 'undefined') {
      console.warn('EOFormulaEngine not loaded - formula evaluation will be limited');
      return;
    }

    // Get the global activity store if available
    const activityStore = typeof window !== 'undefined' ? window.activityStore : null;

    this.formulaEngine = new EOFormulaEngine({
      workbench: this,
      activityStore: activityStore,
      actor: 'user',
      getSet: (name) => {
        return this.sets?.find(s => s.name === name || s.id === name);
      },
      getLinkedRecords: (record, fieldName) => {
        return this._getLinkedRecordsForFormula(record, fieldName);
      }
    });
  }

  /**
   * Get linked records for formula evaluation
   */
  _getLinkedRecordsForFormula(record, fieldName) {
    if (!record) return [];

    const currentSet = this.getCurrentSet();
    if (!currentSet) return [];

    // Find the link field
    const field = currentSet.fields?.find(f =>
      f.name === fieldName || f.id === fieldName
    );

    if (!field || field.type !== 'link') return [];

    // Get linked record IDs
    const values = record.values || record;
    const linkedData = values[field.id] || values[field.name];

    if (!linkedData) return [];

    // Find the linked set
    const linkedSetId = field.options?.linked?.setId;
    if (!linkedSetId) return [];

    const linkedSet = this.sets?.find(s => s.id === linkedSetId);
    if (!linkedSet) return [];

    // Get linked record IDs from the array
    const linkedIds = Array.isArray(linkedData)
      ? linkedData.map(l => l.recordId || l)
      : [linkedData.recordId || linkedData];

    // Return matching records
    return (linkedSet.records || []).filter(r => linkedIds.includes(r.id));
  }

  /**
   * Evaluate a formula against a record using the pipeline-based formula engine
   */
  _evaluateFormula(formula, record) {
    try {
      if (!formula) return '';

      // Use the formula engine if available
      if (this.formulaEngine) {
        const result = this.formulaEngine.evaluateFormula(formula, record, {
          set: this.getCurrentSet()
        });

        if (result.error) {
          console.warn('Formula evaluation error:', result.error);
          return '#ERROR';
        }

        // Format the result for display
        return this._formatFormulaResult(result.value);
      }

      // Fallback: Simple field reference replacement
      return this._evaluateFormulaFallback(formula, record);
    } catch (e) {
      console.error('Formula evaluation exception:', e);
      return '#ERROR';
    }
  }

  /**
   * Format formula result for display
   */
  _formatFormulaResult(value) {
    if (value === null || value === undefined) return '';

    // Handle superposition objects
    if (value && typeof value === 'object' && value._type === 'superposition') {
      if (typeof FORMAT_SUP !== 'undefined') {
        return FORMAT_SUP(value, 'list');
      }
      const states = value.states?.map(s => s.value) || [];
      return states.join(' | ');
    }

    // Handle arrays
    if (Array.isArray(value)) {
      return value.map(v => this._formatFormulaResult(v)).join(', ');
    }

    // Handle objects
    if (typeof value === 'object') {
      return JSON.stringify(value);
    }

    // Handle booleans
    if (typeof value === 'boolean') {
      return value ? 'Yes' : 'No';
    }

    // Handle numbers with reasonable precision
    if (typeof value === 'number') {
      if (Number.isInteger(value)) {
        return String(value);
      }
      // Limit decimal places for display
      return value.toLocaleString(undefined, { maximumFractionDigits: 4 });
    }

    return String(value);
  }

  /**
   * Fallback formula evaluation using simple field reference replacement
   */
  _evaluateFormulaFallback(formula, record) {
    if (!formula || !record) return '';

    const currentSet = this.getCurrentSet();
    const values = record.values || record;

    // Build field lookup map
    const fieldMap = new Map();
    if (currentSet?.fields) {
      for (const field of currentSet.fields) {
        const value = values[field.id] ?? values[field.name] ?? '';
        fieldMap.set(field.name, value);
        fieldMap.set(field.id, value);
      }
    }

    // Handle RECORD_ID() function
    let result = formula.replace(/RECORD_ID\(\)/gi, record.id || '');

    // Replace {Field Name} references with actual values
    result = result.replace(/\{([^}]+)\}/g, (match, fieldRef) => {
      const value = fieldMap.get(fieldRef.trim());
      if (value === undefined || value === null) return '';
      return String(value);
    });

    // Try to evaluate as expression if it looks like one
    if (/^[\d\s+\-*/.()]+$/.test(result)) {
      try {
        // Safe evaluation of numeric expressions only
        const evaluated = Function('"use strict"; return (' + result + ')')();
        return this._formatFormulaResult(evaluated);
      } catch {
        // Return as-is if evaluation fails
      }
    }

    return result;
  }

  _attachTableEventListeners() {
    const table = document.querySelector('.data-table');
    if (!table) return;

    // Use event delegation for most table interactions
    // This greatly reduces the number of event listeners for better performance

    // Delegated click handler for the entire table
    table.addEventListener('click', (e) => {
      const target = e.target;

      // Table group toggle (for grouped views)
      const groupToggle = target.closest('.table-group-toggle');
      if (groupToggle) {
        e.stopPropagation();
        const groupKey = groupToggle.dataset.groupKey;
        if (this.collapsedTableGroups.has(groupKey)) {
          this.collapsedTableGroups.delete(groupKey);
        } else {
          this.collapsedTableGroups.add(groupKey);
        }
        this._renderTableView();
        return;
      }

      // Select all checkbox
      if (target.id === 'select-all') {
        e.stopPropagation();
        const set = this.getCurrentSet();
        if (!set) return;
        if (target.checked) {
          set.records.forEach(r => this.selectedRecords.add(r.id));
        } else {
          this.selectedRecords.clear();
        }
        this._renderTableView();
        this._updateBulkActionsToolbar();
        return;
      }

      // Row checkbox - prevent any default behavior that might cause navigation
      if (target.classList.contains('row-checkbox') && target.dataset.recordId) {
        e.stopPropagation();
        const recordId = target.dataset.recordId;
        if (target.checked) {
          this.selectedRecords.add(recordId);
        } else {
          this.selectedRecords.delete(recordId);
        }
        this._updateStatus();
        this._updateBulkActionsToolbar();
        const row = target.closest('tr');
        row?.classList.toggle('selected', target.checked);
        return;
      }

      // Checkbox cell toggle (single click)
      const checkboxCell = target.closest('.cell-checkbox');
      if (checkboxCell) {
        const td = checkboxCell.closest('td');
        const recordId = td?.closest('tr')?.dataset.recordId;
        const fieldId = td?.dataset.fieldId;
        if (recordId && fieldId) {
          e.stopPropagation(); // Prevent row click
          this._toggleCheckbox(recordId, fieldId);
        }
        return;
      }

      // HTML preview button click (for TEXT fields)
      const htmlPreviewBtn = target.closest('.cell-html-preview-btn');
      if (htmlPreviewBtn) {
        e.stopPropagation(); // Prevent row click and cell edit
        const td = htmlPreviewBtn.closest('td');
        const recordId = td?.closest('tr')?.dataset.recordId;
        const fieldId = td?.dataset.fieldId;
        if (recordId && fieldId) {
          this._showHtmlPreviewModal(recordId, fieldId);
        }
        return;
      }

      // Long text expand button click - opens semantic triplet modal
      const expandBtn = target.closest('.cell-expand-btn:not(.cell-html-preview-btn)');
      if (expandBtn) {
        e.stopPropagation(); // Prevent row click and cell edit
        const td = expandBtn.closest('td');
        const recordId = td?.closest('tr')?.dataset.recordId;
        const fieldId = td?.dataset.fieldId;
        if (recordId && fieldId) {
          this._showCellEditModal(recordId, fieldId);
        }
        return;
      }

      // Field header dropdown
      const dropdown = target.closest('.th-dropdown');
      if (dropdown) {
        e.stopPropagation();
        const th = dropdown.closest('th');
        this._showFieldContextMenu(e, th.dataset.fieldId);
        return;
      }

      // Add column button
      if (target.closest('#add-column-btn')) {
        this._showFieldTypePicker(e);
        return;
      }

      // Add record buttons
      if (target.closest('#add-row-btn') || target.closest('#add-row-cell') || target.closest('#add-first-record')) {
        this.addRecord();
        return;
      }

      // Clear search button
      if (target.closest('#clear-search-btn')) {
        this._clearViewSearch();
        return;
      }

      // Cell history indicator click
      const historyIndicator = target.closest('.cell-history-indicator');
      if (historyIndicator) {
        e.stopPropagation(); // Prevent row click and cell edit
        const recordId = historyIndicator.dataset.recordId;
        const fieldId = historyIndicator.dataset.fieldId;
        if (recordId && fieldId) {
          this._showFieldHistoryPopover(recordId, fieldId, historyIndicator);
        }
        return;
      }

      // Link chip click - navigate to linked record details
      const linkChip = target.closest('.link-chip');
      if (linkChip && linkChip.dataset.linkedId) {
        e.stopPropagation(); // Prevent row click
        const linkedRecordId = linkChip.dataset.linkedId;
        // Find the field to get the linked set ID
        const cell = linkChip.closest('td[data-field-id]');
        const fieldId = cell?.dataset.fieldId;
        const set = this.getCurrentSet();
        const field = set?.fields?.find(f => f.id === fieldId);
        const linkedSetId = field?.options?.linkedSetId;
        this._showLinkedRecordDetail(linkedRecordId, linkedSetId);
        return;
      }

      // Cell click - open semantic triplet modal for editing with history
      const cell = target.closest('td.cell-editable');
      if (cell && !cell.classList.contains('cell-editing')) {
        e.stopPropagation(); // Prevent row click
        const recordId = cell.closest('tr')?.dataset.recordId;
        const fieldId = cell.dataset.fieldId;
        if (recordId && fieldId) {
          this._showCellEditModal(recordId, fieldId);
        }
        return;
      }

      // Row click for detail panel (but not on checkboxes or editing cells)
      if (target.type !== 'checkbox' && !target.closest('.cell-editing')) {
        const row = target.closest('tr[data-record-id]');
        if (row) {
          this._showRecordDetail(row.dataset.recordId);
        }
      }
    });

    // Delegated double-click for cell editing
    table.addEventListener('dblclick', (e) => {
      const cell = e.target.closest('td.cell-editable');
      if (cell && !cell.classList.contains('cell-editing')) {
        this._startCellEdit(cell);
      }
    });

    // Delegated context menu for rows and column headers
    table.addEventListener('contextmenu', (e) => {
      // Check for column header first
      const th = e.target.closest('th[data-field-id]');
      if (th) {
        e.preventDefault();
        this._showFieldContextMenu(e, th.dataset.fieldId);
        return;
      }

      // Then check for row
      const row = e.target.closest('tr[data-record-id]');
      if (row) {
        e.preventDefault();
        this._showRecordContextMenu(e, row.dataset.recordId);
      }
    });

    // Column resize handles still need individual attachment for drag state
    document.querySelectorAll('.th-resize-handle').forEach(handle => {
      this._attachResizeHandler(handle);
    });
  }

  _startCellEdit(cell) {
    if (this.editingCell) {
      this._endCellEdit();
    }

    const recordId = cell.closest('tr')?.dataset.recordId;
    const fieldId = cell.dataset.fieldId;
    if (!recordId || !fieldId) return;

    const set = this.getCurrentSet();
    const record = set?.records.find(r => r.id === recordId);
    const field = set?.fields.find(f => f.id === fieldId);
    if (!record || !field) return;

    // Non-editable field types
    if ([FieldTypes.FORMULA, FieldTypes.ROLLUP, FieldTypes.COUNT, FieldTypes.AUTONUMBER].includes(field.type)) {
      return;
    }

    // Store original content for cancel restoration (avoids full re-render)
    const originalContent = cell.innerHTML;
    this.editingCell = { cell, recordId, fieldId, originalContent, field };
    cell.classList.add('cell-editing');

    const currentValue = record.values[fieldId];

    // Render appropriate editor
    switch (field.type) {
      case FieldTypes.SELECT:
        this._renderSelectEditor(cell, field, currentValue);
        break;
      case FieldTypes.MULTI_SELECT:
        this._renderMultiSelectEditor(cell, field, currentValue);
        break;
      case FieldTypes.DATE:
        this._renderDateEditor(cell, field, currentValue);
        break;
      case FieldTypes.CHECKBOX:
        // Checkbox is toggled directly, not edited
        break;
      case FieldTypes.JSON:
        this._renderJsonEditor(cell, field, currentValue);
        break;
      case FieldTypes.LINK:
        this._renderLinkEditor(cell, field, currentValue);
        break;
      default:
        this._renderTextEditor(cell, field, currentValue);
    }
  }

  _renderTextEditor(cell, field, value) {
    const isLongText = field.type === FieldTypes.LONG_TEXT;

    // Create element properly - input needs value attribute, not inner content
    const input = document.createElement(isLongText ? 'textarea' : 'input');
    input.type = 'text';
    input.className = 'cell-input';
    input.value = value || '';

    cell.innerHTML = '';
    cell.appendChild(input);

    input.focus();
    input.select?.();

    input.addEventListener('blur', () => this._endCellEdit());
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !isLongText) {
        this._endCellEdit();
      }
      if (e.key === 'Escape') {
        this._cancelCellEdit();
      }
      if (e.key === 'Tab') {
        e.preventDefault();
        this._endCellEdit();
        this._moveToNextCell(e.shiftKey);
      }
    });
  }

  _renderSelectEditor(cell, field, value) {
    const choices = field.options.choices || [];
    const currentChoice = choices.find(c => c.id === value);

    // Show current value in the cell while modal is open
    cell.innerHTML = currentChoice
      ? `<span class="select-tag color-${currentChoice.color || 'gray'}">${this._escapeHtml(currentChoice.name)}</span>`
      : '<span class="cell-empty">-</span>';

    // Create modal overlay for select options
    const modal = document.createElement('div');
    modal.className = 'select-modal-overlay';
    modal.innerHTML = `
      <div class="select-modal">
        <div class="select-modal-header">
          <div class="select-modal-search">
            <i class="ph ph-magnifying-glass"></i>
            <input type="text" class="select-modal-input" placeholder="Find an option...">
          </div>
        </div>
        <div class="select-modal-options">
          ${value ? `
            <div class="select-modal-option select-modal-clear" data-value="">
              <span class="select-modal-check"><i class="ph ph-x"></i></span>
              <span class="select-modal-label">Clear selection</span>
            </div>
          ` : ''}
          ${choices.map(choice => `
            <div class="select-modal-option ${choice.id === value ? 'selected' : ''}" data-value="${choice.id}">
              <span class="select-modal-check">${choice.id === value ? '<i class="ph ph-check"></i>' : ''}</span>
              <span class="select-tag color-${choice.color || 'gray'}">${this._escapeHtml(choice.name)}</span>
            </div>
          `).join('')}
          ${choices.length === 0 ? '<div class="select-modal-empty">No options available</div>' : ''}
        </div>
      </div>
    `;

    document.body.appendChild(modal);
    this._selectModal = modal;

    const searchInput = modal.querySelector('.select-modal-input');
    const optionsContainer = modal.querySelector('.select-modal-options');

    // Focus search input
    setTimeout(() => searchInput?.focus(), 10);

    // Search filtering
    searchInput?.addEventListener('input', (e) => {
      const searchTerm = e.target.value.toLowerCase();
      modal.querySelectorAll('.select-modal-option:not(.select-modal-clear)').forEach(opt => {
        const name = opt.querySelector('.select-tag')?.textContent.toLowerCase() || '';
        opt.style.display = name.includes(searchTerm) ? '' : 'none';
      });
    });

    // Option selection
    optionsContainer.addEventListener('click', (e) => {
      const option = e.target.closest('.select-modal-option');
      if (option) {
        const newValue = option.dataset.value || null;
        this._updateCellValue(newValue);
        this._closeSelectModal();
        this._endCellEdit();
      }
    });

    // Close on overlay click
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        this._closeSelectModal();
        this._endCellEdit();
      }
    });

    // Keyboard handling
    const handleKeydown = (e) => {
      if (e.key === 'Escape') {
        this._closeSelectModal();
        this._endCellEdit();
      }
    };
    document.addEventListener('keydown', handleKeydown);
    modal._keydownHandler = handleKeydown;
  }

  _closeSelectModal() {
    if (this._selectModal) {
      if (this._selectModal._keydownHandler) {
        document.removeEventListener('keydown', this._selectModal._keydownHandler);
      }
      this._selectModal.remove();
      this._selectModal = null;
    }
  }

  /**
   * Show modal with full long text content, inline editing, and field history/provenance tabs
   */
  _showLongTextModal(recordId, fieldId) {
    const set = this.getCurrentSet();
    const record = set?.records.find(r => r.id === recordId);
    const field = set?.fields.find(f => f.id === fieldId);
    if (!record || !field) return;

    const value = record.values[fieldId] || '';
    const fieldName = field.name || 'Notes';

    // Get field history and provenance
    const fieldHistory = this._getFieldHistory(recordId, fieldId);
    const fieldProv = record.fieldProvenance?.[fieldId];
    const recordProv = record.provenance;
    const datasetProv = set?.datasetProvenance?.provenance;

    // Determine effective provenance
    let provenanceSource = 'dataset';
    let effectiveProv = datasetProv;
    if (fieldProv && Object.values(fieldProv).some(v => v !== null && v !== undefined)) {
      provenanceSource = 'field';
      effectiveProv = fieldProv;
    } else if (recordProv && Object.values(recordProv).some(v => v !== null && v !== undefined)) {
      provenanceSource = 'record';
      effectiveProv = recordProv;
    }

    // Helper to get provenance value
    const getProvValue = (prov, simpleKey, eoKey) => {
      if (!prov) return null;
      if (prov[simpleKey]) {
        return typeof prov[simpleKey] === 'object' ? prov[simpleKey].value : prov[simpleKey];
      }
      if (prov[eoKey]) {
        return typeof prov[eoKey] === 'object' ? prov[eoKey].value : prov[eoKey];
      }
      return null;
    };

    const provAgent = getProvValue(effectiveProv, 'agent', 'asserting_agent');
    const provMethod = getProvValue(effectiveProv, 'method', 'designation_mechanism');
    const provSource = getProvValue(effectiveProv, 'source', 'identity_kind');
    const hasProvenance = provAgent || provMethod || provSource;

    // Render history timeline
    const historyHtml = fieldHistory.length > 0
      ? `<div class="longtext-modal-history-events">
          ${fieldHistory.slice().reverse().map(event => this._renderFieldHistoryEvent(event, field, recordId, true)).join('')}
        </div>`
      : `<div class="longtext-modal-history-empty">
          <i class="ph ph-clock-afternoon"></i>
          <span>No changes tracked yet</span>
          <div class="longtext-modal-history-hint">Changes will appear here as you edit this field</div>
        </div>`;

    // Render provenance content
    const provenanceHtml = `
      <div class="longtext-modal-provenance">
        <div class="longtext-modal-provenance-source">
          <span class="provenance-source-badge ${provenanceSource}">${provenanceSource}</span>
          provenance
        </div>
        <div class="longtext-modal-provenance-grid">
          <div class="longtext-modal-prov-item">
            <label>Agent</label>
            <span>${provAgent ? this._escapeHtml(provAgent) : '<em class="empty">Not set</em>'}</span>
          </div>
          <div class="longtext-modal-prov-item">
            <label>Method</label>
            <span>${provMethod ? this._escapeHtml(provMethod) : '<em class="empty">Not set</em>'}</span>
          </div>
          <div class="longtext-modal-prov-item">
            <label>Source</label>
            <span>${provSource ? this._escapeHtml(provSource) : '<em class="empty">Not set</em>'}</span>
          </div>
        </div>
      </div>`;

    // Create modal with tabs for content/history/provenance
    const modal = new EOModal({
      title: fieldName,
      size: 'large',
      content: `
        <div class="longtext-modal-tabbed">
          <div class="longtext-modal-tabs">
            <button class="longtext-modal-tab active" data-tab="content">
              <i class="ph ph-text-aa"></i> Content
            </button>
            <button class="longtext-modal-tab" data-tab="history">
              <i class="ph ph-clock-counter-clockwise"></i> History
              <span class="tab-badge">${fieldHistory.length}</span>
            </button>
            <button class="longtext-modal-tab" data-tab="provenance">
              <i class="ph ph-git-branch"></i> Provenance
            </button>
          </div>
          <div class="longtext-modal-tab-content active" data-tab-content="content">
            <div class="longtext-modal-edit-container">
              <textarea class="longtext-modal-textarea" id="longtext-edit-${recordId}-${fieldId}">${this._escapeHtml(value)}</textarea>
            </div>
          </div>
          <div class="longtext-modal-tab-content" data-tab-content="history">
            <div class="longtext-modal-history">
              ${historyHtml}
            </div>
          </div>
          <div class="longtext-modal-tab-content" data-tab-content="provenance">
            ${provenanceHtml}
          </div>
        </div>
      `,
      buttons: [
        {
          label: 'Cancel',
          secondary: true,
          action: 'cancel',
          onClick: () => modal.hide()
        },
        {
          label: 'Save',
          icon: 'ph-floppy-disk',
          primary: true,
          action: 'save',
          onClick: () => {
            const textarea = modal.element.querySelector('.longtext-modal-textarea');
            const newValue = textarea?.value || '';
            if (newValue !== value) {
              this._updateCellValue(recordId, fieldId, newValue);
            }
            modal.hide();
          }
        }
      ]
    });

    modal.show();

    // Attach tab switching handlers
    const tabContainer = modal.element.querySelector('.longtext-modal-tabbed');
    tabContainer?.querySelectorAll('.longtext-modal-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        const tabName = tab.dataset.tab;

        // Update active tab button
        tabContainer.querySelectorAll('.longtext-modal-tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');

        // Update active tab content
        tabContainer.querySelectorAll('.longtext-modal-tab-content').forEach(c => c.classList.remove('active'));
        tabContainer.querySelector(`[data-tab-content="${tabName}"]`)?.classList.add('active');
      });
    });

    // Attach restore button handlers for history events
    modal.element.querySelectorAll('.event-restore-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const restoreValue = JSON.parse(btn.dataset.restoreValue);
        const textarea = modal.element.querySelector('.longtext-modal-textarea');
        if (textarea && confirm('Restore field to this previous value?')) {
          textarea.value = restoreValue ?? '';
          // Switch back to content tab
          const contentTab = modal.element.querySelector('.longtext-modal-tab[data-tab="content"]');
          contentTab?.click();
        }
      });
    });

    // Focus the textarea
    setTimeout(() => {
      const textarea = modal.element.querySelector('.longtext-modal-textarea');
      if (textarea) {
        textarea.focus();
        textarea.setSelectionRange(textarea.value.length, textarea.value.length);
      }
    }, 100);
  }

  /**
   * Get modal size based on field type
   * @param {string} fieldType - The field type
   * @returns {string} Modal size ('small', 'medium', 'large')
   */
  _getModalSizeForFieldType(fieldType) {
    const largeSizes = [FieldTypes.LONG_TEXT, FieldTypes.JSON];
    const mediumSizes = [FieldTypes.LINK, FieldTypes.MULTI_SELECT];

    if (largeSizes.includes(fieldType)) return 'large';
    if (mediumSizes.includes(fieldType)) return 'medium';
    return 'small';
  }

  /**
   * Get the display name for a record based on the set's displayNameFieldId
   * Falls back to the first column if displayNameFieldId is not set
   * @param {Object} set - The set containing the record
   * @param {Object} record - The record to get the display name for
   * @returns {string} The display name or 'Untitled' if empty
   */
  _getRecordDisplayName(set, record) {
    if (!set || !record) return 'Untitled';

    // Use displayNameFieldId if set, otherwise fall back to first field
    const displayFieldId = set.displayNameFieldId || set.fields?.[0]?.id;
    if (!displayFieldId) return 'Untitled';

    const value = record.values?.[displayFieldId];
    if (value === null || value === undefined || value === '') return 'Untitled';

    // Handle different value types
    if (typeof value === 'string') return value;
    if (typeof value === 'number') return String(value);
    if (typeof value === 'boolean') return value ? 'Yes' : 'No';
    if (Array.isArray(value)) return value.join(', ') || 'Untitled';

    return String(value) || 'Untitled';
  }

  /**
   * Show field modal with editable content and toggleable history
   * Opens when clicking on any cell in the table
   */
  _showFieldModal(recordId, fieldId) {
    const set = this.getCurrentSet();
    const record = set?.records.find(r => r.id === recordId);
    const field = set?.fields.find(f => f.id === fieldId);
    if (!record || !field) return;

    const value = record.values[fieldId];
    const fieldName = field.name || 'Field';
    const fieldIcon = FieldTypeIcons[field.type] || 'ph-circle';
    const displayName = this._getRecordDisplayName(set, record);

    // Check if field is editable
    const isEditable = ![FieldTypes.FORMULA, FieldTypes.ROLLUP, FieldTypes.COUNT, FieldTypes.AUTONUMBER].includes(field.type);

    // Get field history
    const fieldHistory = this._getFieldHistory(recordId, fieldId);
    const historyCount = fieldHistory.filter(event => {
      const action = event.payload?.action;
      return action === 'record_updated' || action === 'field_changed' || action === 'update';
    }).length;

    // Determine modal size based on field type
    const modalSize = this._getModalSizeForFieldType(field.type);

    // Render the editor content based on field type
    const editorContent = this._renderFieldModalEditor(field, value, recordId, isEditable);

    // Render history section (collapsible)
    const historyHtml = this._renderFieldModalHistory(fieldHistory, field, recordId);

    // Create modal
    const modal = new EOModal({
      id: `field-modal-${recordId}-${fieldId}`,
      title: `<i class="ph ${fieldIcon}"></i> ${this._escapeHtml(fieldName)}`,
      size: modalSize,
      content: `
        <div class="field-modal-container">
          <div class="field-modal-record-context">
            Record: ${this._escapeHtml(displayName)}
          </div>

          <div class="field-modal-editor-section">
            ${editorContent}
          </div>

          <div class="field-modal-history-section">
            <button class="field-modal-history-toggle ${historyCount > 0 ? 'expanded' : ''}" data-expanded="${historyCount > 0}">
              <i class="ph ph-caret-right toggle-icon"></i>
              <span>History</span>
              <span class="field-modal-history-count">${historyCount}</span>
            </button>
            <div class="field-modal-history-content ${historyCount > 0 ? 'expanded' : ''}">
              ${historyHtml}
            </div>
          </div>
        </div>
      `,
      buttons: isEditable ? [
        {
          label: 'Cancel',
          secondary: true,
          action: 'cancel',
          onClick: () => modal.hide()
        },
        {
          label: 'Save',
          icon: 'ph-floppy-disk',
          primary: true,
          action: 'save',
          onClick: () => {
            const newValue = this._getFieldModalValue(modal, field);
            if (newValue !== undefined && newValue !== value) {
              this._updateRecordValue(recordId, fieldId, newValue);
            }
            modal.hide();
          }
        }
      ] : [
        {
          label: 'Close',
          primary: true,
          action: 'close',
          onClick: () => modal.hide()
        }
      ]
    });

    modal.show();

    // Attach history toggle handler
    const toggleBtn = modal.element.querySelector('.field-modal-history-toggle');
    const historyContent = modal.element.querySelector('.field-modal-history-content');
    toggleBtn?.addEventListener('click', () => {
      const isExpanded = toggleBtn.dataset.expanded === 'true';
      toggleBtn.dataset.expanded = (!isExpanded).toString();
      toggleBtn.classList.toggle('expanded', !isExpanded);
      historyContent?.classList.toggle('expanded', !isExpanded);
    });

    // Attach restore button handlers
    modal.element.querySelectorAll('.event-restore-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const restoreValue = JSON.parse(btn.dataset.restoreValue);
        if (confirm('Restore field to this previous value?')) {
          this._setFieldModalValue(modal, field, restoreValue);
        }
      });
    });

    // Attach type-specific handlers
    this._attachFieldModalHandlers(modal, field, value, recordId);

    // Focus the input element
    setTimeout(() => {
      const focusable = modal.element.querySelector('.field-modal-editor input, .field-modal-editor textarea, .field-modal-editor select');
      if (focusable) {
        focusable.focus();
        if (focusable.select) focusable.select();
      }
    }, 100);
  }

  /**
   * Render the appropriate editor for a field type in the modal
   */
  _renderFieldModalEditor(field, value, recordId, isEditable) {
    if (!isEditable) {
      return this._renderFieldModalReadOnly(field, value);
    }

    switch (field.type) {
      case FieldTypes.TEXT:
      case FieldTypes.URL:
      case FieldTypes.EMAIL:
      case FieldTypes.PHONE:
        return this._renderFieldModalTextInput(field, value);

      case FieldTypes.LONG_TEXT:
        return this._renderFieldModalTextarea(field, value);

      case FieldTypes.NUMBER:
        return this._renderFieldModalNumberInput(field, value);

      case FieldTypes.CHECKBOX:
        return this._renderFieldModalCheckbox(field, value);

      case FieldTypes.SELECT:
        return this._renderFieldModalSelect(field, value);

      case FieldTypes.MULTI_SELECT:
        return this._renderFieldModalMultiSelect(field, value);

      case FieldTypes.DATE:
        return this._renderFieldModalDateInput(field, value);

      case FieldTypes.LINK:
        return this._renderFieldModalLinkEditor(field, value, recordId);

      case FieldTypes.JSON:
        return this._renderFieldModalJsonEditor(field, value);

      default:
        return this._renderFieldModalTextInput(field, value);
    }
  }

  _renderFieldModalReadOnly(field, value) {
    let displayValue = '';

    switch (field.type) {
      case FieldTypes.FORMULA:
        displayValue = `
          <div class="field-modal-readonly-value">${this._escapeHtml(String(value ?? ''))}</div>
          <div class="field-modal-formula-info">
            <span class="field-modal-info-label">Formula:</span>
            <code>${this._escapeHtml(field.options?.formula || '')}</code>
          </div>
        `;
        break;
      case FieldTypes.ROLLUP:
        displayValue = `
          <div class="field-modal-readonly-value">${this._escapeHtml(String(value ?? ''))}</div>
          <div class="field-modal-formula-info">
            <span class="field-modal-info-label">Aggregation:</span>
            <code>${this._escapeHtml(field.options?.aggregation || 'SUM')}</code>
          </div>
        `;
        break;
      case FieldTypes.COUNT:
      case FieldTypes.AUTONUMBER:
        displayValue = `<div class="field-modal-readonly-value">${this._escapeHtml(String(value ?? ''))}</div>`;
        break;
      default:
        displayValue = `<div class="field-modal-readonly-value">${this._escapeHtml(String(value ?? ''))}</div>`;
    }

    return `
      <div class="field-modal-editor field-modal-readonly">
        ${displayValue}
        <div class="field-modal-readonly-notice">
          <i class="ph ph-lock-simple"></i>
          <span>This field is computed automatically</span>
        </div>
      </div>
    `;
  }

  _renderFieldModalTextInput(field, value) {
    const placeholder = field.type === FieldTypes.URL ? 'https://...' :
                        field.type === FieldTypes.EMAIL ? 'email@example.com' :
                        field.type === FieldTypes.PHONE ? '+1 (555) 000-0000' : '';
    return `
      <div class="field-modal-editor">
        <input type="text"
               class="field-modal-input"
               value="${this._escapeHtml(value || '')}"
               placeholder="${placeholder}"
               data-field-type="${field.type}">
      </div>
    `;
  }

  _renderFieldModalTextarea(field, value) {
    const wordCount = value ? value.trim().split(/\s+/).filter(w => w).length : 0;
    return `
      <div class="field-modal-editor field-modal-editor-large">
        <textarea class="field-modal-textarea">${this._escapeHtml(value || '')}</textarea>
        <div class="field-modal-textarea-footer">
          <span class="field-modal-word-count">${wordCount} words</span>
        </div>
      </div>
    `;
  }

  _renderFieldModalNumberInput(field, value) {
    const format = field.options?.format || 'number';
    const precision = field.options?.precision ?? 2;
    return `
      <div class="field-modal-editor">
        <input type="number"
               class="field-modal-input field-modal-number-input"
               value="${value ?? ''}"
               step="${format === 'percent' ? '0.01' : Math.pow(10, -precision)}"
               data-format="${format}">
        ${format !== 'number' ? `<span class="field-modal-number-format">${format === 'currency' ? '$' : format === 'percent' ? '%' : ''}</span>` : ''}
      </div>
    `;
  }

  _renderFieldModalCheckbox(field, value) {
    return `
      <div class="field-modal-editor field-modal-checkbox-editor">
        <label class="field-modal-checkbox-label">
          <input type="checkbox"
                 class="field-modal-checkbox"
                 ${value ? 'checked' : ''}>
          <span class="field-modal-checkbox-visual">
            <i class="ph ${value ? 'ph-check-square-fill' : 'ph-square'}"></i>
          </span>
          <span class="field-modal-checkbox-text">${value ? 'Checked' : 'Unchecked'}</span>
        </label>
      </div>
    `;
  }

  _renderFieldModalSelect(field, value) {
    const choices = field.options?.choices || [];
    const currentChoice = choices.find(c => c.id === value);

    return `
      <div class="field-modal-editor field-modal-select-editor">
        <div class="field-modal-select-current" data-value="${value || ''}">
          ${currentChoice
            ? `<span class="select-tag color-${currentChoice.color || 'gray'}">${this._escapeHtml(currentChoice.name)}</span>`
            : '<span class="field-modal-select-placeholder">Select an option...</span>'
          }
          <i class="ph ph-caret-down"></i>
        </div>
        <div class="field-modal-select-dropdown">
          <div class="field-modal-select-search">
            <i class="ph ph-magnifying-glass"></i>
            <input type="text" placeholder="Search options..." class="field-modal-select-search-input">
          </div>
          <div class="field-modal-select-options">
            ${value ? `
              <div class="field-modal-select-option field-modal-select-clear" data-value="">
                <i class="ph ph-x"></i>
                <span>Clear selection</span>
              </div>
            ` : ''}
            ${choices.map(choice => `
              <div class="field-modal-select-option ${choice.id === value ? 'selected' : ''}" data-value="${choice.id}">
                <span class="field-modal-select-check">${choice.id === value ? '<i class="ph ph-check"></i>' : ''}</span>
                <span class="select-tag color-${choice.color || 'gray'}">${this._escapeHtml(choice.name)}</span>
              </div>
            `).join('')}
          </div>
        </div>
      </div>
    `;
  }

  _renderFieldModalMultiSelect(field, value) {
    const choices = field.options?.choices || [];
    const selectedIds = Array.isArray(value) ? value : (value ? [value] : []);

    return `
      <div class="field-modal-editor field-modal-multiselect-editor">
        <div class="field-modal-multiselect-selected">
          ${selectedIds.length > 0
            ? selectedIds.map(id => {
                const choice = choices.find(c => c.id === id);
                return choice ? `<span class="select-tag color-${choice.color || 'gray'}" data-id="${id}">${this._escapeHtml(choice.name)} <i class="ph ph-x remove-tag"></i></span>` : '';
              }).join('')
            : '<span class="field-modal-multiselect-placeholder">Select options...</span>'
          }
        </div>
        <div class="field-modal-multiselect-search">
          <i class="ph ph-magnifying-glass"></i>
          <input type="text" placeholder="Search options..." class="field-modal-multiselect-search-input">
        </div>
        <div class="field-modal-multiselect-options">
          ${choices.map(choice => `
            <label class="field-modal-multiselect-option">
              <input type="checkbox" value="${choice.id}" ${selectedIds.includes(choice.id) ? 'checked' : ''}>
              <span class="select-tag color-${choice.color || 'gray'}">${this._escapeHtml(choice.name)}</span>
            </label>
          `).join('')}
        </div>
      </div>
    `;
  }

  _renderFieldModalDateInput(field, value) {
    const includeTime = field.options?.includeTime;
    const inputType = includeTime ? 'datetime-local' : 'date';
    let formattedValue = '';

    if (value) {
      try {
        const date = new Date(value);
        if (includeTime) {
          formattedValue = date.toISOString().slice(0, 16);
        } else {
          formattedValue = date.toISOString().slice(0, 10);
        }
      } catch (e) {
        formattedValue = value;
      }
    }

    return `
      <div class="field-modal-editor">
        <input type="${inputType}"
               class="field-modal-input field-modal-date-input"
               value="${formattedValue}">
      </div>
    `;
  }

  _renderFieldModalLinkEditor(field, value, recordId) {
    const linkedSetId = field.options?.linkedSetId;
    const linkedSet = linkedSetId ? this.sets.find(s => s.id === linkedSetId) : this.getCurrentSet();
    const allowMultiple = field.options?.allowMultiple !== false;

    if (!linkedSet) {
      return `<div class="field-modal-editor field-modal-link-error">No linked set configured</div>`;
    }

    const normalizedLinks = this._normalizeLinkValue(value);
    const displayField = field.options?.linkedFieldId
      ? linkedSet.fields.find(f => f.id === field.options.linkedFieldId)
      : (linkedSet.fields.find(f => f.isPrimary) || linkedSet.fields[0]);

    return `
      <div class="field-modal-editor field-modal-link-editor" data-linked-set-id="${linkedSetId}" data-allow-multiple="${allowMultiple}">
        <div class="field-modal-link-selected">
          ${normalizedLinks.length > 0
            ? normalizedLinks.map(link => {
                const linkedRecord = linkedSet.records?.find(r => r.id === link.recordId);
                const displayValue = linkedRecord?.values?.[displayField?.id] || 'Unknown';
                return `<span class="link-chip" data-linked-id="${link.recordId}">${this._escapeHtml(displayValue)} <i class="ph ph-x remove-link"></i></span>`;
              }).join('')
            : '<span class="field-modal-link-placeholder">Link records...</span>'
          }
        </div>
        <div class="field-modal-link-search">
          <i class="ph ph-magnifying-glass"></i>
          <input type="text" placeholder="Search ${linkedSet.name}..." class="field-modal-link-search-input">
        </div>
        <div class="field-modal-link-options" data-loading="true">
          <div class="field-modal-link-loading">
            <i class="ph ph-spinner ph-spin"></i> Loading records...
          </div>
        </div>
      </div>
    `;
  }

  _renderFieldModalJsonEditor(field, value) {
    const displayMode = field.options?.displayMode || 'keyValue';
    let jsonString = '';

    try {
      jsonString = typeof value === 'string' ? value : JSON.stringify(value || {}, null, 2);
    } catch (e) {
      jsonString = String(value || '{}');
    }

    return `
      <div class="field-modal-editor field-modal-editor-large field-modal-json-editor">
        <div class="field-modal-json-toolbar">
          <button class="field-modal-json-mode ${displayMode === 'keyValue' ? 'active' : ''}" data-mode="keyValue">
            <i class="ph ph-list"></i> Key-Value
          </button>
          <button class="field-modal-json-mode ${displayMode === 'raw' ? 'active' : ''}" data-mode="raw">
            <i class="ph ph-code"></i> Raw JSON
          </button>
        </div>
        <textarea class="field-modal-json-textarea">${this._escapeHtml(jsonString)}</textarea>
      </div>
    `;
  }

  /**
   * Render the history section for the field modal
   */
  _renderFieldModalHistory(fieldHistory, field, recordId) {
    const changes = fieldHistory.filter(event => {
      const action = event.payload?.action;
      return action === 'record_updated' || action === 'field_changed' || action === 'update';
    });

    if (changes.length === 0) {
      return `
        <div class="field-modal-history-empty">
          <i class="ph ph-clock-afternoon"></i>
          <span>No changes yet</span>
          <div class="field-modal-history-hint">Changes will appear here as you edit this field</div>
        </div>
      `;
    }

    // Show last 5 changes, with option to show more
    const visibleChanges = changes.slice().reverse().slice(0, 5);
    const hasMore = changes.length > 5;

    return `
      <div class="field-modal-history-events">
        ${visibleChanges.map(event => this._renderFieldHistoryEvent(event, field, recordId, true)).join('')}
      </div>
      ${hasMore ? `
        <button class="field-modal-history-show-more">
          Show all ${changes.length} changes
        </button>
      ` : ''}
    `;
  }

  /**
   * Get the current value from the field modal editor
   */
  _getFieldModalValue(modal, field) {
    const editor = modal.element.querySelector('.field-modal-editor');
    if (!editor) return undefined;

    switch (field.type) {
      case FieldTypes.TEXT:
      case FieldTypes.URL:
      case FieldTypes.EMAIL:
      case FieldTypes.PHONE:
        return editor.querySelector('.field-modal-input')?.value || '';

      case FieldTypes.LONG_TEXT:
        return editor.querySelector('.field-modal-textarea')?.value || '';

      case FieldTypes.NUMBER:
        const numValue = editor.querySelector('.field-modal-number-input')?.value;
        return numValue === '' ? null : parseFloat(numValue);

      case FieldTypes.CHECKBOX:
        return editor.querySelector('.field-modal-checkbox')?.checked || false;

      case FieldTypes.SELECT:
        return editor.querySelector('.field-modal-select-current')?.dataset.value || null;

      case FieldTypes.MULTI_SELECT:
        const checked = editor.querySelectorAll('.field-modal-multiselect-option input:checked');
        return Array.from(checked).map(cb => cb.value);

      case FieldTypes.DATE:
        const dateValue = editor.querySelector('.field-modal-date-input')?.value;
        return dateValue ? new Date(dateValue).toISOString() : null;

      case FieldTypes.LINK:
        const linkChips = editor.querySelectorAll('.link-chip[data-linked-id]');
        const links = Array.from(linkChips).map(chip => ({ recordId: chip.dataset.linkedId }));
        return links.length > 0 ? links : null;

      case FieldTypes.JSON:
        try {
          const jsonText = editor.querySelector('.field-modal-json-textarea')?.value || '{}';
          return JSON.parse(jsonText);
        } catch (e) {
          return editor.querySelector('.field-modal-json-textarea')?.value;
        }

      default:
        return editor.querySelector('input, textarea')?.value;
    }
  }

  /**
   * Set a value in the field modal editor (used for restore)
   */
  _setFieldModalValue(modal, field, value) {
    const editor = modal.element.querySelector('.field-modal-editor');
    if (!editor) return;

    switch (field.type) {
      case FieldTypes.TEXT:
      case FieldTypes.URL:
      case FieldTypes.EMAIL:
      case FieldTypes.PHONE:
        const input = editor.querySelector('.field-modal-input');
        if (input) input.value = value || '';
        break;

      case FieldTypes.LONG_TEXT:
        const textarea = editor.querySelector('.field-modal-textarea');
        if (textarea) {
          textarea.value = value || '';
          this._updateTextareaWordCount(editor, value);
        }
        break;

      case FieldTypes.NUMBER:
        const numInput = editor.querySelector('.field-modal-number-input');
        if (numInput) numInput.value = value ?? '';
        break;

      case FieldTypes.CHECKBOX:
        const checkbox = editor.querySelector('.field-modal-checkbox');
        if (checkbox) {
          checkbox.checked = !!value;
          this._updateCheckboxVisual(editor, !!value);
        }
        break;

      case FieldTypes.SELECT:
        this._updateSelectValue(editor, field, value);
        break;

      case FieldTypes.DATE:
        const dateInput = editor.querySelector('.field-modal-date-input');
        if (dateInput && value) {
          try {
            const date = new Date(value);
            dateInput.value = field.options?.includeTime
              ? date.toISOString().slice(0, 16)
              : date.toISOString().slice(0, 10);
          } catch (e) {
            dateInput.value = value;
          }
        }
        break;

      case FieldTypes.JSON:
        const jsonTextarea = editor.querySelector('.field-modal-json-textarea');
        if (jsonTextarea) {
          try {
            jsonTextarea.value = typeof value === 'string' ? value : JSON.stringify(value || {}, null, 2);
          } catch (e) {
            jsonTextarea.value = String(value || '{}');
          }
        }
        break;
    }
  }

  _updateTextareaWordCount(editor, value) {
    const countEl = editor.querySelector('.field-modal-word-count');
    if (countEl) {
      const wordCount = value ? value.trim().split(/\s+/).filter(w => w).length : 0;
      countEl.textContent = `${wordCount} words`;
    }
  }

  _updateCheckboxVisual(editor, checked) {
    const icon = editor.querySelector('.field-modal-checkbox-visual i');
    const text = editor.querySelector('.field-modal-checkbox-text');
    if (icon) {
      icon.className = `ph ${checked ? 'ph-check-square-fill' : 'ph-square'}`;
    }
    if (text) {
      text.textContent = checked ? 'Checked' : 'Unchecked';
    }
  }

  _updateSelectValue(editor, field, value) {
    const choices = field.options?.choices || [];
    const currentChoice = choices.find(c => c.id === value);
    const currentEl = editor.querySelector('.field-modal-select-current');

    if (currentEl) {
      currentEl.dataset.value = value || '';
      currentEl.innerHTML = currentChoice
        ? `<span class="select-tag color-${currentChoice.color || 'gray'}">${this._escapeHtml(currentChoice.name)}</span><i class="ph ph-caret-down"></i>`
        : '<span class="field-modal-select-placeholder">Select an option...</span><i class="ph ph-caret-down"></i>';
    }

    // Update selected state in dropdown
    editor.querySelectorAll('.field-modal-select-option').forEach(opt => {
      const isSelected = opt.dataset.value === value;
      opt.classList.toggle('selected', isSelected);
      const check = opt.querySelector('.field-modal-select-check');
      if (check) check.innerHTML = isSelected ? '<i class="ph ph-check"></i>' : '';
    });
  }

  /**
   * Attach type-specific event handlers for field modal
   */
  _attachFieldModalHandlers(modal, field, currentValue, recordId) {
    const editor = modal.element.querySelector('.field-modal-editor');
    if (!editor) return;

    switch (field.type) {
      case FieldTypes.LONG_TEXT:
        const textarea = editor.querySelector('.field-modal-textarea');
        textarea?.addEventListener('input', () => {
          this._updateTextareaWordCount(editor, textarea.value);
        });
        break;

      case FieldTypes.CHECKBOX:
        const checkbox = editor.querySelector('.field-modal-checkbox');
        checkbox?.addEventListener('change', () => {
          this._updateCheckboxVisual(editor, checkbox.checked);
        });
        break;

      case FieldTypes.SELECT:
        this._attachSelectHandlers(editor, field);
        break;

      case FieldTypes.MULTI_SELECT:
        this._attachMultiSelectHandlers(editor, field);
        break;

      case FieldTypes.LINK:
        this._attachLinkEditorHandlers(editor, field, currentValue, recordId);
        break;

      case FieldTypes.JSON:
        this._attachJsonEditorHandlers(editor);
        break;
    }
  }

  _attachSelectHandlers(editor, field) {
    const current = editor.querySelector('.field-modal-select-current');
    const dropdown = editor.querySelector('.field-modal-select-dropdown');
    const searchInput = editor.querySelector('.field-modal-select-search-input');

    // Toggle dropdown
    current?.addEventListener('click', () => {
      dropdown?.classList.toggle('open');
      if (dropdown?.classList.contains('open')) {
        searchInput?.focus();
      }
    });

    // Search
    searchInput?.addEventListener('input', (e) => {
      const term = e.target.value.toLowerCase();
      editor.querySelectorAll('.field-modal-select-option:not(.field-modal-select-clear)').forEach(opt => {
        const text = opt.textContent.toLowerCase();
        opt.style.display = text.includes(term) ? '' : 'none';
      });
    });

    // Select option
    editor.querySelectorAll('.field-modal-select-option').forEach(opt => {
      opt.addEventListener('click', () => {
        const value = opt.dataset.value || null;
        this._updateSelectValue(editor, field, value);
        dropdown?.classList.remove('open');
      });
    });

    // Close on outside click
    document.addEventListener('click', (e) => {
      if (!editor.contains(e.target)) {
        dropdown?.classList.remove('open');
      }
    });
  }

  _attachMultiSelectHandlers(editor, field) {
    const searchInput = editor.querySelector('.field-modal-multiselect-search-input');
    const selectedContainer = editor.querySelector('.field-modal-multiselect-selected');
    const choices = field.options?.choices || [];

    // Update selected display
    const updateSelectedDisplay = () => {
      const checked = editor.querySelectorAll('.field-modal-multiselect-option input:checked');
      const selectedIds = Array.from(checked).map(cb => cb.value);

      if (selectedIds.length > 0) {
        selectedContainer.innerHTML = selectedIds.map(id => {
          const choice = choices.find(c => c.id === id);
          return choice ? `<span class="select-tag color-${choice.color || 'gray'}" data-id="${id}">${this._escapeHtml(choice.name)} <i class="ph ph-x remove-tag"></i></span>` : '';
        }).join('');
      } else {
        selectedContainer.innerHTML = '<span class="field-modal-multiselect-placeholder">Select options...</span>';
      }
    };

    // Checkbox change
    editor.querySelectorAll('.field-modal-multiselect-option input').forEach(cb => {
      cb.addEventListener('change', updateSelectedDisplay);
    });

    // Remove tag
    selectedContainer?.addEventListener('click', (e) => {
      const removeBtn = e.target.closest('.remove-tag');
      if (removeBtn) {
        const tag = removeBtn.closest('.select-tag');
        const id = tag?.dataset.id;
        const checkbox = editor.querySelector(`.field-modal-multiselect-option input[value="${id}"]`);
        if (checkbox) {
          checkbox.checked = false;
          updateSelectedDisplay();
        }
      }
    });

    // Search
    searchInput?.addEventListener('input', (e) => {
      const term = e.target.value.toLowerCase();
      editor.querySelectorAll('.field-modal-multiselect-option').forEach(opt => {
        const text = opt.textContent.toLowerCase();
        opt.style.display = text.includes(term) ? '' : 'none';
      });
    });
  }

  async _attachLinkEditorHandlers(editor, field, currentValue, recordId) {
    const linkedSetId = field.options?.linkedSetId;
    const linkedSet = linkedSetId ? this.sets.find(s => s.id === linkedSetId) : this.getCurrentSet();
    const allowMultiple = field.options?.allowMultiple !== false;

    if (!linkedSet) return;

    // Ensure records are loaded
    // Use undefined check specifically - empty array means already loaded (no records in IndexedDB)
    if (linkedSet._recordsInIndexedDB && linkedSet.records === undefined) {
      await this._ensureSetRecords(linkedSet);
    }

    const optionsContainer = editor.querySelector('.field-modal-link-options');
    const selectedContainer = editor.querySelector('.field-modal-link-selected');
    const searchInput = editor.querySelector('.field-modal-link-search-input');

    const displayField = field.options?.linkedFieldId
      ? linkedSet.fields.find(f => f.id === field.options.linkedFieldId)
      : (linkedSet.fields.find(f => f.isPrimary) || linkedSet.fields[0]);

    // Track selected links
    let selectedLinks = this._normalizeLinkValue(currentValue);

    // Render options
    const renderOptions = (filter = '') => {
      const records = linkedSet.records || [];
      const filteredRecords = filter
        ? records.filter(r => {
            const val = r.values?.[displayField?.id] || '';
            return String(val).toLowerCase().includes(filter.toLowerCase());
          })
        : records;

      if (filteredRecords.length === 0) {
        optionsContainer.innerHTML = '<div class="field-modal-link-empty">No matching records</div>';
        return;
      }

      optionsContainer.innerHTML = filteredRecords.map(record => {
        const displayValue = record.values?.[displayField?.id] || 'Untitled';
        const isSelected = selectedLinks.some(l => l.recordId === record.id);
        return `
          <div class="field-modal-link-option ${isSelected ? 'selected' : ''}" data-record-id="${record.id}">
            <span class="field-modal-link-check">${isSelected ? '<i class="ph ph-check"></i>' : ''}</span>
            <span class="field-modal-link-name">${this._escapeHtml(displayValue)}</span>
          </div>
        `;
      }).join('');

      // Attach option click handlers
      optionsContainer.querySelectorAll('.field-modal-link-option').forEach(opt => {
        opt.addEventListener('click', () => {
          const recordId = opt.dataset.recordId;
          const isSelected = selectedLinks.some(l => l.recordId === recordId);

          if (isSelected) {
            selectedLinks = selectedLinks.filter(l => l.recordId !== recordId);
          } else {
            if (allowMultiple) {
              selectedLinks.push({ recordId });
            } else {
              selectedLinks = [{ recordId }];
            }
          }

          updateSelectedDisplay();
          renderOptions(searchInput?.value || '');
        });
      });
    };

    // Update selected display
    const updateSelectedDisplay = () => {
      if (selectedLinks.length > 0) {
        selectedContainer.innerHTML = selectedLinks.map(link => {
          const linkedRecord = linkedSet.records?.find(r => r.id === link.recordId);
          const displayValue = linkedRecord?.values?.[displayField?.id] || 'Unknown';
          return `<span class="link-chip" data-linked-id="${link.recordId}">${this._escapeHtml(displayValue)} <i class="ph ph-x remove-link"></i></span>`;
        }).join('');
      } else {
        selectedContainer.innerHTML = '<span class="field-modal-link-placeholder">Link records...</span>';
      }
    };

    // Remove link
    selectedContainer?.addEventListener('click', (e) => {
      const removeBtn = e.target.closest('.remove-link');
      if (removeBtn) {
        const chip = removeBtn.closest('.link-chip');
        const linkId = chip?.dataset.linkedId;
        selectedLinks = selectedLinks.filter(l => l.recordId !== linkId);
        updateSelectedDisplay();
        renderOptions(searchInput?.value || '');
      }
    });

    // Search
    searchInput?.addEventListener('input', (e) => {
      renderOptions(e.target.value);
    });

    // Initial render
    optionsContainer.dataset.loading = 'false';
    renderOptions();
  }

  _attachJsonEditorHandlers(editor) {
    const modeButtons = editor.querySelectorAll('.field-modal-json-mode');

    modeButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        modeButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        // Could add mode switching logic here
      });
    });
  }

  // ============================================================================
  // Cell Edit Modal - Semantic Triplet Pattern
  // Subject (record) → Predicate (column) → Object (value)
  // ============================================================================

  /**
   * Show the semantic triplet cell-editing modal
   * Displays: Subject (record name) → Predicate (column name) → Object (value)
   * With info disclosure buttons for definitions and collapsible history
   *
   * @param {string} recordId - The record ID
   * @param {string} fieldId - The field ID
   */
  _showCellEditModal(recordId, fieldId) {
    const set = this.getCurrentSet();
    const record = set?.records.find(r => r.id === recordId);
    const field = set?.fields.find(f => f.id === fieldId);
    if (!record || !field) return;

    const value = record.values[fieldId];

    // Get primary field for record name (subject)
    const primaryField = set.fields.find(f => f.isPrimary) || set.fields[0];
    const recordName = primaryField ? (record.values[primaryField.id] || 'Untitled') : 'Untitled';

    // Get record definition (use a designated description/notes field if available)
    const descriptionField = set.fields.find(f =>
      f.type === FieldTypes.LONG_TEXT &&
      (f.name.toLowerCase().includes('description') ||
       f.name.toLowerCase().includes('notes') ||
       f.name.toLowerCase() === 'about')
    );
    const recordDefinition = descriptionField ? record.values[descriptionField.id] : null;

    // Get column/field definition
    const columnDefinition = field.description || null;

    // Check if field is editable
    const isEditable = ![FieldTypes.FORMULA, FieldTypes.ROLLUP, FieldTypes.COUNT, FieldTypes.AUTONUMBER].includes(field.type);

    // Get field history
    const fieldHistory = this._getFieldHistory(recordId, fieldId);
    const historyCount = fieldHistory.filter(event => {
      const action = event.payload?.action;
      return action === 'record_updated' || action === 'field_changed' || action === 'update';
    }).length;

    // Determine modal size based on field type
    const modalSize = this._getCellEditModalSize(field.type);

    // Render the editor content based on field type
    const editorContent = this._renderCellEditModalEditor(field, value, recordId, isEditable);

    // Render history section
    const historyHtml = this._renderCellEditModalHistory(fieldHistory, field);

    // Create modal with semantic triplet header
    const modal = new EOModal({
      id: `cell-edit-modal-${recordId}-${fieldId}`,
      size: modalSize,
      closable: true,
      content: `
        <div class="cell-edit-modal-container">
          <!-- Header: Subject + Predicate -->
          <div class="cell-edit-modal-header">
            <!-- Subject (Record Name) - Primary, Bold -->
            <div class="cell-edit-modal-subject">
              <span class="cell-edit-modal-subject-name">${this._escapeHtml(recordName)}</span>
              <button class="cell-edit-modal-info-btn"
                      data-info-type="record"
                      data-record-id="${recordId}"
                      title="Record information">
                <i class="ph ph-info"></i>
              </button>
            </div>

            <!-- Predicate (Column Name) - Secondary, Muted -->
            <div class="cell-edit-modal-predicate">
              <span class="cell-edit-modal-predicate-name">${this._escapeHtml(field.name)}</span>
              <button class="cell-edit-modal-info-btn"
                      data-info-type="column"
                      data-field-id="${fieldId}"
                      title="Field definition">
                <i class="ph ph-info"></i>
              </button>
            </div>
          </div>

          <!-- Object (Value) -->
          <div class="cell-edit-modal-object">
            ${editorContent}
          </div>

          <!-- History Section -->
          <div class="cell-edit-modal-history">
            <button class="cell-edit-modal-history-toggle" data-expanded="false">
              <i class="ph ph-caret-right toggle-icon"></i>
              <span>History</span>
              <span class="cell-edit-modal-history-count">${historyCount}</span>
            </button>
            <div class="cell-edit-modal-history-content">
              ${historyHtml}
            </div>
          </div>
        </div>
      `,
      buttons: isEditable ? [
        {
          label: 'Cancel',
          secondary: true,
          action: 'cancel',
          onClick: () => modal.hide()
        },
        {
          label: 'Save',
          icon: 'ph-floppy-disk',
          primary: true,
          action: 'save',
          onClick: () => {
            const newValue = this._getCellEditModalValue(modal, field);
            if (newValue !== undefined && newValue !== value) {
              this._updateRecordValue(recordId, fieldId, newValue);
              // Update the cell display
              const cell = document.querySelector(`tr[data-record-id="${recordId}"] td[data-field-id="${fieldId}"]`);
              if (cell) {
                this._updateCellDisplay(cell, recordId, field);
              }
            }
            modal.hide();
          }
        }
      ] : [
        {
          label: 'Close',
          primary: true,
          action: 'close',
          onClick: () => modal.hide()
        }
      ]
    });

    modal.show();

    // Remove default title from modal header (we're using semantic triplet instead)
    const titleEl = modal.element.querySelector('.eo-modal-title');
    if (titleEl) titleEl.style.display = 'none';

    // Attach event handlers
    this._attachCellEditModalHandlers(modal, field, value, recordId, recordDefinition, columnDefinition);

    // Focus the input element
    setTimeout(() => {
      const focusable = modal.element.querySelector('.cell-edit-modal-editor input, .cell-edit-modal-editor textarea');
      if (focusable) {
        focusable.focus();
        if (focusable.select) focusable.select();
      }
    }, 100);
  }

  /**
   * Get modal size based on field type
   */
  _getCellEditModalSize(fieldType) {
    switch (fieldType) {
      case FieldTypes.LONG_TEXT:
      case FieldTypes.JSON:
        return 'large';
      case FieldTypes.MULTI_SELECT:
      case FieldTypes.LINK:
        return 'medium';
      default:
        return 'medium';
    }
  }

  /**
   * Render the appropriate editor for the cell edit modal
   */
  _renderCellEditModalEditor(field, value, recordId, isEditable) {
    if (!isEditable) {
      return this._renderCellEditModalReadOnly(field, value);
    }

    switch (field.type) {
      case FieldTypes.TEXT:
      case FieldTypes.URL:
      case FieldTypes.EMAIL:
      case FieldTypes.PHONE:
        return this._renderCellEditModalTextInput(field, value);

      case FieldTypes.LONG_TEXT:
        return this._renderCellEditModalTextarea(field, value);

      case FieldTypes.NUMBER:
        return this._renderCellEditModalNumberInput(field, value);

      case FieldTypes.CHECKBOX:
        return this._renderCellEditModalCheckbox(field, value);

      case FieldTypes.SELECT:
        return this._renderCellEditModalSelect(field, value);

      case FieldTypes.MULTI_SELECT:
        return this._renderCellEditModalMultiSelect(field, value);

      case FieldTypes.DATE:
        return this._renderCellEditModalDateInput(field, value);

      default:
        return this._renderCellEditModalTextInput(field, value);
    }
  }

  _renderCellEditModalReadOnly(field, value) {
    let displayValue = value !== null && value !== undefined ? String(value) : '(empty)';
    return `
      <div class="cell-edit-modal-editor cell-edit-modal-readonly">
        <div class="cell-edit-modal-readonly-value">${this._escapeHtml(displayValue)}</div>
        <div class="cell-edit-modal-readonly-notice">
          <i class="ph ph-lock-simple"></i>
          <span>This field is computed automatically</span>
        </div>
      </div>
    `;
  }

  _renderCellEditModalTextInput(field, value) {
    const placeholder = field.type === FieldTypes.URL ? 'https://...' :
                        field.type === FieldTypes.EMAIL ? 'email@example.com' :
                        field.type === FieldTypes.PHONE ? '+1 (555) 000-0000' : '';
    return `
      <div class="cell-edit-modal-editor">
        <input type="text"
               class="cell-edit-modal-input"
               value="${this._escapeHtml(value || '')}"
               placeholder="${placeholder}"
               data-field-type="${field.type}">
      </div>
    `;
  }

  _renderCellEditModalTextarea(field, value) {
    return `
      <div class="cell-edit-modal-editor">
        <div class="cell-edit-modal-textarea-wrapper">
          <textarea class="cell-edit-modal-textarea">${this._escapeHtml(value || '')}</textarea>
          <span class="cell-edit-modal-textarea-resize"><i class="ph ph-arrows-out-simple"></i></span>
        </div>
      </div>
    `;
  }

  _renderCellEditModalNumberInput(field, value) {
    const format = field.options?.format || 'number';
    const precision = field.options?.precision ?? 2;
    return `
      <div class="cell-edit-modal-editor">
        <div class="cell-edit-modal-number-wrapper">
          <input type="number"
                 class="cell-edit-modal-number-input"
                 value="${value ?? ''}"
                 step="${format === 'percent' ? '0.01' : Math.pow(10, -precision)}"
                 data-format="${format}">
        </div>
      </div>
    `;
  }

  _renderCellEditModalDateInput(field, value) {
    const includeTime = field.options?.includeTime;
    const inputType = includeTime ? 'datetime-local' : 'date';
    let formattedValue = '';

    if (value) {
      try {
        const date = new Date(value);
        if (includeTime) {
          formattedValue = date.toISOString().slice(0, 16);
        } else {
          formattedValue = date.toISOString().slice(0, 10);
        }
      } catch (e) {
        formattedValue = value;
      }
    }

    return `
      <div class="cell-edit-modal-editor">
        <div class="cell-edit-modal-date-wrapper">
          <input type="${inputType}"
                 class="cell-edit-modal-date-input"
                 value="${formattedValue}">
          <span class="cell-edit-modal-date-icon"><i class="ph ph-calendar"></i></span>
        </div>
      </div>
    `;
  }

  _renderCellEditModalCheckbox(field, value) {
    return `
      <div class="cell-edit-modal-editor">
        <div class="cell-edit-modal-checkbox-wrapper">
          <div class="cell-edit-modal-checkbox-control ${value ? 'checked' : ''}" data-checked="${!!value}">
            <span class="cell-edit-modal-checkbox-visual">
              <i class="ph ${value ? 'ph-check-square-fill' : 'ph-square'}"></i>
            </span>
            <span class="cell-edit-modal-checkbox-label">${value ? 'Yes' : 'No'}</span>
          </div>
        </div>
      </div>
    `;
  }

  _renderCellEditModalSelect(field, value) {
    const choices = field.options?.choices || [];
    const currentChoice = choices.find(c => c.id === value);

    return `
      <div class="cell-edit-modal-editor">
        <div class="cell-edit-modal-select-wrapper" data-value="${value || ''}">
          <div class="cell-edit-modal-select-trigger" tabindex="0">
            <div class="cell-edit-modal-select-value">
              ${currentChoice
                ? `<span class="select-tag color-${currentChoice.color || 'gray'}">${this._escapeHtml(currentChoice.name)}</span>`
                : '<span class="cell-edit-modal-select-placeholder">Select an option...</span>'
              }
            </div>
            <div class="cell-edit-modal-select-icons">
              ${currentChoice && currentChoice.description ? `
                <button class="cell-edit-modal-info-btn"
                        data-info-type="value"
                        data-choice-id="${currentChoice.id}"
                        title="Option definition">
                  <i class="ph ph-info"></i>
                </button>
              ` : ''}
              <i class="ph ph-caret-down cell-edit-modal-select-caret"></i>
            </div>
          </div>
          <div class="cell-edit-modal-select-dropdown">
            ${choices.map(choice => `
              <div class="cell-edit-modal-select-option ${choice.id === value ? 'selected' : ''}"
                   data-value="${choice.id}">
                <span class="cell-edit-modal-select-radio"></span>
                <span class="cell-edit-modal-select-option-label">
                  <span class="select-tag color-${choice.color || 'gray'}">${this._escapeHtml(choice.name)}</span>
                </span>
                ${choice.description ? `
                  <button class="cell-edit-modal-info-btn"
                          data-info-type="value"
                          data-choice-id="${choice.id}"
                          title="Option definition">
                    <i class="ph ph-info"></i>
                  </button>
                ` : ''}
              </div>
            `).join('')}
          </div>
        </div>
      </div>
    `;
  }

  _renderCellEditModalMultiSelect(field, value) {
    const choices = field.options?.choices || [];
    const selectedIds = Array.isArray(value) ? value : (value ? [value] : []);

    return `
      <div class="cell-edit-modal-editor">
        <div class="cell-edit-modal-multiselect-wrapper" data-value="${JSON.stringify(selectedIds)}">
          <div class="cell-edit-modal-multiselect-selected">
            ${selectedIds.length > 0
              ? selectedIds.map(id => {
                  const choice = choices.find(c => c.id === id);
                  if (!choice) return '';
                  return `
                    <span class="cell-edit-modal-multiselect-chip select-tag color-${choice.color || 'gray'}" data-id="${id}">
                      ${this._escapeHtml(choice.name)}
                      ${choice.description ? `
                        <button class="cell-edit-modal-info-btn"
                                data-info-type="value"
                                data-choice-id="${choice.id}"
                                title="Option definition">
                          <i class="ph ph-info"></i>
                        </button>
                      ` : ''}
                      <button class="cell-edit-modal-multiselect-chip-remove" data-id="${id}">
                        <i class="ph ph-x"></i>
                      </button>
                    </span>
                  `;
                }).join('')
              : ''
            }
            <button class="cell-edit-modal-multiselect-add-btn">
              <i class="ph ph-plus"></i> Add
            </button>
          </div>
          <div class="cell-edit-modal-multiselect-dropdown">
            ${choices.map(choice => {
              const isSelected = selectedIds.includes(choice.id);
              return `
                <div class="cell-edit-modal-multiselect-option ${isSelected ? 'selected' : ''}"
                     data-value="${choice.id}">
                  <span class="cell-edit-modal-multiselect-checkbox">
                    ${isSelected ? '<i class="ph ph-check"></i>' : ''}
                  </span>
                  <span class="cell-edit-modal-multiselect-option-label">
                    <span class="select-tag color-${choice.color || 'gray'}">${this._escapeHtml(choice.name)}</span>
                  </span>
                  ${choice.description ? `
                    <button class="cell-edit-modal-info-btn"
                            data-info-type="value"
                            data-choice-id="${choice.id}"
                            title="Option definition">
                      <i class="ph ph-info"></i>
                    </button>
                  ` : ''}
                </div>
              `;
            }).join('')}
          </div>
        </div>
      </div>
    `;
  }

  /**
   * Render history section for cell edit modal
   */
  _renderCellEditModalHistory(fieldHistory, field) {
    const changes = fieldHistory.filter(event => {
      const action = event.payload?.action;
      return action === 'record_updated' || action === 'field_changed' || action === 'update';
    });

    if (changes.length === 0) {
      return `
        <div class="cell-edit-modal-history-empty">
          <i class="ph ph-clock-afternoon"></i>
          <span>No changes yet</span>
        </div>
      `;
    }

    // Show last 5 changes
    const visibleChanges = changes.slice().reverse().slice(0, 5);

    return `
      <div class="cell-edit-modal-history-events">
        ${visibleChanges.map(event => {
          const timestamp = event.timestamp ? new Date(event.timestamp).toLocaleString() : 'Unknown time';
          const agent = event.payload?.actor || event.actor || 'User';
          const oldValue = event.payload?.previousValue ?? event.payload?.oldValue ?? '(empty)';
          const newValue = event.payload?.newValue ?? event.payload?.value ?? '(empty)';

          // Format values for display
          const formatValue = (val) => {
            if (val === null || val === undefined || val === '') return '(empty)';
            if (typeof val === 'object') return JSON.stringify(val).substring(0, 50);
            return String(val).substring(0, 50);
          };

          return `
            <div class="cell-edit-modal-history-event">
              <span class="cell-edit-modal-history-event-icon">
                <i class="ph ph-pencil-simple"></i>
              </span>
              <div class="cell-edit-modal-history-event-content">
                <div class="cell-edit-modal-history-event-meta">
                  <span class="cell-edit-modal-history-event-agent">${this._escapeHtml(agent)}</span>
                  <span class="cell-edit-modal-history-event-time">${timestamp}</span>
                </div>
                <div class="cell-edit-modal-history-event-change">
                  <span class="cell-edit-modal-history-event-old">${this._escapeHtml(formatValue(oldValue))}</span>
                  <span class="cell-edit-modal-history-event-arrow">→</span>
                  <span class="cell-edit-modal-history-event-new">${this._escapeHtml(formatValue(newValue))}</span>
                </div>
              </div>
            </div>
          `;
        }).join('')}
      </div>
    `;
  }

  /**
   * Get value from cell edit modal
   */
  _getCellEditModalValue(modal, field) {
    const editor = modal.element.querySelector('.cell-edit-modal-editor');
    if (!editor) return undefined;

    switch (field.type) {
      case FieldTypes.TEXT:
      case FieldTypes.URL:
      case FieldTypes.EMAIL:
      case FieldTypes.PHONE:
        return editor.querySelector('.cell-edit-modal-input')?.value || '';

      case FieldTypes.LONG_TEXT:
        return editor.querySelector('.cell-edit-modal-textarea')?.value || '';

      case FieldTypes.NUMBER:
        const numValue = editor.querySelector('.cell-edit-modal-number-input')?.value;
        return numValue === '' ? null : parseFloat(numValue);

      case FieldTypes.CHECKBOX:
        return editor.querySelector('.cell-edit-modal-checkbox-control')?.dataset.checked === 'true';

      case FieldTypes.SELECT:
        return editor.querySelector('.cell-edit-modal-select-wrapper')?.dataset.value || null;

      case FieldTypes.MULTI_SELECT:
        try {
          return JSON.parse(editor.querySelector('.cell-edit-modal-multiselect-wrapper')?.dataset.value || '[]');
        } catch (e) {
          return [];
        }

      case FieldTypes.DATE:
        const dateValue = editor.querySelector('.cell-edit-modal-date-input')?.value;
        return dateValue ? new Date(dateValue).toISOString() : null;

      default:
        return editor.querySelector('input, textarea')?.value;
    }
  }

  /**
   * Attach event handlers for cell edit modal
   */
  _attachCellEditModalHandlers(modal, field, currentValue, recordId, recordDefinition, columnDefinition) {
    const container = modal.element.querySelector('.cell-edit-modal-container');
    if (!container) return;

    // History toggle
    const historyToggle = container.querySelector('.cell-edit-modal-history-toggle');
    historyToggle?.addEventListener('click', () => {
      const isExpanded = historyToggle.classList.contains('expanded');
      historyToggle.classList.toggle('expanded', !isExpanded);
    });

    // Info button popovers
    container.querySelectorAll('.cell-edit-modal-info-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        this._showCellEditInfoPopover(btn, field, recordId, recordDefinition, columnDefinition);
      });
    });

    // Field type specific handlers
    switch (field.type) {
      case FieldTypes.CHECKBOX:
        this._attachCellEditCheckboxHandlers(container);
        break;

      case FieldTypes.SELECT:
        this._attachCellEditSelectHandlers(container, field);
        break;

      case FieldTypes.MULTI_SELECT:
        this._attachCellEditMultiSelectHandlers(container, field);
        break;
    }
  }

  /**
   * Show info popover for record, column, or value definition
   * For column definitions, opens a proper modal instead of popover
   */
  _showCellEditInfoPopover(btn, field, recordId, recordDefinition, columnDefinition) {
    const infoType = btn.dataset.infoType;

    // For column definitions, show a proper modal instead of popover
    if (infoType === 'column') {
      this._showDefinitionDetailModal(field, columnDefinition);
      return;
    }

    // Remove any existing popover
    document.querySelectorAll('.cell-edit-modal-info-popover').forEach(p => p.remove());

    let title = '';
    let content = '';

    switch (infoType) {
      case 'record':
        title = 'Record Information';
        content = recordDefinition
          ? `<div class="cell-edit-modal-info-popover-content">${this._escapeHtml(recordDefinition).substring(0, 200)}${recordDefinition.length > 200 ? '...' : ''}</div>`
          : '<div class="cell-edit-modal-info-popover-empty">No description available for this record.</div>';
        break;

      case 'value':
        const choiceId = btn.dataset.choiceId;
        const choice = field.options?.choices?.find(c => c.id === choiceId);
        title = choice ? `${choice.name} Definition` : 'Value Definition';
        content = choice?.description
          ? `<div class="cell-edit-modal-info-popover-content">${this._escapeHtml(choice.description)}</div>`
          : '<div class="cell-edit-modal-info-popover-empty">No definition set for this option.</div>';
        break;
    }

    // Create popover
    const popover = document.createElement('div');
    popover.className = 'cell-edit-modal-info-popover';
    popover.innerHTML = `
      <div class="cell-edit-modal-info-popover-title">${title}</div>
      ${content}
    `;

    // Position popover below the button
    const btnRect = btn.getBoundingClientRect();
    popover.style.position = 'fixed';
    popover.style.top = `${btnRect.bottom + 8}px`;
    popover.style.left = `${btnRect.left - 8}px`;

    document.body.appendChild(popover);

    // Close on outside click
    const closePopover = (e) => {
      if (!popover.contains(e.target) && e.target !== btn) {
        popover.remove();
        document.removeEventListener('click', closePopover);
      }
    };
    setTimeout(() => {
      document.addEventListener('click', closePopover);
    }, 10);
  }

  /**
   * Show a definition detail modal that appears above other modals
   * Provides a first-class UX for viewing and editing definitions
   */
  _showDefinitionDetailModal(field, columnDefinition) {
    // Check if field has a linked definition
    const definitionRef = field.definitionRef || field.semanticBinding;
    const definition = definitionRef?.definitionId
      ? this.definitions?.find(d => d.id === definitionRef.definitionId)
      : null;

    // Get definition details
    const defName = field.name || 'Field';
    const defText = columnDefinition || definition?.term?.definitionText || definition?.description || '';
    const authority = definition?.authority;
    const source = definition?.source;
    const uri = definition?.sourceUri || definition?.term?.uri || definitionRef?.uri || '';

    // Check if this is a stub definition
    const isStub = !defText && !uri;

    // Create the modal backdrop with high z-index
    const modalBackdrop = document.createElement('div');
    modalBackdrop.className = 'definition-detail-modal-backdrop';
    modalBackdrop.innerHTML = `
      <div class="definition-detail-modal">
        <div class="definition-detail-modal-header">
          <div class="definition-detail-modal-title">
            <i class="ph ph-book-open"></i>
            <span>${this._escapeHtml(defName)}</span>
          </div>
          <button class="definition-detail-modal-close" title="Close">
            <i class="ph ph-x"></i>
          </button>
        </div>

        <div class="definition-detail-modal-body">
          ${isStub ? `
            <div class="definition-detail-empty">
              <div class="definition-detail-empty-icon">
                <i class="ph ph-book-open-text"></i>
              </div>
              <div class="definition-detail-empty-text">No definition set for this field</div>
              <div class="definition-detail-empty-hint">
                Link this field to a definition to provide semantic meaning and enable better data understanding.
              </div>
            </div>
          ` : `
            <div class="definition-detail-section">
              <div class="definition-detail-label">Definition</div>
              <div class="definition-detail-text">${this._escapeHtml(defText)}</div>
            </div>

            ${authority ? `
              <div class="definition-detail-section">
                <div class="definition-detail-label">Authority</div>
                <div class="definition-detail-authority">
                  <i class="ph ph-seal-check"></i>
                  <span>${this._escapeHtml(authority.name || authority.shortName || 'Unknown')}</span>
                </div>
              </div>
            ` : ''}

            ${uri ? `
              <div class="definition-detail-section">
                <div class="definition-detail-label">Source URI</div>
                <div class="definition-detail-uri">
                  <i class="ph ph-link"></i>
                  <a href="${this._escapeHtml(uri)}" target="_blank" rel="noopener noreferrer">${this._escapeHtml(uri)}</a>
                </div>
              </div>
            ` : ''}

            ${source ? `
              <div class="definition-detail-section">
                <div class="definition-detail-label">Citation</div>
                <div class="definition-detail-citation">${this._escapeHtml(source.citation || source.title || '')}</div>
              </div>
            ` : ''}
          `}
        </div>

        <div class="definition-detail-modal-footer">
          ${definition ? `
            <button class="definition-detail-btn definition-detail-btn-secondary" data-action="view-full">
              <i class="ph ph-arrow-square-out"></i>
              <span>View Full Definition</span>
            </button>
          ` : `
            <button class="definition-detail-btn definition-detail-btn-secondary" data-action="link">
              <i class="ph ph-link"></i>
              <span>Link Definition</span>
            </button>
          `}
          <button class="definition-detail-btn definition-detail-btn-primary" data-action="close">
            <span>Close</span>
          </button>
        </div>
      </div>
    `;

    document.body.appendChild(modalBackdrop);

    // Animate in
    requestAnimationFrame(() => {
      modalBackdrop.classList.add('visible');
    });

    // Event handlers
    const closeModal = () => {
      modalBackdrop.classList.remove('visible');
      setTimeout(() => modalBackdrop.remove(), 200);
    };

    modalBackdrop.querySelector('.definition-detail-modal-close')?.addEventListener('click', closeModal);
    modalBackdrop.querySelector('[data-action="close"]')?.addEventListener('click', closeModal);

    // Click backdrop to close
    modalBackdrop.addEventListener('click', (e) => {
      if (e.target === modalBackdrop) closeModal();
    });

    // Escape key to close
    const handleEscape = (e) => {
      if (e.key === 'Escape') {
        closeModal();
        document.removeEventListener('keydown', handleEscape);
      }
    };
    document.addEventListener('keydown', handleEscape);

    // View full definition action
    modalBackdrop.querySelector('[data-action="view-full"]')?.addEventListener('click', () => {
      closeModal();
      if (definition) {
        this._showDefinitionDetail(definition.id);
      }
    });

    // Link definition action
    modalBackdrop.querySelector('[data-action="link"]')?.addEventListener('click', () => {
      closeModal();
      this._showDefinitionLinkModal(field.id);
    });
  }

  /**
   * Attach checkbox handlers for cell edit modal
   */
  _attachCellEditCheckboxHandlers(container) {
    const control = container.querySelector('.cell-edit-modal-checkbox-control');
    control?.addEventListener('click', () => {
      const isChecked = control.dataset.checked === 'true';
      const newChecked = !isChecked;
      control.dataset.checked = newChecked.toString();
      control.classList.toggle('checked', newChecked);

      const icon = control.querySelector('.cell-edit-modal-checkbox-visual i');
      if (icon) {
        icon.className = `ph ${newChecked ? 'ph-check-square-fill' : 'ph-square'}`;
      }

      const label = control.querySelector('.cell-edit-modal-checkbox-label');
      if (label) {
        label.textContent = newChecked ? 'Yes' : 'No';
      }
    });
  }

  /**
   * Attach select handlers for cell edit modal
   */
  _attachCellEditSelectHandlers(container, field) {
    const wrapper = container.querySelector('.cell-edit-modal-select-wrapper');
    const trigger = container.querySelector('.cell-edit-modal-select-trigger');
    const dropdown = container.querySelector('.cell-edit-modal-select-dropdown');

    // Toggle dropdown
    trigger?.addEventListener('click', (e) => {
      if (e.target.closest('.cell-edit-modal-info-btn')) return;
      wrapper?.classList.toggle('open');
    });

    // Select option
    container.querySelectorAll('.cell-edit-modal-select-option').forEach(opt => {
      opt.addEventListener('click', (e) => {
        if (e.target.closest('.cell-edit-modal-info-btn')) return;

        const value = opt.dataset.value;
        wrapper.dataset.value = value;

        // Update selection visual
        container.querySelectorAll('.cell-edit-modal-select-option').forEach(o => {
          o.classList.toggle('selected', o.dataset.value === value);
        });

        // Update trigger display
        const choice = field.options?.choices?.find(c => c.id === value);
        const valueDisplay = trigger.querySelector('.cell-edit-modal-select-value');
        if (valueDisplay) {
          valueDisplay.innerHTML = choice
            ? `<span class="select-tag color-${choice.color || 'gray'}">${this._escapeHtml(choice.name)}</span>`
            : '<span class="cell-edit-modal-select-placeholder">Select an option...</span>';
        }

        // Update info button visibility
        const iconsDiv = trigger.querySelector('.cell-edit-modal-select-icons');
        if (iconsDiv) {
          const existingInfoBtn = iconsDiv.querySelector('.cell-edit-modal-info-btn');
          if (choice && choice.description && !existingInfoBtn) {
            const infoBtn = document.createElement('button');
            infoBtn.className = 'cell-edit-modal-info-btn';
            infoBtn.dataset.infoType = 'value';
            infoBtn.dataset.choiceId = choice.id;
            infoBtn.title = 'Option definition';
            infoBtn.innerHTML = '<i class="ph ph-info"></i>';
            iconsDiv.insertBefore(infoBtn, iconsDiv.querySelector('.cell-edit-modal-select-caret'));
          } else if (existingInfoBtn && (!choice || !choice.description)) {
            existingInfoBtn.remove();
          } else if (existingInfoBtn && choice) {
            existingInfoBtn.dataset.choiceId = choice.id;
          }
        }

        wrapper.classList.remove('open');
      });
    });

    // Close on outside click
    document.addEventListener('click', (e) => {
      if (!wrapper.contains(e.target)) {
        wrapper.classList.remove('open');
      }
    });
  }

  /**
   * Attach multi-select handlers for cell edit modal
   */
  _attachCellEditMultiSelectHandlers(container, field) {
    const wrapper = container.querySelector('.cell-edit-modal-multiselect-wrapper');
    const selectedContainer = container.querySelector('.cell-edit-modal-multiselect-selected');
    const dropdown = container.querySelector('.cell-edit-modal-multiselect-dropdown');
    const addBtn = container.querySelector('.cell-edit-modal-multiselect-add-btn');
    const choices = field.options?.choices || [];

    // Get current selected IDs
    const getSelectedIds = () => {
      try {
        return JSON.parse(wrapper.dataset.value || '[]');
      } catch (e) {
        return [];
      }
    };

    // Update the selected chips display
    const updateSelectedDisplay = (selectedIds) => {
      wrapper.dataset.value = JSON.stringify(selectedIds);

      // Rebuild chips
      const chipsHtml = selectedIds.map(id => {
        const choice = choices.find(c => c.id === id);
        if (!choice) return '';
        return `
          <span class="cell-edit-modal-multiselect-chip select-tag color-${choice.color || 'gray'}" data-id="${id}">
            ${this._escapeHtml(choice.name)}
            ${choice.description ? `
              <button class="cell-edit-modal-info-btn"
                      data-info-type="value"
                      data-choice-id="${choice.id}"
                      title="Option definition">
                <i class="ph ph-info"></i>
              </button>
            ` : ''}
            <button class="cell-edit-modal-multiselect-chip-remove" data-id="${id}">
              <i class="ph ph-x"></i>
            </button>
          </span>
        `;
      }).join('');

      selectedContainer.innerHTML = `
        ${chipsHtml}
        <button class="cell-edit-modal-multiselect-add-btn">
          <i class="ph ph-plus"></i> Add
        </button>
      `;

      // Update dropdown options
      container.querySelectorAll('.cell-edit-modal-multiselect-option').forEach(opt => {
        const isSelected = selectedIds.includes(opt.dataset.value);
        opt.classList.toggle('selected', isSelected);
        const checkbox = opt.querySelector('.cell-edit-modal-multiselect-checkbox');
        if (checkbox) {
          checkbox.innerHTML = isSelected ? '<i class="ph ph-check"></i>' : '';
        }
      });

      // Re-attach add button handler
      const newAddBtn = selectedContainer.querySelector('.cell-edit-modal-multiselect-add-btn');
      newAddBtn?.addEventListener('click', () => {
        wrapper.classList.toggle('open');
      });

      // Re-attach remove handlers
      selectedContainer.querySelectorAll('.cell-edit-modal-multiselect-chip-remove').forEach(removeBtn => {
        removeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          const idToRemove = removeBtn.dataset.id;
          const newIds = getSelectedIds().filter(id => id !== idToRemove);
          updateSelectedDisplay(newIds);
        });
      });

      // Re-attach info button handlers
      selectedContainer.querySelectorAll('.cell-edit-modal-info-btn').forEach(infoBtn => {
        infoBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this._showCellEditInfoPopover(infoBtn, field, null, null, null);
        });
      });
    };

    // Toggle dropdown
    addBtn?.addEventListener('click', () => {
      wrapper.classList.toggle('open');
    });

    // Option click
    container.querySelectorAll('.cell-edit-modal-multiselect-option').forEach(opt => {
      opt.addEventListener('click', (e) => {
        if (e.target.closest('.cell-edit-modal-info-btn')) return;

        const value = opt.dataset.value;
        let selectedIds = getSelectedIds();

        if (selectedIds.includes(value)) {
          selectedIds = selectedIds.filter(id => id !== value);
        } else {
          selectedIds.push(value);
        }

        updateSelectedDisplay(selectedIds);
      });
    });

    // Remove chip
    selectedContainer?.querySelectorAll('.cell-edit-modal-multiselect-chip-remove').forEach(removeBtn => {
      removeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const idToRemove = removeBtn.dataset.id;
        const newIds = getSelectedIds().filter(id => id !== idToRemove);
        updateSelectedDisplay(newIds);
      });
    });

    // Close dropdown on outside click
    document.addEventListener('click', (e) => {
      if (!wrapper.contains(e.target)) {
        wrapper.classList.remove('open');
      }
    });
  }

  /**
   * Show modal with full source long text content (read-only)
   * Used for viewing source data which is immutable
   */
  _showSourceLongTextModal(fieldName, fullValue) {
    const modal = new EOModal({
      title: fieldName,
      size: 'large',
      content: `
        <div class="longtext-modal-content source-longtext-modal">
          <div class="source-longtext-modal-notice">
            <i class="ph ph-lock-simple"></i>
            <span>Source data is read-only</span>
          </div>
          <div class="longtext-modal-text">${this._escapeHtml(fullValue).replace(/\n/g, '<br>')}</div>
        </div>
      `,
      buttons: [
        {
          label: 'Close',
          primary: true,
          action: 'close',
          onClick: () => modal.hide()
        }
      ]
    });

    modal.show();
  }

  /**
   * Show modal with HTML preview - renders HTML content and allows switching between rendered and source views
   */
  _showHtmlPreviewModal(recordId, fieldId) {
    const set = this.getCurrentSet();
    const record = set?.records.find(r => r.id === recordId);
    const field = set?.fields.find(f => f.id === fieldId);
    if (!record || !field) return;

    const value = record.values[fieldId] || '';
    const fieldName = field.name || 'Content';
    const hasHtml = /<[a-z][\s\S]*>/i.test(value);

    // Create modal for displaying HTML content
    const modal = new EOModal({
      title: fieldName,
      size: 'large',
      content: `
        <div class="html-preview-modal-content">
          <div class="html-preview-tabs">
            <button class="html-preview-tab active" data-tab="rendered">
              <i class="ph ph-eye"></i> Rendered
            </button>
            <button class="html-preview-tab" data-tab="source">
              <i class="ph ph-code"></i> Source
            </button>
          </div>
          <div class="html-preview-pane active" data-pane="rendered">
            <div class="html-preview-rendered">${value}</div>
          </div>
          <div class="html-preview-pane" data-pane="source">
            <div class="html-preview-source">${this._escapeHtml(value)}</div>
          </div>
        </div>
      `,
      buttons: [
        {
          label: 'Edit',
          icon: 'ph-pencil-simple',
          secondary: true,
          action: 'edit',
          onClick: () => {
            modal.hide();
            // Find the cell and start editing
            const cell = this.container.querySelector(`tr[data-record-id="${recordId}"] td[data-field-id="${fieldId}"]`);
            if (cell) {
              this._startCellEdit(cell);
            }
          }
        },
        {
          label: 'Close',
          primary: true,
          action: 'close',
          onClick: () => modal.hide()
        }
      ]
    });

    // Add tab switching functionality after showing modal
    modal.show();

    // Set up tab switching
    const modalEl = modal.element;
    const tabs = modalEl.querySelectorAll('.html-preview-tab');
    const panes = modalEl.querySelectorAll('.html-preview-pane');

    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const targetPane = tab.dataset.tab;

        // Update active tab
        tabs.forEach(t => t.classList.remove('active'));
        tab.classList.add('active');

        // Update active pane
        panes.forEach(p => {
          p.classList.toggle('active', p.dataset.pane === targetPane);
        });
      });
    });
  }

  _closeSelectEditor = (e) => {
    if (!e.target.closest('.select-dropdown')) {
      this._endCellEdit();
    }
  }

  _renderMultiSelectEditor(cell, field, currentValue) {
    const choices = field.options?.choices || [];
    const currentSelections = Array.isArray(currentValue) ? currentValue : (currentValue ? [currentValue] : []);

    let html = '<div class="multiselect-dropdown">';
    html += '<div class="multiselect-dropdown-search">';
    html += '<input type="text" placeholder="Search options..." class="multiselect-search-input">';
    html += '</div>';
    html += '<div class="multiselect-dropdown-options">';

    choices.forEach(choice => {
      const isSelected = currentSelections.includes(choice.id);
      html += `
        <div class="multiselect-option ${isSelected ? 'selected' : ''}" data-value="${choice.id}">
          <span class="multiselect-option-check">${isSelected ? '<i class="ph ph-check"></i>' : ''}</span>
          <span class="select-tag color-${choice.color || 'gray'}">${this._escapeHtml(choice.name)}</span>
        </div>
      `;
    });

    if (choices.length === 0) {
      html += '<div class="multiselect-option-empty">No options available</div>';
    }

    html += '</div>';
    html += '<div class="multiselect-dropdown-footer">';
    html += '<button class="multiselect-done-btn">Done</button>';
    html += '</div>';
    html += '</div>';

    cell.innerHTML = html;

    const dropdown = cell.querySelector('.multiselect-dropdown');
    const searchInput = cell.querySelector('.multiselect-search-input');
    let selectedIds = [...currentSelections];

    // Search filtering
    searchInput?.addEventListener('input', (e) => {
      const searchTerm = e.target.value.toLowerCase();
      dropdown.querySelectorAll('.multiselect-option').forEach(opt => {
        const name = opt.querySelector('.select-tag')?.textContent.toLowerCase() || '';
        opt.style.display = name.includes(searchTerm) ? '' : 'none';
      });
    });
    searchInput?.focus();

    // Toggle selection
    dropdown.querySelectorAll('.multiselect-option').forEach(option => {
      option.addEventListener('click', (e) => {
        e.stopPropagation();
        const choiceId = option.dataset.value;

        const idx = selectedIds.indexOf(choiceId);
        if (idx > -1) {
          selectedIds.splice(idx, 1);
          option.classList.remove('selected');
          option.querySelector('.multiselect-option-check').innerHTML = '';
        } else {
          selectedIds.push(choiceId);
          option.classList.add('selected');
          option.querySelector('.multiselect-option-check').innerHTML = '<i class="ph ph-check"></i>';
        }
      });
    });

    // Done button
    dropdown.querySelector('.multiselect-done-btn')?.addEventListener('click', (e) => {
      e.stopPropagation();
      this._updateCellValue(selectedIds.length > 0 ? selectedIds : null);
      this._endCellEdit();
    });

    // Close on click outside and save - use longer delay to avoid race conditions
    setTimeout(() => {
      const closeHandler = (e) => {
        if (!e.target.closest('.multiselect-dropdown')) {
          this._updateCellValue(selectedIds.length > 0 ? selectedIds : null);
          this._endCellEdit();
          document.removeEventListener('click', closeHandler);
        }
      };
      document.addEventListener('click', closeHandler);
    }, 100);
  }

  async _renderLinkEditor(cell, field, currentValue) {
    const linkedSetId = field.options?.linkedSetId;
    const linkedViewId = field.options?.linkedViewId;
    const allowMultiple = field.options?.allowMultiple !== false;
    const hasEdgeFields = field.options?.enableEdgeData && field.options?.edgeFields?.length > 0;
    const linkedSet = linkedSetId ? this.sets.find(s => s.id === linkedSetId) : this.getCurrentSet();

    if (!linkedSet) {
      cell.innerHTML = '<div class="link-editor-error">No linked set configured</div>';
      return;
    }

    // CRITICAL: Ensure linked set records are loaded from IndexedDB before rendering
    // This fixes the issue where linking across sets showed empty dropdown
    // Use undefined check specifically - empty array means already loaded (no records in IndexedDB)
    if (linkedSet._recordsInIndexedDB && linkedSet.records === undefined) {
      cell.innerHTML = '<div class="link-editor-loading"><i class="ph ph-spinner ph-spin"></i> Loading records...</div>';
      await this._ensureSetRecords(linkedSet);
    }

    // Use linkedFieldId if set, otherwise fall back to primary field
    const displayField = field.options?.linkedFieldId
      ? linkedSet.fields.find(f => f.id === field.options.linkedFieldId)
      : (linkedSet.fields.find(f => f.isPrimary) || linkedSet.fields[0]);

    // Use normalized format for current links (handles both old and new formats)
    const normalizedLinks = this._normalizeLinkValue(currentValue);
    const currentLinkIds = normalizedLinks.map(l => l.recordId);

    // Get records, optionally filtered by view
    let availableRecords = [...(linkedSet.records || [])];
    let linkedView = null;

    if (linkedViewId) {
      linkedView = linkedSet.views?.find(v => v.id === linkedViewId);
      if (linkedView?.config?.filters?.length > 0) {
        // Apply the view's filters to the records
        availableRecords = availableRecords.filter(record => {
          return linkedView.config.filters.every(filter => {
            const value = record.values[filter.fieldId];
            return this._matchesFilter(value, filter);
          });
        });
      }
    }

    // Build dropdown with available records
    let html = '<div class="link-dropdown">';
    html += '<div class="link-dropdown-header">';
    const viewLabel = linkedView ? ` › ${this._escapeHtml(linkedView.name)}` : '';
    const edgeBadge = hasEdgeFields ? '<span class="edge-badge" title="Edge data enabled"><i class="ph ph-arrows-horizontal"></i></span>' : '';
    html += `<span class="link-dropdown-title">Link to ${this._escapeHtml(linkedSet.name)}${viewLabel}${edgeBadge}</span>`;
    html += '</div>';
    html += '<div class="link-dropdown-search"><input type="text" placeholder="Search records..." class="link-search-input"></div>';
    html += '<div class="link-dropdown-options">';

    availableRecords.forEach(record => {
      const recordName = record.values?.[displayField?.id] || 'Untitled';
      const isLinked = currentLinkIds.includes(record.id);
      const linkData = normalizedLinks.find(l => l.recordId === record.id);
      const hasEdgeData = hasEdgeFields && linkData?.edgeData && Object.keys(linkData.edgeData).length > 0;
      const edgeButton = hasEdgeFields && isLinked
        ? `<span class="link-option-edge${hasEdgeData ? ' has-data' : ''}" data-record-id="${record.id}" title="Edit edge data"><i class="ph ph-arrows-horizontal"></i></span>`
        : '';
      html += `
        <div class="link-option ${isLinked ? 'selected' : ''}" data-record-id="${record.id}">
          <span class="link-option-check">${isLinked ? '<i class="ph ph-check"></i>' : ''}</span>
          <span class="link-option-name">${this._escapeHtml(recordName)}</span>
          ${edgeButton}
        </div>
      `;
    });

    if (availableRecords.length === 0) {
      const emptyMsg = linkedView ? 'No records match this view\'s filters' : 'No records in this set';
      html += `<div class="link-option-empty">${emptyMsg}</div>`;
    }

    html += '</div></div>';
    cell.innerHTML = html;

    const dropdown = cell.querySelector('.link-dropdown');
    const searchInput = cell.querySelector('.link-search-input');

    // Maintain current links in new format (preserving edge data)
    let selectedLinks = [...normalizedLinks];

    // Helper to convert selected links to value format
    const getValueFromLinks = () => {
      if (selectedLinks.length === 0) return null;
      return selectedLinks;
    };

    // Search filtering
    searchInput?.addEventListener('input', (e) => {
      const searchTerm = e.target.value.toLowerCase();
      dropdown.querySelectorAll('.link-option').forEach(opt => {
        const name = opt.querySelector('.link-option-name')?.textContent.toLowerCase() || '';
        opt.style.display = name.includes(searchTerm) ? '' : 'none';
      });
    });
    searchInput?.focus();

    // Handle edge button clicks
    if (hasEdgeFields) {
      dropdown.querySelectorAll('.link-option-edge').forEach(edgeBtn => {
        edgeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          const recordId = edgeBtn.dataset.recordId;
          const sourceRecordId = this.editingCell?.recordId;
          const fieldId = field.id;
          if (sourceRecordId && recordId) {
            // Close the editor first, save current state
            this._updateCellValue(getValueFromLinks());
            this._endCellEdit();
            // Then show edge lens panel
            this._showEdgeLensPanel(sourceRecordId, fieldId, recordId);
          }
        });
      });
    }

    // Toggle selection
    dropdown.querySelectorAll('.link-option').forEach(option => {
      option.addEventListener('click', (e) => {
        // Don't toggle if clicking on edge button
        if (e.target.closest('.link-option-edge')) return;

        e.stopPropagation();
        const recordId = option.dataset.recordId;

        if (allowMultiple) {
          // Toggle in array
          const idx = selectedLinks.findIndex(l => l.recordId === recordId);
          if (idx > -1) {
            selectedLinks.splice(idx, 1);
            option.classList.remove('selected');
            option.querySelector('.link-option-check').innerHTML = '';
            // Remove edge button
            const edgeBtn = option.querySelector('.link-option-edge');
            if (edgeBtn) edgeBtn.remove();
          } else {
            selectedLinks.push(this._createLinkObject(recordId));
            option.classList.add('selected');
            option.querySelector('.link-option-check').innerHTML = '<i class="ph ph-check"></i>';
            // Add edge button if applicable
            if (hasEdgeFields) {
              const nameSpan = option.querySelector('.link-option-name');
              if (nameSpan && !option.querySelector('.link-option-edge')) {
                const edgeBtn = document.createElement('span');
                edgeBtn.className = 'link-option-edge';
                edgeBtn.dataset.recordId = recordId;
                edgeBtn.title = 'Edit edge data';
                edgeBtn.innerHTML = '<i class="ph ph-arrows-horizontal"></i>';
                edgeBtn.addEventListener('click', (ev) => {
                  ev.stopPropagation();
                  const sourceRecordId = this.editingCell?.recordId;
                  if (sourceRecordId) {
                    this._updateCellValue(getValueFromLinks());
                    this._endCellEdit();
                    this._showEdgeLensPanel(sourceRecordId, field.id, recordId);
                  }
                });
                option.appendChild(edgeBtn);
              }
            }
          }
        } else {
          // Single selection - replace
          dropdown.querySelectorAll('.link-option').forEach(o => {
            o.classList.remove('selected');
            o.querySelector('.link-option-check').innerHTML = '';
            const oldEdgeBtn = o.querySelector('.link-option-edge');
            if (oldEdgeBtn) oldEdgeBtn.remove();
          });
          selectedLinks = [this._createLinkObject(recordId)];
          option.classList.add('selected');
          option.querySelector('.link-option-check').innerHTML = '<i class="ph ph-check"></i>';
          // Add edge button if applicable
          if (hasEdgeFields) {
            const edgeBtn = document.createElement('span');
            edgeBtn.className = 'link-option-edge';
            edgeBtn.dataset.recordId = recordId;
            edgeBtn.title = 'Edit edge data';
            edgeBtn.innerHTML = '<i class="ph ph-arrows-horizontal"></i>';
            edgeBtn.addEventListener('click', (ev) => {
              ev.stopPropagation();
              const sourceRecordId = this.editingCell?.recordId;
              if (sourceRecordId) {
                this._updateCellValue(getValueFromLinks());
                this._endCellEdit();
                this._showEdgeLensPanel(sourceRecordId, field.id, recordId);
              }
            });
            option.appendChild(edgeBtn);
          }
          // Auto-close for single select
          this._updateCellValue(getValueFromLinks());
          this._endCellEdit();
          return;
        }
      });
    });

    // Close on click outside and save - use longer delay to avoid race conditions
    setTimeout(() => {
      const closeHandler = (e) => {
        if (!e.target.closest('.link-dropdown')) {
          this._updateCellValue(getValueFromLinks());
          this._endCellEdit();
          document.removeEventListener('click', closeHandler);
        }
      };
      document.addEventListener('click', closeHandler);
    }, 100);
  }

  _closeLinkEditor = (e) => {
    if (!e.target.closest('.link-dropdown')) {
      this._endCellEdit();
    }
  }

  _renderDateEditor(cell, field, value) {
    const input = document.createElement('input');
    input.type = field.options?.includeTime ? 'datetime-local' : 'date';
    input.className = 'cell-input';
    input.value = value || '';

    cell.innerHTML = '';
    cell.appendChild(input);

    input.focus();

    input.addEventListener('blur', () => this._endCellEdit());
    input.addEventListener('change', () => this._endCellEdit());
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') this._cancelCellEdit();
    });
  }

  _renderJsonEditor(cell, field, value) {
    // Parse value into object for table view
    let data = value;
    if (typeof value === 'string' && value.trim()) {
      try {
        data = JSON.parse(value);
      } catch (e) {
        data = value;
      }
    }

    // Create wrapper with toggle
    const wrapper = document.createElement('div');
    wrapper.className = 'json-editor-wrapper json-editor-table-mode';

    // Create toggle header
    const header = document.createElement('div');
    header.className = 'json-editor-header';

    const toggleGroup = document.createElement('div');
    toggleGroup.className = 'json-editor-toggle-group';

    const tableBtn = document.createElement('button');
    tableBtn.className = 'json-editor-toggle active';
    tableBtn.innerHTML = '<i class="ph ph-table"></i> Table';
    tableBtn.type = 'button';

    const rawBtn = document.createElement('button');
    rawBtn.className = 'json-editor-toggle';
    rawBtn.innerHTML = '<i class="ph ph-brackets-curly"></i> JSON';
    rawBtn.type = 'button';

    toggleGroup.appendChild(tableBtn);
    toggleGroup.appendChild(rawBtn);
    header.appendChild(toggleGroup);
    wrapper.appendChild(header);

    // Create content container
    const content = document.createElement('div');
    content.className = 'json-editor-content';

    // Get key suggestions from all records with same field
    const keySuggestions = this._getJsonKeySuggestions(field.id);

    // Render table view by default
    const tableView = this._createJsonTableView(data, keySuggestions);
    content.appendChild(tableView);

    // Create raw JSON view (hidden by default)
    const rawView = document.createElement('div');
    rawView.className = 'json-raw-view hidden';

    const textarea = document.createElement('textarea');
    textarea.className = 'cell-input cell-json-editor';
    let jsonString = '';
    if (data !== null && data !== undefined) {
      if (typeof data === 'object') {
        try {
          jsonString = JSON.stringify(data, null, 2);
        } catch (e) {
          jsonString = String(data);
        }
      } else {
        jsonString = String(data);
      }
    }
    textarea.value = jsonString;

    const validationIndicator = document.createElement('span');
    validationIndicator.className = 'json-validation-indicator valid';
    validationIndicator.innerHTML = '<i class="ph ph-check-circle"></i>';

    rawView.appendChild(textarea);
    rawView.appendChild(validationIndicator);
    content.appendChild(rawView);

    wrapper.appendChild(content);

    // Add actions footer
    const footer = document.createElement('div');
    footer.className = 'json-editor-footer';

    const saveBtn = document.createElement('button');
    saveBtn.className = 'json-editor-save';
    saveBtn.innerHTML = '<i class="ph ph-check"></i> Save';
    saveBtn.type = 'button';

    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'json-editor-cancel';
    cancelBtn.innerHTML = 'Cancel';
    cancelBtn.type = 'button';

    footer.appendChild(cancelBtn);
    footer.appendChild(saveBtn);
    wrapper.appendChild(footer);

    cell.innerHTML = '';
    cell.appendChild(wrapper);

    // Toggle handlers
    tableBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      tableBtn.classList.add('active');
      rawBtn.classList.remove('active');
      wrapper.classList.add('json-editor-table-mode');
      wrapper.classList.remove('json-editor-raw-mode');
      tableView.classList.remove('hidden');
      rawView.classList.add('hidden');
      // Sync raw JSON to table
      try {
        const rawData = JSON.parse(textarea.value.trim() || '{}');
        this._updateJsonTableView(tableView, rawData, keySuggestions);
      } catch (e) {
        // Invalid JSON, keep current table state
      }
    });

    rawBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      rawBtn.classList.add('active');
      tableBtn.classList.remove('active');
      wrapper.classList.add('json-editor-raw-mode');
      wrapper.classList.remove('json-editor-table-mode');
      rawView.classList.remove('hidden');
      tableView.classList.add('hidden');
      // Sync table to raw JSON
      const tableData = this._getJsonFromTableView(tableView);
      textarea.value = JSON.stringify(tableData, null, 2);
      textarea.focus();
    });

    // Validation for raw mode
    const validateJson = () => {
      const val = textarea.value.trim();
      if (!val) {
        validationIndicator.className = 'json-validation-indicator valid';
        validationIndicator.innerHTML = '<i class="ph ph-check-circle"></i>';
        return true;
      }
      try {
        JSON.parse(val);
        validationIndicator.className = 'json-validation-indicator valid';
        validationIndicator.innerHTML = '<i class="ph ph-check-circle"></i>';
        return true;
      } catch (e) {
        validationIndicator.className = 'json-validation-indicator invalid';
        validationIndicator.innerHTML = '<i class="ph ph-x-circle"></i>';
        return false;
      }
    };
    textarea.addEventListener('input', validateJson);

    // Save handler
    saveBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      if (wrapper.classList.contains('json-editor-raw-mode')) {
        if (validateJson()) {
          this._endJsonEdit();
        }
      } else {
        // Get data from table view
        const tableData = this._getJsonFromTableView(tableView);
        textarea.value = JSON.stringify(tableData);
        this._endJsonEdit();
      }
    });

    // Cancel handler
    cancelBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      this._cancelCellEdit();
    });

    // Keyboard shortcuts
    wrapper.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        this._cancelCellEdit();
      }
      if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
        e.preventDefault();
        saveBtn.click();
      }
    });

    // Focus first input in table view
    const firstInput = tableView.querySelector('input');
    if (firstInput) {
      firstInput.focus();
    }
  }

  /**
   * Get all unique keys used in this JSON field across all records
   */
  _getJsonKeySuggestions(fieldId) {
    const set = this.sets.find(s => s.id === this.currentSetId);
    if (!set) return [];

    const keys = new Set();
    set.records.forEach(record => {
      let value = record.values?.[fieldId];
      if (typeof value === 'string') {
        try {
          value = JSON.parse(value);
        } catch (e) {
          return;
        }
      }
      if (value && typeof value === 'object' && !Array.isArray(value)) {
        Object.keys(value).forEach(k => keys.add(k));
      }
    });
    return Array.from(keys).sort();
  }

  /**
   * Create editable table view for JSON object
   */
  _createJsonTableView(data, keySuggestions = []) {
    const container = document.createElement('div');
    container.className = 'json-table-editor';

    // Create datalist for autocomplete
    const datalistId = 'json-keys-' + Date.now();
    const datalist = document.createElement('datalist');
    datalist.id = datalistId;
    keySuggestions.forEach(key => {
      const option = document.createElement('option');
      option.value = key;
      datalist.appendChild(option);
    });
    container.appendChild(datalist);

    // Create table
    const table = document.createElement('div');
    table.className = 'json-table-rows';

    // Ensure data is an object
    let objData = {};
    if (data && typeof data === 'object' && !Array.isArray(data)) {
      objData = data;
    } else if (data !== null && data !== undefined && typeof data !== 'object') {
      // Primitive value - show as single row
      objData = { value: data };
    }

    // Add rows for each key-value pair
    Object.entries(objData).forEach(([key, value]) => {
      const row = this._createJsonTableRow(key, value, datalistId);
      table.appendChild(row);
    });

    container.appendChild(table);

    // Add row button
    const addRow = document.createElement('button');
    addRow.className = 'json-add-row';
    addRow.type = 'button';
    addRow.innerHTML = '<i class="ph ph-plus"></i> Add field';
    addRow.addEventListener('click', (e) => {
      e.stopPropagation();
      const row = this._createJsonTableRow('', '', datalistId);
      table.appendChild(row);
      const keyInput = row.querySelector('.json-row-key');
      if (keyInput) keyInput.focus();
    });
    container.appendChild(addRow);

    return container;
  }

  /**
   * Create a single key-value row for the JSON table editor
   */
  _createJsonTableRow(key, value, datalistId) {
    const row = document.createElement('div');
    row.className = 'json-table-row';

    // Key input with autocomplete
    const keyInput = document.createElement('input');
    keyInput.type = 'text';
    keyInput.className = 'json-row-key';
    keyInput.placeholder = 'key';
    keyInput.value = key;
    keyInput.setAttribute('list', datalistId);

    // Value input
    const valueInput = document.createElement('input');
    valueInput.type = 'text';
    valueInput.className = 'json-row-value';
    valueInput.placeholder = 'value';
    // Format value for display
    if (value !== null && value !== undefined) {
      if (typeof value === 'object') {
        valueInput.value = JSON.stringify(value);
      } else {
        valueInput.value = String(value);
      }
    }

    // Delete button
    const deleteBtn = document.createElement('button');
    deleteBtn.type = 'button';
    deleteBtn.className = 'json-row-delete';
    deleteBtn.innerHTML = '<i class="ph ph-trash"></i>';
    deleteBtn.title = 'Remove field';
    deleteBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      row.remove();
    });

    row.appendChild(keyInput);
    row.appendChild(valueInput);
    row.appendChild(deleteBtn);

    return row;
  }

  /**
   * Update JSON table view with new data
   */
  _updateJsonTableView(container, data, keySuggestions) {
    const table = container.querySelector('.json-table-rows');
    if (!table) return;

    // Get datalist ID
    const datalist = container.querySelector('datalist');
    const datalistId = datalist?.id || 'json-keys-' + Date.now();

    // Clear existing rows
    table.innerHTML = '';

    // Add rows for new data
    if (data && typeof data === 'object' && !Array.isArray(data)) {
      Object.entries(data).forEach(([key, value]) => {
        const row = this._createJsonTableRow(key, value, datalistId);
        table.appendChild(row);
      });
    }
  }

  /**
   * Extract JSON object from table view
   */
  _getJsonFromTableView(container) {
    const result = {};
    const rows = container.querySelectorAll('.json-table-row');

    rows.forEach(row => {
      const keyInput = row.querySelector('.json-row-key');
      const valueInput = row.querySelector('.json-row-value');

      if (keyInput && valueInput) {
        const key = keyInput.value.trim();
        let value = valueInput.value.trim();

        if (key) {
          // Try to parse value as JSON (for numbers, booleans, objects, arrays)
          if (value === '') {
            result[key] = '';
          } else if (value === 'true') {
            result[key] = true;
          } else if (value === 'false') {
            result[key] = false;
          } else if (value === 'null') {
            result[key] = null;
          } else if (!isNaN(value) && value !== '') {
            result[key] = Number(value);
          } else if ((value.startsWith('{') && value.endsWith('}')) ||
                     (value.startsWith('[') && value.endsWith(']'))) {
            try {
              result[key] = JSON.parse(value);
            } catch (e) {
              result[key] = value;
            }
          } else {
            result[key] = value;
          }
        }
      }
    });

    return result;
  }

  _endJsonEdit() {
    if (!this.editingCell) return;

    const { cell, recordId, fieldId, field } = this.editingCell;
    const textarea = cell.querySelector('.cell-json-editor');

    if (textarea) {
      const rawValue = textarea.value.trim();
      let parsedValue = null;

      if (rawValue) {
        try {
          parsedValue = JSON.parse(rawValue);
        } catch (e) {
          // If not valid JSON, store as string
          parsedValue = rawValue;
        }
      }

      this._updateRecordValue(recordId, fieldId, parsedValue);
    }

    // Clear editing state first
    const editingRef = this.editingCell;
    this.editingCell = null;

    // Update display
    requestAnimationFrame(() => {
      this._updateCellDisplay(editingRef.cell, editingRef.recordId, editingRef.field);
      editingRef.cell.classList.add('cell-edit-saved');
      setTimeout(() => editingRef.cell.classList.remove('cell-edit-saved'), 300);
    });
  }

  _endCellEdit() {
    if (!this.editingCell) return;

    // Close any open select modal
    this._closeSelectModal();

    const { cell, recordId, fieldId, field } = this.editingCell;
    const input = cell.querySelector('.cell-input');

    if (input) {
      const newValue = input.value;
      this._updateRecordValue(recordId, fieldId, newValue);
    }

    // Clear editing state first
    const editingRef = this.editingCell;
    this.editingCell = null;

    // Use requestAnimationFrame for smoother update with visual feedback
    requestAnimationFrame(() => {
      this._updateCellDisplay(editingRef.cell, editingRef.recordId, editingRef.field);
      // Add saved animation feedback
      editingRef.cell.classList.add('cell-edit-saved');
      setTimeout(() => editingRef.cell.classList.remove('cell-edit-saved'), 300);
    });
  }

  _cancelCellEdit() {
    if (!this.editingCell) return;

    // Close any open select modal
    this._closeSelectModal();

    const { cell, originalContent } = this.editingCell;
    this.editingCell = null;

    // Restore original content directly with visual feedback
    requestAnimationFrame(() => {
      cell.innerHTML = originalContent;
      cell.classList.remove('cell-editing');
      // Add cancelled animation feedback
      cell.classList.add('cell-edit-cancelled');
      setTimeout(() => cell.classList.remove('cell-edit-cancelled'), 200);
    });
  }

  /**
   * Update only the specific cell's display content without re-rendering the table.
   * This is the key performance optimization for inline editing.
   */
  _updateCellDisplay(cell, recordId, field) {
    const set = this.getCurrentSet();
    const record = set?.records.find(r => r.id === recordId);
    if (!record || !field) return;

    const value = record.values[field.id];
    cell.classList.remove('cell-editing');

    // Generate new cell content based on field type
    cell.innerHTML = this._renderCellContent(field, value);

    // Re-attach click handler for checkbox cells
    if (field.type === FieldTypes.CHECKBOX) {
      const checkbox = cell.querySelector('.cell-checkbox');
      if (checkbox) {
        cell.onclick = () => {
          this._toggleCheckbox(recordId, field.id);
        };
      }
    }
  }

  /**
   * Render just the inner content of a cell (without the td wrapper).
   * Used for targeted cell updates.
   */
  _renderCellContent(field, value) {
    switch (field.type) {
      case FieldTypes.TEXT:
      case FieldTypes.LONG_TEXT:
        return value ? this._escapeHtml(value) : '<span class="cell-empty">Empty</span>';

      case FieldTypes.NUMBER:
        return value != null ? `<span class="cell-number">${this._formatNumber(value, field)}</span>` : '<span class="cell-empty">-</span>';

      case FieldTypes.CHECKBOX:
        return `
          <div class="cell-checkbox">
            <i class="ph ${value ? 'ph-check-square checked' : 'ph-square unchecked'}"></i>
          </div>
        `;

      case FieldTypes.SELECT:
        if (value) {
          const choice = field.options?.choices?.find(c => c.id === value);
          if (choice) {
            return `<span class="select-tag color-${choice.color || 'gray'}">${this._escapeHtml(choice.name)}</span>`;
          }
        }
        return '<span class="cell-empty">-</span>';

      case FieldTypes.MULTI_SELECT:
        if (Array.isArray(value) && value.length > 0) {
          let content = '<div class="cell-select">';
          value.forEach(v => {
            const choice = field.options?.choices?.find(c => c.id === v);
            if (choice) {
              content += `<span class="select-tag color-${choice.color || 'gray'}">${this._escapeHtml(choice.name)}</span>`;
            }
          });
          return content + '</div>';
        }
        return '<span class="cell-empty">-</span>';

      case FieldTypes.DATE:
        return value ? `<span class="cell-date">${this._formatDate(value, field)}</span>` : '<span class="cell-empty">-</span>';

      case FieldTypes.URL:
        return value ? `<span class="cell-url"><a href="${this._escapeHtml(value)}" target="_blank">${this._escapeHtml(value)}</a></span>` : '<span class="cell-empty">-</span>';

      case FieldTypes.EMAIL:
        return value ? `<span class="cell-url"><a href="mailto:${this._escapeHtml(value)}">${this._escapeHtml(value)}</a></span>` : '<span class="cell-empty">-</span>';

      case FieldTypes.JSON:
        if (value !== null && value !== undefined) {
          const displayMode = field.options?.displayMode || 'keyValue';
          if (displayMode === 'raw') {
            const jsonStr = typeof value === 'object' ? JSON.stringify(value) : String(value);
            return `<span class="cell-json-raw">${this._escapeHtml(jsonStr)}</span>`;
          } else {
            return this._renderJsonKeyValue(value, field);
          }
        }
        return '<span class="cell-empty">-</span>';

      default:
        return value ? this._escapeHtml(String(value)) : '<span class="cell-empty">-</span>';
    }
  }

  _updateCellValue(value) {
    if (!this.editingCell) return;
    const { recordId, fieldId } = this.editingCell;
    this._updateRecordValue(recordId, fieldId, value);
  }

  _updateRecordValue(recordId, fieldId, value, skipUndo = false, skipReciprocal = false) {
    const set = this.getCurrentSet();

    // Safety check: If records are in IndexedDB but not loaded, this is a bug
    // The records should have been loaded by _loadRecordsFromIndexedDBOnStartup or _selectSet
    // Use undefined check specifically - empty array means already loaded (no records in IndexedDB)
    if (set && set._recordsInIndexedDB && set.records === undefined) {
      console.error('[DATA LOSS PREVENTION] Attempted to update record but records not loaded from IndexedDB. Loading now...');
      this._ensureSetRecords(set).then(() => {
        // Retry the update after records are loaded
        this._updateRecordValue(recordId, fieldId, value, skipUndo, skipReciprocal);
      });
      return;
    }

    const record = set?.records.find(r => r.id === recordId);
    if (!record) return;

    const oldValue = record.values[fieldId];

    // Skip if value hasn't changed
    if (oldValue === value) return;

    // Track for undo/redo (unless this is an undo/redo operation)
    if (!skipUndo) {
      this._pushUndoAction({
        type: 'update_field',
        recordId,
        fieldId,
        oldValue,
        newValue: value,
        setId: set.id
      });
    }

    // Create EO event for the change
    if (this.eoApp) {
      this._createEOEvent('record_updated', {
        recordId,
        fieldId,
        oldValue,
        newValue: value
      });
    }

    // Record activity for activity stream (only for non-undo operations)
    if (!skipUndo) {
      const field = set?.fields.find(f => f.id === fieldId);
      const primaryField = set?.fields.find(f => f.isPrimary) || set?.fields[0];
      const recordName = primaryField ? (record.values[primaryField.id] || 'Record') : 'Record';
      const fieldName = field?.name || 'Field';
      const oldDisplayValue = oldValue !== undefined && oldValue !== null ? String(oldValue).substring(0, 30) : '(empty)';
      const newDisplayValue = value !== undefined && value !== null ? String(value).substring(0, 30) : '(empty)';
      this._recordActivity({
        action: 'update',
        entityType: 'record',
        name: recordName,
        details: `${fieldName}: "${oldDisplayValue}" → "${newDisplayValue}"`,
        canReverse: true,
        reverseData: {
          type: 'update_field',
          setId: set.id,
          recordId,
          fieldId,
          previousValue: oldValue,
          property: 'value'
        }
      });
    }

    record.values[fieldId] = value;
    record.updatedAt = new Date().toISOString();

    // Record activity for the field change
    const field = set.fields.find(f => f.id === fieldId);
    const primaryField = set.fields?.find(f => f.isPrimary) || set.fields?.[0];
    const recordName = primaryField ? (record.values[primaryField.id] || 'Untitled') : 'Record';

    // Get display values for old and new (for select fields, show the choice name)
    let oldDisplayValue = oldValue;
    let newDisplayValue = value;
    if (field && (field.type === 'select' || field.type === 'multiSelect') && field.options?.choices) {
      const oldChoice = field.options.choices.find(c => c.id === oldValue);
      const newChoice = field.options.choices.find(c => c.id === value);
      oldDisplayValue = oldChoice?.name || oldValue || 'None';
      newDisplayValue = newChoice?.name || value || 'None';
    }

    this._recordActivity({
      action: 'update',
      entityType: 'record',
      name: recordName,
      details: `Changed "${field?.name || 'field'}" from "${oldDisplayValue || 'empty'}" to "${newDisplayValue || 'empty'}" in "${set.name}"`,
      canReverse: true,
      reverseData: { type: 'update_field', recordId, fieldId, oldValue, newValue: value, setId: set.id }
    });

    // Update reciprocal links for LINK fields
    if (field && field.type === FieldTypes.LINK && !skipReciprocal) {
      this._updateReciprocalLinks(set.id, recordId, field, oldValue, value);
    }

    this._saveData();
  }

  _pushUndoAction(action) {
    this.undoStack.push(action);
    if (this.undoStack.length > this.maxUndoStackSize) {
      this.undoStack.shift();
    }
    // Clear redo stack when a new action is performed
    this.redoStack = [];
    this._updateUndoRedoStatus();
  }

  _undo() {
    if (this.undoStack.length === 0) {
      this._showToast('Nothing to undo', 'info');
      return;
    }

    const action = this.undoStack.pop();
    this.redoStack.push(action);

    switch (action.type) {
      case 'update_field':
        this._updateRecordValue(action.recordId, action.fieldId, action.oldValue, true);
        this._renderView();
        this._showToast('Undone', 'success');
        break;

      case 'delete_record':
        // Restore deleted record
        const set = this.sets.find(s => s.id === action.setId);
        if (set) {
          set.records.push(action.record);
          this._saveData();
          this._renderView();
          this._showToast('Record restored', 'success');
        }
        break;

      case 'create_record':
        // Remove created record
        const createSet = this.sets.find(s => s.id === action.setId);
        if (createSet) {
          const idx = createSet.records.findIndex(r => r.id === action.recordId);
          if (idx > -1) {
            createSet.records.splice(idx, 1);
            this._saveData();
            this._renderView();
            this._showToast('Record creation undone', 'success');
          }
        }
        break;
    }

    this._updateUndoRedoStatus();
  }

  _redo() {
    if (this.redoStack.length === 0) {
      this._showToast('Nothing to redo', 'info');
      return;
    }

    const action = this.redoStack.pop();
    this.undoStack.push(action);

    switch (action.type) {
      case 'update_field':
        this._updateRecordValue(action.recordId, action.fieldId, action.newValue, true);
        this._renderView();
        this._showToast('Redone', 'success');
        break;

      case 'delete_record':
        // Re-delete the record
        const set = this.sets.find(s => s.id === action.setId);
        if (set) {
          const idx = set.records.findIndex(r => r.id === action.record.id);
          if (idx > -1) {
            set.records.splice(idx, 1);
            this._saveData();
            this._renderView();
            this._showToast('Record deleted again', 'success');
          }
        }
        break;

      case 'create_record':
        // Re-create the record
        const createSet = this.sets.find(s => s.id === action.setId);
        if (createSet) {
          createSet.records.push(action.record);
          this._saveData();
          this._renderView();
          this._showToast('Record recreated', 'success');
        }
        break;
    }

    this._updateUndoRedoStatus();
  }

  _updateUndoRedoStatus() {
    // Update any UI elements that show undo/redo status
    const undoBtn = document.getElementById('btn-undo');
    const redoBtn = document.getElementById('btn-redo');
    if (undoBtn) undoBtn.disabled = this.undoStack.length === 0;
    if (redoBtn) redoBtn.disabled = this.redoStack.length === 0;
  }

  _toggleCheckbox(recordId, fieldId) {
    const set = this.getCurrentSet();
    const record = set?.records.find(r => r.id === recordId);
    const field = set?.fields.find(f => f.id === fieldId);
    if (!record || !field) return;

    const currentValue = record.values[fieldId];
    this._updateRecordValue(recordId, fieldId, !currentValue);

    // Find the cell and update only its content - no full re-render
    const cell = document.querySelector(`tr[data-record-id="${recordId}"] td[data-field-id="${fieldId}"]`);
    if (cell) {
      requestAnimationFrame(() => {
        this._updateCellDisplay(cell, recordId, field);
      });
    }
  }

  _attachResizeHandler(handle) {
    let startX, startWidth, th;

    const onMouseDown = (e) => {
      th = handle.closest('th');
      startX = e.pageX;
      startWidth = th.offsetWidth;
      handle.classList.add('resizing');

      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
      e.preventDefault();
    };

    const onMouseMove = (e) => {
      const width = Math.max(80, startWidth + (e.pageX - startX));
      th.style.width = width + 'px';
      // Also update corresponding td cells for non-field columns
      const columnType = handle.dataset.columnType;
      if (columnType === 'source') {
        document.querySelectorAll('.col-source').forEach(cell => {
          cell.style.width = width + 'px';
        });
      }
    };

    const onMouseUp = () => {
      handle.classList.remove('resizing');
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);

      // Save the new width
      const fieldId = th.dataset.fieldId;
      const columnType = handle.dataset.columnType;
      const set = this.getCurrentSet();

      if (fieldId) {
        // Regular field column
        const field = set?.fields.find(f => f.id === fieldId);
        if (field) {
          field.width = th.offsetWidth;
          this._saveData();
        }
      } else if (columnType === 'source') {
        // Source/Provenance column - save to view config
        const view = this.getCurrentView();
        if (view) {
          view.config = view.config || {};
          view.config.sourceColumnWidth = th.offsetWidth;
          this._saveData();
        }
      }
    };

    handle.addEventListener('mousedown', onMouseDown);
  }

  // --------------------------------------------------------------------------
  // Cards View
  // --------------------------------------------------------------------------

  _renderCardsView() {
    const set = this.getCurrentSet();
    const baseRecords = this.getFilteredRecords();
    const fields = this._getVisibleFields();
    const searchTerm = this.viewSearchTerm;

    // Apply search filter
    let allRecords = baseRecords;
    if (searchTerm) {
      allRecords = baseRecords.filter(record => {
        const { matches } = this._recordMatchesSearch(record, searchTerm, set?.fields || []);
        return matches;
      });
    }

    // Implement chunked loading for large datasets
    const totalRecords = allRecords.length;
    const displayCount = Math.min(this.displayedRecordCount, totalRecords);
    const records = allRecords.slice(0, displayCount);
    const hasMoreRecords = displayCount < totalRecords;
    const remainingRecords = totalRecords - displayCount;

    let html = '<div class="card-grid">';

    if (allRecords.length === 0 && !searchTerm) {
      html = `
        <div class="empty-state">
          <i class="ph ph-cards"></i>
          <h3>No Records</h3>
          <p>Add your first record to see it here</p>
          <button class="btn btn-primary" id="cards-add-record">
            <i class="ph ph-plus"></i>
            Add Record
          </button>
        </div>
      `;
    } else if (allRecords.length === 0 && searchTerm) {
      html = `
        <div class="empty-state search-no-results-state">
          <i class="ph ph-magnifying-glass"></i>
          <h3>No Results</h3>
          <p>No records match "${this._escapeHtml(searchTerm)}"</p>
          <button class="btn btn-secondary" id="cards-clear-search">
            Clear search
          </button>
        </div>
      `;
    } else {
      records.forEach(record => {
        const primaryField = fields.find(f => f.isPrimary) || fields[0];
        const title = record.values[primaryField?.id] || 'Untitled';
        const isSelected = this.selectedRecords.has(record.id);

        html += `
          <div class="record-card ${isSelected ? 'selected' : ''}" data-record-id="${record.id}">
            <div class="card-header">
              <span class="card-title">${this._highlightText(title, searchTerm)}</span>
              <button class="card-menu"><i class="ph ph-dots-three"></i></button>
            </div>
            <div class="card-body">
              ${fields.slice(1, 5).map(field => {
                const value = record.values[field.id];
                const formatted = this._formatCellValueSimple(value, field, searchTerm);
                return `
                  <div class="card-field">
                    <span class="card-field-label">${this._escapeHtml(field.name)}</span>
                    <span class="card-field-value">${formatted}</span>
                  </div>
                `;
              }).join('')}
            </div>
          </div>
        `;
      });

      // Load More button if there are more records
      if (hasMoreRecords) {
        const loadMoreCount = Math.min(this.recordBatchSize, remainingRecords);
        html += `
          <div class="cards-load-more">
            <button class="load-more-btn" id="cards-load-more">
              <i class="ph ph-caret-down"></i>
              <span>Load ${loadMoreCount.toLocaleString()} more</span>
              <span class="load-more-remaining">(${remainingRecords.toLocaleString()} remaining)</span>
            </button>
            <button class="load-all-btn" id="cards-load-all">
              <i class="ph ph-cards"></i>
              <span>Load all ${totalRecords.toLocaleString()}</span>
            </button>
          </div>
        `;
      }
    }

    html += '</div>';
    this.elements.contentArea.innerHTML = html;

    // Attach event listeners
    document.querySelectorAll('.record-card').forEach(card => {
      card.addEventListener('click', () => {
        this._showRecordDetail(card.dataset.recordId);
      });

      card.querySelector('.card-menu')?.addEventListener('click', (e) => {
        e.stopPropagation();
        this._showRecordContextMenu(e, card.dataset.recordId);
      });
    });

    document.getElementById('cards-add-record')?.addEventListener('click', () => this.addRecord());
    document.getElementById('cards-clear-search')?.addEventListener('click', () => this._clearViewSearch());

    // Load more handlers for cards view
    document.getElementById('cards-load-more')?.addEventListener('click', () => {
      this._loadMoreRecordsForView('cards', false);
    });
    document.getElementById('cards-load-all')?.addEventListener('click', () => {
      this._loadMoreRecordsForView('cards', true);
    });
  }

  /**
   * Load more records for a specific view type
   * @param {string} viewType - The type of view (cards, kanban)
   * @param {boolean} loadAll - If true, loads all remaining records
   */
  _loadMoreRecordsForView(viewType, loadAll = false) {
    const allRecords = this.getFilteredRecords();
    const totalRecords = allRecords.length;

    if (loadAll) {
      if (totalRecords - this.displayedRecordCount > 500) {
        this._showLoadingOverlay('Loading all records...', {
          showProgress: true,
          progress: 0,
          progressText: `Loading ${totalRecords.toLocaleString()} records...`
        });

        requestAnimationFrame(() => {
          this.displayedRecordCount = totalRecords;
          if (viewType === 'cards') this._renderCardsView();
          else if (viewType === 'kanban') this._renderKanbanView();
          this._hideLoadingOverlay();
        });
      } else {
        this.displayedRecordCount = totalRecords;
        if (viewType === 'cards') this._renderCardsView();
        else if (viewType === 'kanban') this._renderKanbanView();
      }
    } else {
      this.displayedRecordCount = Math.min(
        this.displayedRecordCount + this.recordBatchSize,
        totalRecords
      );
      if (viewType === 'cards') this._renderCardsView();
      else if (viewType === 'kanban') this._renderKanbanView();
    }
  }

  _formatCellValueSimple(value, field, searchTerm = '') {
    if (value == null || value === '') return '<span class="cell-empty">-</span>';

    switch (field.type) {
      case FieldTypes.CHECKBOX:
        return value ? '<i class="ph ph-check-circle" style="color: var(--success-500)"></i>' : '<i class="ph ph-circle" style="color: var(--text-muted)"></i>';
      case FieldTypes.SELECT:
        const choice = field.options.choices?.find(c => c.id === value);
        return choice ? `<span class="select-tag color-${choice.color}">${this._highlightText(choice.name, searchTerm)}</span>` : '-';
      case FieldTypes.DATE:
        return this._formatDate(value, field);
      default:
        return this._highlightText(String(value), searchTerm);
    }
  }

  // --------------------------------------------------------------------------
  // Kanban View
  // --------------------------------------------------------------------------

  _renderKanbanView() {
    const set = this.getCurrentSet();
    const baseRecords = this.getFilteredRecords();
    const view = this.getCurrentView();
    const searchTerm = this.viewSearchTerm;

    // Apply search filter
    let records = baseRecords;
    if (searchTerm) {
      records = baseRecords.filter(record => {
        const { matches } = this._recordMatchesSearch(record, searchTerm, set?.fields || []);
        return matches;
      });
    }

    // Deduplicate records by ID to prevent rendering the same record multiple times
    const seenIds = new Set();
    records = records.filter(record => {
      if (seenIds.has(record.id)) return false;
      seenIds.add(record.id);
      return true;
    });

    // Find grouping field (must be a select field)
    // Check for groupByFieldId (preferred) or kanbanField (legacy)
    const groupFieldId = view?.config?.groupByFieldId || view?.config?.kanbanField;
    let groupField = null;

    // First, try to find the explicitly configured grouping field
    if (groupFieldId) {
      groupField = set?.fields?.find(f => f.id === groupFieldId);
    }

    // Fallback to first SELECT field if configured field not found
    if (!groupField) {
      groupField = set?.fields?.find(f => f.type === FieldTypes.SELECT);
    }

    if (!groupField) {
      this.elements.contentArea.innerHTML = `
        <div class="empty-state">
          <i class="ph ph-kanban"></i>
          <h3>No Status Field</h3>
          <p>Add a single select field to use Kanban view</p>
          <button class="btn btn-primary" id="kanban-add-field">
            <i class="ph ph-plus"></i>
            Add Select Field
          </button>
        </div>
      `;

      document.getElementById('kanban-add-field')?.addEventListener('click', () => {
        this._addField(FieldTypes.SELECT, 'Status');
      });
      return;
    }

    // Check if search returned no results
    if (records.length === 0 && searchTerm) {
      this.elements.contentArea.innerHTML = `
        <div class="empty-state search-no-results-state">
          <i class="ph ph-magnifying-glass"></i>
          <h3>No Results</h3>
          <p>No records match "${this._escapeHtml(searchTerm)}"</p>
          <button class="btn btn-secondary" id="kanban-clear-search">
            Clear search
          </button>
        </div>
      `;

      document.getElementById('kanban-clear-search')?.addEventListener('click', () => {
        this._clearViewSearch();
      });
      return;
    }

    // Ensure field.options.choices exists (defensive check)
    if (!groupField.options) groupField.options = {};
    if (!groupField.options.choices) groupField.options.choices = [];

    const choices = groupField.options.choices;
    const primaryField = set?.fields.find(f => f.isPrimary) || set?.fields[0];

    let html = '<div class="kanban-container">';

    // Create a column for each choice + uncategorized
    const columns = [...choices, { id: null, name: 'Uncategorized', color: 'gray' }];

    columns.forEach(column => {
      const columnRecords = records.filter(r => {
        const val = r.values[groupField.id];
        return column.id === null ? (val == null || val === '') : val === column.id;
      });

      const isUncategorized = column.id === null;
      html += `
        <div class="kanban-column" data-column-id="${column.id || 'null'}">
          <div class="kanban-column-header">
            <div class="kanban-column-title">
              <span class="select-tag color-${column.color || 'gray'}">${this._escapeHtml(column.name)}</span>
              <span class="kanban-column-count">${columnRecords.length}</span>
            </div>
            ${!isUncategorized ? `
              <button class="kanban-column-edit" data-choice-id="${column.id}" title="Edit status">
                <i class="ph ph-pencil-simple"></i>
              </button>
            ` : ''}
          </div>
          <div class="kanban-column-body" data-column-id="${column.id || 'null'}">
            ${columnRecords.map(record => {
              const title = record.values[primaryField?.id] || 'Untitled';
              return `
                <div class="kanban-card" data-record-id="${record.id}" draggable="true">
                  <div class="kanban-card-title">${this._highlightText(title, searchTerm)}</div>
                </div>
              `;
            }).join('')}
            <div class="kanban-add-card" data-column-id="${column.id || ''}">
              <i class="ph ph-plus"></i>
              <span>Add</span>
            </div>
          </div>
        </div>
      `;
    });

    // Add "Add Status" button at the end
    html += `
      <div class="kanban-add-column">
        <button class="kanban-add-status-btn" id="kanban-add-status">
          <i class="ph ph-plus"></i>
          <span>Add Status</span>
        </button>
      </div>
    `;

    html += '</div>';
    this.elements.contentArea.innerHTML = html;

    // Drag and drop
    this._attachKanbanDragHandlers(groupField);

    // Card click
    document.querySelectorAll('.kanban-card').forEach(card => {
      card.addEventListener('click', () => {
        this._showRecordDetail(card.dataset.recordId);
      });
    });

    // Add card buttons
    document.querySelectorAll('.kanban-add-card').forEach(btn => {
      btn.addEventListener('click', () => {
        const columnId = btn.dataset.columnId;
        const record = this.addRecord();
        if (columnId) {
          this._updateRecordValue(record.id, groupField.id, columnId);
          // Re-render kanban to show the card in the correct column
          this._renderKanbanView();
        }
      });
    });

    // Edit status buttons
    document.querySelectorAll('.kanban-column-edit').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const choiceId = btn.dataset.choiceId;
        this._showEditStatusModal(groupField, choiceId);
      });
    });

    // Add status button
    document.getElementById('kanban-add-status')?.addEventListener('click', () => {
      this._showAddStatusModal(groupField);
    });
  }

  _showEditStatusModal(field, choiceId) {
    const choice = field.options?.choices?.find(c => c.id === choiceId);
    if (!choice) return;

    const colors = ['gray', 'red', 'orange', 'yellow', 'green', 'blue', 'purple', 'pink'];

    this._showModal('Edit Status', `
      <div class="modal-form">
        <div class="form-group">
          <label>Name</label>
          <input type="text" id="status-name" value="${this._escapeHtml(choice.name)}" class="form-input">
        </div>
        <div class="form-group">
          <label>Color</label>
          <div class="color-picker">
            ${colors.map(color => `
              <button class="color-option color-${color} ${choice.color === color ? 'selected' : ''}"
                      data-color="${color}" title="${color}"></button>
            `).join('')}
          </div>
        </div>
        <div class="form-group" style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border-primary);">
          <button class="btn btn-danger" id="delete-status-btn">
            <i class="ph ph-trash"></i>
            Delete Status
          </button>
        </div>
      </div>
    `, () => {
      const name = document.getElementById('status-name')?.value?.trim();
      const selectedColor = document.querySelector('.color-option.selected')?.dataset.color || choice.color;

      if (!name) {
        alert('Please enter a name');
        return;
      }

      // Update the choice
      choice.name = name;
      choice.color = selectedColor;

      this._saveData();
      this._renderKanbanView();
      this._showToast('Status updated', 'success');
    });

    // Attach color picker handlers
    setTimeout(() => {
      document.querySelectorAll('.color-option').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          document.querySelectorAll('.color-option').forEach(b => b.classList.remove('selected'));
          btn.classList.add('selected');
        });
      });

      document.getElementById('delete-status-btn')?.addEventListener('click', () => {
        // Remove the choice
        const idx = field.options.choices.findIndex(c => c.id === choiceId);
        if (idx > -1) {
          field.options.choices.splice(idx, 1);

          // Clear this value from all records
          const set = this.getCurrentSet();
          set?.records.forEach(r => {
            if (r.values[field.id] === choiceId) {
              r.values[field.id] = null;
            }
          });

          this._saveData();
          this._closeModal();
          this._renderKanbanView();
          this._showToast('Status deleted', 'success');
        }
      });
    }, 0);
  }

  _showAddStatusModal(field) {
    const colors = ['gray', 'red', 'orange', 'yellow', 'green', 'blue', 'purple', 'pink'];

    this._showModal('Add Status', `
      <div class="modal-form">
        <div class="form-group">
          <label>Name</label>
          <input type="text" id="status-name" placeholder="Enter status name" class="form-input">
        </div>
        <div class="form-group">
          <label>Color</label>
          <div class="color-picker">
            ${colors.map((color, i) => `
              <button class="color-option color-${color} ${i === 0 ? 'selected' : ''}"
                      data-color="${color}" title="${color}"></button>
            `).join('')}
          </div>
        </div>
      </div>
    `, () => {
      const name = document.getElementById('status-name')?.value?.trim();
      const selectedColor = document.querySelector('.color-option.selected')?.dataset.color || 'gray';

      if (!name) {
        alert('Please enter a name');
        return;
      }

      // Add the new choice
      if (!field.options.choices) {
        field.options.choices = [];
      }

      field.options.choices.push({
        id: generateId(),
        name,
        color: selectedColor
      });

      this._saveData();
      this._renderKanbanView();
      this._showToast('Status added', 'success');
    });

    // Attach color picker handlers
    setTimeout(() => {
      document.querySelectorAll('.color-option').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          document.querySelectorAll('.color-option').forEach(b => b.classList.remove('selected'));
          btn.classList.add('selected');
        });
      });
      document.getElementById('status-name')?.focus();
    }, 0);
  }

  _attachKanbanDragHandlers(groupField) {
    const container = document.querySelector('.kanban-container');
    if (!container) return;

    // Store groupField reference for event handlers
    const fieldId = groupField.id;

    // Use event delegation on the container for more reliable drag-and-drop
    container.addEventListener('dragstart', (e) => {
      const card = e.target.closest('.kanban-card');
      if (!card) return;

      card.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', card.dataset.recordId);
      e.dataTransfer.setData('application/x-kanban-card', card.dataset.recordId);
    });

    container.addEventListener('dragend', (e) => {
      const card = e.target.closest('.kanban-card');
      if (card) {
        card.classList.remove('dragging');
      }
      // Clear all drag-over states
      container.querySelectorAll('.kanban-column-body').forEach(col => {
        col.classList.remove('drag-over');
      });
    });

    container.addEventListener('dragover', (e) => {
      const column = e.target.closest('.kanban-column-body');
      if (!column) return;

      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';

      // Only add drag-over to the target column
      container.querySelectorAll('.kanban-column-body').forEach(col => {
        col.classList.toggle('drag-over', col === column);
      });
    });

    container.addEventListener('dragleave', (e) => {
      const column = e.target.closest('.kanban-column-body');
      if (!column) return;

      // Check if we're leaving to a child element
      const relatedTarget = e.relatedTarget;
      if (column.contains(relatedTarget)) return;

      column.classList.remove('drag-over');
    });

    container.addEventListener('drop', (e) => {
      const column = e.target.closest('.kanban-column-body');
      if (!column) return;

      e.preventDefault();
      e.stopPropagation();
      column.classList.remove('drag-over');

      const recordId = e.dataTransfer.getData('text/plain') ||
                       e.dataTransfer.getData('application/x-kanban-card');
      if (!recordId) return;

      const columnId = column.dataset.columnId;
      const newValue = columnId === 'null' ? null : columnId;

      this._updateRecordValue(recordId, fieldId, newValue);

      // Refresh the detail panel if it's showing this record
      // Must refresh BEFORE re-rendering to show updated values
      if (this.elements.detailPanel?.classList.contains('open') && this.currentDetailRecordId === recordId) {
        this._showRecordDetail(recordId);
      }

      // Save changes and re-render kanban
      this._saveData();
      this._renderKanbanView();

      // Show feedback
      this._showToast('Card moved', 'success');
    });
  }

  // --------------------------------------------------------------------------
  // Calendar View
  // --------------------------------------------------------------------------

  _renderCalendarView() {
    const set = this.getCurrentSet();
    const baseRecords = this.getFilteredRecords();
    const searchTerm = this.viewSearchTerm;

    // Apply search filter
    let records = baseRecords;
    if (searchTerm) {
      records = baseRecords.filter(record => {
        const { matches } = this._recordMatchesSearch(record, searchTerm, set?.fields || []);
        return matches;
      });
    }

    // Find date field
    let dateField = set?.fields.find(f => f.type === FieldTypes.DATE);

    if (!dateField) {
      this.elements.contentArea.innerHTML = `
        <div class="empty-state">
          <i class="ph ph-calendar-blank"></i>
          <h3>No Date Field</h3>
          <p>Add a date field to use Calendar view</p>
          <button class="btn btn-primary" id="calendar-add-field">
            <i class="ph ph-plus"></i>
            Add Date Field
          </button>
        </div>
      `;

      document.getElementById('calendar-add-field')?.addEventListener('click', () => {
        this._addField(FieldTypes.DATE, 'Date');
      });
      return;
    }

    // Check if search returned no results
    if (records.length === 0 && searchTerm) {
      this.elements.contentArea.innerHTML = `
        <div class="empty-state search-no-results-state">
          <i class="ph ph-magnifying-glass"></i>
          <h3>No Results</h3>
          <p>No records match "${this._escapeHtml(searchTerm)}"</p>
          <button class="btn btn-secondary" id="calendar-clear-search">
            Clear search
          </button>
        </div>
      `;

      document.getElementById('calendar-clear-search')?.addEventListener('click', () => {
        this._clearViewSearch();
      });
      return;
    }

    // Use calendar state for navigation, default to current date
    if (!this.calendarDate) {
      this.calendarDate = new Date();
    }
    const now = new Date();
    const year = this.calendarDate.getFullYear();
    const month = this.calendarDate.getMonth();

    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const startDay = firstDay.getDay();
    const daysInMonth = lastDay.getDate();

    const primaryField = set?.fields.find(f => f.isPrimary) || set?.fields[0];
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
      'July', 'August', 'September', 'October', 'November', 'December'];

    let html = `
      <div class="calendar-container">
        <div class="calendar-header">
          <div class="calendar-nav">
            <button class="calendar-nav-btn" id="cal-prev"><i class="ph ph-caret-left"></i></button>
            <button class="calendar-nav-btn" id="cal-next"><i class="ph ph-caret-right"></i></button>
          </div>
          <h2 class="calendar-title">${monthNames[month]} ${year}</h2>
          <button class="btn btn-secondary" id="cal-today">Today</button>
        </div>
        <div class="calendar-grid">
    `;

    // Day headers
    const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    dayNames.forEach(day => {
      html += `<div class="calendar-day-header">${day}</div>`;
    });

    // Empty cells before first day
    for (let i = 0; i < startDay; i++) {
      html += '<div class="calendar-day other-month"></div>';
    }

    // Days of month
    for (let day = 1; day <= daysInMonth; day++) {
      const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
      const isToday = day === now.getDate() && month === now.getMonth() && year === now.getFullYear();

      // Find records for this day
      const dayRecords = records.filter(r => {
        const val = r.values[dateField.id];
        if (!val) return false;
        // Handle both string dates and Date objects
        // Use local date formatting to avoid timezone offset issues
        let dateValue;
        if (typeof val === 'string') {
          dateValue = val;
        } else if (val instanceof Date) {
          // Use local date components to avoid UTC conversion offset
          const y = val.getFullYear();
          const m = String(val.getMonth() + 1).padStart(2, '0');
          const d = String(val.getDate()).padStart(2, '0');
          dateValue = `${y}-${m}-${d}`;
        } else {
          dateValue = String(val);
        }
        return dateValue.startsWith(dateStr);
      });

      html += `
        <div class="calendar-day ${isToday ? 'today' : ''}" data-date="${dateStr}">
          <div class="calendar-day-number">${day}</div>
          ${dayRecords.slice(0, 3).map(r => {
            const title = r.values[primaryField?.id] || 'Event';
            return `<div class="calendar-event" data-record-id="${r.id}">${this._highlightText(title, searchTerm)}</div>`;
          }).join('')}
          ${dayRecords.length > 3 ? `<div class="calendar-event">+${dayRecords.length - 3} more</div>` : ''}
        </div>
      `;
    }

    html += '</div></div>';
    this.elements.contentArea.innerHTML = html;

    // Use event delegation on the calendar container for reliable event handling
    const calendarContainer = document.querySelector('.calendar-container');
    if (calendarContainer) {
      const dateFieldId = dateField.id;

      calendarContainer.addEventListener('click', (e) => {
        const target = e.target;

        // Handle navigation buttons
        const prevBtn = target.closest('#cal-prev');
        const nextBtn = target.closest('#cal-next');
        const todayBtn = target.closest('#cal-today');

        if (prevBtn) {
          e.preventDefault();
          e.stopPropagation();
          this.calendarDate.setMonth(this.calendarDate.getMonth() - 1);
          this._renderCalendarView();
          return;
        }

        if (nextBtn) {
          e.preventDefault();
          e.stopPropagation();
          this.calendarDate.setMonth(this.calendarDate.getMonth() + 1);
          this._renderCalendarView();
          return;
        }

        if (todayBtn) {
          e.preventDefault();
          e.stopPropagation();
          this.calendarDate = new Date();
          this._renderCalendarView();
          return;
        }

        // Handle calendar event clicks
        const eventEl = target.closest('.calendar-event');
        if (eventEl && eventEl.dataset.recordId) {
          e.stopPropagation();
          this._showRecordDetail(eventEl.dataset.recordId);
          return;
        }

        // Handle calendar day clicks (for adding new records)
        const dayEl = target.closest('.calendar-day');
        if (dayEl && dayEl.dataset.date && !dayEl.classList.contains('other-month')) {
          const date = dayEl.dataset.date;
          const record = this.addRecord();
          this._updateRecordValue(record.id, dateFieldId, date);
          this._renderCalendarView();
          return;
        }
      });
    }
  }

  // --------------------------------------------------------------------------
  // Graph View (Cytoscape.js powered)
  // --------------------------------------------------------------------------

  _renderGraphView() {
    const set = this.getCurrentSet();
    const baseRecords = this.getFilteredRecords();
    const searchTerm = this.viewSearchTerm;

    // Apply search filter
    let records = baseRecords;
    if (searchTerm) {
      records = baseRecords.filter(record => {
        const { matches } = this._recordMatchesSearch(record, searchTerm, set?.fields || []);
        return matches;
      });
    }

    const primaryField = set?.fields.find(f => f.isPrimary) || set?.fields[0];

    // Check for link fields to show relationships
    const linkFields = set?.fields.filter(f => f.type === FieldTypes.LINK) || [];

    // Check for a corresponding relationship set
    const relationshipSet = set ? this.sets.find(s =>
      s.name === `${set.name} - Relationships` ||
      s.name === `${set.name} - Edges`
    ) : null;
    const hasRelationshipSet = relationshipSet && relationshipSet.records?.length > 0;

    // Determine if we have any relationship data
    const hasRelationships = linkFields.length > 0 || hasRelationshipSet;
    const relationshipInfo = hasRelationshipSet
      ? `${relationshipSet.records.length} relationships`
      : (linkFields.length > 0 ? `${linkFields.length} relationship type${linkFields.length !== 1 ? 's' : ''}` : '');

    // Check if search returned no results
    if (records.length === 0 && searchTerm) {
      this.elements.contentArea.innerHTML = `
        <div class="empty-state search-no-results-state">
          <i class="ph ph-magnifying-glass"></i>
          <h3>No Results</h3>
          <p>No records match "${this._escapeHtml(searchTerm)}"</p>
          <button class="btn btn-secondary" id="graph-clear-search">
            Clear search
          </button>
        </div>
      `;

      document.getElementById('graph-clear-search')?.addEventListener('click', () => {
        this._clearViewSearch();
      });
      return;
    }

    // Initialize graph display settings if not set
    if (!this.graphSettings) {
      this.graphSettings = {
        layout: 'force', // 'force', 'circular', 'grid', 'concentric'
        showLabels: true,
        labelPosition: 'outside', // 'inside', 'outside', 'hover'
        nodeSize: 'medium', // 'small', 'medium', 'large'
      };
    }

    this.elements.contentArea.innerHTML = `
      <div class="graph-container">
        <div class="graph-toolbar">
          <div class="graph-info">
            <i class="ph ph-graph"></i>
            <span>${records.length} nodes${hasRelationships ? `, ${relationshipInfo}` : ''}</span>
          </div>
          <div class="graph-controls-inline">
            <div class="graph-control-group">
              <label class="graph-control-label">Layout:</label>
              <select id="graph-layout-select" class="graph-select">
                <option value="force" ${this.graphSettings.layout === 'force' ? 'selected' : ''}>Force</option>
                <option value="circular" ${this.graphSettings.layout === 'circular' ? 'selected' : ''}>Circular</option>
                <option value="grid" ${this.graphSettings.layout === 'grid' ? 'selected' : ''}>Grid</option>
                <option value="concentric" ${this.graphSettings.layout === 'concentric' ? 'selected' : ''}>Concentric</option>
              </select>
            </div>
            <div class="graph-control-group">
              <label class="graph-control-label">Labels:</label>
              <select id="graph-label-select" class="graph-select">
                <option value="outside" ${this.graphSettings.labelPosition === 'outside' ? 'selected' : ''}>Outside</option>
                <option value="inside" ${this.graphSettings.labelPosition === 'inside' ? 'selected' : ''}>Inside</option>
                <option value="hover" ${this.graphSettings.labelPosition === 'hover' ? 'selected' : ''}>On Hover</option>
              </select>
            </div>
            <div class="graph-control-group">
              <label class="graph-control-label">Size:</label>
              <select id="graph-size-select" class="graph-select">
                <option value="small" ${this.graphSettings.nodeSize === 'small' ? 'selected' : ''}>Small</option>
                <option value="medium" ${this.graphSettings.nodeSize === 'medium' ? 'selected' : ''}>Medium</option>
                <option value="large" ${this.graphSettings.nodeSize === 'large' ? 'selected' : ''}>Large</option>
              </select>
            </div>
            <div class="graph-control-divider"></div>
            <button class="graph-control-btn" id="graph-zoom-in" title="Zoom In">
              <i class="ph ph-magnifying-glass-plus"></i>
            </button>
            <button class="graph-control-btn" id="graph-zoom-out" title="Zoom Out">
              <i class="ph ph-magnifying-glass-minus"></i>
            </button>
            <button class="graph-control-btn" id="graph-center" title="Center & Fit">
              <i class="ph ph-crosshair"></i>
            </button>
          </div>
        </div>
        <div class="graph-canvas-wrapper" id="cy-workbench-container">
          <div class="graph-loading" id="graph-loading">
            <div class="graph-loading-content">
              <i class="ph ph-spinner ph-spin"></i>
              <span>Calculating layout...</span>
            </div>
          </div>
        </div>
        ${!hasRelationships && records.length > 0 ? `
          <div class="graph-hint graph-hint-actionable">
            <div class="graph-hint-content">
              <i class="ph ph-link-simple"></i>
              <div class="graph-hint-text">
                <strong>No relationships found</strong>
                <p>Add a "Link to record" field to connect records and visualize relationships as edges in the graph.</p>
              </div>
            </div>
            <button class="graph-hint-action" id="graph-add-link-field">
              <i class="ph ph-plus"></i>
              Add Link Field
            </button>
          </div>
        ` : ''}
      </div>
    `;

    // Show loading indicator for large graphs
    const showGraphLoading = records.length > 50;
    if (showGraphLoading) {
      this._showGraphLoading('Building graph...');
    }

    // Initialize Cytoscape graph (use setTimeout to allow loading UI to render)
    if (showGraphLoading) {
      setTimeout(() => {
        this._initWorkbenchCytoscape(records, primaryField, linkFields);
      }, 50);
    } else {
      this._initWorkbenchCytoscape(records, primaryField, linkFields);
    }

    // Add control event listeners
    document.getElementById('graph-layout-select')?.addEventListener('change', (e) => {
      this.graphSettings.layout = e.target.value;
      this._showGraphLoading('Recalculating layout...');
      setTimeout(() => {
        this._applyWorkbenchLayout();
      }, 50);
    });

    document.getElementById('graph-label-select')?.addEventListener('change', (e) => {
      this.graphSettings.labelPosition = e.target.value;
      this._updateWorkbenchLabelStyle();
    });

    document.getElementById('graph-size-select')?.addEventListener('change', (e) => {
      this.graphSettings.nodeSize = e.target.value;
      this._updateWorkbenchNodeSize();
    });

    // Zoom controls
    document.getElementById('graph-zoom-in')?.addEventListener('click', () => {
      if (this.workbenchCy) {
        this.workbenchCy.zoom(this.workbenchCy.zoom() * 1.2);
        this.workbenchCy.center();
      }
    });

    document.getElementById('graph-zoom-out')?.addEventListener('click', () => {
      if (this.workbenchCy) {
        this.workbenchCy.zoom(this.workbenchCy.zoom() / 1.2);
        this.workbenchCy.center();
      }
    });

    document.getElementById('graph-center')?.addEventListener('click', () => {
      if (this.workbenchCy) {
        this.workbenchCy.fit(undefined, 50);
      }
    });

    // Add Link Field button in graph hint
    document.getElementById('graph-add-link-field')?.addEventListener('click', () => {
      this._addLinkFieldFromGraph();
    });
  }

  /**
   * Helper to add a link field from the graph view hint
   */
  _addLinkFieldFromGraph() {
    const set = this.getCurrentSet();
    if (!set) return;

    // Show linked set selection modal, then add the field
    this._showLinkedSetSelectionModal((options) => {
      if (options) {
        this._addField(FieldTypes.LINK, 'Related Records', options);
        this._showToast('Link field added! Connect records to see relationships in the graph.', 'success');
        // Switch to table view to show the new field
        this._switchViewType('table');
      }
    });
  }

  /**
   * Initialize Cytoscape graph for workbench
   */
  _initWorkbenchCytoscape(records, primaryField, linkFields) {
    const container = document.getElementById('cy-workbench-container');
    if (!container || records.length === 0) return;

    // Destroy existing instance
    if (this.workbenchCy) {
      this.workbenchCy.destroy();
      this.workbenchCy = null;
    }

    // Get size class
    const sizeClass = `size-${this.graphSettings.nodeSize || 'medium'}`;
    const labelClass = `label-${this.graphSettings.labelPosition || 'outside'}`;

    // Create nodes
    const nodes = records.map(record => {
      const label = record.values?.[primaryField?.id] || 'Untitled';
      return {
        data: {
          id: record.id,
          label: label,
          record: record
        },
        classes: `${sizeClass} ${labelClass}`
      };
    });

    // Build node maps for edge lookup
    const nodeMap = new Map(records.map(r => [r.id, r]));
    const nodeByTitle = new Map();
    records.forEach(record => {
      const title = record.values?.[primaryField?.id];
      if (title) nodeByTitle.set(title, record);
    });

    // Create edges from link fields
    const edges = [];
    records.forEach(record => {
      linkFields.forEach(field => {
        // Use normalized format to handle both old and new link value formats
        const normalizedLinks = this._normalizeLinkValue(record.values?.[field.id]);
        const hasEdgeFields = field.options?.enableEdgeData && field.options?.edgeFields?.length > 0;

        normalizedLinks.forEach(link => {
          const linkedId = link.recordId;
          const edgeData = link.edgeData || {};

          // Check if target is in current set
          if (nodeMap.has(linkedId)) {
            const hasData = hasEdgeFields && Object.keys(edgeData).length > 0;
            edges.push({
              data: {
                id: `${record.id}-${linkedId}-${field.name}`,
                source: record.id,
                target: linkedId,
                fieldId: field.id,
                fieldName: field.name,
                edgeData: edgeData,
                hasEdgeData: hasData,
                color: CytoscapeColors.GRAPH_DATA
              },
              classes: `link-edge${hasData ? ' has-edge-data' : ''}`
            });
          } else {
            // Try to find by title/name match for cross-set or legacy links
            const targetRecord = nodeByTitle.get(linkedId);
            if (targetRecord) {
              const hasData = hasEdgeFields && Object.keys(edgeData).length > 0;
              edges.push({
                data: {
                  id: `${record.id}-${targetRecord.id}-${field.name}`,
                  source: record.id,
                  target: targetRecord.id,
                  fieldId: field.id,
                  fieldName: field.name,
                  edgeData: edgeData,
                  hasEdgeData: hasData,
                  color: CytoscapeColors.GRAPH_DATA
                },
                classes: `link-edge${hasData ? ' has-edge-data' : ''}`
              });
            }
          }
        });
      });
    });

    // Also look for edges in relationship sets
    const currentSet = this.getCurrentSet();
    if (currentSet) {
      const relationshipSet = this.sets.find(s =>
        s.name === `${currentSet.name} - Relationships` ||
        s.name === `${currentSet.name} - Edges` ||
        (s.name?.includes('Relationships') && s.name?.includes(currentSet.name))
      );

      if (relationshipSet) {
        const fromField = relationshipSet.fields?.find(f =>
          f.name?.toLowerCase() === 'from' || f.name?.toLowerCase() === 'source'
        );
        const toField = relationshipSet.fields?.find(f =>
          f.name?.toLowerCase() === 'to' || f.name?.toLowerCase() === 'target'
        );

        if (fromField && toField) {
          relationshipSet.records?.forEach(relRecord => {
            const fromValue = relRecord.values?.[fromField.id];
            const toValue = relRecord.values?.[toField.id];

            if (!fromValue || !toValue) return;

            // Find matching nodes by ID or title
            let sourceRecord = nodeMap.get(fromValue) || nodeByTitle.get(fromValue);
            let targetRecord = nodeMap.get(toValue) || nodeByTitle.get(toValue);

            if (sourceRecord && targetRecord) {
              const typeField = relationshipSet.fields?.find(f => f.name?.toLowerCase() === 'type');
              const edgeType = typeField ? relRecord.values?.[typeField.id] : 'relationship';

              edges.push({
                data: {
                  id: `${sourceRecord.id}-${targetRecord.id}-${edgeType}`,
                  source: sourceRecord.id,
                  target: targetRecord.id,
                  fieldName: edgeType,
                  color: CytoscapeColors.GRAPH_DATA
                },
                classes: 'link-edge'
              });
            }
          });
        }
      }
    }

    // Count connections for node sizing
    const connectionCount = new Map();
    edges.forEach(edge => {
      connectionCount.set(edge.data.source, (connectionCount.get(edge.data.source) || 0) + 1);
      connectionCount.set(edge.data.target, (connectionCount.get(edge.data.target) || 0) + 1);
    });

    // Add connection count to node data
    nodes.forEach(node => {
      node.data.connections = connectionCount.get(node.data.id) || 0;
      if (node.data.connections >= 3) {
        node.classes += ' high-connectivity';
      }
    });

    // Initialize Cytoscape with workbench stylesheet
    this.workbenchCy = createCytoscapeInstance(container, {
      useWorkbenchStyle: true,
      elements: [...nodes, ...edges]
    });

    // Apply initial layout
    this._applyWorkbenchLayout();

    // Set up event handlers
    this.workbenchCy.on('tap', 'node', (evt) => {
      const nodeId = evt.target.id();
      this._showRecordDetail(nodeId);
    });

    // Hover effects
    this.workbenchCy.on('mouseover', 'node', (evt) => {
      evt.target.addClass('highlighted');
      container.style.cursor = 'pointer';
    });

    this.workbenchCy.on('mouseout', 'node', (evt) => {
      evt.target.removeClass('highlighted');
      container.style.cursor = 'default';
    });

    this.workbenchCy.on('tap', 'edge', (evt) => {
      const edge = evt.target;
      const edgeData = edge.data();
      this._showEdgeDetail(edgeData);
    });

    this.workbenchCy.on('mouseover', 'edge', (evt) => {
      evt.target.addClass('highlighted');
      container.style.cursor = 'pointer';
    });

    this.workbenchCy.on('mouseout', 'edge', (evt) => {
      evt.target.removeClass('highlighted');
      container.style.cursor = 'default';
    });
  }

  /**
   * Show loading indicator in graph view
   */
  _showGraphLoading(message = 'Calculating layout...') {
    const loadingEl = document.getElementById('graph-loading');
    if (loadingEl) {
      const textEl = loadingEl.querySelector('span');
      if (textEl) textEl.textContent = message;
      loadingEl.style.display = 'flex';
    }
  }

  /**
   * Hide loading indicator in graph view
   */
  _hideGraphLoading() {
    const loadingEl = document.getElementById('graph-loading');
    if (loadingEl) {
      loadingEl.style.display = 'none';
    }
  }

  /**
   * Apply layout to workbench graph
   */
  _applyWorkbenchLayout() {
    if (!this.workbenchCy) return;

    const layoutType = this.graphSettings?.layout || 'force';
    const layoutConfig = getLayoutConfig(layoutType);

    // Add callback to hide loading when layout completes
    const layout = this.workbenchCy.layout({
      ...layoutConfig,
      stop: () => {
        this._hideGraphLoading();
      }
    });
    layout.run();
  }

  /**
   * Update label style on workbench graph
   */
  _updateWorkbenchLabelStyle() {
    if (!this.workbenchCy) return;

    const labelPosition = this.graphSettings?.labelPosition || 'outside';

    // Remove existing label classes and add new one
    this.workbenchCy.nodes().forEach(node => {
      node.removeClass('label-outside label-inside label-hover');
      node.addClass(`label-${labelPosition}`);
    });
  }

  /**
   * Update node size on workbench graph
   */
  _updateWorkbenchNodeSize() {
    if (!this.workbenchCy) return;

    const nodeSize = this.graphSettings?.nodeSize || 'medium';

    // Remove existing size classes and add new one
    this.workbenchCy.nodes().forEach(node => {
      node.removeClass('size-small size-medium size-large');
      node.addClass(`size-${nodeSize}`);
    });
  }

  // --------------------------------------------------------------------------
  // Pipeline View - Visual Pipeline Editor with Time-Travel
  // --------------------------------------------------------------------------

  _renderPipelineView() {
    const set = this.getCurrentSet();

    // Create container
    this.elements.contentArea.innerHTML = `
      <div class="pipeline-view-container" id="pipeline-view-container">
        <!-- Temporal Pipeline Canvas will be mounted here -->
      </div>
    `;

    const container = document.getElementById('pipeline-view-container');

    // Initialize or reuse pipeline for this set
    if (!this._pipelineInstances) {
      this._pipelineInstances = new Map();
    }

    let pipeline = this._pipelineInstances.get(set?.id);

    if (!pipeline) {
      // Create new pipeline
      pipeline = new TemporalPipeline({
        id: `pipeline_${set?.id || 'default'}`,
        name: `${set?.name || 'Data'} Pipeline`,
        eventStore: this.eventStore,
        workbench: this
      });

      // Add a source node for the current set if we have one
      if (set) {
        const sourceNode = pipeline.addNode(TemporalNodeType.SOURCE, {
          x: 100,
          y: 200,
          config: {
            setId: set.id,
            setName: set.name
          }
        });
      }

      // Detect keyframes from event store
      pipeline.detectKeyframes();

      this._pipelineInstances.set(set?.id, pipeline);
    }

    // Create the visual canvas
    this._currentPipelineCanvas = new TemporalPipelineCanvas(container, pipeline, {
      onNodeSelect: (node) => {
        console.log('Node selected:', node);
      },
      onNodeConfigure: (node) => {
        console.log('Configure node:', node);
      },
      onPipelineChange: (pipeline) => {
        // Could save pipeline state here
        console.log('Pipeline changed:', pipeline.toFormula());
      }
    });

    // Initial cook
    pipeline.cookAll();
  }

  // --------------------------------------------------------------------------
  // Data Flow View - n8n-Inspired Visual Data Transformer
  // --------------------------------------------------------------------------

  _renderFlowView() {
    const set = this.getCurrentSet();

    // Create container
    this.elements.contentArea.innerHTML = `
      <div class="flow-view-container" id="flow-view-container">
        <!-- Data Flow Canvas will be mounted here -->
      </div>
    `;

    const container = document.getElementById('flow-view-container');

    // Initialize or reuse flow pipeline for this set
    if (!this._flowInstances) {
      this._flowInstances = new Map();
    }

    let flow = this._flowInstances.get(set?.id);

    if (!flow) {
      // Create new flow pipeline
      flow = new DataFlowPipeline({
        id: `flow_${set?.id || 'default'}`,
        name: `${set?.name || 'Data'} Flow`,
        eventStore: this.eventStore,
        workbench: this,
        runMode: 'auto'
      });

      // Add a source node for the current set if we have one
      if (set) {
        flow.addNode(DataFlowNodeType.SET, {
          x: 100,
          y: 200,
          config: {
            setId: set.id,
            setName: set.name
          }
        });
      }

      this._flowInstances.set(set?.id, flow);
    }

    // Create the visual canvas
    this._currentFlowCanvas = new DataFlowCanvas(container, flow, {
      showTimeline: true,
      timelineCollapsed: true,
      showAIButton: true,
      onNodeSelect: (node) => {
        console.log('Flow node selected:', node);
      },
      onPipelineChange: (flow) => {
        // Could save flow state here
        console.log('Flow changed');
      },
      onAIRequest: (action, flow) => {
        console.log('AI request:', action);
        this._showToast(`AI ${action} requested`, 'info');
      }
    });

    // Execute the flow
    flow.executeAll();
  }

  // --------------------------------------------------------------------------
  // Filesystem View - Full Content Hierarchy
  // --------------------------------------------------------------------------

  _renderFilesystemView() {
    const currentSet = this.getCurrentSet();

    // Build hierarchy: Sources → Sets → Views → Records
    const hierarchy = this._buildContentHierarchy();

    this.elements.contentArea.innerHTML = `
      <div class="filesystem-container">
        <div class="filesystem-toolbar">
          <div class="filesystem-info">
            <i class="ph ph-folder-open"></i>
            <span>Content Hierarchy</span>
          </div>
          <div class="filesystem-breadcrumb" id="fs-breadcrumb">
            <span class="fs-breadcrumb-item root" data-level="root">
              <i class="ph ph-house"></i> Root
            </span>
          </div>
          <div class="filesystem-controls">
            <button class="filesystem-control-btn ${this.fsViewMode === 'tree' ? 'active' : ''}"
                    data-mode="tree" title="Tree View">
              <i class="ph ph-tree-structure"></i>
            </button>
            <button class="filesystem-control-btn ${this.fsViewMode === 'columns' ? 'active' : ''}"
                    data-mode="columns" title="Column View">
              <i class="ph ph-columns"></i>
            </button>
          </div>
        </div>
        <div class="filesystem-content" id="fs-content">
          ${this.fsViewMode === 'columns'
            ? this._renderFilesystemTable(hierarchy, currentSet)
            : this._renderFilesystemTree(hierarchy, currentSet)}
        </div>
      </div>
    `;

    this._attachFilesystemEventHandlers();
  }

  /**
   * Build the complete content hierarchy
   * Structure: Sources (GIVEN) → Sets (Interpretation) → Views (Lens) → Records
   */
  _buildContentHierarchy() {
    const hierarchy = {
      sources: new Map(),
      manualSets: []
    };

    // Group sets by their source
    for (const set of this.sets) {
      const prov = set.datasetProvenance;
      const provSourceValue = this._getProvenanceValue(prov?.provenance?.source);
      if (prov && (prov.originalFilename || provSourceValue)) {
        const sourceName = prov.originalFilename || provSourceValue || 'Unknown';
        const sourceKey = sourceName.toLowerCase();

        if (!hierarchy.sources.has(sourceKey)) {
          hierarchy.sources.set(sourceKey, {
            name: sourceName,
            type: 'source',
            level: 'given',
            importedAt: prov.importedAt,
            provenance: prov.provenance,
            children: []
          });
        }
        hierarchy.sources.get(sourceKey).children.push({
          ...set,
          type: 'set',
          level: 'meant'
        });
      } else {
        hierarchy.manualSets.push({
          ...set,
          type: 'set',
          level: 'meant'
        });
      }
    }

    return hierarchy;
  }

  /**
   * Render the filesystem tree view
   */
  _renderFilesystemTree(hierarchy, currentSet) {
    let html = '<div class="fs-tree">';

    // Layer indicator
    html += `
      <div class="fs-layer-legend">
        <div class="fs-layer-item given">
          <i class="ph ph-download"></i>
          <span>GIVEN</span>
          <span class="fs-layer-desc">Raw data sources</span>
        </div>
        <div class="fs-layer-item meant">
          <i class="ph ph-database"></i>
          <span>MEANT</span>
          <span class="fs-layer-desc">Interpreted data</span>
        </div>
        <div class="fs-layer-item lens">
          <i class="ph ph-eye"></i>
          <span>LENS</span>
          <span class="fs-layer-desc">Views & perspectives</span>
        </div>
        <div class="fs-layer-item entity">
          <i class="ph ph-rows"></i>
          <span>ENTITY</span>
          <span class="fs-layer-desc">Individual records</span>
        </div>
      </div>
    `;

    // Render imported sources
    const sources = Array.from(hierarchy.sources.values());
    if (sources.length > 0) {
      html += `<div class="fs-section">`;
      for (const source of sources) {
        const isExpanded = this.expandedFsNodes?.has(`source:${source.name}`) ?? true;
        html += this._renderSourceNode(source, isExpanded, currentSet);
      }
      html += `</div>`;
    }

    // Render manual sets
    if (hierarchy.manualSets.length > 0) {
      const isExpanded = this.expandedFsNodes?.has('manual') ?? true;
      html += `
        <div class="fs-section">
          <div class="fs-node source-node manual ${isExpanded ? 'expanded' : ''}" data-node-id="manual">
            <div class="fs-node-header" data-level="given">
              <i class="ph ph-caret-right fs-toggle"></i>
              <i class="ph ph-pencil-simple-line fs-icon"></i>
              <span class="fs-node-title">Manual Entry</span>
              <span class="fs-node-count">${hierarchy.manualSets.length} sets</span>
            </div>
            <div class="fs-node-children">
              ${hierarchy.manualSets.map(set => this._renderSetNode(set, currentSet)).join('')}
            </div>
          </div>
        </div>
      `;
    }

    // If no data yet
    if (sources.length === 0 && hierarchy.manualSets.length === 0) {
      html += `
        <div class="fs-empty">
          <i class="ph ph-folder-open"></i>
          <h3>No Content Yet</h3>
          <p>Import data or create a set to see the content hierarchy</p>
          <div class="fs-empty-actions">
            <button class="btn btn-primary" id="fs-import-btn">
              <i class="ph ph-file-arrow-down"></i> Import Data
            </button>
            <button class="btn btn-secondary" id="fs-create-set-btn">
              <i class="ph ph-plus"></i> Create Set
            </button>
          </div>
        </div>
      `;
    }

    html += '</div>';
    return html;
  }

  /**
   * Render the filesystem as a table view (like Windows Explorer / Finder)
   */
  _renderFilesystemTable(hierarchy, currentSet) {
    const rows = [];

    // Flatten hierarchy into table rows
    const sources = Array.from(hierarchy.sources.values());
    for (const source of sources) {
      const sourceExpanded = this.expandedFsNodes?.has(`source:${source.name}`) ?? true;
      const importDate = source.importedAt
        ? new Date(source.importedAt).toLocaleDateString()
        : '';

      rows.push({
        id: `source:${source.name}`,
        name: source.name,
        type: 'Source',
        icon: this._getSourceIcon(source.name).replace('ph-', ''),
        count: `${source.children.length} sets`,
        modified: importDate,
        depth: 0,
        hasChildren: source.children.length > 0,
        expanded: sourceExpanded,
        nodeType: 'source'
      });

      if (sourceExpanded) {
        for (const set of source.children) {
          this._addSetToTableRows(rows, set, 1, currentSet);
        }
      }
    }

    // Manual sets
    if (hierarchy.manualSets.length > 0) {
      const manualExpanded = this.expandedFsNodes?.has('manual') ?? true;

      rows.push({
        id: 'manual',
        name: 'Manual Entry',
        type: 'Source',
        icon: 'pencil-simple-line',
        count: `${hierarchy.manualSets.length} sets`,
        modified: '',
        depth: 0,
        hasChildren: hierarchy.manualSets.length > 0,
        expanded: manualExpanded,
        nodeType: 'source'
      });

      if (manualExpanded) {
        for (const set of hierarchy.manualSets) {
          this._addSetToTableRows(rows, set, 1, currentSet);
        }
      }
    }

    if (rows.length === 0) {
      return `
        <div class="fs-table-empty">
          <i class="ph ph-folder-open"></i>
          <h3>No Content Yet</h3>
          <p>Import data or create a set to get started</p>
          <div class="fs-empty-actions">
            <button class="btn btn-primary" id="fs-import-btn">
              <i class="ph ph-file-arrow-down"></i> Import Data
            </button>
            <button class="btn btn-secondary" id="fs-create-set-btn">
              <i class="ph ph-plus"></i> Create Set
            </button>
          </div>
        </div>
      `;
    }

    return `
      <div class="fs-table-container">
        <table class="fs-table">
          <thead>
            <tr>
              <th class="fs-table-name">Name</th>
              <th class="fs-table-type">Type</th>
              <th class="fs-table-count">Records</th>
              <th class="fs-table-modified">Modified</th>
            </tr>
          </thead>
          <tbody>
            ${rows.map(row => this._renderTableRow(row, currentSet)).join('')}
          </tbody>
        </table>
      </div>
    `;
  }

  /**
   * Add a set and its children to table rows
   */
  _addSetToTableRows(rows, set, depth, currentSet) {
    const isActive = set.id === currentSet?.id;
    const setExpanded = this.expandedFsNodes?.has(`set:${set.id}`) ?? isActive;
    const views = set.views || [];
    const recordCount = set.records?.length || 0;

    // Extract just the icon name (e.g., 'database' from 'ph ph-database' or 'ph-database')
    const rawIcon = set.icon || 'ph ph-database';
    const iconName = rawIcon.split(' ').pop().replace('ph-', '');

    rows.push({
      id: `set:${set.id}`,
      setId: set.id,
      name: set.name,
      type: 'Dataset',
      icon: iconName,
      count: `${recordCount} records`,
      modified: '',
      depth: depth,
      hasChildren: views.length > 0,
      expanded: setExpanded,
      nodeType: 'set',
      isActive: isActive
    });

    if (setExpanded) {
      // Add views
      for (const view of views) {
        const viewIcons = {
          table: 'table',
          cards: 'cards',
          kanban: 'kanban',
          calendar: 'calendar-blank',
          graph: 'graph',
          filesystem: 'folder-open',
          timeline: 'clock-countdown',
          pipeline: 'cooking-pot',
          flow: 'flow-arrow'
        };
        const isViewActive = view.id === this.currentViewId && set.id === currentSet?.id;

        rows.push({
          id: `view:${view.id}`,
          viewId: view.id,
          setId: set.id,
          name: view.name,
          type: view.type.charAt(0).toUpperCase() + view.type.slice(1),
          icon: viewIcons[view.type] || 'table',
          count: '',
          modified: '',
          depth: depth + 1,
          hasChildren: false,
          expanded: false,
          nodeType: 'view',
          isActive: isViewActive
        });
      }
    }
  }

  /**
   * Render a single table row
   */
  _renderTableRow(row, currentSet) {
    const indent = row.depth * 20;
    const toggleIcon = row.hasChildren
      ? (row.expanded ? 'ph-caret-down' : 'ph-caret-right')
      : 'ph-minus';
    const toggleClass = row.hasChildren ? 'fs-table-toggle' : 'fs-table-spacer';

    return `
      <tr class="fs-table-row ${row.isActive ? 'active' : ''} ${row.nodeType}-row"
          data-row-id="${this._escapeHtml(row.id)}"
          data-node-type="${row.nodeType}"
          ${row.setId ? `data-set-id="${row.setId}"` : ''}
          ${row.viewId ? `data-view-id="${row.viewId}"` : ''}>
        <td class="fs-table-name">
          <div class="fs-table-name-content" style="padding-left: ${indent}px">
            <i class="ph ${toggleIcon} ${toggleClass}"></i>
            <i class="ph ph-${row.icon} fs-table-icon"></i>
            <span class="fs-table-name-text">${this._escapeHtml(row.name)}</span>
          </div>
        </td>
        <td class="fs-table-type">
          <span class="fs-type-badge fs-type-${row.nodeType}">${row.type}</span>
        </td>
        <td class="fs-table-count">${row.count}</td>
        <td class="fs-table-modified">${row.modified}</td>
      </tr>
    `;
  }

  /**
   * Render a source node
   */
  _renderSourceNode(source, isExpanded, currentSet) {
    const sourceIcon = this._getSourceIcon(source.name);
    const provTooltip = this._formatSourceProvenance(source);
    const importDate = source.importedAt
      ? new Date(source.importedAt).toLocaleDateString()
      : '';

    return `
      <div class="fs-node source-node ${isExpanded ? 'expanded' : ''}"
           data-node-id="source:${this._escapeHtml(source.name)}">
        <div class="fs-node-header" data-level="given" title="${this._escapeHtml(provTooltip)}">
          <i class="ph ph-caret-right fs-toggle"></i>
          <i class="ph ${sourceIcon} fs-icon"></i>
          <span class="fs-node-title">${this._escapeHtml(source.name)}</span>
          <span class="fs-node-meta">${importDate}</span>
          <span class="fs-node-count">${source.children.length} sets</span>
        </div>
        <div class="fs-node-children">
          ${source.children.map(set => this._renderSetNode(set, currentSet)).join('')}
        </div>
      </div>
    `;
  }

  /**
   * Render a set node with its views
   */
  _renderSetNode(set, currentSet) {
    const isActive = set.id === currentSet?.id;
    const isExpanded = this.expandedFsNodes?.has(`set:${set.id}`) ?? isActive;
    const views = set.views || [];

    return `
      <div class="fs-node set-node ${isExpanded ? 'expanded' : ''} ${isActive ? 'active' : ''}"
           data-node-id="set:${set.id}">
        <div class="fs-node-header" data-level="meant" data-set-id="${set.id}">
          <i class="ph ph-caret-right fs-toggle"></i>
          <i class="${set.icon || 'ph ph-database'} fs-icon"></i>
          <span class="fs-node-title">${this._escapeHtml(set.name)}</span>
          <span class="fs-node-count">${set.records?.length || 0} records</span>
        </div>
        <div class="fs-node-children">
          ${views.map(view => this._renderViewNode(view, set, currentSet)).join('')}
          ${this._renderRecordsSummary(set)}
        </div>
      </div>
    `;
  }

  /**
   * Render a view node
   */
  _renderViewNode(view, set, currentSet) {
    const isActive = view.id === this.currentViewId && set.id === currentSet?.id;
    const viewIcons = {
      table: 'ph-table',
      cards: 'ph-cards',
      kanban: 'ph-kanban',
      calendar: 'ph-calendar-blank',
      graph: 'ph-graph',
      filesystem: 'ph-folder-open',
      timeline: 'ph-clock-countdown',
      pipeline: 'ph-cooking-pot',
      flow: 'ph-flow-arrow'
    };

    return `
      <div class="fs-node view-node ${isActive ? 'active' : ''}"
           data-node-id="view:${view.id}"
           data-view-id="${view.id}"
           data-set-id="${set.id}">
        <div class="fs-node-header" data-level="lens">
          <i class="ph ph-minus fs-spacer"></i>
          <i class="ph ${viewIcons[view.type] || 'ph-table'} fs-icon"></i>
          <span class="fs-node-title">${this._escapeHtml(view.name)}</span>
          <span class="fs-node-type">${view.type}</span>
        </div>
      </div>
    `;
  }

  /**
   * Render records summary under a set
   */
  _renderRecordsSummary(set) {
    const recordCount = set.records?.length || 0;
    if (recordCount === 0) return '';

    const isExpanded = this.expandedFsNodes?.has(`records:${set.id}`) ?? false;
    const displayRecords = isExpanded ? set.records.slice(0, 50) : [];
    const primaryField = set.fields?.find(f => f.isPrimary) || set.fields?.[0];

    return `
      <div class="fs-node records-node ${isExpanded ? 'expanded' : ''}"
           data-node-id="records:${set.id}">
        <div class="fs-node-header" data-level="entity">
          <i class="ph ph-caret-right fs-toggle"></i>
          <i class="ph ph-rows fs-icon"></i>
          <span class="fs-node-title">Records</span>
          <span class="fs-node-count">${recordCount} items</span>
        </div>
        <div class="fs-node-children">
          ${displayRecords.map(record => {
            const title = record.values?.[primaryField?.id] || 'Untitled';
            return `
              <div class="fs-node record-node" data-record-id="${record.id}" data-set-id="${set.id}">
                <div class="fs-node-header" data-level="entity">
                  <i class="ph ph-minus fs-spacer"></i>
                  <i class="ph ph-file-text fs-icon"></i>
                  <span class="fs-node-title">${this._escapeHtml(String(title).substring(0, 40))}</span>
                </div>
              </div>
            `;
          }).join('')}
          ${recordCount > 50 ? `
            <div class="fs-more-indicator">
              <i class="ph ph-dots-three"></i>
              <span>+${recordCount - 50} more records</span>
            </div>
          ` : ''}
        </div>
      </div>
    `;
  }

  /**
   * Attach event handlers to filesystem view
   */
  _attachFilesystemEventHandlers() {
    const container = document.getElementById('fs-content');
    if (!container) return;

    // Initialize state
    if (!this.expandedFsNodes) this.expandedFsNodes = new Set();
    if (!this.fsViewMode) this.fsViewMode = 'columns';

    const tree = container.querySelector('.fs-tree');

    // Restore selection from previous render
    if (this.selectedFsNodeId) {
      const selectedNode = container.querySelector(`.fs-node[data-node-id="${this.selectedFsNodeId}"]`);
      if (selectedNode) {
        selectedNode.classList.add('selected');
      }
    }
    if (tree) {
      tree.setAttribute('tabindex', '0');
    }

    // Helper to select a node visually (without opening)
    const selectNode = (nodeId) => {
      // Remove previous selection
      container.querySelectorAll('.fs-node.selected').forEach(n => {
        n.classList.remove('selected');
      });
      this.selectedFsNodeId = nodeId;
      if (nodeId) {
        const node = container.querySelector(`.fs-node[data-node-id="${nodeId}"]`);
        if (node) {
          node.classList.add('selected');
          // Scroll into view if needed
          node.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        }
      }
    };

    // Helper to open/navigate to a node
    const openNode = (node) => {
      if (!node) return;

      if (node.classList.contains('set-node')) {
        const setId = node.querySelector('.fs-node-header')?.dataset.setId;
        if (setId) this._selectSet(setId);
      } else if (node.classList.contains('view-node')) {
        const setId = node.dataset.setId;
        const viewId = node.dataset.viewId;
        if (setId && viewId) {
          if (this.currentSetId !== setId) this._selectSet(setId);
          this._selectView(viewId);
        }
      } else if (node.classList.contains('record-node')) {
        const recordId = node.dataset.recordId;
        const setId = node.dataset.setId;
        if (recordId && setId) {
          if (this.currentSetId !== setId) this._selectSet(setId);
          this._showRecordDetail(recordId);
        }
      } else if (node.classList.contains('source-node') || node.classList.contains('records-node')) {
        // Toggle expand/collapse for container nodes
        node.classList.toggle('expanded');
        const nodeId = node.dataset.nodeId;
        if (node.classList.contains('expanded')) {
          this.expandedFsNodes.add(nodeId);
        } else {
          this.expandedFsNodes.delete(nodeId);
        }
      }
    };

    // Get all navigable nodes in order
    const getNavigableNodes = () => {
      const nodes = [];
      const collectNodes = (parentEl) => {
        parentEl.querySelectorAll(':scope > .fs-node, :scope > .fs-section > .fs-node').forEach(node => {
          nodes.push(node);
          // If expanded, also collect children
          if (node.classList.contains('expanded')) {
            const children = node.querySelector('.fs-node-children');
            if (children) collectNodes(children);
          }
        });
      };
      collectNodes(tree);
      return nodes;
    };

    // Toggle nodes via chevron click
    container.querySelectorAll('.fs-toggle').forEach(toggle => {
      toggle.addEventListener('click', (e) => {
        e.stopPropagation();
        const node = toggle.closest('.fs-node');
        const nodeId = node.dataset.nodeId;
        node.classList.toggle('expanded');
        if (node.classList.contains('expanded')) {
          this.expandedFsNodes.add(nodeId);
        } else {
          this.expandedFsNodes.delete(nodeId);
        }
      });
    });

    // Single-click on any node header = select only
    container.querySelectorAll('.fs-node-header').forEach(header => {
      header.addEventListener('click', (e) => {
        if (e.target.closest('.fs-toggle')) return;
        const node = header.closest('.fs-node');
        const nodeId = node?.dataset.nodeId;
        if (nodeId) {
          selectNode(nodeId);
          tree?.focus();
        }
      });
    });

    // Double-click on any node header = open/navigate
    container.querySelectorAll('.fs-node-header').forEach(header => {
      header.addEventListener('dblclick', (e) => {
        if (e.target.closest('.fs-toggle')) return;
        const node = header.closest('.fs-node');
        openNode(node);
      });
    });

    // Keyboard navigation
    tree?.addEventListener('keydown', (e) => {
      const nodes = getNavigableNodes();
      const currentIndex = nodes.findIndex(n => n.dataset.nodeId === this.selectedFsNodeId);

      switch (e.key) {
        case 'ArrowDown':
          e.preventDefault();
          if (currentIndex < nodes.length - 1) {
            selectNode(nodes[currentIndex + 1].dataset.nodeId);
          } else if (currentIndex === -1 && nodes.length > 0) {
            selectNode(nodes[0].dataset.nodeId);
          }
          break;
        case 'ArrowUp':
          e.preventDefault();
          if (currentIndex > 0) {
            selectNode(nodes[currentIndex - 1].dataset.nodeId);
          } else if (currentIndex === -1 && nodes.length > 0) {
            selectNode(nodes[nodes.length - 1].dataset.nodeId);
          }
          break;
        case 'ArrowRight':
          e.preventDefault();
          if (currentIndex >= 0) {
            const node = nodes[currentIndex];
            if (!node.classList.contains('expanded') && node.querySelector('.fs-node-children')) {
              node.classList.add('expanded');
              this.expandedFsNodes.add(node.dataset.nodeId);
            }
          }
          break;
        case 'ArrowLeft':
          e.preventDefault();
          if (currentIndex >= 0) {
            const node = nodes[currentIndex];
            if (node.classList.contains('expanded')) {
              node.classList.remove('expanded');
              this.expandedFsNodes.delete(node.dataset.nodeId);
            } else {
              // Navigate to parent
              const parent = node.parentElement?.closest('.fs-node');
              if (parent?.dataset.nodeId) {
                selectNode(parent.dataset.nodeId);
              }
            }
          }
          break;
        case 'Enter':
          e.preventDefault();
          if (currentIndex >= 0) {
            openNode(nodes[currentIndex]);
          }
          break;
        case ' ':
          e.preventDefault();
          if (currentIndex >= 0) {
            const node = nodes[currentIndex];
            // Space toggles expand/collapse
            if (node.querySelector('.fs-node-children')) {
              node.classList.toggle('expanded');
              if (node.classList.contains('expanded')) {
                this.expandedFsNodes.add(node.dataset.nodeId);
              } else {
                this.expandedFsNodes.delete(node.dataset.nodeId);
              }
            }
          }
          break;
      }
    });

    // View mode toggle
    document.querySelectorAll('.filesystem-control-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        this.fsViewMode = btn.dataset.mode;
        this._renderFilesystemView();
      });
    });

    // Empty state buttons
    document.getElementById('fs-import-btn')?.addEventListener('click', () => {
      this._showImportModal();
    });

    document.getElementById('fs-create-set-btn')?.addEventListener('click', () => {
      this._showNewSetModal();
    });

    // Table view event handlers
    this._attachTableEventHandlers(container);
  }

  /**
   * Attach event handlers for table view
   */
  _attachTableEventHandlers(container) {
    const table = container.querySelector('.fs-table');
    if (!table) return;

    // Single click to select
    table.querySelectorAll('.fs-table-row').forEach(row => {
      row.addEventListener('click', (e) => {
        // If clicking on toggle, handle expand/collapse
        if (e.target.closest('.fs-table-toggle')) {
          const rowId = row.dataset.rowId;
          if (this.expandedFsNodes.has(rowId)) {
            this.expandedFsNodes.delete(rowId);
          } else {
            this.expandedFsNodes.add(rowId);
          }
          this._renderFilesystemView();
          return;
        }

        // Select the row
        table.querySelectorAll('.fs-table-row.selected').forEach(r => r.classList.remove('selected'));
        row.classList.add('selected');
        this.selectedFsNodeId = row.dataset.rowId;
      });

      // Double click to open
      row.addEventListener('dblclick', () => {
        const nodeType = row.dataset.nodeType;
        const setId = row.dataset.setId;
        const viewId = row.dataset.viewId;

        if (nodeType === 'set' && setId) {
          this._selectSet(setId);
        } else if (nodeType === 'view' && setId && viewId) {
          if (this.currentSetId !== setId) this._selectSet(setId);
          this._selectView(viewId);
        } else if (nodeType === 'source') {
          // Toggle expand
          const rowId = row.dataset.rowId;
          if (this.expandedFsNodes.has(rowId)) {
            this.expandedFsNodes.delete(rowId);
          } else {
            this.expandedFsNodes.add(rowId);
          }
          this._renderFilesystemView();
        }
      });
    });

    // Keyboard navigation for table
    table.setAttribute('tabindex', '0');
    table.addEventListener('keydown', (e) => {
      const rows = Array.from(table.querySelectorAll('.fs-table-row'));
      const selectedRow = table.querySelector('.fs-table-row.selected');
      const currentIndex = selectedRow ? rows.indexOf(selectedRow) : -1;

      const selectRow = (index) => {
        if (index >= 0 && index < rows.length) {
          rows.forEach(r => r.classList.remove('selected'));
          rows[index].classList.add('selected');
          rows[index].scrollIntoView({ block: 'nearest' });
          this.selectedFsNodeId = rows[index].dataset.rowId;
        }
      };

      switch (e.key) {
        case 'ArrowDown':
          e.preventDefault();
          selectRow(currentIndex + 1);
          break;
        case 'ArrowUp':
          e.preventDefault();
          selectRow(currentIndex > 0 ? currentIndex - 1 : 0);
          break;
        case 'ArrowRight':
          e.preventDefault();
          if (selectedRow) {
            const rowId = selectedRow.dataset.rowId;
            if (!this.expandedFsNodes.has(rowId)) {
              this.expandedFsNodes.add(rowId);
              this._renderFilesystemView();
            }
          }
          break;
        case 'ArrowLeft':
          e.preventDefault();
          if (selectedRow) {
            const rowId = selectedRow.dataset.rowId;
            if (this.expandedFsNodes.has(rowId)) {
              this.expandedFsNodes.delete(rowId);
              this._renderFilesystemView();
            }
          }
          break;
        case 'Enter':
          e.preventDefault();
          if (selectedRow) {
            selectedRow.dispatchEvent(new MouseEvent('dblclick'));
          }
          break;
      }
    });
  }

  // --------------------------------------------------------------------------
  // Record Operations
  // --------------------------------------------------------------------------

  addRecord(values = {}, skipUndo = false) {
    const set = this.getCurrentSet();
    if (!set) {
      this._showToast('Select a set first to add a record', 'warning');
      return null;
    }

    // Ensure records array exists
    if (!Array.isArray(set.records)) {
      set.records = [];
    }

    // Pre-populate values from view filters when no values provided
    // This ensures new records match the current view's filters and remain visible
    const view = this.getCurrentView();
    if (Object.keys(values).length === 0 && view?.config?.filters?.length > 0) {
      view.config.filters.forEach(filter => {
        // Only use enabled "is" filters (exact match) for pre-population
        if (filter.enabled !== false && filter.operator === 'is' && filter.filterValue != null) {
          values[filter.fieldId] = filter.filterValue;
        }
      });
    }

    const record = createRecord(set.id, values);
    set.records.push(record);

    // Show feedback toast for successful record creation
    this._showToast('Record added', 'success');

    // Dual-write to backing source if set has a manual origin source
    // This maintains the invariant that source contains all data
    this._dualWriteRecordToSource(set, record);

    // Track for undo (unless skipping)
    if (!skipUndo) {
      this._pushUndoAction({
        type: 'create_record',
        recordId: record.id,
        record: { ...record },
        setId: set.id
      });
    }

    // Create EO event
    if (this.eoApp) {
      this._createEOEvent('record_created', { recordId: record.id, values });
    }

    // Record activity for activity stream
    const primaryField = set.fields?.find(f => f.isPrimary) || set.fields?.[0];
    const recordName = primaryField ? (values[primaryField.id] || 'New Record') : 'New Record';
    this._recordActivity({
      action: 'create',
      entityType: 'record',
      name: recordName,
      details: `In set "${set.name}"`,
      reverseData: { type: 'create_record', recordId: record.id, setId: set.id }
    });

    this._saveData();
    this._renderView();
    this._renderSidebar();

    return record;
  }

  /**
   * Dual-write a record to the backing source (if applicable)
   *
   * When a set has a backing source with origin='manual', we also
   * write the record to the source to maintain data consistency.
   * This ensures the source is always the canonical data layer.
   *
   * @param {Object} set - The set the record belongs to
   * @param {Object} record - The record to write
   */
  _dualWriteRecordToSource(set, record) {
    // Check if set has a backing source
    const sourceId = set.datasetProvenance?.sourceId || set.derivation?.parentSourceId;
    if (!sourceId) return;

    // Ensure sourceStore is initialized
    if (!this.sourceStore) {
      this._initSourceStore();
    }

    // Get the source
    const source = this.sourceStore.get(sourceId);
    if (!source) return;

    // Only dual-write to manual origin sources
    if (source.origin !== 'manual') return;

    // Convert record values from field IDs to field names
    const sourceRecord = {};
    for (const field of set.fields) {
      const fieldValue = record.values[field.id];
      if (fieldValue !== undefined) {
        sourceRecord[field.sourceColumn || field.name] = fieldValue;
      }
    }

    // Add metadata
    sourceRecord._recordId = record.id;
    sourceRecord._setId = set.id;
    sourceRecord._createdAt = record.createdAt;

    // Write to source
    this.sourceStore.addRecordToSource(sourceId, sourceRecord);
  }

  deleteRecord(recordId, skipUndo = false) {
    const set = this.getCurrentSet();
    if (!set) return;

    const index = set.records.findIndex(r => r.id === recordId);
    if (index === -1) return;

    const record = set.records[index];

    // Track for undo (unless skipping)
    if (!skipUndo) {
      this._pushUndoAction({
        type: 'delete_record',
        recordId,
        record: { ...record, values: { ...record.values } },
        setId: set.id
      });
    }

    // Add to tossed items (nothing is ever deleted per Rule 9)
    this.tossedItems.unshift({
      type: 'record',
      record: JSON.parse(JSON.stringify(record)), // Deep clone
      setId: set.id,
      setName: set.name,
      recordIndex: index,
      tossedAt: new Date().toISOString()
    });
    if (this.tossedItems.length > this.maxTossedItems) {
      this.tossedItems.pop();
    }

    // Create EO event
    if (this.eoApp) {
      this._createEOEvent('record_deleted', { recordId, record });
    }

    // Register as ghost if ghost registry is available
    if (typeof getGhostRegistry === 'function') {
      const ghostRegistry = getGhostRegistry();
      const tombstoneEvent = {
        id: `tombstone_${Date.now().toString(36)}_${Math.random().toString(36).substr(2, 6)}`,
        timestamp: new Date().toISOString(),
        actor: 'user',
        payload: {
          action: 'tombstone',
          targetId: recordId,
          reason: 'User deleted record',
          targetSnapshot: {
            type: 'record',
            setId: set.id,
            setName: set.name,
            payload: record
          }
        },
        context: { workspace: 'default' }
      };
      ghostRegistry.registerGhost(recordId, tombstoneEvent, {
        entityType: 'record',
        workspace: 'default'
      });
    }

    // Record activity for the deletion
    const primaryField = set.fields?.find(f => f.isPrimary) || set.fields?.[0];
    const deletedRecordName = primaryField ? (record.values[primaryField.id] || 'Untitled') : 'Record';
    this._recordActivity({
      action: 'delete',
      entityType: 'record',
      name: deletedRecordName,
      details: `Tossed from "${set.name}"`,
      canReverse: true,
      reverseData: { type: 'restore_tossed', item: { type: 'record', record, setId: set.id } }
    });

    set.records.splice(index, 1);
    this.selectedRecords.delete(recordId);

    this._saveData();
    this._renderView();
    this._renderSidebar();
    this._updateTossedBadge();

    // Show undo toast with countdown (reuse deletedRecordName from activity recording above)
    this._showToast(`Tossed record "${deletedRecordName}"`, 'info', {
      countdown: 5000,
      action: {
        label: 'Undo',
        callback: () => {
          // Restore the record using _restoreTossedItem (which also records activity)
          const tossedIndex = this.tossedItems.findIndex(
            t => t.type === 'record' && t.record.id === record.id
          );
          if (tossedIndex !== -1) {
            this._restoreTossedItem(tossedIndex);
          }
        }
      }
    });
  }

  duplicateRecord(recordId) {
    const set = this.getCurrentSet();
    const original = set?.records.find(r => r.id === recordId);
    if (!original) return;

    const duplicate = createRecord(set.id, { ...original.values });
    set.records.push(duplicate);

    // Record activity for the duplication
    const primaryField = set.fields?.find(f => f.isPrimary) || set.fields?.[0];
    const recordName = primaryField ? (original.values[primaryField.id] || 'Untitled') : 'Record';
    this._recordActivity({
      action: 'duplicate',
      entityType: 'record',
      name: `${recordName} (Copy)`,
      details: `Duplicated from "${recordName}" in "${set.name}"`
    });

    this._saveData();
    this._renderView();
    this._renderSidebar();

    return duplicate;
  }

  // --------------------------------------------------------------------------
  // Field Operations
  // --------------------------------------------------------------------------

  /**
   * Generate a unique auto-name for a new field based on its type.
   * Creates names like "Text", "Text 1", "Text 2", etc.
   * @param {string} type - The field type
   * @returns {string} A unique field name
   */
  _generateFieldName(type) {
    const set = this.getCurrentSet();
    if (!set) return FieldTypeDisplayNames[type] || 'Field';

    const baseName = FieldTypeDisplayNames[type] || 'Field';
    const existingNames = new Set(set.fields.map(f => f.name));

    // If base name is available, use it
    if (!existingNames.has(baseName)) {
      return baseName;
    }

    // Otherwise, find the next available number
    let counter = 1;
    while (existingNames.has(`${baseName} ${counter}`)) {
      counter++;
    }
    return `${baseName} ${counter}`;
  }

  _addField(type, name = 'New Field', options = {}) {
    const set = this.getCurrentSet();
    if (!set) {
      this._showToast('Please select a set first to add a new field', 'warning');
      return null;
    }

    // For select fields, ensure default choices if not provided
    if ((type === FieldTypes.SELECT || type === FieldTypes.MULTI_SELECT) && !options.choices) {
      options.choices = [
        { id: generateId(), name: 'Option 1', color: 'blue' },
        { id: generateId(), name: 'Option 2', color: 'green' },
        { id: generateId(), name: 'Option 3', color: 'yellow' }
      ];
    }

    const field = createField(name, type, options);

    // Support inserting at a specific index
    if (typeof options.insertAtIndex === 'number' && options.insertAtIndex >= 0) {
      set.fields.splice(options.insertAtIndex, 0, field);
    } else {
      set.fields.push(field);
    }

    // Dual-write field to backing source if set has a manual origin source
    this._dualWriteFieldToSource(set, field);

    // Auto-create stub definition and link field to it
    this._createAndLinkStubDefinition(set, field);

    // Record field history event
    this._recordFieldEvent(field.id, 'field.created', {
      name: name,
      type: type
    });

    // Record activity for the field addition
    this._recordActivity({
      action: 'create',
      entityType: 'field',
      name: field.name,
      details: `Added ${type} field to "${set.name}"`,
      canReverse: false
    });

    this._saveData();
    this._renderView();

    return field;
  }

  /**
   * Dual-write a field to the backing source schema (if applicable)
   *
   * When a set has a backing source with origin='manual', we also
   * add the field to the source schema to maintain consistency.
   *
   * @param {Object} set - The set the field belongs to
   * @param {Object} field - The field to write
   */
  _dualWriteFieldToSource(set, field) {
    // Check if set has a backing source
    const sourceId = set.datasetProvenance?.sourceId || set.derivation?.parentSourceId;
    if (!sourceId) return;

    // Ensure sourceStore is initialized
    if (!this.sourceStore) {
      this._initSourceStore();
    }

    // Get the source
    const source = this.sourceStore.get(sourceId);
    if (!source) return;

    // Only dual-write to manual origin sources
    if (source.origin !== 'manual') return;

    // Add field to source schema
    this.sourceStore.addFieldToSource(sourceId, {
      name: field.name,
      type: field.type,
      sourceColumn: field.name
    });
  }

  /**
   * Create a stub definition and link the field to it automatically
   * Per design: All keys should have a definition stub by default
   *
   * @param {Object} set - The set containing the field
   * @param {Object} field - The field to create a definition for
   */
  _createAndLinkStubDefinition(set, field) {
    // Skip if field already has a definition
    if (field.definitionId || field.semanticBinding?.definitionId) {
      return;
    }

    // Use the DefinitionsSetManager if available
    const DefinitionsSetManager = window.EO?.DefinitionsSetManager;
    if (DefinitionsSetManager) {
      const manager = new DefinitionsSetManager(this);
      manager.ensureDefinitionsSet();

      // Create the stub definition data
      const stubDefData = {
        id: `def_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        term: {
          term: field.name,
          label: this._formatFieldNameAsLabel(field.name)
        },
        status: 'stub',
        populationMethod: 'pending',
        discoveredFrom: {
          setId: set.id,
          setName: set.name,
          fieldId: field.id,
          fieldName: field.name,
          fieldType: field.type,
          discoveredAt: new Date().toISOString()
        }
      };

      // Create the definition record
      const record = manager.createDefinitionRecord(stubDefData, stubDefData.discoveredFrom);

      // Link the field to the definition
      manager.linkFieldToDefinition(set.id, field.id, record.id);

      // Also add to workbench.definitions for backward compatibility
      if (!this.definitions) this.definitions = [];
      const existingDef = this.definitions.find(d => d.id === record.id);
      if (!existingDef) {
        this.definitions.push({
          id: record.id,
          name: field.name,
          description: '',
          status: 'stub',
          sourceUri: null,
          terms: [{
            name: field.name,
            label: this._formatFieldNameAsLabel(field.name),
            type: field.type,
            description: ''
          }],
          importedAt: new Date().toISOString(),
          discoveredFrom: stubDefData.discoveredFrom
        });
      }

      console.log(`Created stub definition for field "${field.name}" in set "${set.name}"`);
    } else {
      // Fallback: Just add to workbench.definitions without Definitions Set integration
      if (!this.definitions) this.definitions = [];

      const stubId = `def_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const stubDef = {
        id: stubId,
        name: field.name,
        description: '',
        status: 'stub',
        sourceUri: null,
        terms: [{
          name: field.name,
          label: this._formatFieldNameAsLabel(field.name),
          type: field.type,
          description: ''
        }],
        importedAt: new Date().toISOString(),
        discoveredFrom: {
          setId: set.id,
          setName: set.name,
          fieldId: field.id,
          fieldName: field.name,
          fieldType: field.type,
          discoveredAt: new Date().toISOString()
        }
      };

      this.definitions.push(stubDef);

      // Link field to definition
      field.definitionId = stubId;
      field.semanticBinding = {
        definitionId: stubId,
        definitionTerm: field.name,
        boundAt: new Date().toISOString(),
        boundBy: 'auto-stub'
      };

      console.log(`Created stub definition (fallback) for field "${field.name}"`);
    }
  }

  /**
   * Format a field name as a human-readable label
   * @param {string} fieldName - The field name to format
   * @returns {string} Human-readable label
   */
  _formatFieldNameAsLabel(fieldName) {
    return fieldName
      .replace(/_/g, ' ')
      .replace(/([a-z])([A-Z])/g, '$1 $2')
      .replace(/\b\w/g, c => c.toUpperCase())
      .trim();
  }

  /**
   * Get comprehensive definition info for a field
   * Checks all possible definition binding methods
   *
   * @param {Object} field - The field to check
   * @returns {Object} Definition info { hasDefinition, isStub, definitionId, name, uri, status }
   */
  _getFieldDefinitionInfo(field) {
    // Check for definition binding from multiple sources
    const definitionId = field.definitionId ||
                         field.semanticBinding?.definitionId ||
                         field.definitionRef?.definitionId;

    if (!definitionId) {
      return { hasDefinition: false };
    }

    // Find the definition
    const definition = this.definitions?.find(d => d.id === definitionId);

    // Also check in Definitions Set if available
    let definitionSetRecord = null;
    const definitionsSet = this.sets?.find(s => s.id === 'set_definitions');
    if (definitionsSet) {
      definitionSetRecord = definitionsSet.records?.find(r => r.id === definitionId);
    }

    // Determine status (stub vs populated)
    const status = definition?.status ||
                   definitionSetRecord?.values?.fld_def_status ||
                   'stub';
    const isStub = status === 'stub';

    // Get name/label
    const name = definition?.name ||
                 definition?.terms?.[0]?.name ||
                 definitionSetRecord?.values?.fld_def_term ||
                 field.semanticBinding?.definitionTerm ||
                 field.name;

    // Get URI if available
    const uri = definition?.sourceUri ||
                definitionSetRecord?.values?.fld_def_meaning_uri ||
                field.definitionRef?.uri ||
                null;

    return {
      hasDefinition: true,
      isStub,
      definitionId,
      name,
      uri,
      status
    };
  }

  _deleteField(fieldId) {
    const set = this.getCurrentSet();
    if (!set) return;

    const index = set.fields.findIndex(f => f.id === fieldId);
    if (index === -1) return;

    // Don't delete the primary field if it's the only one
    if (set.fields[index].isPrimary && set.fields.length === 1) {
      this._showToast('Cannot delete the primary field', 'warning');
      return;
    }

    const field = set.fields[index];

    // Save field values from all records before removing
    const fieldValues = {};
    set.records.forEach(record => {
      if (record.values[fieldId] !== undefined) {
        fieldValues[record.id] = record.values[fieldId];
      }
    });

    // Add to tossed items (nothing is ever deleted per Rule 9)
    this.tossedItems.unshift({
      type: 'field',
      field: { ...field },
      fieldValues: fieldValues,
      setId: set.id,
      tossedAt: new Date().toISOString()
    });
    if (this.tossedItems.length > this.maxTossedItems) {
      this.tossedItems.pop();
    }

    // Record field history event before deletion
    this._recordFieldEvent(fieldId, 'field.deleted', {
      name: field.name,
      type: field.type
    });

    // Record activity for the field deletion
    this._recordActivity({
      action: 'delete',
      entityType: 'field',
      name: field.name,
      details: `Tossed ${field.type} field from "${set.name}"`,
      canReverse: true,
      reverseData: { type: 'restore_tossed', item: { type: 'field', field, fieldValues, setId: set.id } }
    });

    set.fields.splice(index, 1);

    // Remove field values from all records
    set.records.forEach(record => {
      delete record.values[fieldId];
    });

    this._saveData();
    this._renderView();
    this._updateTossedBadge();

    // Show undo toast with countdown
    this._showToast(`Tossed field "${field.name}"`, 'info', {
      countdown: 5000,
      action: {
        label: 'Undo',
        callback: () => {
          // Restore the field using _restoreTossedItem (which also records activity and field event)
          const tossedIndex = this.tossedItems.findIndex(
            t => t.type === 'field' && t.field.id === field.id
          );
          if (tossedIndex !== -1) {
            this._restoreTossedItem(tossedIndex);
          }
        }
      }
    });
  }

  _renameField(fieldId, newName) {
    const set = this.getCurrentSet();
    const field = set?.fields.find(f => f.id === fieldId);
    if (!field) return;

    const oldName = field.name;
    field.name = newName;

    // Record history event
    if (oldName !== newName) {
      this._recordFieldEvent(fieldId, 'field.renamed', {
        name: { from: oldName, to: newName }
      });

      // Record activity for the rename
      this._recordActivity({
        action: 'rename',
        entityType: 'field',
        name: newName,
        details: `Renamed from "${oldName}" to "${newName}" in "${set.name}"`
      });
    }

    this._saveData();
    this._renderView();
  }

  _changeFieldType(fieldId, newType, options = {}) {
    const set = this.getCurrentSet();
    const field = set?.fields.find(f => f.id === fieldId);
    if (!field) return;

    const oldType = field.type;

    // Don't do anything if the type hasn't changed
    if (oldType === newType) return;

    // Record the change in activity stream
    this._createEOEvent('field_type_changed', {
      setId: set.id,
      setName: set.name,
      fieldId: field.id,
      fieldName: field.name,
      oldType: oldType,
      newType: newType
    });

    // Record field history event
    this._recordFieldEvent(fieldId, 'field.type_changed', {
      type: { from: oldType, to: newType }
    });

    // Record activity for the type change
    this._recordActivity({
      action: 'update',
      entityType: 'field',
      name: field.name,
      details: `Changed type from ${oldType} to ${newType} in "${set.name}"`
    });

    // Update the field type
    field.type = newType;

    // Reset type-specific options for the new type
    field.options = {};
    switch (newType) {
      case FieldTypes.SELECT:
      case FieldTypes.MULTI_SELECT:
        field.options.choices = [
          { id: generateId(), name: 'Option 1', color: 'blue' },
          { id: generateId(), name: 'Option 2', color: 'green' },
          { id: generateId(), name: 'Option 3', color: 'yellow' }
        ];
        break;
      case FieldTypes.NUMBER:
        field.options.precision = 0;
        field.options.format = 'number';
        break;
      case FieldTypes.DATE:
        field.options.includeTime = false;
        field.options.dateFormat = 'local';
        field.options.timeFormat = '12h';
        break;
      case FieldTypes.LINK:
        // Use provided options or defaults
        field.options.linkedSetId = options.linkedSetId || null;
        field.options.linkedViewId = options.linkedViewId || null;
        field.options.linkedFieldId = options.linkedFieldId || null;
        field.options.allowMultiple = options.allowMultiple || false;
        field.options.enableEdgeData = options.enableEdgeData || false;
        field.options.edgeFields = options.edgeFields || [];
        break;
      case FieldTypes.ATTACHMENT:
        field.options.maxFiles = null;
        break;
      case FieldTypes.PHONE:
        field.options.defaultCountry = 'US';
        break;
      case FieldTypes.FORMULA:
        // Use provided options from the formula editor or defaults
        field.options.formula = options.formula || '';
        field.options.resultType = options.resultType || 'text';
        break;
      case FieldTypes.ROLLUP:
        field.options.linkedFieldId = null;
        field.options.rollupFieldId = null;
        field.options.aggregation = 'SUM';
        break;
      case FieldTypes.COUNT:
        field.options.linkedFieldId = null;
        break;
      case FieldTypes.AUTONUMBER:
        field.options.prefix = '';
        field.options.startValue = 1;
        break;
      case FieldTypes.JSON:
        field.options.displayMode = 'keyValue';
        break;
    }

    // Handle auto-linking when converting to LINK type with convertFromFieldId
    if (newType === FieldTypes.LINK && options.convertFromFieldId && options.linkedSetId) {
      this._performAutoLinking(fieldId, options.convertFromFieldId, options.linkedSetId, options.linkedFieldId, options.allowMultiple);
    }

    this._saveData();
    this._renderView();
  }

  // --------------------------------------------------------------------------
  // Context Menus
  // --------------------------------------------------------------------------

  /**
   * Show a context menu at the given position with the specified items
   * @param {number} x - X position
   * @param {number} y - Y position
   * @param {Array} items - Menu items: { icon, label, action, divider?, class? }
   */
  _showContextMenu(x, y, items) {
    const menu = this.elements.contextMenu;
    if (!menu) return;

    // Build menu HTML
    menu.innerHTML = items.map(item => {
      if (item.divider) {
        return '<div class="context-menu-divider"></div>';
      }
      const dangerClass = (item.class === 'danger' || item.danger) ? ' danger' : '';
      return `
        <div class="context-menu-item${dangerClass}">
          <i class="ph ${item.icon}"></i>
          <span>${this._escapeHtml(item.label)}</span>
        </div>
      `;
    }).join('');

    // Calculate position with viewport boundary checking
    const menuWidth = 200;
    const menuHeight = 300;
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    let left = x;
    let top = y;

    if (left + menuWidth > viewportWidth - 10) {
      left = viewportWidth - menuWidth - 10;
    }
    if (left < 10) left = 10;
    if (top + menuHeight > viewportHeight - 10) {
      top = viewportHeight - menuHeight - 10;
    }
    if (top < 10) top = 10;

    menu.style.left = left + 'px';
    menu.style.top = top + 'px';
    menu.classList.add('active');

    // Attach click handlers
    const menuItems = menu.querySelectorAll('.context-menu-item');
    let itemIndex = 0;
    items.forEach((item, idx) => {
      if (!item.divider && item.action) {
        const menuItem = menuItems[itemIndex];
        if (menuItem) {
          menuItem.addEventListener('click', () => {
            menu.classList.remove('active');
            item.action();
          });
        }
        itemIndex++;
      } else if (!item.divider) {
        itemIndex++;
      }
    });
  }

  _showRecordContextMenu(e, recordId) {
    const menu = this.elements.contextMenu;
    if (!menu) return;

    const hasPickedUp = this.pickedUp && this.pickedUp.type === 'record';

    menu.innerHTML = `
      <div class="context-menu-item" data-action="open">
        <i class="ph ph-arrow-square-out"></i>
        <span>Open record</span>
      </div>
      <div class="context-menu-item" data-action="view-history">
        <i class="ph ph-clock-counter-clockwise"></i>
        <span>View history</span>
      </div>
      <div class="context-menu-item" data-action="pick-up">
        <i class="ph ph-hand-grabbing"></i>
        <span>Pick up record</span>
      </div>
      ${hasPickedUp ? `
        <div class="context-menu-item" data-action="put-down">
          <i class="ph ph-hand-pointing"></i>
          <span>Put down here (merge)</span>
        </div>
      ` : ''}
      <div class="context-menu-item" data-action="duplicate">
        <i class="ph ph-copy"></i>
        <span>Duplicate</span>
      </div>
      <div class="context-menu-divider"></div>
      <div class="context-menu-item warning" data-action="toss">
        <i class="ph ph-arrow-bend-up-right"></i>
        <span>Toss record</span>
      </div>
    `;

    // Calculate position with viewport boundary checking
    const menuWidth = 200;
    const menuHeight = 130;
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    let left = e.pageX;
    let top = e.pageY;

    if (left + menuWidth > viewportWidth - 10) {
      left = viewportWidth - menuWidth - 10;
    }
    if (left < 10) left = 10;
    if (top + menuHeight > viewportHeight - 10) {
      top = viewportHeight - menuHeight - 10;
    }
    if (top < 10) top = 10;

    menu.style.left = left + 'px';
    menu.style.top = top + 'px';
    menu.classList.add('active');

    menu.querySelectorAll('.context-menu-item').forEach(item => {
      item.addEventListener('click', () => {
        menu.classList.remove('active');
        const action = item.dataset.action;

        switch (action) {
          case 'open':
            this._showRecordDetail(recordId);
            break;
          case 'view-history':
            this._showRecordHistoryDrawer(recordId);
            break;
          case 'pick-up':
            const set = this.getCurrentSet();
            const record = set?.records.find(r => r.id === recordId);
            if (record) {
              this._pickUp('record', { ...record }, {
                setId: set.id,
                viewId: this.currentViewId,
                recordId
              });
            }
            break;
          case 'put-down':
            if (this.pickedUp?.type === 'record') {
              this._mergeRecords(this.pickedUp.data, recordId);
              this._clearPickedUp();
            }
            break;
          case 'duplicate':
            this.duplicateRecord(recordId);
            break;
          case 'toss':
            this._tossRecord(recordId);
            break;
        }
      });
    });
  }

  /**
   * Toss a record (not deleted, just removed from view)
   */
  _tossRecord(recordId) {
    const set = this.getCurrentSet();
    if (!set) return;

    const recordIndex = set.records.findIndex(r => r.id === recordId);
    if (recordIndex === -1) return;

    const record = set.records[recordIndex];

    // Add to tossed items
    this.tossedItems.unshift({
      type: 'record',
      record: { ...record },
      setId: set.id,
      tossedAt: new Date().toISOString()
    });

    if (this.tossedItems.length > this.maxTossedItems) {
      this.tossedItems.pop();
    }

    // Remove from set
    set.records.splice(recordIndex, 1);

    this._renderView();
    this._saveData();
    this._updateTossedBadge();
    this._showToast('Record tossed - pick it up from the tossed pile', 'info');
  }

  /**
   * Merge two records together
   * TABLE RULE 5: Ensures new fields from source are added to set's field list
   */
  _mergeRecords(sourceRecord, targetRecordId) {
    const set = this.getCurrentSet();
    if (!set) return;

    const targetRecord = set.records.find(r => r.id === targetRecordId);
    if (!targetRecord) return;

    // Build a set of existing field IDs for quick lookup
    const existingFieldIds = new Set(set.fields.map(f => f.id));

    // Track new fields that need to be added (TABLE RULE 5)
    const newFieldsToAdd = [];

    // Count merged fields
    let mergedFieldCount = 0;

    // Merge values from source into target (source wins for non-empty values)
    Object.entries(sourceRecord.values).forEach(([fieldId, value]) => {
      if (value !== undefined && value !== null && value !== '') {
        targetRecord.values[fieldId] = value;
        mergedFieldCount++;

        // Check if this field exists in the set - if not, we need to add it
        if (!existingFieldIds.has(fieldId)) {
          // Create a new field for this value (TABLE RULE 5)
          const newField = ensureValidField({
            id: fieldId,
            name: fieldId, // Use ID as name fallback, can be renamed later
            type: typeof value === 'number' ? 'number' :
                  typeof value === 'boolean' ? 'checkbox' : 'text'
          });
          newFieldsToAdd.push(newField);
          existingFieldIds.add(fieldId); // Prevent duplicates
        }
      }
    });

    // Add any new fields to the set (TABLE RULE 5)
    if (newFieldsToAdd.length > 0) {
      set.fields = [...set.fields, ...newFieldsToAdd];
    }

    targetRecord.updatedAt = new Date().toISOString();

    // Record activity for record merge
    const newFieldsNote = newFieldsToAdd.length > 0
      ? ` (${newFieldsToAdd.length} new field${newFieldsToAdd.length !== 1 ? 's' : ''} added)`
      : '';
    this._recordActivity({
      action: 'update',
      operator: 'SYN', // Synthesize - merging identities
      entityType: 'record',
      name: `Record in ${set.name}`,
      details: `Merged ${mergedFieldCount} field${mergedFieldCount !== 1 ? 's' : ''} from source record into target record${newFieldsNote}`,
      canReverse: false
    });

    this._renderView();
    this._saveData();
    this._showToast('Records merged', 'success');
  }

  _showFieldContextMenu(e, fieldId) {
    const menu = this.elements.contextMenu;
    if (!menu) return;

    const set = this.getCurrentSet();
    const field = set?.fields.find(f => f.id === fieldId);
    if (!field) return;

    // Get the field index for insert operations
    const fieldIndex = set.fields.findIndex(f => f.id === fieldId);

    // Get friendly type name for display
    const typeNames = {
      'text': 'Text',
      'longText': 'Long text',
      'number': 'Number',
      'select': 'Single select',
      'multiSelect': 'Multiple select',
      'date': 'Date',
      'checkbox': 'Checkbox',
      'link': 'Link',
      'attachment': 'Attachment',
      'url': 'URL',
      'email': 'Email',
      'phone': 'Phone',
      'formula': 'Formula',
      'rollup': 'Rollup',
      'count': 'Count',
      'autonumber': 'Autonumber',
      'json': 'JSON'
    };

    // Build linked set/view info for LINK fields
    let linkInfo = '';
    if (field.type === FieldTypes.LINK && field.options?.linkedSetId) {
      const linkedSet = this.sets.find(s => s.id === field.options.linkedSetId);
      if (linkedSet) {
        let linkTarget = linkedSet.name;
        if (field.options.linkedViewId) {
          const linkedView = linkedSet.views?.find(v => v.id === field.options.linkedViewId);
          if (linkedView) {
            linkTarget += ` › ${linkedView.name}`;
          }
        }
        // Show linked field if not using primary
        if (field.options.linkedFieldId) {
          const linkedField = linkedSet.fields?.find(f => f.id === field.options.linkedFieldId);
          if (linkedField) {
            linkTarget += ` (${linkedField.name})`;
          }
        }
        linkInfo = `
          <div class="context-menu-item" data-action="configure-link" style="opacity: 0.8;">
            <i class="ph ph-arrow-bend-up-right"></i>
            <span style="font-size: 11px;">→ ${this._escapeHtml(linkTarget)}</span>
          </div>
        `;
      }
    }

    menu.innerHTML = `
      <div class="context-menu-item" data-action="insert-left" data-field-index="${fieldIndex}">
        <i class="ph ph-arrow-line-left"></i>
        <span>Insert field left</span>
      </div>
      <div class="context-menu-item" data-action="insert-right" data-field-index="${fieldIndex}">
        <i class="ph ph-arrow-line-right"></i>
        <span>Insert field right</span>
      </div>
      <div class="context-menu-divider"></div>
      <div class="context-menu-item" data-action="rename">
        <i class="ph ph-pencil"></i>
        <span>Rename field</span>
      </div>
      ${field.type === FieldTypes.FORMULA ? `
        <div class="context-menu-item" data-action="edit-formula">
          <i class="ph ph-function"></i>
          <span>Edit formula</span>
        </div>
      ` : ''}
      <div class="context-menu-item" data-action="change-type">
        <i class="ph ${FieldTypeIcons[field.type]}"></i>
        <span>Change type (${typeNames[field.type] || field.type})</span>
      </div>
      ${linkInfo}
      <div class="context-menu-item" data-action="hide">
        <i class="ph ph-eye-slash"></i>
        <span>Hide field</span>
      </div>
      <div class="context-menu-divider"></div>
      ${(() => {
        // Check if this field is currently the display name field
        const isCurrentDisplayName = set.displayNameFieldId === fieldId ||
          (!set.displayNameFieldId && fieldIndex === 0);
        return `
          <div class="context-menu-item ${isCurrentDisplayName ? 'disabled' : ''}" data-action="set-display-name" ${isCurrentDisplayName ? 'style="opacity: 0.5; cursor: default;"' : ''}>
            <i class="ph ${isCurrentDisplayName ? 'ph-check' : 'ph-identification-card'}"></i>
            <span>${isCurrentDisplayName ? 'Display name column' : 'Set as display name'}</span>
          </div>
        `;
      })()}
      ${!field.isPrimary ? `
        <div class="context-menu-item danger" data-action="delete">
          <i class="ph ph-trash"></i>
          <span>Delete field</span>
        </div>
      ` : ''}
    `;

    // Calculate position with viewport boundary checking
    const menuWidth = 200; // approximate width based on min-width: 180px + padding
    const menuHeight = field.isPrimary ? 200 : 240; // approximate height (includes insert options)
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    let left = e.pageX;
    let top = e.pageY;

    // Prevent menu from going off right edge
    if (left + menuWidth > viewportWidth - 10) {
      left = viewportWidth - menuWidth - 10;
    }
    // Prevent menu from going off left edge
    if (left < 10) {
      left = 10;
    }
    // Prevent menu from going off bottom edge
    if (top + menuHeight > viewportHeight - 10) {
      top = viewportHeight - menuHeight - 10;
    }
    // Prevent menu from going off top edge
    if (top < 10) {
      top = 10;
    }

    menu.style.left = left + 'px';
    menu.style.top = top + 'px';
    menu.classList.add('active');

    // Store menu position for sub-pickers (before menu is hidden)
    const menuPosition = { left, top };

    menu.querySelectorAll('.context-menu-item').forEach(item => {
      item.addEventListener('click', (clickEvent) => {
        menu.classList.remove('active');
        const action = item.dataset.action;

        switch (action) {
          case 'insert-left':
            this._showFieldTypePicker(clickEvent, (newType, typeOptions = {}) => {
              const insertIndex = parseInt(item.dataset.fieldIndex, 10);
              this._addField(newType, 'New Field', { ...typeOptions, insertAtIndex: insertIndex });
            }, menuPosition);
            break;
          case 'insert-right':
            this._showFieldTypePicker(clickEvent, (newType, typeOptions = {}) => {
              const insertIndex = parseInt(item.dataset.fieldIndex, 10) + 1;
              this._addField(newType, 'New Field', { ...typeOptions, insertAtIndex: insertIndex });
            }, menuPosition);
            break;
          case 'rename':
            this._showRenameFieldModal(fieldId);
            break;
          case 'edit-formula':
            this._showFormulaEditor(field);
            break;
          case 'change-type':
            // Pass the stored menu position since the context menu is now hidden
            this._showFieldTypePicker(clickEvent, (newType, options = {}) => {
              this._changeFieldType(fieldId, newType, options);
            }, menuPosition);
            break;
          case 'configure-link':
            // Reconfigure linked set/view for LINK fields
            this._showLinkedSetSelectionModal((options) => {
              field.options.linkedSetId = options.linkedSetId;
              field.options.linkedViewId = options.linkedViewId;
              field.options.linkedFieldId = options.linkedFieldId;
              field.options.allowMultiple = options.allowMultiple;
              field.options.enableEdgeData = options.enableEdgeData;
              field.options.edgeFields = options.edgeFields;

              // Handle auto-linking if conversion was requested
              if (options.convertFromFieldId && options.linkedFieldId) {
                this._performAutoLinking(field.id, options.convertFromFieldId, options.linkedSetId, options.linkedFieldId, options.allowMultiple);
              }

              this._renderView();
              this._saveData();
              this._showToast('Link configuration updated', 'success');
            }, field.options);
            break;
          case 'hide':
            this._hideField(fieldId);
            break;
          case 'set-display-name':
            this._setDisplayNameField(fieldId);
            break;
          case 'delete':
            this._deleteField(fieldId);
            break;
        }
      });
    });
  }

  _showSetContextMenu(e, setId) {
    const menu = this.elements.contextMenu;
    if (!menu) return;

    const set = this.sets.find(s => s.id === setId);
    const hasRecords = set && set.records && set.records.length > 0;
    const hasSources = this.sourceStore && this.sourceStore.getByStatus('active').length > 0;
    const isSample = set?.isSample === true;

    // Build the menu HTML
    let menuHtml = `
      <div class="context-menu-item" data-action="rename">
        <i class="ph ph-pencil"></i>
        <span>Rename</span>
      </div>
      <div class="context-menu-item" data-action="duplicate">
        <i class="ph ph-copy"></i>
        <span>Duplicate</span>
      </div>
      <div class="context-menu-divider"></div>
      <div class="context-menu-item ${!hasSources ? 'disabled' : ''}" data-action="add-source" ${!hasSources ? 'title="Import a source first"' : ''}>
        <i class="ph ph-plus-circle"></i>
        <span>Add Source...</span>
      </div>
      <div class="context-menu-item ${!hasRecords ? 'disabled' : ''}" data-action="create-views-from-column" ${!hasRecords ? 'title="Requires records in the set"' : ''}>
        <i class="ph ph-columns"></i>
        <span>Create views from column...</span>
      </div>
      <div class="context-menu-divider"></div>
    `;

    // Sample data can only be cleared via Settings > Clear Sample Data
    if (isSample) {
      menuHtml += `
        <div class="context-menu-item disabled" data-action="sample-info" title="Sample data can only be cleared via Settings → Clear Sample Data">
          <i class="ph ph-flask"></i>
          <span>Sample Data (use Settings to clear)</span>
        </div>
      `;
    } else {
      menuHtml += `
        <div class="context-menu-item" data-action="archive">
          <i class="ph ph-archive"></i>
          <span>Archive</span>
        </div>
        <div class="context-menu-item danger" data-action="delete">
          <i class="ph ph-trash"></i>
          <span>Delete</span>
        </div>
      `;
    }

    menu.innerHTML = menuHtml;

    // Calculate position with viewport boundary checking
    const menuWidth = 220;
    const menuHeight = 180;
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    let left = e.pageX;
    let top = e.pageY;

    if (left + menuWidth > viewportWidth - 10) {
      left = viewportWidth - menuWidth - 10;
    }
    if (left < 10) left = 10;
    if (top + menuHeight > viewportHeight - 10) {
      top = viewportHeight - menuHeight - 10;
    }
    if (top < 10) top = 10;

    menu.style.left = left + 'px';
    menu.style.top = top + 'px';
    menu.classList.add('active');

    menu.querySelectorAll('.context-menu-item').forEach(item => {
      item.addEventListener('click', () => {
        const action = item.dataset.action;
        menu.classList.remove('active');

        // Handle set actions
        switch (action) {
          case 'rename':
            this._renameSet(setId);
            break;
          case 'duplicate':
            this._duplicateSet(setId);
            break;
          case 'add-source':
            if (!item.classList.contains('disabled')) {
              this._showAddSourceToSetModal(setId);
            }
            break;
          case 'create-views-from-column':
            if (!item.classList.contains('disabled')) {
              this._showCreateViewsFromColumnModal(setId);
            }
            break;
          case 'archive':
            this._archiveSet(setId);
            break;
          case 'sample-info':
            this._showToast('Sample data can only be cleared via Settings → Clear Sample Data', 'info');
            break;
          case 'delete':
            this._deleteSet(setId);
            break;
        }
      });
    });
  }

  _showViewContextMenu(e, viewId) {
    const menu = this.elements.contextMenu;
    if (!menu) return;

    menu.innerHTML = `
      <div class="context-menu-item" data-action="rename">
        <i class="ph ph-pencil"></i>
        <span>Rename</span>
      </div>
      <div class="context-menu-item" data-action="duplicate">
        <i class="ph ph-copy"></i>
        <span>Duplicate</span>
      </div>
      <div class="context-menu-divider"></div>
      <div class="context-menu-item danger" data-action="delete">
        <i class="ph ph-trash"></i>
        <span>Delete</span>
      </div>
    `;

    // Calculate position with viewport boundary checking
    const viewMenuWidth = 200;
    const viewMenuHeight = 130;
    const vWidth = window.innerWidth;
    const vHeight = window.innerHeight;

    let viewLeft = e.pageX;
    let viewTop = e.pageY;

    if (viewLeft + viewMenuWidth > vWidth - 10) {
      viewLeft = vWidth - viewMenuWidth - 10;
    }
    if (viewLeft < 10) viewLeft = 10;
    if (viewTop + viewMenuHeight > vHeight - 10) {
      viewTop = vHeight - viewMenuHeight - 10;
    }
    if (viewTop < 10) viewTop = 10;

    menu.style.left = viewLeft + 'px';
    menu.style.top = viewTop + 'px';
    menu.classList.add('active');
  }

  // --------------------------------------------------------------------------
  // Field Type Picker
  // --------------------------------------------------------------------------

  _showAddFieldMenu(targetBtn) {
    // Check if a set is selected first
    const set = this.getCurrentSet();
    if (!set) {
      this._showToast('Please select a set first to add a new field', 'warning');
      return;
    }

    // Show field type picker positioned relative to the button
    if (targetBtn) {
      const rect = targetBtn.getBoundingClientRect();
      const position = {
        left: rect.left,
        top: rect.bottom + 4
      };
      this._showFieldTypePicker({ target: targetBtn }, null, position);
    }
  }

  _showFieldTypePicker(e, callback = null, position = null) {
    // Try cached element first, then query DOM as fallback
    let picker = this.elements.fieldTypePicker;
    if (!picker) {
      picker = document.getElementById('field-type-picker');
      if (picker) {
        this.elements.fieldTypePicker = picker;
      }
    }
    if (!picker) {
      console.error('Field type picker element not found');
      this._showToast('Could not open field type picker', 'error');
      return;
    }

    const pickerWidth = 240; // matches CSS width
    const pickerHeight = 400; // matches CSS max-height
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    let left, top;

    // Use provided position if available (e.g., from context menu)
    if (position) {
      left = position.left;
      top = position.top;
    } else {
      // Try to get position from th/button, or fall back to event coordinates
      const targetElement = e.target.closest('th, button, .context-menu-item');

      if (targetElement) {
        const rect = targetElement.getBoundingClientRect();
        left = rect.left;
        top = rect.bottom + 4;
      } else {
        // Fallback to event coordinates
        left = e.pageX || e.clientX || 100;
        top = e.pageY || e.clientY || 100;
      }
    }

    // Prevent picker from going off bottom edge
    if (top + pickerHeight > viewportHeight - 10) {
      top = viewportHeight - pickerHeight - 10;
    }
    // Prevent picker from going off top edge
    if (top < 10) {
      top = 10;
    }

    // Calculate left position, ensuring picker doesn't go off the right edge
    if (left + pickerWidth > viewportWidth - 10) {
      left = viewportWidth - pickerWidth - 10;
    }
    // Ensure it doesn't go off the left edge either
    if (left < 10) {
      left = 10;
    }

    picker.style.left = left + 'px';
    picker.style.top = top + 'px';
    picker.classList.add('active');

    // Get all field type items for keyboard navigation
    const items = Array.from(picker.querySelectorAll('.field-type-item'));
    let focusedIndex = -1;

    // Helper to update focused item
    const updateFocus = (newIndex) => {
      if (focusedIndex >= 0 && focusedIndex < items.length) {
        items[focusedIndex].classList.remove('keyboard-focused');
      }
      focusedIndex = newIndex;
      if (focusedIndex >= 0 && focusedIndex < items.length) {
        items[focusedIndex].classList.add('keyboard-focused');
        items[focusedIndex].scrollIntoView({ block: 'nearest' });
      }
    };

    // Helper to select the focused or specified item
    const selectItem = (item) => {
      cleanup();
      picker.classList.remove('active');
      const type = item.dataset.type;

      // For LINK type, show a modal to select the target set/view
      if (type === FieldTypes.LINK) {
        this._showLinkedSetSelectionModal((options) => {
          const { linkedSetId, linkedViewId, linkedFieldId, allowMultiple, convertFromFieldId, enableEdgeData, edgeFields } = options;

          if (callback) {
            // When changing type, pass the options through callback (including convertFromFieldId for auto-linking)
            callback(type, { linkedSetId, linkedViewId, linkedFieldId, allowMultiple, convertFromFieldId, enableEdgeData, edgeFields });
          } else {
            // When adding new field, pass options directly with auto-generated name
            const autoName = this._generateFieldName(type);
            const newField = this._addField(type, autoName, { linkedSetId, linkedViewId, linkedFieldId, allowMultiple, enableEdgeData, edgeFields });

            // Perform auto-linking if requested
            if (newField && convertFromFieldId) {
              this._performAutoLinking(newField.id, convertFromFieldId, linkedSetId, linkedFieldId, allowMultiple);
              this._saveData();
              this._renderView();
            }
          }
        });
      } else if (type === FieldTypes.FORMULA) {
        // For FORMULA type, show the formula editor
        this._showFormulaEditor(null, callback);
      } else {
        if (callback) {
          callback(type);
        } else {
          // Use auto-generated name based on field type
          const autoName = this._generateFieldName(type);
          this._addField(type, autoName);
        }
      }
    };

    // Keyboard handler for navigation
    const handleKeydown = (event) => {
      // Self-cleanup if picker was closed externally
      if (!picker.classList.contains('active')) {
        cleanup();
        return;
      }

      switch (event.key) {
        case 'ArrowDown':
        case 'j':
          event.preventDefault();
          updateFocus(focusedIndex < items.length - 1 ? focusedIndex + 1 : 0);
          break;
        case 'ArrowUp':
        case 'k':
          event.preventDefault();
          updateFocus(focusedIndex > 0 ? focusedIndex - 1 : items.length - 1);
          break;
        case 'Enter':
          event.preventDefault();
          if (focusedIndex >= 0 && focusedIndex < items.length) {
            selectItem(items[focusedIndex]);
          }
          break;
        case 'Escape':
          event.preventDefault();
          cleanup();
          picker.classList.remove('active');
          break;
      }
    };

    // Cleanup function to remove event listeners
    const cleanup = () => {
      document.removeEventListener('keydown', handleKeydown);
      items.forEach(item => item.classList.remove('keyboard-focused'));
    };

    // Add keyboard listener
    document.addEventListener('keydown', handleKeydown);

    // Add click handlers to each item
    items.forEach((item, index) => {
      item.addEventListener('click', () => selectItem(item), { once: true });
      // Also update focus on hover for better UX
      item.addEventListener('mouseenter', () => updateFocus(index));
    });

    // Focus first item by default for keyboard navigation
    updateFocus(0);
  }

  _hideField(fieldId) {
    const view = this.getCurrentView();
    const set = this.getCurrentSet();
    if (!view) return;

    const field = set?.fields?.find(f => f.id === fieldId);

    if (!view.config.hiddenFields) {
      view.config.hiddenFields = [];
    }
    view.config.hiddenFields.push(fieldId);

    // Record activity for hiding field
    this._recordActivity({
      action: 'filter',
      entityType: 'field',
      name: field?.name || 'Field',
      details: `Hid field "${field?.name || 'Unknown'}" in view "${view.name}"`,
      canReverse: false
    });

    this._saveData();
    this._renderView();
  }

  /**
   * Set a field as the display name column for records in this set
   * @param {string} fieldId - The ID of the field to set as display name
   */
  _setDisplayNameField(fieldId) {
    const set = this.getCurrentSet();
    if (!set) return;

    const field = set.fields?.find(f => f.id === fieldId);
    if (!field) return;

    // Get the previous display name field for activity logging
    const previousFieldId = set.displayNameFieldId;
    const previousField = previousFieldId
      ? set.fields?.find(f => f.id === previousFieldId)
      : set.fields?.[0];

    // Update the display name field
    set.displayNameFieldId = fieldId;

    // Record activity for changing display name field
    this._recordActivity({
      action: 'update',
      entityType: 'set',
      name: set.name,
      details: `Changed display name column from "${previousField?.name || 'first column'}" to "${field.name}"`,
      payload: {
        action: 'display_name_changed',
        setId: set.id,
        previousFieldId: previousFieldId,
        newFieldId: fieldId,
        previousFieldName: previousField?.name || null,
        newFieldName: field.name
      }
    });

    this._saveData();
    this._showToast(`"${field.name}" is now the display name column`, 'success');
  }

  // --------------------------------------------------------------------------
  // Modals
  // --------------------------------------------------------------------------

  _showModal(title, content, onConfirm, options = {}) {
    const overlay = this.elements.modal;
    const modal = overlay?.querySelector('.modal');
    if (!overlay || !modal) return;

    modal.querySelector('.modal-title').textContent = title;
    modal.querySelector('.modal-body').innerHTML = content;

    // Handle hideFooter option
    const footer = document.getElementById('modal-footer');
    if (footer) {
      footer.style.display = options.hideFooter ? 'none' : '';
    }

    // Reset confirm button text when showing a new modal
    const confirmBtn = document.getElementById('modal-confirm');
    if (confirmBtn && !options.hideFooter) {
      confirmBtn.innerHTML = options.confirmText || 'Save';
      confirmBtn.disabled = false;
    }

    overlay.classList.add('active');

    if (confirmBtn) {
      confirmBtn.onclick = () => {
        if (onConfirm) onConfirm();
        this._closeModal();
      };
    }
  }

  _closeModal() {
    this.elements.modal?.classList.remove('active');

    // Restore standard modal footer buttons (some modals replace these with custom buttons)
    const modalFooter = document.getElementById('modal-footer');
    if (modalFooter) {
      modalFooter.innerHTML = `
        <button class="btn btn-secondary" id="modal-cancel">Cancel</button>
        <button class="btn btn-primary" id="modal-confirm">Save</button>
      `;
      // Re-attach cancel click handler
      document.getElementById('modal-cancel')?.addEventListener('click', () => this._closeModal());
    }
  }

  // Mobile panel management methods
  _isMobile() {
    return window.matchMedia('(max-width: 768px)').matches;
  }

  _showMobileBackdrop() {
    const backdrop = document.getElementById('mobile-panel-backdrop');
    if (backdrop && this._isMobile()) {
      backdrop.classList.add('active');
    }
  }

  _hideMobileBackdrop() {
    const backdrop = document.getElementById('mobile-panel-backdrop');
    if (backdrop) {
      backdrop.classList.remove('active');
    }
  }

  _toggleMobileSidebar() {
    const sidebar = this.elements.sidebar;
    if (!sidebar) return;

    const isOpen = sidebar.classList.contains('mobile-open');

    if (isOpen) {
      sidebar.classList.remove('mobile-open');
      this._hideMobileBackdrop();
    } else {
      // Close detail panel first if open
      this._closeDetailPanel();
      sidebar.classList.add('mobile-open');
      this._showMobileBackdrop();
    }
  }

  _closeDetailPanel() {
    const detailPanel = this.elements.detailPanel;
    if (detailPanel) {
      detailPanel.classList.remove('open');
      if (this._isMobile()) {
        this._hideMobileBackdrop();
      }
    }
  }

  _openDetailPanel() {
    const detailPanel = this.elements.detailPanel;
    if (detailPanel) {
      // Close sidebar first on mobile
      if (this._isMobile()) {
        this.elements.sidebar?.classList.remove('mobile-open');
      }
      detailPanel.classList.add('open');
      if (this._isMobile()) {
        this._showMobileBackdrop();
      }
    }
  }

  _closeMobilePanels() {
    // Close sidebar
    this.elements.sidebar?.classList.remove('mobile-open');
    // Close detail panel
    this.elements.detailPanel?.classList.remove('open');
    // Hide backdrop
    this._hideMobileBackdrop();
  }

  _initMobileSwipeGestures() {
    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;
    const minSwipeDistance = 50;

    // Sidebar swipe handling
    const sidebar = this.elements.sidebar;
    if (sidebar) {
      sidebar.addEventListener('touchstart', (e) => {
        touchStartX = e.changedTouches[0].screenX;
        touchStartY = e.changedTouches[0].screenY;
      }, { passive: true });

      sidebar.addEventListener('touchend', (e) => {
        touchEndX = e.changedTouches[0].screenX;
        touchEndY = e.changedTouches[0].screenY;
        const deltaX = touchEndX - touchStartX;
        const deltaY = Math.abs(touchEndY - touchStartY);

        // Left swipe on sidebar to close
        if (deltaX < -minSwipeDistance && deltaY < 100) {
          this.elements.sidebar?.classList.remove('mobile-open');
          this._hideMobileBackdrop();
        }
      }, { passive: true });
    }

    // Detail panel swipe handling
    const detailPanel = this.elements.detailPanel;
    if (detailPanel) {
      detailPanel.addEventListener('touchstart', (e) => {
        touchStartX = e.changedTouches[0].screenX;
        touchStartY = e.changedTouches[0].screenY;
      }, { passive: true });

      detailPanel.addEventListener('touchend', (e) => {
        touchEndX = e.changedTouches[0].screenX;
        touchEndY = e.changedTouches[0].screenY;
        const deltaX = touchEndX - touchStartX;
        const deltaY = Math.abs(touchEndY - touchStartY);

        // Right swipe on detail panel to close
        if (deltaX > minSwipeDistance && deltaY < 100) {
          this._closeDetailPanel();
        }
      }, { passive: true });
    }

    // Edge swipe to open sidebar (from left edge)
    document.addEventListener('touchstart', (e) => {
      touchStartX = e.changedTouches[0].screenX;
      touchStartY = e.changedTouches[0].screenY;
    }, { passive: true });

    document.addEventListener('touchend', (e) => {
      if (!this._isMobile()) return;

      touchEndX = e.changedTouches[0].screenX;
      touchEndY = e.changedTouches[0].screenY;
      const deltaX = touchEndX - touchStartX;
      const deltaY = Math.abs(touchEndY - touchStartY);

      // Right swipe from left edge to open sidebar
      if (touchStartX < 30 && deltaX > minSwipeDistance && deltaY < 100) {
        if (!this.elements.sidebar?.classList.contains('mobile-open')) {
          this._toggleMobileSidebar();
        }
      }
    }, { passive: true });
  }

  _showImportModal() {
    // Call the global showImportModal function from eo_import.js
    if (typeof showImportModal === 'function') {
      try {
        showImportModal();
      } catch (error) {
        console.error('Error opening import modal:', error);
        this._showToast('Failed to open import dialog. Please try again.', 'error');
      }
    } else {
      console.error('showImportModal function not available');
      this._showToast('Import feature is not available. Please refresh the page.', 'error');
    }
  }

  _showNewSetModal() {
    // Get active sources for selection
    const activeSources = (this.sources || []).filter(s => s.status !== 'archived');
    const sortedSources = activeSources.sort((a, b) => {
      if (!a.importedAt) return 1;
      if (!b.importedAt) return -1;
      return new Date(b.importedAt) - new Date(a.importedAt);
    });

    const sourcesListHtml = sortedSources.length > 0 ? `
      <div class="form-group">
        <label class="form-label">Select Sources (Optional)</label>
        <div class="source-selection-hint">
          <i class="ph ph-info"></i>
          <span>Select one or more imported sources to include data in your new set, or leave empty to create a blank set.</span>
        </div>
        <div class="source-selection-list" id="source-selection-list">
          ${sortedSources.map(source => {
            const icon = this._getSourceIcon(source.name);
            const recordCount = source.recordCount || source.records?.length || 0;
            const fieldCount = source.schema?.fields?.length || 0;
            const importDate = source.importedAt ? new Date(source.importedAt).toLocaleDateString() : 'Unknown';
            return `
              <label class="source-selection-item" data-source-id="${source.id}">
                <input type="checkbox" class="source-checkbox" value="${source.id}">
                <div class="source-selection-icon">
                  <i class="ph ${icon}"></i>
                </div>
                <div class="source-selection-info">
                  <div class="source-selection-name">${source.name}</div>
                  <div class="source-selection-meta">
                    ${recordCount} records · ${fieldCount} fields · Imported ${importDate}
                  </div>
                </div>
              </label>
            `;
          }).join('')}
        </div>
      </div>
    ` : `
      <div class="form-group">
        <div class="source-selection-empty">
          <i class="ph ph-file-dashed"></i>
          <span>No imported sources available.</span>
          <button type="button" class="btn btn-primary btn-sm" id="new-set-import-btn" style="margin-top: 12px;">
            <i class="ph ph-upload"></i>
            Import Data First
          </button>
          <span class="source-selection-empty-hint">Or create an empty set below</span>
        </div>
      </div>
    `;

    this._showModal('Create New Set', `
      <div class="form-group">
        <label class="form-label">Set Name</label>
        <input type="text" class="form-input" id="new-set-name" placeholder="My Data" autofocus>
      </div>
      ${sourcesListHtml}
      <style>
        .source-selection-hint {
          display: flex;
          gap: 8px;
          padding: 8px 12px;
          background: var(--bg-secondary, #1e293b);
          border-radius: 6px;
          margin-bottom: 12px;
          font-size: 12px;
          color: var(--text-secondary, #cbd5e1);
        }
        .source-selection-hint i {
          color: var(--accent, #60a5fa);
          flex-shrink: 0;
        }
        .source-selection-list {
          max-height: 250px;
          overflow-y: auto;
          border: 1px solid var(--border-color, #334155);
          border-radius: 8px;
          background: var(--bg-secondary, #1e293b);
        }
        .source-selection-item {
          display: flex;
          align-items: center;
          gap: 12px;
          padding: 12px;
          cursor: pointer;
          border-bottom: 1px solid var(--border-color, #334155);
          transition: background 0.15s;
          color: var(--text-primary, #f1f5f9);
        }
        .source-selection-item:last-child {
          border-bottom: none;
        }
        .source-selection-item:hover {
          background: var(--bg-hover, rgba(255, 255, 255, 0.05));
        }
        .source-selection-item input[type="checkbox"] {
          width: 18px;
          height: 18px;
          cursor: pointer;
          accent-color: var(--accent, #60a5fa);
        }
        .source-selection-item input[type="checkbox"]:checked + .source-selection-icon {
          color: var(--accent, #60a5fa);
          background: rgba(96, 165, 250, 0.15);
        }
        .source-selection-icon {
          width: 32px;
          height: 32px;
          display: flex;
          align-items: center;
          justify-content: center;
          background: var(--bg-tertiary, #0f172a);
          border-radius: 6px;
          font-size: 16px;
          color: var(--text-secondary, #cbd5e1);
        }
        .source-selection-info {
          flex: 1;
          min-width: 0;
        }
        .source-selection-name {
          font-weight: 500;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
          color: var(--text-primary, #f1f5f9);
        }
        .source-selection-meta {
          font-size: 11px;
          color: var(--text-tertiary, #64748b);
          margin-top: 2px;
        }
        .source-selection-empty {
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 8px;
          padding: 24px;
          text-align: center;
          color: var(--text-tertiary, #64748b);
        }
        .source-selection-empty i {
          font-size: 32px;
        }
        .source-selection-empty-hint {
          font-size: 12px;
          color: var(--text-muted, #94a3b8);
          margin-top: 8px;
        }
      </style>
    `, () => {
      const name = document.getElementById('new-set-name')?.value || 'Untitled Set';

      // Get selected sources
      const selectedSourceIds = [];
      document.querySelectorAll('#source-selection-list .source-checkbox:checked').forEach(cb => {
        selectedSourceIds.push(cb.value);
      });

      if (selectedSourceIds.length === 0) {
        // No sources selected - create scratch set with backing source
        // This maintains the invariant that all sets have a backing source

        // Ensure sourceStore is initialized
        if (!this.sourceStore) {
          this._initSourceStore();
        }

        // Get or create the SetCreator
        if (!this._setCreator) {
          this._setCreator = new SetCreator(this.sourceStore, this.eoApp?.eventStore);
        }

        // Create scratch set with backing source
        const result = this._setCreator.createSetFromScratch({
          setName: name,
          fields: [{ name: 'Name', type: 'text' }],
          actor: 'user'
        });

        // Add the backing source to our sources list
        if (!this.sources) this.sources = [];
        this.sources.push(result.source);

        // Add the set
        this.sets.push(result.set);
        this._addSetToProject(result.set.id);
        this._addSourceToProject(result.source.id);
        this.currentSetId = result.set.id;
        this.currentViewId = result.set.views[0]?.id;

        this._saveData();
        this._renderSidebar();
        this._renderView();
        this._updateBreadcrumb();
      } else if (selectedSourceIds.length === 1) {
        // Single source selected - use SetFromSourceUI for field selection
        this._closeModal();
        this._showSetFromSourceUI(selectedSourceIds[0]);
      } else {
        // Multiple sources selected - show relational merge UI with 3 questions
        this._closeModal();
        this._showRelationalMergeUI(selectedSourceIds);
      }
    });

    // Focus input
    setTimeout(() => {
      document.getElementById('new-set-name')?.focus();
      // Add handler for "Import Data First" button when no sources available
      document.getElementById('new-set-import-btn')?.addEventListener('click', () => {
        this._closeModal();
        this._showImportModal();
      });
    }, 100);
  }

  /**
   * Initialize the consolidated "New" action dropdown in the sidebar
   * Provides a single, consistent location for all creation actions
   */
  _initNewActionDropdown() {
    const btn = document.getElementById('btn-new-action');
    const dropdown = document.getElementById('new-action-dropdown');

    if (!btn || !dropdown) return;

    // Toggle dropdown on button click
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const isVisible = dropdown.style.display !== 'none';
      dropdown.style.display = isVisible ? 'none' : 'block';
    });

    // Handle action item clicks
    dropdown.addEventListener('click', (e) => {
      const item = e.target.closest('.new-action-item');
      if (!item) return;

      const action = item.dataset.action;
      dropdown.style.display = 'none';

      switch (action) {
        case 'project':
          this._showNewProjectModal();
          break;
        case 'source':
          this._showImportModal();
          break;
        case 'definition':
          this._showImportDefinitionModal();
          break;
        case 'set':
          this._showNewSetModal();
          break;
        case 'view':
          this._showNewViewForCurrentSet();
          break;
        case 'record':
          this.addRecord();
          break;
        case 'field':
          this._showAddFieldMenu(btn);
          break;
        case 'export':
          this._showNewExportModal();
          break;
      }
    });
  }

  /**
   * Show view type picker for current set
   * Used by the consolidated "New" menu
   */
  _showNewViewForCurrentSet() {
    const set = this.getCurrentSet();
    if (!set) {
      this._showToast('Please select or create a set first', 'warning');
      return;
    }
    // Show view type picker - reuse existing method if available
    if (typeof this._showViewTypePicker === 'function') {
      // Create a temporary button element to position the picker
      const btn = document.getElementById('btn-new-action');
      this._showViewTypePicker({ target: btn }, set.id);
    } else {
      this._showNewViewModal();
    }
  }

  /**
   * Create a set from multiple selected sources
   * Combines records from all sources with a unified schema
   */
  _createSetFromMultipleSources(name, sourceIds) {
    const sources = sourceIds.map(id => this.sources?.find(s => s.id === id)).filter(Boolean);

    if (sources.length === 0) {
      this._showToast('No valid sources found', 'error');
      return;
    }

    // Collect all unique fields from all sources
    const fieldMap = new Map();
    sources.forEach(source => {
      const fields = source.schema?.fields || [];
      fields.forEach(field => {
        const fieldName = field.name.toLowerCase();
        if (!fieldMap.has(fieldName)) {
          fieldMap.set(fieldName, {
            id: `fld_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 6)}`,
            name: field.name,
            type: field.type || 'TEXT',
            width: field.width || 150
          });
        }
      });
    });

    const combinedFields = Array.from(fieldMap.values());

    // Combine all records
    const allRecords = [];
    sources.forEach(source => {
      const records = source.records || [];
      records.forEach(record => {
        allRecords.push({
          id: `rec_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 8)}`,
          setId: null, // Will be set after set creation
          values: { ...record },
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          _sourceId: source.id // Track which source this came from
        });
      });
    });

    // Create the set
    const timestamp = new Date().toISOString();
    const setId = `set_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 6)}`;

    const newSet = {
      id: setId,
      name: name,
      icon: 'ph-table',
      fields: combinedFields,
      records: allRecords.map(r => ({ ...r, setId })),
      views: [{
        id: `view_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 6)}`,
        name: 'Main View',
        type: 'table',
        config: {}
      }],
      createdAt: timestamp,
      updatedAt: timestamp,
      derivation: {
        strategy: 'combined',
        sourceIds: sourceIds,
        derivedAt: timestamp
      }
    };

    this.sets.push(newSet);
    this._addSetToProject(newSet.id);
    this.currentSetId = newSet.id;
    this.currentViewId = newSet.views[0]?.id;

    this._saveData();
    this._renderSidebar();
    this._renderView();
    this._updateBreadcrumb();
    this._showToast(`Set "${name}" created with ${allRecords.length} records from ${sources.length} sources`, 'success');
  }

  /**
   * Show merge options modal when multiple sources are selected
   * Allows user to choose merge strategy, join columns, and output options
   */
  _showMergeOptionsModal(setName, sourceIds) {
    const sources = sourceIds.map(id => this.sources?.find(s => s.id === id)).filter(Boolean);

    if (sources.length < 2) {
      this._showToast('Need at least 2 sources to merge', 'error');
      return;
    }

    // Collect all fields from all sources for join column selection
    const allFields = new Map();
    sources.forEach((source, idx) => {
      const fields = source.schema?.fields || [];
      fields.forEach(field => {
        const key = field.name.toLowerCase();
        if (!allFields.has(key)) {
          allFields.set(key, {
            name: field.name,
            sources: [source.id]
          });
        } else {
          allFields.get(key).sources.push(source.id);
        }
      });
    });

    // Find common fields (exist in multiple sources) for join suggestions
    const commonFields = Array.from(allFields.entries())
      .filter(([_, data]) => data.sources.length > 1)
      .map(([_, data]) => data.name);

    const sourceFieldsHtml = sources.map((source, idx) => {
      const fields = source.schema?.fields || [];
      return `
        <div class="merge-source-fields" data-source-id="${source.id}">
          <div class="merge-source-header">
            <i class="ph ${this._getSourceIcon(source.name)}"></i>
            <span class="merge-source-name">${source.name}</span>
            <span class="merge-source-count">${source.recordCount || source.records?.length || 0} records</span>
          </div>
          <select class="merge-join-field form-select" id="join-field-${idx}" data-source-idx="${idx}">
            <option value="">Select join column...</option>
            ${fields.map(f => `<option value="${f.name}" ${commonFields.includes(f.name) ? 'class="suggested"' : ''}>${f.name}</option>`).join('')}
          </select>
        </div>
      `;
    }).join('');

    this._showModal('Merge Sources', `
      <div class="merge-options-container">
        <div class="merge-set-name">
          <label class="form-label">Set Name</label>
          <input type="text" class="form-input" id="merge-set-name" value="${setName}" placeholder="Merged Data">
        </div>

        <div class="form-group">
          <label class="form-label">Merge Strategy</label>
          <div class="merge-strategy-options">
            <label class="merge-strategy-option">
              <input type="radio" name="merge-strategy" value="union" checked>
              <div class="merge-strategy-card">
                <i class="ph ph-rows"></i>
                <div class="merge-strategy-content">
                  <strong>Union (Stack)</strong>
                  <span>Combine all records from each source into one table. Columns are merged by name.</span>
                </div>
              </div>
            </label>
            <label class="merge-strategy-option">
              <input type="radio" name="merge-strategy" value="join">
              <div class="merge-strategy-card">
                <i class="ph ph-intersect"></i>
                <div class="merge-strategy-content">
                  <strong>Join (Match)</strong>
                  <span>Match records between sources based on a common column value.</span>
                </div>
              </div>
            </label>
          </div>
        </div>

        <div class="merge-join-options" id="merge-join-options" style="display: none;">
          <div class="form-group">
            <label class="form-label">Join Type</label>
            <div class="merge-join-type-options">
              <label class="join-type-option">
                <input type="radio" name="join-type" value="inner" checked>
                <span class="join-type-badge inner">Inner</span>
                <span class="join-type-desc">Only matching records</span>
              </label>
              <label class="join-type-option">
                <input type="radio" name="join-type" value="left">
                <span class="join-type-badge left">Left</span>
                <span class="join-type-desc">All from first + matches</span>
              </label>
              <label class="join-type-option">
                <input type="radio" name="join-type" value="right">
                <span class="join-type-badge right">Right</span>
                <span class="join-type-desc">All from second + matches</span>
              </label>
              <label class="join-type-option">
                <input type="radio" name="join-type" value="full">
                <span class="join-type-badge full">Full</span>
                <span class="join-type-desc">All records from both</span>
              </label>
            </div>
          </div>

          <div class="form-group">
            <label class="form-label">Join Columns</label>
            ${commonFields.length > 0 ? `
              <div class="merge-common-fields-hint">
                <i class="ph ph-lightbulb"></i>
                <span>Common columns found: ${commonFields.join(', ')}</span>
              </div>
            ` : ''}
            <div class="merge-source-fields-container">
              ${sourceFieldsHtml}
            </div>
          </div>
        </div>

        <div class="form-group">
          <label class="form-label">Output Options</label>
          <label class="merge-output-option">
            <input type="checkbox" id="merge-split-types">
            <span>Split into separate record types by source</span>
            <i class="ph ph-info" title="Creates a _recordType field to distinguish records from each source"></i>
          </label>
          <label class="merge-output-option">
            <input type="checkbox" id="merge-include-source">
            <span>Include source reference field</span>
            <i class="ph ph-info" title="Adds a _sourceId field to track which source each record came from"></i>
          </label>
        </div>

        <div class="merge-preview-section" id="merge-preview-section">
          <button class="btn btn-secondary btn-sm" id="merge-preview-btn">
            <i class="ph ph-eye"></i> Preview Result
          </button>
          <div class="merge-preview-result" id="merge-preview-result"></div>
        </div>
      </div>

      <style>
        .merge-options-container {
          display: flex;
          flex-direction: column;
          gap: 16px;
        }
        .merge-strategy-options {
          display: flex;
          flex-direction: column;
          gap: 8px;
        }
        .merge-strategy-option {
          cursor: pointer;
        }
        .merge-strategy-option input[type="radio"] {
          display: none;
        }
        .merge-strategy-card {
          display: flex;
          align-items: flex-start;
          gap: 12px;
          padding: 12px;
          border: 2px solid var(--border-color, #334155);
          border-radius: 8px;
          transition: all 0.15s;
          background: var(--bg-secondary, #1e293b);
        }
        .merge-strategy-card i {
          font-size: 24px;
          color: var(--text-secondary, #cbd5e1);
          margin-top: 2px;
        }
        .merge-strategy-content {
          display: flex;
          flex-direction: column;
          gap: 4px;
        }
        .merge-strategy-content strong {
          color: var(--text-primary, #f1f5f9);
        }
        .merge-strategy-content span {
          font-size: 12px;
          color: var(--text-tertiary, #64748b);
        }
        .merge-strategy-option input:checked + .merge-strategy-card {
          border-color: var(--accent, #60a5fa);
          background: rgba(96, 165, 250, 0.1);
        }
        .merge-strategy-option input:checked + .merge-strategy-card i {
          color: var(--accent, #60a5fa);
        }
        .merge-join-options {
          padding: 16px;
          background: var(--bg-secondary, #1e293b);
          border-radius: 8px;
          border: 1px solid var(--border-color, #334155);
        }
        .merge-join-type-options {
          display: grid;
          grid-template-columns: repeat(2, 1fr);
          gap: 8px;
        }
        .join-type-option {
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 4px;
          padding: 8px;
          border: 1px solid var(--border-color, #334155);
          border-radius: 6px;
          cursor: pointer;
          transition: all 0.15s;
        }
        .join-type-option:hover {
          background: var(--bg-hover, rgba(255, 255, 255, 0.05));
        }
        .join-type-option input {
          display: none;
        }
        .join-type-option input:checked ~ .join-type-badge {
          transform: scale(1.1);
        }
        .join-type-option input:checked ~ .join-type-badge.inner {
          background: #3b82f6;
          color: white;
        }
        .join-type-option input:checked ~ .join-type-badge.left {
          background: #8b5cf6;
          color: white;
        }
        .join-type-option input:checked ~ .join-type-badge.right {
          background: #10b981;
          color: white;
        }
        .join-type-option input:checked ~ .join-type-badge.full {
          background: #f59e0b;
          color: white;
        }
        .join-type-badge {
          font-size: 11px;
          font-weight: 600;
          padding: 4px 8px;
          border-radius: 4px;
          background: var(--bg-tertiary, #0f172a);
          color: var(--text-secondary, #cbd5e1);
          transition: all 0.15s;
        }
        .join-type-desc {
          font-size: 10px;
          color: var(--text-tertiary, #64748b);
          text-align: center;
        }
        .merge-source-fields-container {
          display: flex;
          flex-direction: column;
          gap: 12px;
        }
        .merge-source-fields {
          display: flex;
          flex-direction: column;
          gap: 8px;
          padding: 12px;
          background: var(--bg-tertiary, #0f172a);
          border-radius: 6px;
        }
        .merge-source-header {
          display: flex;
          align-items: center;
          gap: 8px;
        }
        .merge-source-header i {
          font-size: 16px;
          color: var(--text-secondary, #cbd5e1);
        }
        .merge-source-name {
          font-weight: 500;
          color: var(--text-primary, #f1f5f9);
        }
        .merge-source-count {
          font-size: 11px;
          color: var(--text-tertiary, #64748b);
          margin-left: auto;
        }
        .merge-common-fields-hint {
          display: flex;
          align-items: center;
          gap: 8px;
          padding: 8px 12px;
          background: rgba(96, 165, 250, 0.1);
          border-radius: 6px;
          margin-bottom: 8px;
          font-size: 12px;
          color: var(--accent, #60a5fa);
        }
        .merge-common-fields-hint i {
          font-size: 16px;
        }
        .merge-output-option {
          display: flex;
          align-items: center;
          gap: 8px;
          padding: 8px 12px;
          background: var(--bg-secondary, #1e293b);
          border-radius: 6px;
          cursor: pointer;
          margin-bottom: 8px;
          color: var(--text-primary, #f1f5f9);
        }
        .merge-output-option input {
          accent-color: var(--accent, #60a5fa);
        }
        .merge-output-option i {
          margin-left: auto;
          color: var(--text-tertiary, #64748b);
          font-size: 14px;
        }
        .merge-preview-section {
          padding-top: 8px;
          border-top: 1px solid var(--border-color, #334155);
        }
        .merge-preview-result {
          margin-top: 8px;
          padding: 12px;
          background: var(--bg-tertiary, #0f172a);
          border-radius: 6px;
          font-size: 12px;
          color: var(--text-secondary, #cbd5e1);
          display: none;
        }
        .merge-preview-result.visible {
          display: block;
        }
        .merge-preview-stat {
          display: flex;
          justify-content: space-between;
          padding: 4px 0;
          border-bottom: 1px solid var(--border-color, #334155);
        }
        .merge-preview-stat:last-child {
          border-bottom: none;
        }
        .merge-preview-stat strong {
          color: var(--text-primary, #f1f5f9);
        }
        .merge-join-field.form-select option.suggested {
          font-weight: bold;
        }
      </style>
    `, () => {
      // Get all configuration values
      const finalName = document.getElementById('merge-set-name')?.value || setName;
      const strategy = document.querySelector('input[name="merge-strategy"]:checked')?.value || 'union';
      const joinType = document.querySelector('input[name="join-type"]:checked')?.value || 'inner';
      const splitTypes = document.getElementById('merge-split-types')?.checked || false;
      const includeSource = document.getElementById('merge-include-source')?.checked || false;

      // Get join columns if join strategy
      const joinColumns = [];
      if (strategy === 'join') {
        sources.forEach((source, idx) => {
          const select = document.getElementById(`join-field-${idx}`);
          if (select?.value) {
            joinColumns.push({
              sourceId: source.id,
              field: select.value
            });
          }
        });

        // Validate join columns
        if (joinColumns.length < 2) {
          this._showToast('Please select join columns for all sources', 'warning');
          return;
        }
      }

      const mergeConfig = {
        name: finalName,
        strategy,
        joinType,
        joinColumns,
        splitTypes,
        includeSource,
        sourceIds
      };

      this._executeMerge(mergeConfig);
    });

    // Attach event listeners after modal is shown
    setTimeout(() => {
      // Toggle join options visibility
      document.querySelectorAll('input[name="merge-strategy"]').forEach(radio => {
        radio.addEventListener('change', (e) => {
          const joinOptions = document.getElementById('merge-join-options');
          if (joinOptions) {
            joinOptions.style.display = e.target.value === 'join' ? 'block' : 'none';
          }
        });
      });

      // Preview button
      document.getElementById('merge-preview-btn')?.addEventListener('click', () => {
        this._showMergePreview(sources);
      });
    }, 100);
  }

  /**
   * Show merge preview based on current settings
   */
  _showMergePreview(sources) {
    const strategy = document.querySelector('input[name="merge-strategy"]:checked')?.value || 'union';
    const resultDiv = document.getElementById('merge-preview-result');

    if (!resultDiv) return;

    let totalRecords = 0;
    let totalFields = new Set();

    sources.forEach(source => {
      totalRecords += source.recordCount || source.records?.length || 0;
      const fields = source.schema?.fields || [];
      fields.forEach(f => totalFields.add(f.name.toLowerCase()));
    });

    let previewHtml = '';
    if (strategy === 'union') {
      previewHtml = `
        <div class="merge-preview-stat">
          <span>Total records (combined)</span>
          <strong>${totalRecords}</strong>
        </div>
        <div class="merge-preview-stat">
          <span>Unique fields</span>
          <strong>${totalFields.size}</strong>
        </div>
        <div class="merge-preview-stat">
          <span>Sources</span>
          <strong>${sources.length}</strong>
        </div>
      `;
    } else {
      // For join, estimate is harder - just show source info
      const joinType = document.querySelector('input[name="join-type"]:checked')?.value || 'inner';
      const joinDesc = {
        'inner': 'Records that match in both sources',
        'left': `All ${sources[0]?.records?.length || 0} from first source + matches`,
        'right': `All ${sources[1]?.records?.length || 0} from second source + matches`,
        'full': 'All records from both sources'
      };
      previewHtml = `
        <div class="merge-preview-stat">
          <span>Join type</span>
          <strong>${joinType.charAt(0).toUpperCase() + joinType.slice(1)}</strong>
        </div>
        <div class="merge-preview-stat">
          <span>Expected result</span>
          <strong>${joinDesc[joinType]}</strong>
        </div>
        <div class="merge-preview-stat">
          <span>Combined fields</span>
          <strong>${totalFields.size}</strong>
        </div>
      `;
    }

    resultDiv.innerHTML = previewHtml;
    resultDiv.classList.add('visible');
  }

  /**
   * Execute the merge based on configuration
   */
  _executeMerge(config) {
    const sources = config.sourceIds.map(id => this.sources?.find(s => s.id === id)).filter(Boolean);

    if (sources.length < 2) {
      this._showToast('Invalid source configuration', 'error');
      return;
    }

    if (config.strategy === 'union') {
      this._executeUnionMerge(config, sources);
    } else if (config.strategy === 'join') {
      this._executeJoinMerge(config, sources);
    }
  }

  /**
   * Execute a union (stack) merge - combines all records
   */
  _executeUnionMerge(config, sources) {
    // Collect all unique fields from all sources
    const fieldMap = new Map();
    sources.forEach(source => {
      const fields = source.schema?.fields || [];
      fields.forEach(field => {
        const fieldName = field.name.toLowerCase();
        if (!fieldMap.has(fieldName)) {
          fieldMap.set(fieldName, {
            id: `fld_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 6)}`,
            name: field.name,
            type: field.type || 'TEXT',
            width: field.width || 150
          });
        }
      });
    });

    // Add special fields if requested
    if (config.splitTypes) {
      fieldMap.set('_recordtype', {
        id: `fld_${Date.now().toString(36)}_rt`,
        name: '_recordType',
        type: 'TEXT',
        width: 150
      });
    }

    if (config.includeSource) {
      fieldMap.set('_sourceid', {
        id: `fld_${Date.now().toString(36)}_sid`,
        name: '_sourceId',
        type: 'TEXT',
        width: 150
      });
    }

    const combinedFields = Array.from(fieldMap.values());

    // Combine all records
    const allRecords = [];
    const timestamp = new Date().toISOString();

    // Create a name-to-fieldId mapping for value remapping
    const nameToFieldId = new Map();
    fieldMap.forEach((fieldObj, fieldNameLower) => {
      nameToFieldId.set(fieldNameLower, fieldObj.id);
    });

    sources.forEach(source => {
      const records = source.records || [];
      const sourceName = source.name;
      const sourceFields = source.schema?.fields || [];

      // Create source field name mapping (original name -> lowercase for lookup)
      const sourceFieldNames = new Map();
      sourceFields.forEach(f => {
        sourceFieldNames.set(f.name, f.name.toLowerCase());
      });

      records.forEach(record => {
        // Remap record values from field names to field IDs
        const remappedValues = {};

        Object.entries(record).forEach(([key, value]) => {
          // Try to find the field by name (case-insensitive)
          const keyLower = key.toLowerCase();
          const fieldId = nameToFieldId.get(keyLower);
          if (fieldId) {
            remappedValues[fieldId] = value;
          }
        });

        const newRecord = {
          id: `rec_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 8)}`,
          setId: null,
          values: remappedValues,
          createdAt: timestamp,
          updatedAt: timestamp
        };

        if (config.splitTypes) {
          const rtFieldId = nameToFieldId.get('_recordtype');
          if (rtFieldId) {
            newRecord.values[rtFieldId] = sourceName;
          }
        }

        if (config.includeSource) {
          const sidFieldId = nameToFieldId.get('_sourceid');
          if (sidFieldId) {
            newRecord.values[sidFieldId] = source.id;
          }
        }

        allRecords.push(newRecord);
      });
    });

    // Create the set
    const setId = `set_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 6)}`;

    const newSet = {
      id: setId,
      name: config.name,
      icon: 'ph-table',
      fields: combinedFields,
      records: allRecords.map(r => ({ ...r, setId })),
      views: [{
        id: `view_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 6)}`,
        name: 'Main View',
        type: 'table',
        config: {}
      }],
      createdAt: timestamp,
      updatedAt: timestamp,
      derivation: {
        strategy: 'union',
        sourceIds: config.sourceIds,
        options: {
          splitTypes: config.splitTypes,
          includeSource: config.includeSource
        },
        derivedAt: timestamp
      }
    };

    this.sets.push(newSet);
    this._addSetToProject(newSet.id);
    this.currentSetId = newSet.id;
    this.currentViewId = newSet.views[0]?.id;

    this._saveData();
    this._renderSidebar();
    this._renderView();
    this._updateBreadcrumb();
    this._showToast(`Set "${config.name}" created with ${allRecords.length} records from ${sources.length} sources`, 'success');
  }

  /**
   * Execute a join merge - matches records based on common column
   */
  _executeJoinMerge(config, sources) {
    if (sources.length !== 2) {
      this._showToast('Join currently supports exactly 2 sources', 'warning');
      return;
    }

    const [leftSource, rightSource] = sources;
    const leftField = config.joinColumns.find(c => c.sourceId === leftSource.id)?.field;
    const rightField = config.joinColumns.find(c => c.sourceId === rightSource.id)?.field;

    if (!leftField || !rightField) {
      this._showToast('Please select join columns for both sources', 'error');
      return;
    }

    const leftRecords = leftSource.records || [];
    const rightRecords = rightSource.records || [];

    // Build index on right records
    const rightIndex = new Map();
    rightRecords.forEach((record, idx) => {
      const key = String(record[rightField] ?? '').toLowerCase().trim();
      if (!rightIndex.has(key)) {
        rightIndex.set(key, []);
      }
      rightIndex.get(key).push({ record, idx });
    });

    // Collect all fields from both sources
    const leftFields = leftSource.schema?.fields || [];
    const rightFields = rightSource.schema?.fields || [];

    const fieldMap = new Map();

    // Add left fields
    leftFields.forEach(field => {
      const fieldId = `fld_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 6)}`;
      fieldMap.set(field.name.toLowerCase(), {
        id: fieldId,
        name: field.name,
        type: field.type || 'TEXT',
        width: field.width || 150,
        sourceTable: 'left'
      });
    });

    // Add right fields (with prefix if name conflicts)
    rightFields.forEach(field => {
      const baseName = field.name.toLowerCase();
      let finalName = field.name;
      if (fieldMap.has(baseName)) {
        finalName = `${rightSource.name}_${field.name}`;
      }
      const fieldId = `fld_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 6)}`;
      fieldMap.set(finalName.toLowerCase(), {
        id: fieldId,
        name: finalName,
        originalName: field.name,
        type: field.type || 'TEXT',
        width: field.width || 150,
        sourceTable: 'right'
      });
    });

    // Add special fields if requested
    if (config.splitTypes) {
      fieldMap.set('_recordtype', {
        id: `fld_${Date.now().toString(36)}_rt`,
        name: '_recordType',
        type: 'TEXT',
        width: 150
      });
    }

    if (config.includeSource) {
      fieldMap.set('_leftsourceid', {
        id: `fld_${Date.now().toString(36)}_lsid`,
        name: '_leftSourceId',
        type: 'TEXT',
        width: 150
      });
      fieldMap.set('_rightsourceid', {
        id: `fld_${Date.now().toString(36)}_rsid`,
        name: '_rightSourceId',
        type: 'TEXT',
        width: 150
      });
    }

    const combinedFields = Array.from(fieldMap.values());
    const timestamp = new Date().toISOString();

    // Create name-to-fieldId mappings for value remapping
    // For left fields: original name -> field ID
    const leftNameToFieldId = new Map();
    leftFields.forEach(f => {
      const fieldObj = fieldMap.get(f.name.toLowerCase());
      if (fieldObj) {
        leftNameToFieldId.set(f.name.toLowerCase(), fieldObj.id);
      }
    });

    // For right fields: need to handle prefixed names for conflicts
    const rightNameToFieldId = new Map();
    rightFields.forEach(f => {
      const baseName = f.name.toLowerCase();
      // Check if this field was renamed due to conflict
      if (fieldMap.has(baseName) && fieldMap.get(baseName).sourceTable === 'left') {
        // Conflict - use prefixed name
        const prefixedName = `${rightSource.name}_${f.name}`.toLowerCase();
        const fieldObj = fieldMap.get(prefixedName);
        if (fieldObj) {
          rightNameToFieldId.set(f.name.toLowerCase(), fieldObj.id);
        }
      } else {
        const fieldObj = fieldMap.get(baseName);
        if (fieldObj) {
          rightNameToFieldId.set(f.name.toLowerCase(), fieldObj.id);
        }
      }
    });

    // Get field IDs for special fields
    const recordTypeFieldId = fieldMap.get('_recordtype')?.id;
    const leftSourceIdFieldId = fieldMap.get('_leftsourceid')?.id;
    const rightSourceIdFieldId = fieldMap.get('_rightsourceid')?.id;

    // Execute join
    const joinedRecords = [];
    const matchedRightIndices = new Set();

    // Process left records
    leftRecords.forEach((leftRecord, leftIdx) => {
      const leftKey = String(leftRecord[leftField] ?? '').toLowerCase().trim();
      const matches = rightIndex.get(leftKey) || [];

      if (matches.length > 0) {
        // Found matches
        matches.forEach(({ record: rightRecord, idx: rightIdx }) => {
          matchedRightIndices.add(rightIdx);

          const values = {};

          // Add left values with field ID keys
          Object.entries(leftRecord).forEach(([key, val]) => {
            const fieldId = leftNameToFieldId.get(key.toLowerCase());
            if (fieldId) {
              values[fieldId] = val;
            }
          });

          // Add right values with field ID keys
          Object.entries(rightRecord).forEach(([key, val]) => {
            const fieldId = rightNameToFieldId.get(key.toLowerCase());
            if (fieldId) {
              values[fieldId] = val;
            }
          });

          if (config.splitTypes && recordTypeFieldId) {
            values[recordTypeFieldId] = 'matched';
          }

          if (config.includeSource) {
            if (leftSourceIdFieldId) values[leftSourceIdFieldId] = leftSource.id;
            if (rightSourceIdFieldId) values[rightSourceIdFieldId] = rightSource.id;
          }

          joinedRecords.push({
            id: `rec_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 8)}`,
            setId: null,
            values,
            createdAt: timestamp,
            updatedAt: timestamp,
            _leftIndex: leftIdx,
            _rightIndex: rightIdx
          });
        });
      } else if (config.joinType === 'left' || config.joinType === 'full') {
        // No match - include left only
        const values = {};

        // Add left values with field ID keys
        Object.entries(leftRecord).forEach(([key, val]) => {
          const fieldId = leftNameToFieldId.get(key.toLowerCase());
          if (fieldId) {
            values[fieldId] = val;
          }
        });

        // Null out right fields using field IDs
        rightNameToFieldId.forEach((fieldId) => {
          values[fieldId] = null;
        });

        if (config.splitTypes && recordTypeFieldId) {
          values[recordTypeFieldId] = `${leftSource.name}_only`;
        }

        if (config.includeSource) {
          if (leftSourceIdFieldId) values[leftSourceIdFieldId] = leftSource.id;
          if (rightSourceIdFieldId) values[rightSourceIdFieldId] = null;
        }

        joinedRecords.push({
          id: `rec_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 8)}`,
          setId: null,
          values,
          createdAt: timestamp,
          updatedAt: timestamp,
          _leftIndex: leftIdx,
          _rightIndex: null
        });
      }
    });

    // For right/full join - include unmatched right records
    if (config.joinType === 'right' || config.joinType === 'full') {
      rightRecords.forEach((rightRecord, rightIdx) => {
        if (!matchedRightIndices.has(rightIdx)) {
          const values = {};

          // Null out left fields using field IDs
          leftNameToFieldId.forEach((fieldId) => {
            values[fieldId] = null;
          });

          // Add right values with field ID keys
          Object.entries(rightRecord).forEach(([key, val]) => {
            const fieldId = rightNameToFieldId.get(key.toLowerCase());
            if (fieldId) {
              values[fieldId] = val;
            }
          });

          if (config.splitTypes && recordTypeFieldId) {
            values[recordTypeFieldId] = `${rightSource.name}_only`;
          }

          if (config.includeSource) {
            if (leftSourceIdFieldId) values[leftSourceIdFieldId] = null;
            if (rightSourceIdFieldId) values[rightSourceIdFieldId] = rightSource.id;
          }

          joinedRecords.push({
            id: `rec_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 8)}`,
            setId: null,
            values,
            createdAt: timestamp,
            updatedAt: timestamp,
            _leftIndex: null,
            _rightIndex: rightIdx
          });
        }
      });
    }

    // Create the set
    const setId = `set_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 6)}`;

    const newSet = {
      id: setId,
      name: config.name,
      icon: 'ph-intersect',
      fields: combinedFields,
      records: joinedRecords.map(r => ({ ...r, setId })),
      views: [{
        id: `view_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 6)}`,
        name: 'Main View',
        type: 'table',
        config: {}
      }],
      createdAt: timestamp,
      updatedAt: timestamp,
      derivation: {
        strategy: 'con',
        joinSetIds: [leftSource.id, rightSource.id],
        constraint: {
          joinConditions: [{
            leftField,
            rightField,
            operator: 'eq'
          }],
          joinType: config.joinType,
          splitTypes: config.splitTypes,
          includeSource: config.includeSource
        },
        derivedAt: timestamp
      }
    };

    this.sets.push(newSet);
    this._addSetToProject(newSet.id);
    this.currentSetId = newSet.id;
    this.currentViewId = newSet.views[0]?.id;

    this._saveData();
    this._renderSidebar();
    this._renderView();
    this._updateBreadcrumb();

    const matchedCount = matchedRightIndices.size;
    this._showToast(`Joined set "${config.name}" created with ${joinedRecords.length} records (${matchedCount} matches)`, 'success');
  }

  _showNewViewModal() {
    this._showModal('Create New Lens', `
      <div class="form-group">
        <label class="form-label">Lens Name</label>
        <input type="text" class="form-input" id="new-view-name" placeholder="My View">
      </div>
      <div class="form-group">
        <label class="form-label">Lens Type</label>
        <select class="form-select" id="new-view-type">
          <option value="table">Grid (Table)</option>
          <option value="cards">Cards</option>
          <option value="kanban">Kanban</option>
          <option value="calendar">Calendar</option>
          <option value="graph">Graph</option>
          <option value="timeline">Timeline</option>
        </select>
      </div>
      <div class="compliance-note">
        <i class="ph ph-info"></i>
        <span>Lenses are MEANT events - interpretations of how to visualize data (Rule 1)</span>
      </div>
    `, () => {
      const name = document.getElementById('new-view-name')?.value || 'New View';
      const type = document.getElementById('new-view-type')?.value || 'table';

      const set = this.getCurrentSet();
      if (!set) return;

      // Create in legacy format
      const view = createView(name, type);
      set.views.push(view);
      this.currentViewId = view.id;

      // Also create in registry
      try {
        this.viewRegistry?.createLens?.({
          id: view.id,
          name: name,
          lensType: this._mapViewTypeToLensType(type),
          config: view.config || {}
        }, set.id);
      } catch (e) {
        console.warn('Failed to create lens in registry:', e);
      }

      this._saveData();
      this._renderViewsNav();
      this._renderView();
      this._updateBreadcrumb();
    });
  }

  /**
   * Show modal to create a new workspace
   */
  _showNewWorkspaceModal() {
    this._showModal('Create New Workspace', `
      <div class="form-group">
        <label class="form-label">Workspace Name</label>
        <input type="text" class="form-input" id="new-workspace-name" placeholder="My Workspace" autofocus>
      </div>
      <div class="form-group">
        <label class="form-label">Description</label>
        <textarea class="form-input" id="new-workspace-desc" rows="2" placeholder="Optional description..."></textarea>
      </div>
      <div class="form-group">
        <label class="form-label">Icon</label>
        <select class="form-select" id="new-workspace-icon">
          <option value="ph-folder-simple">Folder</option>
          <option value="ph-briefcase">Briefcase</option>
          <option value="ph-buildings">Buildings</option>
          <option value="ph-users">Team</option>
          <option value="ph-rocket">Project</option>
          <option value="ph-lightbulb">Ideas</option>
        </select>
      </div>
      <div class="compliance-note">
        <i class="ph ph-shield-check"></i>
        <span>Workspaces define horizon boundaries (Rule 4: Perspectivality)</span>
      </div>
    `, () => {
      const name = document.getElementById('new-workspace-name')?.value || 'Untitled Workspace';
      const desc = document.getElementById('new-workspace-desc')?.value || '';
      const icon = document.getElementById('new-workspace-icon')?.value || 'ph-folder-simple';

      try {
        const workspace = this.viewRegistry?.createWorkspace?.({
          name,
          description: desc,
          icon,
          horizon: { timeRange: null, actors: [], entityTypes: [] }
        }, ['user_action']);

        if (workspace) {
          this.currentWorkspaceId = workspace.id;
          this._renderSidebar();
          this._updateBreadcrumb();
          this._saveData();
        }
      } catch (e) {
        alert('Failed to create workspace: ' + e.message);
      }
    });

    setTimeout(() => {
      document.getElementById('new-workspace-name')?.focus();
    }, 100);
  }

  /**
   * Show modal to create a new focus (filtered view)
   * Rule 5: Focus can only RESTRICT, never expand
   */
  _showNewFocusModal() {
    const set = this.getCurrentSet();
    if (!set) return;

    const fields = set.fields || [];

    this._showModal('Create Focus (Filtered View)', `
      <div class="form-group">
        <label class="form-label">Focus Name</label>
        <input type="text" class="form-input" id="new-focus-name" placeholder="e.g., My Tasks This Week" autofocus>
      </div>
      <div class="form-group">
        <label class="form-label">Filter By</label>
        <select class="form-select" id="focus-filter-field">
          <option value="">Select field...</option>
          ${fields.map(f => `<option value="${f.id}">${this._escapeHtml(f.name)}</option>`).join('')}
        </select>
      </div>
      <div class="form-group">
        <label class="form-label">Operator</label>
        <select class="form-select" id="focus-filter-op">
          <option value="equals">Equals</option>
          <option value="not_equals">Not Equals</option>
          <option value="contains">Contains</option>
          <option value="is_empty">Is Empty</option>
          <option value="is_not_empty">Is Not Empty</option>
        </select>
      </div>
      <div class="form-group">
        <label class="form-label">Value</label>
        <input type="text" class="form-input" id="focus-filter-value" placeholder="Filter value...">
      </div>
      <div class="compliance-note warning">
        <i class="ph ph-warning"></i>
        <span><strong>Rule 5:</strong> Focuses can only RESTRICT what's visible, never expand beyond the parent lens.</span>
      </div>
    `, () => {
      const name = document.getElementById('new-focus-name')?.value || 'Filtered View';
      const fieldId = document.getElementById('focus-filter-field')?.value;
      const operator = document.getElementById('focus-filter-op')?.value || 'equals';
      const value = document.getElementById('focus-filter-value')?.value;

      if (!fieldId) {
        alert('Please select a field to filter by');
        return;
      }

      try {
        const focus = this.viewRegistry?.createFocus?.({
          name,
          restrictions: {
            filters: [{
              fieldId,
              operator,
              value
            }]
          },
          provenance: { filterReason: 'user_created_focus' }
        }, this.currentLensId || this.currentViewId);

        if (focus) {
          this.currentFocusId = focus.id;
          this._renderFocusesNav();
          this._renderView();
          this._updateBreadcrumb();
          this._saveData();
        }
      } catch (e) {
        alert('Failed to create focus: ' + e.message);
      }
    });

    setTimeout(() => {
      document.getElementById('new-focus-name')?.focus();
    }, 100);
  }

  /**
   * Show modal to create an export
   * Rule 9: Exports are immutable captures that can be superseded (downloads and records)
   */
  _showNewExportModal() {
    this._showModal('Create Export', `
      <div class="form-group">
        <label class="form-label">Export Name</label>
        <input type="text" class="form-input" id="new-export-name"
               placeholder="e.g., Q1 Review - ${new Date().toLocaleDateString()}" autofocus>
      </div>
      <div class="form-group">
        <label class="form-label">Purpose</label>
        <select class="form-select" id="export-purpose">
          <option value="review">Review/Audit</option>
          <option value="backup">Backup</option>
          <option value="milestone">Milestone</option>
          <option value="comparison">Comparison Point</option>
        </select>
      </div>
      <div class="form-group">
        <label class="form-label">Notes</label>
        <textarea class="form-input" id="export-notes" rows="2" placeholder="Optional notes about this export..."></textarea>
      </div>
      <div class="compliance-note">
        <i class="ph ph-export"></i>
        <span><strong>Rule 9:</strong> Exports are immutable. They download the current state and record it. Can be superseded but never modified.</span>
      </div>
    `, () => {
      const name = document.getElementById('new-export-name')?.value ||
                   `Export ${new Date().toLocaleDateString()}`;
      const purpose = document.getElementById('export-purpose')?.value || 'review';
      const notes = document.getElementById('export-notes')?.value || '';

      try {
        const sourceViewId = this.currentFocusId || this.currentLensId || this.currentViewId;
        const now = new Date().toISOString();

        // Create export record
        const exportRecord = {
          id: `exp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          name,
          purpose,
          notes,
          sourceViewId,
          createdAt: now,
          capturedAt: now,
          createdBy: 'current_user',
          // Capture snapshot of current data
          snapshot: {
            sets: this.sets?.length || 0,
            sources: this.sources?.length || 0,
            definitions: this.definitions?.length || 0
          }
        };

        // Add to exports array and project
        if (!Array.isArray(this.exports)) {
          this.exports = [];
        }
        this.exports.push(exportRecord);
        this._addExportToProject(exportRecord.id);

        // Save data
        this._saveData();

        // Update exports nav
        this._renderExportsNav();

        // Show success notification
        this._showNotification(`Export "${name}" created successfully`);
        this._showToast(`Export created: ${name}`, 'success');

      } catch (e) {
        console.error('Failed to create export:', e);
        this._showToast('Failed to create export: ' + e.message, 'error');
      }
    });

    setTimeout(() => {
      document.getElementById('new-export-name')?.focus();
    }, 100);
  }

  /**
   * Show workspace context menu
   */
  _showWorkspaceContextMenu(e, workspaceId) {
    const menu = this.elements.contextMenu;
    if (!menu) return;

    menu.innerHTML = `
      <div class="context-menu-item" data-action="rename">
        <i class="ph ph-pencil"></i>
        <span>Rename</span>
      </div>
      <div class="context-menu-item" data-action="export">
        <i class="ph ph-export"></i>
        <span>Create Export</span>
      </div>
      <div class="context-menu-item" data-action="lineage">
        <i class="ph ph-tree-structure"></i>
        <span>View Lineage (Rule 7)</span>
      </div>
      <div class="context-menu-divider"></div>
      <div class="context-menu-item danger" data-action="supersede">
        <i class="ph ph-arrows-clockwise"></i>
        <span>Supersede (Rule 9)</span>
      </div>
    `;

    menu.style.left = e.pageX + 'px';
    menu.style.top = e.pageY + 'px';
    menu.classList.add('active');

    menu.querySelectorAll('.context-menu-item').forEach(item => {
      item.addEventListener('click', () => {
        menu.classList.remove('active');
        const action = item.dataset.action;

        switch (action) {
          case 'export':
            this._showNewExportModal();
            break;
          case 'lineage':
            this._showViewLineage(workspaceId);
            break;
          case 'supersede':
            this._showSupersedeModal(workspaceId);
            break;
        }
      });
    });
  }

  /**
   * Show view lineage (Rule 7: Traceability)
   */
  _showViewLineage(viewId) {
    const lineage = this.viewRegistry?.getViewLineage?.(viewId) || [];

    if (lineage.length === 0) {
      alert('No lineage information available');
      return;
    }

    const lineageHtml = lineage.map((item, index) => `
      ${index > 0 ? '<div class="lineage-arrow"><i class="ph ph-arrow-down"></i></div>' : ''}
      <div class="lineage-item ${index === 0 ? 'current' : ''}">
        <div class="lineage-type">${item.viewType.toUpperCase()}</div>
        <div class="lineage-name">${this._escapeHtml(item.name)}</div>
        <div class="lineage-id">${item.id}</div>
      </div>
    `).join('');

    this._showModal('View Lineage (Rule 7: Groundedness)', `
      <div class="lineage-chain">
        ${lineageHtml}
      </div>
      <div class="compliance-note">
        <i class="ph ph-link"></i>
        <span>All interpretations must trace back to Given events (raw experience)</span>
      </div>
    `, null);

    // Hide confirm button for info-only modal
    document.getElementById('modal-confirm').style.display = 'none';
    document.getElementById('modal-cancel').textContent = 'Close';
  }

  /**
   * Show supersede modal (Rule 9: Defeasibility)
   */
  _showSupersedeModal(viewId) {
    const view = this.viewRegistry?.workspaces?.get(viewId) ||
                 this.viewRegistry?.sets?.get(viewId) ||
                 this.viewRegistry?.lenses?.get(viewId);

    if (!view) return;

    this._showModal('Supersede View (Rule 9)', `
      <div class="form-group">
        <label class="form-label">Current: ${this._escapeHtml(view.name)}</label>
        <input type="text" class="form-input" id="supersede-new-name"
               value="${this._escapeHtml(view.name)} (Updated)" autofocus>
      </div>
      <div class="form-group">
        <label class="form-label">Reason for Supersession</label>
        <textarea class="form-input" id="supersede-reason" rows="2"
                  placeholder="Why is this being superseded?"></textarea>
      </div>
      <div class="compliance-note warning">
        <i class="ph ph-warning"></i>
        <span><strong>Rule 9:</strong> The original view will be marked as superseded but NOT deleted. Views are never erased, only replaced.</span>
      </div>
    `, () => {
      const newName = document.getElementById('supersede-new-name')?.value;
      const reason = document.getElementById('supersede-reason')?.value;

      if (!newName) return;

      try {
        const newView = this.viewRegistry?.supersedeView?.(viewId, {
          ...view.toJSON?.() || view,
          name: newName
        }, reason);

        if (newView) {
          this._showNotification(`View superseded. New ID: ${newView.id}`);
          this._renderSidebar();
        }
      } catch (e) {
        alert('Failed to supersede: ' + e.message);
      }
    });
  }

  _showRenameFieldModal(fieldId) {
    const set = this.getCurrentSet();
    const field = set?.fields.find(f => f.id === fieldId);
    if (!field) return;

    this._showModal('Rename Field', `
      <div class="form-group">
        <label class="form-label">Field Name</label>
        <input type="text" class="form-input" id="rename-field-input" value="${this._escapeHtml(field.name)}">
      </div>
    `, () => {
      const newName = document.getElementById('rename-field-input')?.value;
      if (newName) {
        this._renameField(fieldId, newName);
      }
    });

    setTimeout(() => {
      const input = document.getElementById('rename-field-input');
      input?.focus();
      input?.select();
    }, 100);
  }

  /**
   * Show modal to select which set or view to link to when creating/changing to a LINK field
   * @param {Function} callback - Called with { linkedSetId, linkedViewId, linkedFieldId, allowMultiple, convertFromFieldId } when confirmed
   * @param {Object} existingOptions - Optional existing options to pre-populate
   */
  _showLinkedSetSelectionModal(callback, existingOptions = {}) {
    const currentSet = this.getCurrentSet();

    // Get all sets except the current one (can't link to self in most cases, but we'll allow it)
    const availableSets = this.sets || [];

    if (availableSets.length === 0) {
      alert('No sets available to link to. Please create at least one set first.');
      return;
    }

    // Pre-select existing option, current set, or first available set
    const defaultSetId = existingOptions.linkedSetId || currentSet?.id || availableSets[0]?.id;

    const setOptions = availableSets.map(s => {
      const selected = s.id === defaultSetId ? 'selected' : '';
      const isCurrent = s.id === currentSet?.id ? ' (current set)' : '';
      return `<option value="${s.id}" ${selected}>${this._escapeHtml(s.name)}${isCurrent}</option>`;
    }).join('');

    const allowMultipleChecked = existingOptions.allowMultiple ? 'checked' : '';

    // Build initial view options for the pre-selected set
    let initialViewOptions = '<option value="">All records (no view filter)</option>';
    const preSelectedSet = availableSets.find(s => s.id === defaultSetId);
    if (preSelectedSet?.views?.length > 0) {
      initialViewOptions += preSelectedSet.views.map(v => {
        const selected = existingOptions.linkedViewId === v.id ? 'selected' : '';
        const hasFilters = v.config?.filters?.length > 0 ? ' (filtered)' : '';
        return `<option value="${v.id}" ${selected}>${this._escapeHtml(v.name)}${hasFilters}</option>`;
      }).join('');
    }

    // Build initial linked field options for the pre-selected set
    const buildLinkedFieldOptions = (set, selectedFieldId) => {
      if (!set?.fields?.length) return '<option value="">(primary field)</option>';

      const primaryField = set.fields.find(f => f.isPrimary) || set.fields[0];
      let options = `<option value="">(primary field: ${this._escapeHtml(primaryField?.name || 'Name')})</option>`;

      set.fields.forEach(f => {
        const selected = f.id === selectedFieldId ? 'selected' : '';
        const isPrimaryLabel = f.isPrimary ? ' (primary)' : '';
        options += `<option value="${f.id}" ${selected}>${this._escapeHtml(f.name)}${isPrimaryLabel}</option>`;
      });

      return options;
    };

    let initialLinkedFieldOptions = buildLinkedFieldOptions(preSelectedSet, existingOptions.linkedFieldId);

    // Build source field options for converting existing field values to links
    const buildSourceFieldOptions = () => {
      if (!currentSet?.fields?.length) return '<option value="">No conversion</option>';

      let options = '<option value="">No conversion</option>';
      currentSet.fields.forEach(f => {
        // Only show text-like fields that can have values to match
        if ([FieldTypes.TEXT, FieldTypes.LONG_TEXT, FieldTypes.SELECT, FieldTypes.NUMBER].includes(f.type)) {
          options += `<option value="${f.id}">${this._escapeHtml(f.name)}</option>`;
        }
      });
      return options;
    };

    // Build edge fields list if existing
    const existingEdgeFields = existingOptions.edgeFields || [];
    const enableEdgeDataChecked = existingOptions.enableEdgeData ? 'checked' : '';

    let edgeFieldsHtml = '';
    existingEdgeFields.forEach((ef, idx) => {
      edgeFieldsHtml += `
        <div class="edge-field-item" data-idx="${idx}">
          <input type="text" class="form-input edge-field-name" placeholder="Field name" value="${this._escapeHtml(ef.name || '')}">
          <select class="form-select edge-field-type">
            <option value="TEXT" ${ef.type === 'TEXT' ? 'selected' : ''}>Text</option>
            <option value="NUMBER" ${ef.type === 'NUMBER' ? 'selected' : ''}>Number</option>
            <option value="DATE" ${ef.type === 'DATE' ? 'selected' : ''}>Date</option>
            <option value="CHECKBOX" ${ef.type === 'CHECKBOX' ? 'selected' : ''}>Checkbox</option>
            <option value="SELECT" ${ef.type === 'SELECT' ? 'selected' : ''}>Select</option>
          </select>
          <button type="button" class="btn btn-sm btn-ghost edge-field-remove" title="Remove field"><i class="ph ph-x"></i></button>
        </div>
      `;
    });

    this._showModal('Link to Records', `
      <div class="form-group">
        <label class="form-label">Link to which set?</label>
        <select class="form-select" id="linked-set-select">
          ${setOptions}
        </select>
        <div class="form-hint" style="margin-top: 6px; font-size: 11px; color: var(--text-tertiary);">
          Choose the set containing records you want to link to
        </div>
      </div>
      <div class="form-group">
        <label class="form-label">Link to which view? <span style="font-weight: normal; color: var(--text-muted);">(optional)</span></label>
        <select class="form-select" id="linked-view-select">
          ${initialViewOptions}
        </select>
        <div class="form-hint" style="margin-top: 6px; font-size: 11px; color: var(--text-tertiary);">
          Optionally restrict to records visible in a specific view (applies that view's filters)
        </div>
      </div>
      <div class="form-group">
        <label class="form-label">Match on which field?</label>
        <select class="form-select" id="linked-field-select">
          ${initialLinkedFieldOptions}
        </select>
        <div class="form-hint" style="margin-top: 6px; font-size: 11px; color: var(--text-tertiary);">
          Which field in the target set to use for matching and display
        </div>
      </div>
      <div class="form-group">
        <label class="form-checkbox" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="allow-multiple-check" ${allowMultipleChecked}>
          <span>Allow linking to multiple records</span>
        </label>
        <div class="form-hint" style="margin-top: 6px; font-size: 11px; color: var(--text-tertiary);">
          When enabled, each cell can link to multiple records from the selected set
        </div>
      </div>
      <div class="form-divider" style="margin: 16px 0; border-top: 1px solid var(--border-color);"></div>
      <div class="form-group">
        <label class="form-label"><i class="ph ph-magic-wand" style="margin-right: 4px;"></i>Auto-link from existing field <span style="font-weight: normal; color: var(--text-muted);">(optional)</span></label>
        <select class="form-select" id="convert-from-field-select">
          ${buildSourceFieldOptions()}
        </select>
        <div class="form-hint" style="margin-top: 6px; font-size: 11px; color: var(--text-tertiary);">
          Convert values from this field to links by matching against the target field. If multiple records match, all will be linked.
        </div>
      </div>
      <div class="form-divider" style="margin: 16px 0; border-top: 1px solid var(--border-color);"></div>
      <div class="form-group">
        <label class="form-checkbox" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="enable-edge-data-check" ${enableEdgeDataChecked}>
          <span><i class="ph ph-arrows-horizontal" style="margin-right: 4px;"></i>Enable Edge Data</span>
        </label>
        <div class="form-hint" style="margin-top: 6px; font-size: 11px; color: var(--text-tertiary);">
          Store data on the relationship itself (creates an "Edge Lens" for editing edge properties)
        </div>
      </div>
      <div id="edge-fields-section" style="display: ${existingOptions.enableEdgeData ? 'block' : 'none'};">
        <div class="form-group">
          <label class="form-label">Edge Fields</label>
          <div id="edge-fields-list" style="display: flex; flex-direction: column; gap: 8px;">
            ${edgeFieldsHtml}
          </div>
          <button type="button" class="btn btn-sm btn-secondary" id="add-edge-field-btn" style="margin-top: 8px;">
            <i class="ph ph-plus"></i> Add Edge Field
          </button>
          <div class="form-hint" style="margin-top: 6px; font-size: 11px; color: var(--text-tertiary);">
            Define fields that will be stored on each link/edge (e.g., "weight", "relationship type", "start date")
          </div>
        </div>
      </div>
      <div class="form-divider" style="margin: 16px 0; border-top: 1px solid var(--border-color);"></div>
      <div class="form-group">
        <label class="form-label"><i class="ph ph-eye" style="margin-right: 4px;"></i>Preview Matches</label>
        <div id="link-preview-container" style="background: var(--surface-secondary); border-radius: 6px; padding: 12px; min-height: 60px;">
          <div class="link-preview-loading" style="color: var(--text-muted); font-size: 12px;">
            Select a set to see preview matches...
          </div>
        </div>
        <div class="form-hint" style="margin-top: 6px; font-size: 11px; color: var(--text-tertiary);">
          Showing up to 3 sample records from the target set
        </div>
      </div>
    `, () => {
      const linkedSetId = document.getElementById('linked-set-select')?.value;
      const linkedViewId = document.getElementById('linked-view-select')?.value || null;
      const linkedFieldId = document.getElementById('linked-field-select')?.value || null;
      const allowMultiple = document.getElementById('allow-multiple-check')?.checked || false;
      const convertFromFieldId = document.getElementById('convert-from-field-select')?.value || null;
      const enableEdgeData = document.getElementById('enable-edge-data-check')?.checked || false;

      // Collect edge fields
      const edgeFields = [];
      document.querySelectorAll('.edge-field-item').forEach(item => {
        const name = item.querySelector('.edge-field-name')?.value?.trim();
        const type = item.querySelector('.edge-field-type')?.value || 'TEXT';
        if (name) {
          edgeFields.push({
            id: item.dataset.fieldId || `ef-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            name,
            type,
            options: {}
          });
        }
      });

      if (!linkedSetId) {
        alert('Please select a set to link to');
        return;
      }

      if (callback) {
        callback({ linkedSetId, linkedViewId, linkedFieldId, allowMultiple, convertFromFieldId, enableEdgeData, edgeFields });
      }
    }, { confirmText: '<i class="ph ph-link"></i> Link' });

    // Update view and field dropdowns when set selection changes
    const setSelect = document.getElementById('linked-set-select');
    const viewSelect = document.getElementById('linked-view-select');
    const fieldSelect = document.getElementById('linked-field-select');
    const previewContainer = document.getElementById('link-preview-container');

    // Function to update preview with sample records from selected set
    const updatePreview = async (set, viewId, fieldId) => {
      if (!previewContainer) return;

      if (!set) {
        previewContainer.innerHTML = `
          <div class="link-preview-loading" style="color: var(--text-muted); font-size: 12px;">
            Select a set to see preview matches...
          </div>
        `;
        return;
      }

      // CRITICAL: Ensure records are loaded from IndexedDB before displaying preview
      // This fixes the issue where linking to sets stored in IndexedDB showed no records
      // Use undefined check specifically - empty array means already loaded (no records in IndexedDB)
      if (set._recordsInIndexedDB && set.records === undefined) {
        previewContainer.innerHTML = `
          <div class="link-preview-loading" style="color: var(--text-muted); font-size: 12px;">
            <i class="ph ph-spinner ph-spin" style="margin-right: 6px;"></i>Loading records...
          </div>
        `;
        await this._ensureSetRecords(set);
      }

      // Get records (filtered by view if selected)
      let records = [...(set.records || [])];
      if (viewId && set.views) {
        const view = set.views.find(v => v.id === viewId);
        if (view?.config?.filters?.length > 0) {
          records = records.filter(record => {
            return view.config.filters.every(filter => {
              if (filter.enabled === false) return true;
              const value = record.values?.[filter.fieldId];
              return this._matchesFilter(value, filter);
            });
          });
        }
      }

      // Get the field to display (primary if not specified)
      let displayField;
      if (fieldId) {
        displayField = set.fields?.find(f => f.id === fieldId);
      }
      if (!displayField) {
        displayField = set.fields?.find(f => f.isPrimary) || set.fields?.[0];
      }

      if (records.length === 0) {
        previewContainer.innerHTML = `
          <div style="color: var(--text-muted); font-size: 12px;">
            <i class="ph ph-empty" style="margin-right: 4px;"></i>
            No records in this set${viewId ? ' (with current view filter)' : ''}
          </div>
        `;
        return;
      }

      // Show up to 3 sample records
      const sampleRecords = records.slice(0, 3);
      const totalCount = records.length;
      const moreCount = totalCount - sampleRecords.length;

      const previewItems = sampleRecords.map(record => {
        const value = displayField ? record.values?.[displayField.id] : '';
        const displayValue = value !== null && value !== undefined ? this._escapeHtml(String(value)) : '(empty)';
        return `
          <div style="display: flex; align-items: center; gap: 8px; padding: 6px 8px; background: var(--surface-primary); border-radius: 4px; margin-bottom: 4px;">
            <i class="ph ph-link" style="color: var(--text-muted); font-size: 12px;"></i>
            <span style="font-size: 13px; color: var(--text-primary);">${displayValue}</span>
          </div>
        `;
      }).join('');

      const moreHtml = moreCount > 0 ? `
        <div style="font-size: 11px; color: var(--text-muted); margin-top: 4px;">
          +${moreCount} more record${moreCount !== 1 ? 's' : ''} available
        </div>
      ` : '';

      previewContainer.innerHTML = previewItems + moreHtml;
    };

    // Initial preview for pre-selected set
    updatePreview(preSelectedSet, existingOptions.linkedViewId, existingOptions.linkedFieldId);

    setSelect?.addEventListener('change', () => {
      const selectedSetId = setSelect.value;
      const selectedSet = availableSets.find(s => s.id === selectedSetId);

      // Update view options
      let viewOptions = '<option value="">All records (no view filter)</option>';
      if (selectedSet?.views?.length > 0) {
        viewOptions += selectedSet.views.map(v => {
          const hasFilters = v.config?.filters?.length > 0 ? ' (filtered)' : '';
          return `<option value="${v.id}">${this._escapeHtml(v.name)}${hasFilters}</option>`;
        }).join('');
      }

      if (viewSelect) {
        viewSelect.innerHTML = viewOptions;
      }

      // Update linked field options
      if (fieldSelect) {
        fieldSelect.innerHTML = buildLinkedFieldOptions(selectedSet, null);
      }

      // Update preview
      updatePreview(selectedSet, null, null);
    });

    // Update preview when view changes
    viewSelect?.addEventListener('change', () => {
      const selectedSetId = setSelect?.value;
      const selectedSet = availableSets.find(s => s.id === selectedSetId);
      const selectedViewId = viewSelect.value || null;
      const selectedFieldId = fieldSelect?.value || null;
      updatePreview(selectedSet, selectedViewId, selectedFieldId);
    });

    // Update preview when field changes
    fieldSelect?.addEventListener('change', () => {
      const selectedSetId = setSelect?.value;
      const selectedSet = availableSets.find(s => s.id === selectedSetId);
      const selectedViewId = viewSelect?.value || null;
      const selectedFieldId = fieldSelect.value || null;
      updatePreview(selectedSet, selectedViewId, selectedFieldId);
    });

    // Toggle edge data section visibility
    const enableEdgeDataCheck = document.getElementById('enable-edge-data-check');
    const edgeFieldsSection = document.getElementById('edge-fields-section');

    enableEdgeDataCheck?.addEventListener('change', () => {
      if (edgeFieldsSection) {
        edgeFieldsSection.style.display = enableEdgeDataCheck.checked ? 'block' : 'none';
      }
    });

    // Add edge field button
    const addEdgeFieldBtn = document.getElementById('add-edge-field-btn');
    const edgeFieldsList = document.getElementById('edge-fields-list');

    const addEdgeFieldItem = () => {
      const idx = edgeFieldsList?.querySelectorAll('.edge-field-item').length || 0;
      const fieldId = `ef-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      const itemHtml = `
        <div class="edge-field-item" data-idx="${idx}" data-field-id="${fieldId}">
          <input type="text" class="form-input edge-field-name" placeholder="Field name" value="">
          <select class="form-select edge-field-type">
            <option value="TEXT">Text</option>
            <option value="NUMBER">Number</option>
            <option value="DATE">Date</option>
            <option value="CHECKBOX">Checkbox</option>
            <option value="SELECT">Select</option>
          </select>
          <button type="button" class="btn btn-sm btn-ghost edge-field-remove" title="Remove field"><i class="ph ph-x"></i></button>
        </div>
      `;
      if (edgeFieldsList) {
        edgeFieldsList.insertAdjacentHTML('beforeend', itemHtml);
        // Add remove handler to the new item
        const newItem = edgeFieldsList.querySelector(`.edge-field-item[data-idx="${idx}"]`);
        newItem?.querySelector('.edge-field-remove')?.addEventListener('click', () => {
          newItem.remove();
        });
        newItem?.querySelector('.edge-field-name')?.focus();
      }
    };

    addEdgeFieldBtn?.addEventListener('click', addEdgeFieldItem);

    // Add remove handlers to existing edge field items
    document.querySelectorAll('.edge-field-remove').forEach(btn => {
      btn.addEventListener('click', () => {
        btn.closest('.edge-field-item')?.remove();
      });
    });

    setTimeout(() => {
      document.getElementById('linked-set-select')?.focus();
    }, 100);
  }

  /**
   * Perform auto-linking by matching source field values to target field values
   * Finds all records in the target set where the target field matches the source field value
   * If multiple matches, all are linked.
   * @param {string} linkFieldId - The LINK field in the current set
   * @param {string} sourceFieldId - The source field whose values to match
   * @param {string} targetSetId - The target set to link to
   * @param {string} targetFieldId - The field in the target set to match against (null = primary field)
   * @param {boolean} allowMultiple - Whether to allow multiple links per record
   */
  _performAutoLinking(linkFieldId, sourceFieldId, targetSetId, targetFieldId, allowMultiple) {
    const currentSet = this.getCurrentSet();
    if (!currentSet) return;

    const targetSet = this.sets.find(s => s.id === targetSetId);
    if (!targetSet) return;

    // Determine which field to match against in the target set
    let matchField;
    if (targetFieldId) {
      matchField = targetSet.fields.find(f => f.id === targetFieldId);
    } else {
      // Use primary field
      matchField = targetSet.fields.find(f => f.isPrimary) || targetSet.fields[0];
    }

    if (!matchField) return;

    // Build an index of target field values to record IDs for efficient lookup
    // Handle case-insensitive matching and trim whitespace
    const targetIndex = new Map();
    targetSet.records.forEach(record => {
      let value = record.values?.[matchField.id];

      // Normalize the value for matching
      if (value !== null && value !== undefined) {
        const normalizedValue = String(value).trim().toLowerCase();
        if (normalizedValue) {
          if (!targetIndex.has(normalizedValue)) {
            targetIndex.set(normalizedValue, []);
          }
          targetIndex.get(normalizedValue).push(record.id);
        }
      }
    });

    // Track how many records were linked
    let linkedCount = 0;
    let totalLinks = 0;

    // For each record in the current set, match its source field value
    currentSet.records.forEach(record => {
      let sourceValue = record.values?.[sourceFieldId];

      if (sourceValue === null || sourceValue === undefined) return;

      // Normalize the source value
      const normalizedSourceValue = String(sourceValue).trim().toLowerCase();
      if (!normalizedSourceValue) return;

      // Find matching records in the target set
      const matchingRecordIds = targetIndex.get(normalizedSourceValue) || [];

      if (matchingRecordIds.length === 0) return;

      // Get current links (if any)
      let currentLinks = record.values?.[linkFieldId] || [];
      if (!Array.isArray(currentLinks)) {
        currentLinks = currentLinks ? [currentLinks] : [];
      }

      // Merge new matches with existing links
      let newLinks;
      if (allowMultiple) {
        // Add all matching record IDs, avoiding duplicates
        const linkSet = new Set(currentLinks);
        matchingRecordIds.forEach(id => linkSet.add(id));
        newLinks = Array.from(linkSet);
      } else {
        // Only keep the first match
        newLinks = [matchingRecordIds[0]];
      }

      // Update the record
      if (!record.values) record.values = {};
      record.values[linkFieldId] = newLinks;

      linkedCount++;
      totalLinks += newLinks.length;
    });

    // Show feedback to user
    if (linkedCount > 0) {
      const matchText = allowMultiple ? `${totalLinks} total links` : `${linkedCount} links`;
      this._showToast(`Auto-linked ${linkedCount} records (${matchText})`, 'success');
    } else {
      this._showToast('No matching records found for auto-linking', 'info');
    }
  }

  /**
   * Show the formula editor modal for creating or editing formula fields
   * @param {Object|null} field - Existing field to edit, or null for creating new
   * @param {Function|null} callback - Callback when changing an existing field's type
   */
  _showFormulaEditor(field, callback = null) {
    // Use the original formula editor
    if (!this.formulaEditor) {
      this.formulaEditor = new EOFormulaEditor(this);
    }

    if (field) {
      // Editing existing formula field
      this.formulaEditor.showEdit(field, (data) => {
        // Update the field
        field.name = data.name;
        field.options.formula = data.formula;
        field.options.resultType = data.resultType;

        // V3 editor provides evaluationContext (frame-aware settings)
        if (data.evaluationContext) {
          field.options.evaluationContext = data.evaluationContext;
        }

        // Record field history event
        this._recordFieldEvent(field.id, 'field.updated', {
          name: data.name,
          formula: data.formula,
          resultType: data.resultType,
          evaluationContext: data.evaluationContext
        });

        this._saveData();
        this._renderView();
        this._showToast(`Updated formula field "${data.name}"`, 'success');
      }, () => {
        // Cancelled
      });
    } else {
      // Creating new formula field
      this.formulaEditor.showCreate((data) => {
        // Build field options with evaluationContext if present (V3 editor)
        const fieldOptions = {
          formula: data.formula,
          resultType: data.resultType
        };
        if (data.evaluationContext) {
          fieldOptions.evaluationContext = data.evaluationContext;
        }

        if (callback) {
          // This is for type change scenarios
          callback(FieldTypes.FORMULA, fieldOptions);
        } else {
          // Adding a new field directly
          this._addField(FieldTypes.FORMULA, data.name, fieldOptions);
          this._showToast(`Created formula field "${data.name}"`, 'success');
        }
      }, () => {
        // Cancelled - do nothing
      });
    }
  }

  // --------------------------------------------------------------------------
  // Detail Panel
  // --------------------------------------------------------------------------

  _showRecordDetail(recordId) {
    const set = this.getCurrentSet();
    const record = set?.records.find(r => r.id === recordId);
    if (!record) return;

    const panel = this.elements.detailPanel;
    const body = document.getElementById('detail-panel-body');
    if (!panel || !body) return;

    this.currentDetailRecordId = recordId;

    // Use visible fields (respects view's hiddenFields and fieldOrder)
    const fields = this._getVisibleFields();
    const primaryField = set.fields.find(f => f.isPrimary) || set.fields[0];
    const title = record.values[primaryField?.id] || 'Untitled';

    body.innerHTML = `
      <div class="detail-record">
        <h2 style="font-size: 18px; margin-bottom: 16px;">
          <i class="ph ph-note" style="color: var(--primary-500);"></i>
          ${this._escapeHtml(title)}
        </h2>
        ${fields.map(field => {
          const value = record.values[field.id];
          const isEditable = ![FieldTypes.FORMULA, FieldTypes.ROLLUP, FieldTypes.COUNT, FieldTypes.AUTONUMBER].includes(field.type);
          return `
            <div class="detail-field-group" data-field-id="${field.id}">
              <div class="detail-field-label">
                <i class="ph ${FieldTypeIcons[field.type]}"></i>
                ${this._escapeHtml(field.name)}
                <button class="field-history-btn"
                        data-field-id="${field.id}"
                        data-record-id="${recordId}"
                        title="View field history & provenance">
                  <i class="ph ph-clock-counter-clockwise"></i>
                </button>
              </div>
              <div class="detail-field-value ${isEditable ? 'editable' : ''}"
                   data-field-id="${field.id}"
                   data-record-id="${recordId}"
                   ${isEditable ? 'title="Click to edit"' : ''}>
                ${this._renderDetailFieldValue(field, value)}
              </div>
            </div>
          `;
        }).join('')}
        <div class="detail-actions">
          <button class="detail-action-btn" id="detail-duplicate">
            <i class="ph ph-copy"></i>
            <span>Duplicate</span>
          </button>
          <button class="detail-action-btn danger" id="detail-delete">
            <i class="ph ph-trash"></i>
            <span>Delete</span>
          </button>
        </div>

        ${this._renderProvenanceSection(record, set)}

        ${this._renderHistorySection(record)}

        <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border-primary);">
          <div style="font-size: 11px; color: var(--text-muted);">
            <i class="ph ph-clock"></i> Created: ${this._formatDateSafe(record.createdAt)}<br>
            <i class="ph ph-pencil"></i> Updated: ${this._formatDateSafe(record.updatedAt)}<br>
            <i class="ph ph-hash"></i> ID: ${record.id}
          </div>
        </div>
      </div>
    `;

    // Add click handlers for editable fields
    body.querySelectorAll('.detail-field-value.editable').forEach(el => {
      el.addEventListener('click', () => {
        this._startDetailFieldEdit(el);
      });
    });

    // Action buttons

    document.getElementById('detail-duplicate')?.addEventListener('click', () => {
      this.duplicateRecord(recordId);
      this._showToast('Record duplicated', 'success');
    });

    document.getElementById('detail-delete')?.addEventListener('click', () => {
      this.deleteRecord(recordId);
      panel.classList.remove('open');
      this._showToast('Record tossed', 'info');
    });

    // Provenance field editing
    body.querySelectorAll('.provenance-value.editable').forEach(el => {
      el.addEventListener('click', () => {
        this._startProvenanceEdit(el, recordId, set);
      });
    });

    // Field history buttons
    body.querySelectorAll('.field-history-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const fieldId = btn.dataset.fieldId;
        const recId = btn.dataset.recordId;
        this._showFieldHistoryPopover(recId, fieldId, btn);
      });
    });

    // Link chip click handlers in detail panel
    body.querySelectorAll('.link-chip').forEach(el => {
      el.addEventListener('click', () => {
        const linkedId = el.dataset.linkedId;
        const fieldId = el.closest('.detail-field-group')?.dataset.fieldId;
        const field = set?.fields?.find(f => f.id === fieldId);
        const linkedSetId = field?.options?.linkedSetId;
        if (linkedId) {
          this._showLinkedRecordDetail(linkedId, linkedSetId);
        }
      });
    });

    this._openDetailPanel();
  }

  /**
   * Show linked record details from any set (used when clicking on link chips)
   * @param {string} linkedRecordId - The ID of the linked record to show
   * @param {string} linkedSetId - The ID of the set containing the linked record
   * @param {object} context - Optional context about where we navigated from
   */
  _showLinkedRecordDetail(linkedRecordId, linkedSetId, context = null) {
    // Find the linked set
    const linkedSet = linkedSetId ? this.sets?.find(s => s.id === linkedSetId) : null;

    // If no linked set specified, try to find the record across all sets
    let record, targetSet;
    if (linkedSet) {
      record = linkedSet.records?.find(r => r.id === linkedRecordId);
      targetSet = linkedSet;
    } else {
      // Search across all sets
      for (const set of this.sets) {
        record = set.records?.find(r => r.id === linkedRecordId);
        if (record) {
          targetSet = set;
          break;
        }
      }
    }

    if (!record || !targetSet) {
      this._showToast(`Linked record not found: ${linkedRecordId}`, 'warning');
      return;
    }

    const panel = this.elements.detailPanel;
    const body = document.getElementById('detail-panel-body');
    if (!panel || !body) return;

    // Store navigation context for back button
    if (!this._detailNavigationStack) {
      this._detailNavigationStack = [];
    }

    // Push current detail to stack if there's one open (for back navigation)
    if (this.currentDetailRecordId && context !== 'back') {
      this._detailNavigationStack.push({
        recordId: this.currentDetailRecordId,
        setId: this.getCurrentSet()?.id
      });
    }

    // Clear stack if this is a back navigation
    if (context === 'back') {
      // Stack is already popped by the back button handler
    }

    this.currentDetailRecordId = linkedRecordId;
    this._currentDetailSetId = targetSet.id;

    const currentSet = this.getCurrentSet();
    const isFromDifferentSet = currentSet?.id !== targetSet.id;
    const fields = targetSet.fields || [];
    const primaryField = fields.find(f => f.isPrimary) || fields[0];
    const title = record.values[primaryField?.id] || 'Untitled';

    // Build breadcrumb if viewing record from different set
    const breadcrumbHtml = isFromDifferentSet ? `
      <div class="linked-record-breadcrumb">
        <button class="linked-record-back-btn" id="linked-record-back">
          <i class="ph ph-arrow-left"></i>
          Back
        </button>
        <div class="linked-record-source">
          <i class="ph ph-table"></i>
          <span class="linked-record-set-name">${this._escapeHtml(targetSet.name)}</span>
        </div>
      </div>
    ` : '';

    body.innerHTML = `
      ${breadcrumbHtml}
      <div class="detail-record ${isFromDifferentSet ? 'linked-record-view' : ''}">
        <h2 style="font-size: 18px; margin-bottom: 16px;">
          <i class="ph ${isFromDifferentSet ? 'ph-link' : 'ph-note'}" style="color: var(--primary-500);"></i>
          ${this._escapeHtml(title)}
        </h2>
        ${fields.map(field => {
          const value = record.values[field.id];
          // For linked records from other sets, make them read-only to avoid confusion
          const isEditable = !isFromDifferentSet && ![FieldTypes.FORMULA, FieldTypes.ROLLUP, FieldTypes.COUNT, FieldTypes.AUTONUMBER].includes(field.type);
          return `
            <div class="detail-field-group" data-field-id="${field.id}">
              <div class="detail-field-label">
                <i class="ph ${FieldTypeIcons[field.type]}"></i>
                ${this._escapeHtml(field.name)}
              </div>
              <div class="detail-field-value ${isEditable ? 'editable' : ''}"
                   data-field-id="${field.id}"
                   data-record-id="${linkedRecordId}"
                   data-set-id="${targetSet.id}"
                   ${isEditable ? 'title="Click to edit"' : ''}>
                ${this._renderLinkedDetailFieldValue(field, value, targetSet)}
              </div>
            </div>
          `;
        }).join('')}

        ${!isFromDifferentSet ? `
          <div class="detail-actions">
            <button class="detail-action-btn" id="detail-duplicate">
              <i class="ph ph-copy"></i>
              <span>Duplicate</span>
            </button>
            <button class="detail-action-btn danger" id="detail-delete">
              <i class="ph ph-trash"></i>
              <span>Delete</span>
            </button>
          </div>
        ` : `
          <div class="detail-actions">
            <button class="detail-action-btn" id="linked-record-open-in-set">
              <i class="ph ph-arrow-square-out"></i>
              <span>Open in ${this._escapeHtml(targetSet.name)}</span>
            </button>
          </div>
        `}

        <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border-primary);">
          <div style="font-size: 11px; color: var(--text-muted);">
            <i class="ph ph-clock"></i> Created: ${this._formatDateSafe(record.createdAt)}<br>
            <i class="ph ph-pencil"></i> Updated: ${this._formatDateSafe(record.updatedAt)}<br>
            <i class="ph ph-hash"></i> ID: ${record.id}
          </div>
        </div>
      </div>
    `;

    // Add click handlers for editable fields (only if same set)
    if (!isFromDifferentSet) {
      body.querySelectorAll('.detail-field-value.editable').forEach(el => {
        el.addEventListener('click', () => {
          this._startDetailFieldEdit(el);
        });
      });

      document.getElementById('detail-duplicate')?.addEventListener('click', () => {
        this.duplicateRecord(linkedRecordId);
        this._showToast('Record duplicated', 'success');
      });

      document.getElementById('detail-delete')?.addEventListener('click', () => {
        this.deleteRecord(linkedRecordId);
        panel.classList.remove('open');
        this._showToast('Record tossed', 'info');
      });
    }

    // Back button handler
    document.getElementById('linked-record-back')?.addEventListener('click', () => {
      if (this._detailNavigationStack && this._detailNavigationStack.length > 0) {
        const prev = this._detailNavigationStack.pop();
        if (prev.setId === currentSet?.id) {
          this._showRecordDetail(prev.recordId);
        } else {
          this._showLinkedRecordDetail(prev.recordId, prev.setId, 'back');
        }
      } else {
        panel.classList.remove('open');
      }
    });

    // Open in set button handler
    document.getElementById('linked-record-open-in-set')?.addEventListener('click', () => {
      this._navigateToRecordInSet(linkedRecordId, targetSet.id);
    });

    // Add click handlers for link chips in the detail panel
    body.querySelectorAll('.link-chip').forEach(el => {
      el.addEventListener('click', () => {
        const linkedId = el.dataset.linkedId;
        const fieldId = el.closest('.detail-field-group')?.dataset.fieldId;
        const field = targetSet.fields?.find(f => f.id === fieldId);
        const nextLinkedSetId = field?.options?.linkedSetId;
        if (linkedId) {
          this._showLinkedRecordDetail(linkedId, nextLinkedSetId);
        }
      });
    });

    this._openDetailPanel();
  }

  /**
   * Navigate to a record in its own set (switch sets and show detail)
   */
  _navigateToRecordInSet(recordId, setId) {
    // First switch to the set
    this._selectSet(setId);

    // Then show the record detail after a brief delay to allow view to update
    setTimeout(() => {
      this._showRecordDetail(recordId);
      // Try to scroll to the record in the table
      const row = document.querySelector(`tr[data-record-id="${recordId}"]`);
      if (row) {
        row.scrollIntoView({ behavior: 'smooth', block: 'center' });
        row.classList.add('highlight-row');
        setTimeout(() => row.classList.remove('highlight-row'), 2000);
      }
    }, 100);
  }

  /**
   * Render field value for linked record detail panel
   * Similar to _renderDetailFieldValue but uses the correct set context
   */
  _renderLinkedDetailFieldValue(field, value, sourceSet) {
    const computedFieldTypes = [FieldTypes.FORMULA, FieldTypes.ROLLUP, FieldTypes.COUNT, FieldTypes.AUTONUMBER];

    if (!computedFieldTypes.includes(field.type) && (value === null || value === undefined || value === '')) {
      return '<span class="cell-empty">Empty</span>';
    }

    switch (field.type) {
      case FieldTypes.CHECKBOX:
        return `<i class="ph ${value ? 'ph-check-square' : 'ph-square'}" style="font-size: 18px; color: ${value ? 'var(--success-500)' : 'var(--text-muted)'}"></i>`;
      case FieldTypes.SELECT:
        const choice = field.options?.choices?.find(c => c.id === value);
        return choice ? `<span class="select-tag color-${choice.color || 'gray'}">${this._escapeHtml(choice.name)}</span>` : this._escapeHtml(String(value));
      case FieldTypes.MULTI_SELECT:
        if (Array.isArray(value)) {
          return value.map(v => {
            const c = field.options?.choices?.find(ch => ch.id === v);
            return c ? `<span class="select-tag color-${c.color || 'gray'}">${this._escapeHtml(c.name)}</span>` : '';
          }).join(' ');
        }
        return '<span class="cell-empty">-</span>';
      case FieldTypes.DATE:
        return this._formatDate(value, field);
      case FieldTypes.URL:
        return `<a href="${this._escapeHtml(value)}" target="_blank" style="color: var(--primary-500);">${this._escapeHtml(value)}</a>`;
      case FieldTypes.EMAIL:
        return `<a href="mailto:${this._escapeHtml(value)}" style="color: var(--primary-500);">${this._escapeHtml(value)}</a>`;
      case FieldTypes.LINK:
        const detailLinks = this._normalizeLinkValue(value);
        if (detailLinks.length > 0) {
          const linkedSetId = field.options?.linkedSetId;
          const linkedSet = linkedSetId ? this.sets?.find(s => s.id === linkedSetId) : sourceSet;
          const displayField = field.options?.linkedFieldId
            ? linkedSet?.fields?.find(f => f.id === field.options.linkedFieldId)
            : (linkedSet?.fields?.find(f => f.isPrimary) || linkedSet?.fields?.[0]);
          const hasEdgeFields = field.options?.enableEdgeData && field.options?.edgeFields?.length > 0;
          return detailLinks.map(link => {
            const linkedRecord = linkedSet?.records?.find(r => r.id === link.recordId);
            const name = linkedRecord?.values?.[displayField?.id] || 'Unknown';
            const hasEdgeData = hasEdgeFields && link.edgeData && Object.keys(link.edgeData).length > 0;
            const edgeIndicator = hasEdgeData ? '<i class="ph ph-arrows-horizontal edge-indicator" title="Has edge data"></i>' : '';
            return `<span class="link-chip clickable${hasEdgeData ? ' has-edge-data' : ''}" data-linked-id="${link.recordId}" data-linked-set-id="${linkedSetId || ''}">${this._escapeHtml(name)}${edgeIndicator}</span>`;
          }).join(' ');
        }
        return '<span class="cell-empty">No links</span>';
      case FieldTypes.ATTACHMENT:
        if (Array.isArray(value) && value.length > 0) {
          return value.map(att => {
            const name = typeof att === 'object' ? (att.name || att.filename || 'File') : String(att);
            return `<span class="attachment-chip"><i class="ph ph-file"></i> ${this._escapeHtml(name)}</span>`;
          }).join(' ');
        }
        return '<span class="cell-empty">No files</span>';
      case FieldTypes.FORMULA:
        return '<span class="cell-formula cell-empty">Formula</span>';
      default:
        if (typeof value === 'object') {
          return `<code style="font-size: 11px;">${this._escapeHtml(JSON.stringify(value, null, 2).substring(0, 100))}...</code>`;
        }
        return this._escapeHtml(String(value));
    }
  }

  /**
   * Show edge details in the detail panel
   */
  _showEdgeDetail(edgeData) {
    const panel = this.elements.detailPanel;
    const body = document.getElementById('detail-panel-body');
    if (!panel || !body) return;

    const set = this.getCurrentSet();
    const sourceRecord = set?.records.find(r => r.id === edgeData.source);
    const targetRecord = set?.records.find(r => r.id === edgeData.target);
    const field = edgeData.fieldId ? set?.fields?.find(f => f.id === edgeData.fieldId) : null;

    const primaryField = set?.fields?.find(f => f.isPrimary) || set?.fields?.[0];
    const sourceName = sourceRecord?.values?.[primaryField?.id] || edgeData.source;
    const targetName = targetRecord?.values?.[primaryField?.id] || edgeData.target;

    const hasEdgeFields = field?.options?.enableEdgeData && field?.options?.edgeFields?.length > 0;
    const storedEdgeData = edgeData.edgeData || {};

    this.currentDetailRecordId = null;

    let html = `
      <div class="detail-record">
        <h2 style="font-size: 18px; margin-bottom: 16px;">
          <i class="ph ph-arrow-right" style="color: var(--primary-500);"></i>
          Edge Details
        </h2>

        <div class="detail-field-group">
          <div class="detail-field-label">
            <i class="ph ph-link"></i>
            Relationship Type
          </div>
          <div class="detail-field-value">
            ${this._escapeHtml(edgeData.fieldName || 'Link')}
          </div>
        </div>

        <div class="detail-field-group">
          <div class="detail-field-label">
            <i class="ph ph-export"></i>
            Source
          </div>
          <div class="detail-field-value edge-node-link" data-record-id="${edgeData.source}" style="cursor: pointer; color: var(--primary-500);">
            ${this._escapeHtml(sourceName)}
          </div>
        </div>

        <div class="detail-field-group">
          <div class="detail-field-label">
            <i class="ph ph-sign-in"></i>
            Target
          </div>
          <div class="detail-field-value edge-node-link" data-record-id="${edgeData.target}" style="cursor: pointer; color: var(--primary-500);">
            ${this._escapeHtml(targetName)}
          </div>
        </div>
    `;

    // Show edge data if available
    if (hasEdgeFields && Object.keys(storedEdgeData).length > 0) {
      html += `
        <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border-primary);">
          <div class="detail-field-label" style="margin-bottom: 8px;">
            <i class="ph ph-database"></i>
            Edge Data
          </div>
      `;

      field.options.edgeFields.forEach(edgeField => {
        const value = storedEdgeData[edgeField.id];
        if (value !== null && value !== undefined) {
          const displayValue = this._renderEdgeLensFieldValue(edgeField, value);
          html += `
            <div class="detail-field-group" style="margin-left: 8px;">
              <div class="detail-field-label" style="font-size: 11px;">
                ${this._escapeHtml(edgeField.name)}
              </div>
              <div class="detail-field-value" style="font-size: 13px;">
                ${displayValue}
              </div>
            </div>
          `;
        }
      });

      html += `</div>`;
    }

    // Add Edit Edge Data button if edge fields are enabled
    if (hasEdgeFields) {
      html += `
        <div style="margin-top: 16px;">
          <button class="btn btn-primary btn-sm edit-edge-data-btn" style="width: 100%;">
            <i class="ph ph-arrows-horizontal"></i>
            Edit Edge Data
          </button>
        </div>
      `;
    }

    html += `
        <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border-primary);">
          <div style="font-size: 11px; color: var(--text-muted);">
            <i class="ph ph-hash"></i> Edge ID: ${this._escapeHtml(edgeData.id)}
          </div>
        </div>
      </div>
    `;

    body.innerHTML = html;

    // Add click handlers for navigating to source/target records
    body.querySelectorAll('.edge-node-link').forEach(el => {
      el.addEventListener('click', () => {
        const recordId = el.dataset.recordId;
        if (recordId) {
          this._showRecordDetail(recordId);
        }
      });
    });

    // Add click handler for Edit Edge Data button
    const editBtn = body.querySelector('.edit-edge-data-btn');
    if (editBtn && field) {
      editBtn.addEventListener('click', () => {
        this._showEdgeLensPanel(edgeData.source, field.id, edgeData.target);
      });
    }

    this._openDetailPanel();
  }

  /**
   * Show Edge Lens panel for editing edge data on a link
   * @param {string} sourceRecordId - The source record ID
   * @param {string} fieldId - The link field ID
   * @param {string} targetRecordId - The target (linked) record ID
   */
  _showEdgeLensPanel(sourceRecordId, fieldId, targetRecordId) {
    const panel = this.elements.detailPanel;
    const body = document.getElementById('detail-panel-body');
    if (!panel || !body) return;

    const set = this.getCurrentSet();
    const sourceRecord = set?.records.find(r => r.id === sourceRecordId);
    const field = set?.fields.find(f => f.id === fieldId);
    if (!sourceRecord || !field) return;

    const linkedSet = this.sets.find(s => s.id === field.options?.linkedSetId);
    const targetRecord = linkedSet?.records.find(r => r.id === targetRecordId);

    const primaryField = set?.fields.find(f => f.isPrimary) || set?.fields?.[0];
    // Use linkedFieldId if set, otherwise fall back to primary field for the target record
    const linkedDisplayField = field.options?.linkedFieldId
      ? linkedSet?.fields?.find(f => f.id === field.options.linkedFieldId)
      : (linkedSet?.fields?.find(f => f.isPrimary) || linkedSet?.fields?.[0]);

    const sourceName = sourceRecord?.values?.[primaryField?.id] || sourceRecordId;
    const targetName = targetRecord?.values?.[linkedDisplayField?.id] || targetRecordId;

    const edgeFields = field.options?.edgeFields || [];
    const currentValue = sourceRecord.values[fieldId];
    const edgeData = this._getEdgeData(currentValue, targetRecordId) || {};

    this.currentDetailRecordId = null;
    this.currentEdgeLens = {
      sourceRecordId,
      fieldId,
      targetRecordId,
      edgeData
    };

    // Render edge lens panel
    let html = `
      <div class="edge-lens-panel">
        <h2 style="font-size: 18px; margin-bottom: 16px;">
          <i class="ph ph-arrows-horizontal" style="color: var(--primary-500);"></i>
          Edge Lens
        </h2>

        <div class="edge-lens-header">
          <div class="edge-lens-connection">
            <div class="edge-lens-node source" data-record-id="${sourceRecordId}" title="Click to view source record">
              <i class="ph ph-circle-fill" style="color: var(--primary-400);"></i>
              <span>${this._escapeHtml(sourceName)}</span>
            </div>
            <div class="edge-lens-arrow">
              <i class="ph ph-arrow-right"></i>
              <span class="edge-lens-field-name">${this._escapeHtml(field.name)}</span>
            </div>
            <div class="edge-lens-node target" data-record-id="${targetRecordId}" title="Click to view target record">
              <i class="ph ph-circle-fill" style="color: var(--success-500);"></i>
              <span>${this._escapeHtml(targetName)}</span>
            </div>
          </div>
        </div>

        <div class="edge-lens-divider"></div>

        <div class="edge-lens-fields">
          <div class="edge-lens-section-title">
            <i class="ph ph-database"></i>
            Edge Data
          </div>
    `;

    if (edgeFields.length === 0) {
      html += `
          <div class="edge-lens-empty">
            <i class="ph ph-info" style="color: var(--text-muted);"></i>
            <span>No edge fields defined. Configure edge fields in the field settings.</span>
          </div>
      `;
    } else {
      edgeFields.forEach(edgeField => {
        const value = edgeData[edgeField.id];
        const displayValue = this._renderEdgeLensFieldValue(edgeField, value);
        html += `
          <div class="edge-lens-field-group" data-edge-field-id="${edgeField.id}">
            <div class="edge-lens-field-label">
              <i class="ph ${this._getFieldTypeIcon(edgeField.type)}"></i>
              ${this._escapeHtml(edgeField.name)}
            </div>
            <div class="edge-lens-field-value editable"
                 data-edge-field-id="${edgeField.id}"
                 data-edge-field-type="${edgeField.type}">
              ${displayValue}
            </div>
          </div>
        `;
      });
    }

    html += `
        </div>
      </div>
    `;

    body.innerHTML = html;

    // Add click handlers for source/target nodes
    body.querySelectorAll('.edge-lens-node').forEach(el => {
      el.addEventListener('click', () => {
        const recordId = el.dataset.recordId;
        if (recordId) {
          this._showRecordDetail(recordId);
        }
      });
    });

    // Add click handlers for editable edge fields
    body.querySelectorAll('.edge-lens-field-value.editable').forEach(el => {
      el.addEventListener('click', (e) => {
        e.stopPropagation();
        this._startEdgeLensFieldEdit(el);
      });
    });

    this._openDetailPanel();
  }

  /**
   * Render a value for display in the edge lens
   */
  _renderEdgeLensFieldValue(edgeField, value) {
    if (value === null || value === undefined || value === '') {
      return '<span class="cell-empty">-</span>';
    }

    switch (edgeField.type) {
      case FieldTypes.CHECKBOX:
        return value ? '<i class="ph ph-check-square"></i>' : '<i class="ph ph-square"></i>';
      case FieldTypes.NUMBER:
        return `<span class="cell-number">${this._escapeHtml(String(value))}</span>`;
      case FieldTypes.DATE:
        return this._formatDate(value, edgeField);
      case FieldTypes.SELECT:
        const choice = edgeField.options?.choices?.find(c => c.id === value);
        if (choice) {
          return `<span class="select-tag color-${choice.color || 'gray'}">${this._escapeHtml(choice.name)}</span>`;
        }
        return this._escapeHtml(String(value));
      case FieldTypes.URL:
        return `<a href="${this._escapeHtml(value)}" target="_blank">${this._escapeHtml(value)}</a>`;
      default:
        return this._escapeHtml(String(value));
    }
  }

  /**
   * Get the icon class for a field type
   */
  _getFieldTypeIcon(type) {
    const icons = {
      [FieldTypes.TEXT]: 'ph-text-t',
      [FieldTypes.LONG_TEXT]: 'ph-article',
      [FieldTypes.NUMBER]: 'ph-hash',
      [FieldTypes.SELECT]: 'ph-list',
      [FieldTypes.MULTI_SELECT]: 'ph-list-checks',
      [FieldTypes.DATE]: 'ph-calendar',
      [FieldTypes.CHECKBOX]: 'ph-check-square',
      [FieldTypes.URL]: 'ph-link',
      [FieldTypes.EMAIL]: 'ph-at',
      [FieldTypes.PHONE]: 'ph-phone',
      [FieldTypes.ATTACHMENT]: 'ph-paperclip'
    };
    return icons[type] || 'ph-text-t';
  }

  /**
   * Start editing an edge lens field
   */
  _startEdgeLensFieldEdit(el) {
    if (!this.currentEdgeLens) return;

    const edgeFieldId = el.dataset.edgeFieldId;
    const edgeFieldType = el.dataset.edgeFieldType;
    const { sourceRecordId, fieldId, targetRecordId, edgeData } = this.currentEdgeLens;

    const set = this.getCurrentSet();
    const field = set?.fields.find(f => f.id === fieldId);
    const edgeField = field?.options?.edgeFields?.find(f => f.id === edgeFieldId);
    if (!edgeField) return;

    const currentValue = edgeData[edgeFieldId] || '';

    el.classList.add('editing');

    // Create appropriate editor based on type
    switch (edgeFieldType) {
      case FieldTypes.CHECKBOX:
        // Toggle immediately
        const newCheckValue = !currentValue;
        this._saveEdgeLensFieldValue(edgeFieldId, newCheckValue);
        el.classList.remove('editing');
        el.innerHTML = this._renderEdgeLensFieldValue(edgeField, newCheckValue);
        return;

      case FieldTypes.SELECT:
        this._renderEdgeLensSelectEditor(el, edgeField, currentValue, edgeFieldId);
        return;

      case FieldTypes.DATE:
        const dateInput = document.createElement('input');
        dateInput.type = edgeField.options?.includeTime ? 'datetime-local' : 'date';
        dateInput.className = 'edge-lens-input';
        dateInput.value = currentValue || '';
        el.innerHTML = '';
        el.appendChild(dateInput);
        dateInput.focus();
        dateInput.addEventListener('blur', () => {
          this._saveEdgeLensFieldValue(edgeFieldId, dateInput.value);
          el.classList.remove('editing');
          el.innerHTML = this._renderEdgeLensFieldValue(edgeField, dateInput.value);
        });
        dateInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') dateInput.blur();
          if (e.key === 'Escape') {
            el.classList.remove('editing');
            el.innerHTML = this._renderEdgeLensFieldValue(edgeField, currentValue);
          }
        });
        return;

      case FieldTypes.NUMBER:
        const numInput = document.createElement('input');
        numInput.type = 'number';
        numInput.className = 'edge-lens-input';
        numInput.value = currentValue || '';
        el.innerHTML = '';
        el.appendChild(numInput);
        numInput.focus();
        numInput.addEventListener('blur', () => {
          const numVal = numInput.value ? parseFloat(numInput.value) : null;
          this._saveEdgeLensFieldValue(edgeFieldId, numVal);
          el.classList.remove('editing');
          el.innerHTML = this._renderEdgeLensFieldValue(edgeField, numVal);
        });
        numInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') numInput.blur();
          if (e.key === 'Escape') {
            el.classList.remove('editing');
            el.innerHTML = this._renderEdgeLensFieldValue(edgeField, currentValue);
          }
        });
        return;

      default:
        // Text input
        const textInput = document.createElement('input');
        textInput.type = 'text';
        textInput.className = 'edge-lens-input';
        textInput.value = currentValue || '';
        el.innerHTML = '';
        el.appendChild(textInput);
        textInput.focus();
        textInput.addEventListener('blur', () => {
          this._saveEdgeLensFieldValue(edgeFieldId, textInput.value);
          el.classList.remove('editing');
          el.innerHTML = this._renderEdgeLensFieldValue(edgeField, textInput.value);
        });
        textInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') textInput.blur();
          if (e.key === 'Escape') {
            el.classList.remove('editing');
            el.innerHTML = this._renderEdgeLensFieldValue(edgeField, currentValue);
          }
        });
        return;
    }
  }

  /**
   * Render a select editor for edge lens field
   */
  _renderEdgeLensSelectEditor(el, edgeField, currentValue, edgeFieldId) {
    const choices = edgeField.options?.choices || [];

    let html = '<div class="edge-lens-select-dropdown">';
    html += '<div class="edge-lens-select-option" data-value="">Clear selection</div>';
    choices.forEach(choice => {
      const selected = choice.id === currentValue ? 'selected' : '';
      html += `
        <div class="edge-lens-select-option ${selected}" data-value="${choice.id}">
          <span class="select-tag color-${choice.color || 'gray'}">${this._escapeHtml(choice.name)}</span>
        </div>
      `;
    });
    html += '</div>';

    el.innerHTML = html;

    const dropdown = el.querySelector('.edge-lens-select-dropdown');
    dropdown.querySelectorAll('.edge-lens-select-option').forEach(opt => {
      opt.addEventListener('click', (e) => {
        e.stopPropagation();
        const value = opt.dataset.value || null;
        this._saveEdgeLensFieldValue(edgeFieldId, value);
        el.classList.remove('editing');
        el.innerHTML = this._renderEdgeLensFieldValue(edgeField, value);
      });
    });

    // Close on click outside
    setTimeout(() => {
      const closeHandler = (e) => {
        if (!e.target.closest('.edge-lens-select-dropdown')) {
          el.classList.remove('editing');
          el.innerHTML = this._renderEdgeLensFieldValue(edgeField, currentValue);
          document.removeEventListener('click', closeHandler);
        }
      };
      document.addEventListener('click', closeHandler);
    }, 100);
  }

  /**
   * Save an edge lens field value
   */
  _saveEdgeLensFieldValue(edgeFieldId, value) {
    if (!this.currentEdgeLens) return;

    const { sourceRecordId, fieldId, targetRecordId } = this.currentEdgeLens;
    const set = this.getCurrentSet();
    const record = set?.records.find(r => r.id === sourceRecordId);
    if (!record) return;

    const currentValue = record.values[fieldId];
    const newEdgeData = { [edgeFieldId]: value };
    const updatedValue = this._updateEdgeData(currentValue, targetRecordId, newEdgeData);

    // Update current edge lens state
    this.currentEdgeLens.edgeData = {
      ...this.currentEdgeLens.edgeData,
      [edgeFieldId]: value
    };

    // Save to record
    this._updateRecordValue(sourceRecordId, fieldId, updatedValue);
    this._renderView();
  }

  /**
   * Start editing a provenance field
   */
  _startProvenanceEdit(el, recordId, set) {
    const provKey = el.dataset.provKey;
    const record = set.records.find(r => r.id === recordId);
    if (!record) return;

    // Get current value - normalize to array for editing
    const rawValue = record.provenance?.[provKey];
    let entries = [];
    if (Array.isArray(rawValue)) {
      entries = [...rawValue];
    } else if (rawValue !== null && rawValue !== undefined && rawValue !== '') {
      entries = [rawValue];
    }

    el.classList.add('editing');

    const renderEditor = () => {
      el.innerHTML = `
        <div class="prov-editor" style="display: flex; flex-direction: column; gap: 6px;">
          ${entries.length > 0 ? `
            <div class="prov-entries" style="display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 4px;">
              ${entries.map((entry, idx) => {
                const isRef = entry && typeof entry === 'object' && '$ref' in entry;
                const displayText = isRef
                  ? (this._findRecordById(entry.$ref)
                      ? this._getRecordPrimaryValue(this._findRecordById(entry.$ref))
                      : entry.$ref.substring(0, 8))
                  : this._escapeHtml(String(entry));
                return `
                  <span class="prov-entry-pill" data-index="${idx}"
                        style="display: inline-flex; align-items: center; gap: 4px; padding: 2px 6px; background: var(--bg-tertiary); border-radius: 4px; font-size: 11px;">
                    ${isRef ? '<i class="ph ph-arrow-right" style="font-size: 10px;"></i>' : ''}
                    <span>${displayText}</span>
                    <button class="prov-remove-entry" data-index="${idx}"
                            style="border: none; background: none; padding: 0; cursor: pointer; color: var(--text-muted); font-size: 12px; line-height: 1;">
                      <i class="ph ph-x"></i>
                    </button>
                  </span>
                `;
              }).join('')}
            </div>
          ` : ''}
          <div class="prov-editor-tabs" style="display: flex; gap: 4px; margin-bottom: 4px;">
            <button class="prov-tab active" data-mode="text"
                    style="padding: 2px 8px; font-size: 10px; border-radius: 3px; border: 1px solid var(--border-primary); background: var(--primary-500); color: white; cursor: pointer;">
              Text
            </button>
            <button class="prov-tab" data-mode="ref"
                    style="padding: 2px 8px; font-size: 10px; border-radius: 3px; border: 1px solid var(--border-primary); background: transparent; color: var(--text-muted); cursor: pointer;">
              Link Record
            </button>
          </div>
          <div style="display: flex; gap: 4px;">
            <input type="text" class="prov-input"
                   placeholder="Enter value..."
                   style="flex: 1; padding: 4px 8px; font-size: 12px; border: 1px solid var(--border-primary); border-radius: 4px;">
            <button class="prov-add" title="Add entry"
                    style="padding: 4px 8px; font-size: 11px; border-radius: 3px; border: 1px solid var(--border-primary); background: transparent; cursor: pointer;">
              <i class="ph ph-plus"></i>
            </button>
          </div>
          <div class="prov-editor-actions" style="display: flex; gap: 4px; justify-content: flex-end;">
            <button class="prov-cancel" style="padding: 2px 8px; font-size: 11px; border-radius: 3px; border: 1px solid var(--border-primary); background: transparent; cursor: pointer;">
              Cancel
            </button>
            <button class="prov-save" style="padding: 2px 8px; font-size: 11px; border-radius: 3px; border: none; background: var(--primary-500); color: white; cursor: pointer;">
              Save
            </button>
          </div>
        </div>
      `;

      attachHandlers();
    };

    let currentMode = 'text';

    const attachHandlers = () => {
      const input = el.querySelector('.prov-input');

      // Remove entry buttons
      el.querySelectorAll('.prov-remove-entry').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const idx = parseInt(btn.dataset.index);
          entries.splice(idx, 1);
          renderEditor();
        });
      });

      // Tab switching
      el.querySelectorAll('.prov-tab').forEach(tab => {
        tab.addEventListener('click', (e) => {
          e.stopPropagation();
          currentMode = tab.dataset.mode;
          el.querySelectorAll('.prov-tab').forEach(t => {
            const isActive = t.dataset.mode === currentMode;
            t.style.background = isActive ? 'var(--primary-500)' : 'transparent';
            t.style.color = isActive ? 'white' : 'var(--text-muted)';
            t.classList.toggle('active', isActive);
          });
          input.placeholder = currentMode === 'ref' ? 'Search records...' : 'Enter value...';
          input.focus();
        });
      });

      // Add entry handler
      const addEntry = () => {
        const inputValue = input.value.trim();
        if (!inputValue) return;

        if (currentMode === 'ref') {
          const matchedRecord = this._findRecordBySearch(inputValue);
          if (matchedRecord) {
            entries.push({ $ref: matchedRecord.id });
            input.value = '';
            renderEditor();
          } else {
            this._showToast('No matching record found', 'error');
          }
        } else {
          entries.push(inputValue);
          input.value = '';
          renderEditor();
        }
      };

      el.querySelector('.prov-add')?.addEventListener('click', (e) => {
        e.stopPropagation();
        addEntry();
      });

      // Save handler
      const saveValue = () => {
        // Also add any pending input
        const inputValue = input.value.trim();
        if (inputValue) {
          if (currentMode === 'ref') {
            const matchedRecord = this._findRecordBySearch(inputValue);
            if (matchedRecord) {
              entries.push({ $ref: matchedRecord.id });
            } else if (entries.length === 0) {
              this._showToast('No matching record found', 'error');
              return;
            }
          } else {
            entries.push(inputValue);
          }
        }

        // Normalize: single value stays single, multiple becomes array
        let finalValue = null;
        if (entries.length === 1) {
          finalValue = entries[0];
        } else if (entries.length > 1) {
          finalValue = entries;
        }

        // Update record provenance
        if (!record.provenance) {
          record.provenance = {};
        }
        record.provenance[provKey] = finalValue;

        record.updatedAt = new Date().toISOString();
        this._saveData();
        this._showRecordDetail(recordId);
        this._renderView();
      };

      // Cancel handler
      const cancelEdit = () => {
        this._showRecordDetail(recordId);
      };

      el.querySelector('.prov-save')?.addEventListener('click', (e) => {
        e.stopPropagation();
        saveValue();
      });

      el.querySelector('.prov-cancel')?.addEventListener('click', (e) => {
        e.stopPropagation();
        cancelEdit();
      });

      input?.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          if (e.shiftKey || entries.length > 0) {
            addEntry();
          } else {
            saveValue();
          }
        }
        if (e.key === 'Escape') {
          cancelEdit();
        }
      });

      input?.focus();
    };

    renderEditor();
  }

  /**
   * Search for a record by text
   */
  _findRecordBySearch(query) {
    const lowerQuery = query.toLowerCase();

    for (const set of this.sets) {
      for (const record of set.records) {
        // Check primary field
        const primaryField = set.fields.find(f => f.isPrimary) || set.fields[0];
        const primaryValue = record.values[primaryField?.id];
        if (primaryValue && String(primaryValue).toLowerCase().includes(lowerQuery)) {
          return record;
        }

        // Check all text values
        for (const [fieldId, value] of Object.entries(record.values)) {
          if (typeof value === 'string' && value.toLowerCase().includes(lowerQuery)) {
            return record;
          }
        }
      }
    }

    return null;
  }

  _renderDetailFieldValue(field, value) {
    // Computed field types don't have stored values - they evaluate dynamically
    const computedFieldTypes = [FieldTypes.FORMULA, FieldTypes.ROLLUP, FieldTypes.COUNT, FieldTypes.AUTONUMBER];

    if (!computedFieldTypes.includes(field.type) && (value === null || value === undefined || value === '')) {
      return '<span class="cell-empty">Empty - click to add</span>';
    }

    switch (field.type) {
      case FieldTypes.CHECKBOX:
        return `<i class="ph ${value ? 'ph-check-square' : 'ph-square'}" style="font-size: 18px; color: ${value ? 'var(--success-500)' : 'var(--text-muted)'}"></i>`;
      case FieldTypes.SELECT:
        const choice = field.options?.choices?.find(c => c.id === value);
        return choice ? `<span class="select-tag color-${choice.color || 'gray'}">${this._escapeHtml(choice.name)}</span>` : this._escapeHtml(String(value));
      case FieldTypes.MULTI_SELECT:
        if (Array.isArray(value)) {
          return value.map(v => {
            const c = field.options?.choices?.find(ch => ch.id === v);
            return c ? `<span class="select-tag color-${c.color || 'gray'}">${this._escapeHtml(c.name)}</span>` : '';
          }).join(' ');
        }
        return '<span class="cell-empty">-</span>';
      case FieldTypes.DATE:
        return this._formatDate(value, field);
      case FieldTypes.URL:
        return `<a href="${this._escapeHtml(value)}" target="_blank" style="color: var(--primary-500);">${this._escapeHtml(value)}</a>`;
      case FieldTypes.EMAIL:
        return `<a href="mailto:${this._escapeHtml(value)}" style="color: var(--primary-500);">${this._escapeHtml(value)}</a>`;
      case FieldTypes.LINK:
        const detailLinks = this._normalizeLinkValue(value);
        if (detailLinks.length > 0) {
          const linkedSetId = field.options?.linkedSetId;
          const linkedSet = linkedSetId ? this.sets?.find(s => s.id === linkedSetId) : this.getCurrentSet?.();
          // Use linkedFieldId if set, otherwise fall back to primary field
          const displayField = field.options?.linkedFieldId
            ? linkedSet?.fields?.find(f => f.id === field.options.linkedFieldId)
            : (linkedSet?.fields?.find(f => f.isPrimary) || linkedSet?.fields?.[0]);
          const hasEdgeFields = field.options?.enableEdgeData && field.options?.edgeFields?.length > 0;
          return detailLinks.map(link => {
            const linkedRecord = linkedSet?.records?.find(r => r.id === link.recordId);
            const name = linkedRecord?.values?.[displayField?.id] || 'Unknown';
            const hasEdgeData = hasEdgeFields && link.edgeData && Object.keys(link.edgeData).length > 0;
            const edgeIndicator = hasEdgeData ? '<i class="ph ph-arrows-horizontal edge-indicator" title="Has edge data"></i>' : '';
            return `<span class="link-chip${hasEdgeData ? ' has-edge-data' : ''}" data-linked-id="${link.recordId}">${this._escapeHtml(name)}${edgeIndicator}</span>`;
          }).join(' ');
        }
        return '<span class="cell-empty">No links - click to add</span>';
      case FieldTypes.ATTACHMENT:
        if (Array.isArray(value) && value.length > 0) {
          return value.map(att => {
            const name = typeof att === 'object' ? (att.name || att.filename || 'File') : String(att);
            return `<span class="attachment-chip"><i class="ph ph-file"></i> ${this._escapeHtml(name)}</span>`;
          }).join(' ');
        }
        return '<span class="cell-empty">No files - click to add</span>';
      case FieldTypes.FORMULA:
        // Evaluate the formula using the current detail record
        const set = this.getCurrentSet();
        const record = set?.records.find(r => r.id === this.currentDetailRecordId);
        if (record) {
          const formulaResult = this._evaluateFormula(field.options?.formula, record);
          return `<span class="cell-formula">${formulaResult}</span>`;
        }
        return '<span class="cell-empty">-</span>';
      default:
        if (typeof value === 'object') {
          return `<code style="font-size: 11px;">${this._escapeHtml(JSON.stringify(value, null, 2).substring(0, 100))}...</code>`;
        }
        return this._escapeHtml(String(value));
    }
  }

  _startDetailFieldEdit(el) {
    const fieldId = el.dataset.fieldId;
    const recordId = el.dataset.recordId;

    const set = this.getCurrentSet();
    const record = set?.records.find(r => r.id === recordId);
    const field = set?.fields.find(f => f.id === fieldId);

    if (!record || !field) return;

    const currentValue = record.values[fieldId];

    el.classList.add('editing');

    // Create appropriate editor based on field type
    switch (field.type) {
      case FieldTypes.CHECKBOX:
        // Toggle immediately
        this._updateRecordValue(recordId, fieldId, !currentValue);
        el.classList.remove('editing');
        el.innerHTML = this._renderDetailFieldValue(field, !currentValue);
        this._renderView();
        break;

      case FieldTypes.SELECT:
        this._showSelectDetailEditor(el, field, recordId, currentValue);
        break;

      case FieldTypes.DATE:
        this._showDatePickerEditor(el, field, recordId, currentValue);
        break;

      case FieldTypes.LONG_TEXT:
        el.innerHTML = `
          <div class="detail-editor-wrapper">
            <textarea class="detail-editor" rows="4">${this._escapeHtml(currentValue || '')}</textarea>
            <div class="detail-editor-actions">
              <button class="detail-editor-cancel" title="Cancel (Escape)">
                <i class="ph ph-x"></i>
              </button>
              <button class="detail-editor-save" title="Save (Enter)">
                <i class="ph ph-check"></i>
              </button>
            </div>
          </div>
        `;
        const textareaEditor = el.querySelector('textarea');
        textareaEditor.focus();

        const saveTextarea = () => {
          this._updateRecordValue(recordId, fieldId, textareaEditor.value);
          el.classList.remove('editing');
          el.innerHTML = this._renderDetailFieldValue(field, textareaEditor.value);
          this._renderView();
        };

        const cancelTextarea = () => {
          el.classList.remove('editing');
          el.innerHTML = this._renderDetailFieldValue(field, currentValue);
        };

        el.querySelector('.detail-editor-save')?.addEventListener('click', (e) => {
          e.stopPropagation();
          saveTextarea();
        });
        el.querySelector('.detail-editor-cancel')?.addEventListener('click', (e) => {
          e.stopPropagation();
          cancelTextarea();
        });
        textareaEditor.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') cancelTextarea();
        });
        break;

      case FieldTypes.MULTI_SELECT:
        this._showMultiSelectDetailEditor(el, field, recordId, currentValue);
        break;

      case FieldTypes.LINK:
        this._showLinkDetailEditor(el, field, recordId, currentValue);
        break;

      case FieldTypes.URL:
        this._showUrlDetailEditor(el, field, recordId, currentValue);
        break;

      case FieldTypes.EMAIL:
        this._showEmailDetailEditor(el, field, recordId, currentValue);
        break;

      case FieldTypes.ATTACHMENT:
        this._showAttachmentDetailEditor(el, field, recordId, currentValue);
        break;

      default:
        el.innerHTML = `
          <div class="detail-editor-wrapper">
            <input type="text" class="detail-editor" value="${this._escapeHtml(currentValue || '')}">
            <div class="detail-editor-actions">
              <button class="detail-editor-cancel" title="Cancel (Escape)">
                <i class="ph ph-x"></i>
              </button>
              <button class="detail-editor-save" title="Save (Enter)">
                <i class="ph ph-check"></i>
              </button>
            </div>
          </div>
        `;
        const inputEditor = el.querySelector('input');
        inputEditor.focus();
        inputEditor.select();

        const saveInput = () => {
          this._updateRecordValue(recordId, fieldId, inputEditor.value);
          el.classList.remove('editing');
          el.innerHTML = this._renderDetailFieldValue(field, inputEditor.value);
          this._renderView();
        };

        const cancelInput = () => {
          el.classList.remove('editing');
          el.innerHTML = this._renderDetailFieldValue(field, currentValue);
        };

        el.querySelector('.detail-editor-save')?.addEventListener('click', (e) => {
          e.stopPropagation();
          saveInput();
        });
        el.querySelector('.detail-editor-cancel')?.addEventListener('click', (e) => {
          e.stopPropagation();
          cancelInput();
        });
        inputEditor.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            saveInput();
          }
          if (e.key === 'Escape') {
            cancelInput();
          }
        });
    }
  }

  // --------------------------------------------------------------------------
  // Date Picker
  // --------------------------------------------------------------------------

  _showDatePickerEditor(el, field, recordId, currentValue) {
    const includeTime = field.options?.includeTime;
    const currentDate = currentValue ? new Date(currentValue) : new Date();
    const year = currentDate.getFullYear();
    const month = currentDate.getMonth();

    el.innerHTML = this._renderDatePicker(currentDate, includeTime);
    el.classList.add('date-picker-open');

    const picker = el.querySelector('.date-picker');
    if (!picker) return;

    // Attach navigation
    picker.querySelector('.dp-prev')?.addEventListener('click', (e) => {
      e.stopPropagation();
      this._navigateDatePicker(el, field, recordId, -1);
    });

    picker.querySelector('.dp-next')?.addEventListener('click', (e) => {
      e.stopPropagation();
      this._navigateDatePicker(el, field, recordId, 1);
    });

    // Helper to format date in local timezone (avoids UTC conversion issues)
    const formatLocalDate = (date) => {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    };

    const formatLocalDateTime = (date) => {
      const dateStr = formatLocalDate(date);
      const hours = String(date.getHours()).padStart(2, '0');
      const minutes = String(date.getMinutes()).padStart(2, '0');
      return `${dateStr}T${hours}:${minutes}`;
    };

    // Attach day click handlers
    picker.querySelectorAll('.dp-day:not(.other-month):not(.empty)').forEach(day => {
      day.addEventListener('click', (e) => {
        e.stopPropagation();
        const selectedDay = parseInt(day.textContent);
        const displayedYear = parseInt(picker.dataset.year);
        const displayedMonth = parseInt(picker.dataset.month);
        const displayedDate = new Date(displayedYear, displayedMonth, selectedDay);

        let value = formatLocalDate(displayedDate);

        if (includeTime) {
          const timeInput = picker.querySelector('.dp-time-input');
          if (timeInput?.value) {
            value += 'T' + timeInput.value;
          }
        }

        this._updateRecordValue(recordId, field.id, value);
        this._saveData();
        el.classList.remove('editing', 'date-picker-open');
        el.innerHTML = this._renderDetailFieldValue(field, value);
        this._renderView();
        this._showToast('Date updated', 'success');
      });
    });

    // Today button
    picker.querySelector('.dp-today')?.addEventListener('click', (e) => {
      e.stopPropagation();
      const today = new Date();
      let value = formatLocalDate(today);
      if (includeTime) {
        value = formatLocalDateTime(today);
      }
      this._updateRecordValue(recordId, field.id, value);
      el.classList.remove('editing', 'date-picker-open');
      el.innerHTML = this._renderDetailFieldValue(field, value);
      this._renderView();
    });

    // Clear button
    picker.querySelector('.dp-clear')?.addEventListener('click', (e) => {
      e.stopPropagation();
      this._updateRecordValue(recordId, field.id, null);
      el.classList.remove('editing', 'date-picker-open');
      el.innerHTML = this._renderDetailFieldValue(field, null);
      this._renderView();
    });

    // Store context for navigation
    picker.dataset.recordId = recordId;
    picker.dataset.fieldId = field.id;
    picker.dataset.year = year;
    picker.dataset.month = month;
  }

  _navigateDatePicker(el, field, recordId, delta) {
    const picker = el.querySelector('.date-picker');
    if (!picker) return;

    let year = parseInt(picker.dataset.year);
    let month = parseInt(picker.dataset.month) + delta;

    if (month < 0) {
      month = 11;
      year--;
    } else if (month > 11) {
      month = 0;
      year++;
    }

    // Create a date for the new month (don't set a specific day to avoid selection issues)
    const navigatedDate = new Date(year, month, 1);
    el.innerHTML = this._renderDatePicker(navigatedDate, field.options?.includeTime);
    el.classList.add('date-picker-open');

    const newPicker = el.querySelector('.date-picker');
    if (!newPicker) return;

    // Reattach navigation handlers
    newPicker.querySelector('.dp-prev')?.addEventListener('click', (e) => {
      e.stopPropagation();
      this._navigateDatePicker(el, field, recordId, -1);
    });
    newPicker.querySelector('.dp-next')?.addEventListener('click', (e) => {
      e.stopPropagation();
      this._navigateDatePicker(el, field, recordId, 1);
    });

    // Helper functions for date formatting
    const formatLocalDate = (date) => {
      const y = date.getFullYear();
      const m = String(date.getMonth() + 1).padStart(2, '0');
      const d = String(date.getDate()).padStart(2, '0');
      return `${y}-${m}-${d}`;
    };
    const formatLocalDateTime = (date) => {
      const dateStr = formatLocalDate(date);
      const hours = String(date.getHours()).padStart(2, '0');
      const minutes = String(date.getMinutes()).padStart(2, '0');
      return `${dateStr}T${hours}:${minutes}`;
    };

    // Reattach day click handlers
    newPicker.querySelectorAll('.dp-day:not(.other-month):not(.empty)').forEach(day => {
      day.addEventListener('click', (e) => {
        e.stopPropagation();
        const selectedDay = parseInt(day.textContent);
        const displayedYear = parseInt(newPicker.dataset.year);
        const displayedMonth = parseInt(newPicker.dataset.month);
        const displayedDate = new Date(displayedYear, displayedMonth, selectedDay);

        let value = formatLocalDate(displayedDate);
        if (field.options?.includeTime) {
          const timeInput = newPicker.querySelector('.dp-time-input');
          if (timeInput?.value) {
            value += 'T' + timeInput.value;
          }
        }

        this._updateRecordValue(recordId, field.id, value);
        this._saveData();
        el.classList.remove('editing', 'date-picker-open');
        el.innerHTML = this._renderDetailFieldValue(field, value);
        this._renderView();
        this._showToast('Date updated', 'success');
      });
    });

    // Reattach Today button handler
    newPicker.querySelector('.dp-today')?.addEventListener('click', (e) => {
      e.stopPropagation();
      const today = new Date();
      let value = formatLocalDate(today);
      if (field.options?.includeTime) {
        value = formatLocalDateTime(today);
      }
      this._updateRecordValue(recordId, field.id, value);
      el.classList.remove('editing', 'date-picker-open');
      el.innerHTML = this._renderDetailFieldValue(field, value);
      this._renderView();
    });

    // Reattach Clear button handler
    newPicker.querySelector('.dp-clear')?.addEventListener('click', (e) => {
      e.stopPropagation();
      this._updateRecordValue(recordId, field.id, null);
      el.classList.remove('editing', 'date-picker-open');
      el.innerHTML = this._renderDetailFieldValue(field, null);
      this._renderView();
    });
  }

  _renderDatePicker(currentDate, includeTime) {
    const year = currentDate.getFullYear();
    const month = currentDate.getMonth();
    const today = new Date();

    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const startDay = firstDay.getDay();
    const daysInMonth = lastDay.getDate();

    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
      'July', 'August', 'September', 'October', 'November', 'December'];
    const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

    let daysHtml = '';
    // Empty cells
    for (let i = 0; i < startDay; i++) {
      daysHtml += '<div class="dp-day empty"></div>';
    }
    // Days
    for (let d = 1; d <= daysInMonth; d++) {
      const isToday = d === today.getDate() && month === today.getMonth() && year === today.getFullYear();
      const isSelected = d === currentDate.getDate() && month === currentDate.getMonth() && year === currentDate.getFullYear();
      daysHtml += `<div class="dp-day${isToday ? ' today' : ''}${isSelected ? ' selected' : ''}">${d}</div>`;
    }

    return `
      <div class="date-picker" data-year="${year}" data-month="${month}">
        <div class="dp-header">
          <button class="dp-nav dp-prev" type="button"><i class="ph ph-caret-left"></i></button>
          <span class="dp-title">${monthNames[month]} ${year}</span>
          <button class="dp-nav dp-next" type="button"><i class="ph ph-caret-right"></i></button>
        </div>
        <div class="dp-weekdays">
          ${dayNames.map(d => `<div class="dp-weekday">${d}</div>`).join('')}
        </div>
        <div class="dp-days">
          ${daysHtml}
        </div>
        ${includeTime ? `
          <div class="dp-time">
            <label>Time:</label>
            <input type="time" class="dp-time-input" value="${currentDate.toTimeString().slice(0, 5)}">
          </div>
        ` : ''}
        <div class="dp-footer">
          <button class="dp-btn dp-today" type="button">Today</button>
          <button class="dp-btn dp-clear" type="button">Clear</button>
        </div>
      </div>
    `;
  }

  // --------------------------------------------------------------------------
  // Multi-Select Detail Editor
  // --------------------------------------------------------------------------

  _showSelectDetailEditor(el, field, recordId, currentValue) {
    const choices = field.options?.choices || [];
    const currentChoice = choices.find(c => c.id === currentValue);

    let html = '<div class="detail-select-editor">';
    html += '<div class="detail-select-search">';
    html += '<input type="text" placeholder="Find an option..." class="detail-select-search-input">';
    html += '</div>';
    html += '<div class="detail-select-options">';

    // Clear selection option
    if (currentValue) {
      html += `
        <div class="detail-select-option detail-select-clear" data-value="">
          <span class="detail-select-check"><i class="ph ph-x"></i></span>
          <span class="detail-select-label">Clear selection</span>
        </div>
      `;
    }

    choices.forEach(choice => {
      const isSelected = choice.id === currentValue;
      html += `
        <div class="detail-select-option ${isSelected ? 'selected' : ''}" data-value="${choice.id}">
          <span class="detail-select-check">${isSelected ? '<i class="ph ph-check"></i>' : ''}</span>
          <span class="select-tag color-${choice.color || 'gray'}">${this._escapeHtml(choice.name)}</span>
        </div>
      `;
    });

    if (choices.length === 0) {
      html += '<div class="detail-select-empty">No options configured. Edit field to add choices.</div>';
    }

    html += '</div>';
    html += '</div>';

    el.innerHTML = html;

    const editor = el.querySelector('.detail-select-editor');
    const searchInput = el.querySelector('.detail-select-search-input');

    // Search filtering
    searchInput?.addEventListener('input', (e) => {
      const searchTerm = e.target.value.toLowerCase();
      editor.querySelectorAll('.detail-select-option:not(.detail-select-clear)').forEach(opt => {
        const name = opt.querySelector('.select-tag')?.textContent.toLowerCase() || '';
        opt.style.display = name.includes(searchTerm) ? '' : 'none';
      });
    });
    searchInput?.focus();

    // Selection handler
    editor.querySelectorAll('.detail-select-option').forEach(option => {
      option.addEventListener('click', (e) => {
        e.stopPropagation();
        const newValue = option.dataset.value || null;
        this._updateRecordValue(recordId, field.id, newValue);
        el.classList.remove('editing');
        el.innerHTML = this._renderDetailFieldValue(field, newValue);
        // Re-render the view first
        this._renderView();
        // Then refresh the detail panel to show updated data consistently
        if (this.elements.detailPanel?.classList.contains('open')) {
          this._showRecordDetail(recordId);
        }
      });
    });

    // Close on click outside - use longer delay to avoid race conditions with opening click
    setTimeout(() => {
      const closeHandler = (e) => {
        // Check if click is outside the editor element
        if (!el.contains(e.target)) {
          el.classList.remove('editing');
          el.innerHTML = this._renderDetailFieldValue(field, currentValue);
          document.removeEventListener('click', closeHandler);
        }
      };
      document.addEventListener('click', closeHandler);
    }, 100);
  }

  _showMultiSelectDetailEditor(el, field, recordId, currentValue) {
    const choices = field.options?.choices || [];
    const currentSelections = Array.isArray(currentValue) ? currentValue : (currentValue ? [currentValue] : []);

    let html = '<div class="detail-multiselect-editor">';
    html += '<div class="detail-multiselect-search">';
    html += '<input type="text" placeholder="Search options..." class="detail-multiselect-search-input">';
    html += '</div>';
    html += '<div class="detail-multiselect-options">';

    choices.forEach(choice => {
      const isSelected = currentSelections.includes(choice.id);
      html += `
        <div class="detail-multiselect-option ${isSelected ? 'selected' : ''}" data-value="${choice.id}">
          <span class="detail-multiselect-check">${isSelected ? '<i class="ph ph-check"></i>' : ''}</span>
          <span class="select-tag color-${choice.color || 'gray'}">${this._escapeHtml(choice.name)}</span>
        </div>
      `;
    });

    if (choices.length === 0) {
      html += '<div class="detail-multiselect-empty">No options configured. Edit field to add choices.</div>';
    }

    html += '</div>';
    html += '<div class="detail-multiselect-footer">';
    html += '<button class="detail-multiselect-done">Done</button>';
    html += '</div>';
    html += '</div>';

    el.innerHTML = html;

    const editor = el.querySelector('.detail-multiselect-editor');
    const searchInput = el.querySelector('.detail-multiselect-search-input');
    let selectedIds = [...currentSelections];

    // Search filtering
    searchInput?.addEventListener('input', (e) => {
      const searchTerm = e.target.value.toLowerCase();
      editor.querySelectorAll('.detail-multiselect-option').forEach(opt => {
        const name = opt.querySelector('.select-tag')?.textContent.toLowerCase() || '';
        opt.style.display = name.includes(searchTerm) ? '' : 'none';
      });
    });
    searchInput?.focus();

    // Toggle selection
    editor.querySelectorAll('.detail-multiselect-option').forEach(option => {
      option.addEventListener('click', (e) => {
        e.stopPropagation();
        const choiceId = option.dataset.value;

        const idx = selectedIds.indexOf(choiceId);
        if (idx > -1) {
          selectedIds.splice(idx, 1);
          option.classList.remove('selected');
          option.querySelector('.detail-multiselect-check').innerHTML = '';
        } else {
          selectedIds.push(choiceId);
          option.classList.add('selected');
          option.querySelector('.detail-multiselect-check').innerHTML = '<i class="ph ph-check"></i>';
        }
      });
    });

    // Done button
    editor.querySelector('.detail-multiselect-done')?.addEventListener('click', (e) => {
      e.stopPropagation();
      const newValue = selectedIds.length > 0 ? selectedIds : null;
      this._updateRecordValue(recordId, field.id, newValue);
      el.classList.remove('editing');
      el.innerHTML = this._renderDetailFieldValue(field, newValue);
      this._renderView();
    });

    // Close on click outside - use longer delay to avoid race conditions
    setTimeout(() => {
      const closeHandler = (e) => {
        if (!el.contains(e.target)) {
          const newValue = selectedIds.length > 0 ? selectedIds : null;
          this._updateRecordValue(recordId, field.id, newValue);
          el.classList.remove('editing');
          el.innerHTML = this._renderDetailFieldValue(field, newValue);
          this._renderView();
          document.removeEventListener('click', closeHandler);
        }
      };
      document.addEventListener('click', closeHandler);
    }, 100);
  }

  // --------------------------------------------------------------------------
  // Link Detail Editor
  // --------------------------------------------------------------------------

  async _showLinkDetailEditor(el, field, recordId, currentValue) {
    const linkedSetId = field.options?.linkedSetId;
    const allowMultiple = field.options?.allowMultiple !== false;
    const linkedSet = linkedSetId ? this.sets.find(s => s.id === linkedSetId) : this.getCurrentSet();

    if (!linkedSet) {
      el.innerHTML = '<div class="detail-link-error">No linked set configured</div>';
      return;
    }

    // CRITICAL: Ensure linked set records are loaded from IndexedDB before rendering
    // Use undefined check specifically - empty array means already loaded (no records in IndexedDB)
    if (linkedSet._recordsInIndexedDB && linkedSet.records === undefined) {
      el.innerHTML = '<div class="detail-link-loading"><i class="ph ph-spinner ph-spin"></i> Loading records...</div>';
      await this._ensureSetRecords(linkedSet);
    }

    // Use linkedFieldId if set, otherwise fall back to primary field
    const displayField = field.options?.linkedFieldId
      ? linkedSet.fields.find(f => f.id === field.options.linkedFieldId)
      : (linkedSet.fields.find(f => f.isPrimary) || linkedSet.fields[0]);

    // Normalize current links to handle both old format (array of IDs) and new format (array of objects)
    const normalizedLinks = this._normalizeLinkValue(currentValue);
    const currentLinkIds = normalizedLinks.map(l => l.recordId);

    let html = '<div class="detail-link-editor">';
    html += '<div class="detail-link-search">';
    html += `<input type="text" placeholder="Search ${this._escapeHtml(linkedSet.name)}..." class="detail-link-search-input">`;
    html += '</div>';
    html += '<div class="detail-link-options">';

    const records = linkedSet.records || [];
    records.forEach(record => {
      const recordName = record.values?.[displayField?.id] || 'Untitled';
      const isLinked = currentLinkIds.includes(record.id);
      html += `
        <div class="detail-link-option ${isLinked ? 'selected' : ''}" data-record-id="${record.id}">
          <span class="detail-link-check">${isLinked ? '<i class="ph ph-check"></i>' : ''}</span>
          <span class="detail-link-name">${this._escapeHtml(recordName)}</span>
        </div>
      `;
    });

    if (records.length === 0) {
      html += '<div class="detail-link-empty">No records in linked set</div>';
    }

    html += '</div>';
    html += '<div class="detail-link-footer">';
    html += '<button class="detail-link-done">Done</button>';
    html += '</div>';
    html += '</div>';

    el.innerHTML = html;

    const editor = el.querySelector('.detail-link-editor');
    const searchInput = el.querySelector('.detail-link-search-input');
    let selectedIds = [...currentLinkIds];

    // Search filtering
    searchInput?.addEventListener('input', (e) => {
      const searchTerm = e.target.value.toLowerCase();
      editor.querySelectorAll('.detail-link-option').forEach(opt => {
        const name = opt.querySelector('.detail-link-name')?.textContent.toLowerCase() || '';
        opt.style.display = name.includes(searchTerm) ? '' : 'none';
      });
    });
    searchInput?.focus();

    // Toggle selection
    editor.querySelectorAll('.detail-link-option').forEach(option => {
      option.addEventListener('click', (e) => {
        e.stopPropagation();
        const linkRecordId = option.dataset.recordId;

        if (allowMultiple) {
          const idx = selectedIds.indexOf(linkRecordId);
          if (idx > -1) {
            selectedIds.splice(idx, 1);
            option.classList.remove('selected');
            option.querySelector('.detail-link-check').innerHTML = '';
          } else {
            selectedIds.push(linkRecordId);
            option.classList.add('selected');
            option.querySelector('.detail-link-check').innerHTML = '<i class="ph ph-check"></i>';
          }
        } else {
          // Single selection
          editor.querySelectorAll('.detail-link-option').forEach(o => {
            o.classList.remove('selected');
            o.querySelector('.detail-link-check').innerHTML = '';
          });
          selectedIds = [linkRecordId];
          option.classList.add('selected');
          option.querySelector('.detail-link-check').innerHTML = '<i class="ph ph-check"></i>';
        }
      });
    });

    // Done button
    editor.querySelector('.detail-link-done')?.addEventListener('click', (e) => {
      e.stopPropagation();
      const newValue = selectedIds.length > 0 ? selectedIds : null;
      this._updateRecordValue(recordId, field.id, newValue);
      el.classList.remove('editing');
      el.innerHTML = this._renderDetailFieldValue(field, newValue);
      this._renderView();
    });

    // Close on click outside - use longer delay to avoid race conditions
    setTimeout(() => {
      const closeHandler = (e) => {
        if (!el.contains(e.target)) {
          const newValue = selectedIds.length > 0 ? selectedIds : null;
          this._updateRecordValue(recordId, field.id, newValue);
          el.classList.remove('editing');
          el.innerHTML = this._renderDetailFieldValue(field, newValue);
          this._renderView();
          document.removeEventListener('click', closeHandler);
        }
      };
      document.addEventListener('click', closeHandler);
    }, 100);
  }

  // --------------------------------------------------------------------------
  // URL Detail Editor
  // --------------------------------------------------------------------------

  _showUrlDetailEditor(el, field, recordId, currentValue) {
    el.innerHTML = `
      <div class="detail-editor-wrapper">
        <div class="detail-url-input-wrapper">
          <i class="ph ph-globe"></i>
          <input type="url" class="detail-editor detail-url-input"
                 value="${this._escapeHtml(currentValue || '')}"
                 placeholder="https://example.com">
        </div>
        <div class="detail-editor-actions">
          <button class="detail-editor-cancel" title="Cancel (Escape)">
            <i class="ph ph-x"></i>
          </button>
          <button class="detail-editor-save" title="Save (Enter)">
            <i class="ph ph-check"></i>
          </button>
        </div>
      </div>
    `;

    const inputEditor = el.querySelector('input');
    inputEditor.focus();
    inputEditor.select();

    const saveInput = () => {
      const value = inputEditor.value.trim();
      // Auto-add protocol if missing
      let finalValue = value;
      if (value && !value.match(/^https?:\/\//i)) {
        finalValue = 'https://' + value;
      }
      this._updateRecordValue(recordId, field.id, finalValue || null);
      el.classList.remove('editing');
      el.innerHTML = this._renderDetailFieldValue(field, finalValue || null);
      this._renderView();
    };

    const cancelInput = () => {
      el.classList.remove('editing');
      el.innerHTML = this._renderDetailFieldValue(field, currentValue);
    };

    el.querySelector('.detail-editor-save')?.addEventListener('click', (e) => {
      e.stopPropagation();
      saveInput();
    });
    el.querySelector('.detail-editor-cancel')?.addEventListener('click', (e) => {
      e.stopPropagation();
      cancelInput();
    });
    inputEditor.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        saveInput();
      }
      if (e.key === 'Escape') {
        cancelInput();
      }
    });
  }

  // --------------------------------------------------------------------------
  // Email Detail Editor
  // --------------------------------------------------------------------------

  _showEmailDetailEditor(el, field, recordId, currentValue) {
    el.innerHTML = `
      <div class="detail-editor-wrapper">
        <div class="detail-email-input-wrapper">
          <i class="ph ph-envelope"></i>
          <input type="email" class="detail-editor detail-email-input"
                 value="${this._escapeHtml(currentValue || '')}"
                 placeholder="name@example.com">
        </div>
        <div class="detail-editor-actions">
          <button class="detail-editor-cancel" title="Cancel (Escape)">
            <i class="ph ph-x"></i>
          </button>
          <button class="detail-editor-save" title="Save (Enter)">
            <i class="ph ph-check"></i>
          </button>
        </div>
      </div>
    `;

    const inputEditor = el.querySelector('input');
    inputEditor.focus();
    inputEditor.select();

    const saveInput = () => {
      const value = inputEditor.value.trim();
      this._updateRecordValue(recordId, field.id, value || null);
      el.classList.remove('editing');
      el.innerHTML = this._renderDetailFieldValue(field, value || null);
      this._renderView();
    };

    const cancelInput = () => {
      el.classList.remove('editing');
      el.innerHTML = this._renderDetailFieldValue(field, currentValue);
    };

    el.querySelector('.detail-editor-save')?.addEventListener('click', (e) => {
      e.stopPropagation();
      saveInput();
    });
    el.querySelector('.detail-editor-cancel')?.addEventListener('click', (e) => {
      e.stopPropagation();
      cancelInput();
    });
    inputEditor.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        saveInput();
      }
      if (e.key === 'Escape') {
        cancelInput();
      }
    });
  }

  // --------------------------------------------------------------------------
  // Attachment Detail Editor
  // --------------------------------------------------------------------------

  _showAttachmentDetailEditor(el, field, recordId, currentValue) {
    const attachments = Array.isArray(currentValue) ? currentValue : (currentValue ? [currentValue] : []);

    let html = '<div class="detail-attachment-editor">';
    html += '<div class="detail-attachment-list">';

    attachments.forEach((att, index) => {
      const fileName = typeof att === 'object' ? (att.name || att.filename || 'File') : String(att);
      html += `
        <div class="detail-attachment-item" data-index="${index}">
          <i class="ph ph-file"></i>
          <span class="detail-attachment-name">${this._escapeHtml(fileName)}</span>
          <button class="detail-attachment-remove" data-index="${index}">
            <i class="ph ph-x"></i>
          </button>
        </div>
      `;
    });

    html += '</div>';
    html += '<div class="detail-attachment-actions">';
    html += '<label class="detail-attachment-add">';
    html += '<i class="ph ph-plus"></i> Add file';
    html += '<input type="file" multiple style="display: none;">';
    html += '</label>';
    html += '<button class="detail-attachment-done">Done</button>';
    html += '</div>';
    html += '</div>';

    el.innerHTML = html;

    const editor = el.querySelector('.detail-attachment-editor');
    let currentAttachments = [...attachments];

    // Remove attachment
    editor.querySelectorAll('.detail-attachment-remove').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const index = parseInt(btn.dataset.index);
        currentAttachments.splice(index, 1);
        // Re-render
        this._showAttachmentDetailEditor(el, field, recordId, currentAttachments);
      });
    });

    // Add file
    const fileInput = editor.querySelector('input[type="file"]');
    fileInput?.addEventListener('change', (e) => {
      const files = Array.from(e.target.files);
      files.forEach(file => {
        // Store basic file info (in a real app, you'd upload and store URLs)
        currentAttachments.push({
          name: file.name,
          type: file.type,
          size: file.size,
          lastModified: file.lastModified
        });
      });
      // Re-render
      this._showAttachmentDetailEditor(el, field, recordId, currentAttachments);
    });

    // Done button
    editor.querySelector('.detail-attachment-done')?.addEventListener('click', (e) => {
      e.stopPropagation();
      const newValue = currentAttachments.length > 0 ? currentAttachments : null;
      this._updateRecordValue(recordId, field.id, newValue);
      el.classList.remove('editing');
      el.innerHTML = this._renderDetailFieldValue(field, newValue);
      this._renderView();
    });
  }

  // --------------------------------------------------------------------------
  // Filter & Sort Panels
  // --------------------------------------------------------------------------

  _showFilterPanel() {
    // TODO: Implement filter dropdown
    console.log('Show filter panel');
  }

  _showSortPanel() {
    const panel = document.getElementById('sort-panel');
    if (!panel) return;

    const set = this.getCurrentSet();
    const view = this.getCurrentView();
    if (!set) return;

    // Populate the sort rules from current view config
    const container = document.getElementById('sort-rules');
    if (container) {
      container.innerHTML = '';

      // Add existing sorts
      const sorts = view?.config.sorts || [];
      sorts.forEach((sort, index) => {
        this._addSortRule(container, set.fields, sort, index);
      });
    }

    panel.style.display = 'block';

    // Position near the sort button
    const btn = document.getElementById('btn-sort');
    if (btn) {
      const rect = btn.getBoundingClientRect();
      panel.style.top = `${rect.bottom + 4}px`;
      panel.style.right = `${window.innerWidth - rect.right}px`;
    }
  }

  _addSortRule(container, fields, sort = null, index = -1) {
    const ruleId = index >= 0 ? index : container.children.length;
    const sortableFields = fields.filter(f =>
      ![FieldTypes.FORMULA, FieldTypes.ROLLUP, FieldTypes.MULTI_SELECT].includes(f.type)
    );

    const rule = document.createElement('div');
    rule.className = 'sort-rule';
    rule.dataset.ruleIndex = ruleId;
    rule.innerHTML = `
      <select class="sort-field-select">
        <option value="">Select field...</option>
        ${sortableFields.map(f => `
          <option value="${f.id}" ${sort?.fieldId === f.id ? 'selected' : ''}>
            ${this._escapeHtml(f.name)}
          </option>
        `).join('')}
      </select>
      <select class="sort-direction-select">
        <option value="asc" ${sort?.direction === 'asc' ? 'selected' : ''}>A → Z</option>
        <option value="desc" ${sort?.direction === 'desc' ? 'selected' : ''}>Z → A</option>
      </select>
      <button class="sort-rule-remove" title="Remove sort">
        <i class="ph ph-x"></i>
      </button>
    `;

    rule.querySelector('.sort-rule-remove').addEventListener('click', () => {
      rule.remove();
    });

    container.appendChild(rule);
  }

  // --------------------------------------------------------------------------
  // Status Updates
  // --------------------------------------------------------------------------

  _updateStatus() {
    const set = this.getCurrentSet();
    const records = this.getFilteredRecords();

    if (this.elements.recordCount) {
      this.elements.recordCount.querySelector('span:last-child').textContent =
        `${records.length} record${records.length !== 1 ? 's' : ''}`;
    }

    if (this.elements.selectedCount) {
      this.elements.selectedCount.querySelector('span:last-child').textContent =
        `${this.selectedRecords.size} selected`;
    }

    // Update bulk actions toolbar
    this._updateBulkActionsToolbar();
  }

  /**
   * Update status bar when viewing a source (not a set)
   */
  _updateSourceStatus(source) {
    if (!source) return;

    const recordCount = source.records?.length || source.recordCount || 0;

    if (this.elements.recordCount) {
      this.elements.recordCount.querySelector('span:last-child').textContent =
        `${recordCount.toLocaleString()} record${recordCount !== 1 ? 's' : ''}`;
    }

    // Sources don't have selection, so show 0 selected
    if (this.elements.selectedCount) {
      this.elements.selectedCount.querySelector('span:last-child').textContent =
        '0 selected';
    }

    // Hide bulk actions toolbar for sources (read-only)
    this._updateBulkActionsToolbar();
  }

  // --------------------------------------------------------------------------
  // Keyboard Shortcuts
  // --------------------------------------------------------------------------

  _handleKeyDown(e) {
    // Escape to close modals/menus and clear selection
    if (e.key === 'Escape') {
      this._closeModal();
      this._hideKeyboardShortcuts();
      this._hideFilterPanel();
      this._hideSortPanel();
      this._hideFieldsPanel();
      this._closeTabListDropdown();
      this._closeTabContextMenu();
      this.elements.contextMenu?.classList.remove('active');
      this.elements.fieldTypePicker?.classList.remove('active');
      this.elements.detailPanel?.classList.remove('open');

      if (this.editingCell) {
        this._cancelCellEdit();
      }

      // Clear selection when Escape is pressed (if no modal is open)
      if (this.selectedRecords.size > 0) {
        this._clearSelection();
        this._showToast('Selection cleared', 'info');
      }

      // Hide search results
      this._hideSearchResults();
    }

    // ? to show keyboard shortcuts
    if (e.key === '?' && !e.target.closest('input, textarea')) {
      e.preventDefault();
      this._showKeyboardShortcuts();
    }

    // ========== TAB SHORTCUTS ==========

    // Ctrl + T for new tab
    if ((e.metaKey || e.ctrlKey) && e.key === 't' && !e.target.closest('input, textarea')) {
      e.preventDefault();
      this._createNewTab();
    }

    // Ctrl + W to toss current tab
    if ((e.metaKey || e.ctrlKey) && e.key === 'w' && !e.target.closest('input, textarea')) {
      e.preventDefault();
      this._tossCurrentTab();
    }

    // Ctrl + Shift + T to pick up last tossed tab
    if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'T' && !e.target.closest('input, textarea')) {
      e.preventDefault();
      this._pickUpLastTossed();
    }

    // Escape also clears picked up item
    if (e.key === 'Escape' && this.pickedUp) {
      this._clearPickedUp();
      this._showToast('Dropped picked up item', 'info');
    }

    // ========== UNDO/REDO ==========

    // Ctrl + Z for undo
    if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey && !e.target.closest('input, textarea')) {
      e.preventDefault();
      this._undo();
    }

    // Ctrl + Shift + Z or Ctrl + Y for redo
    if ((e.metaKey || e.ctrlKey) && ((e.shiftKey && e.key === 'Z') || e.key === 'y') && !e.target.closest('input, textarea')) {
      e.preventDefault();
      this._redo();
    }

    // Ctrl + Tab to go to next tab
    if ((e.metaKey || e.ctrlKey) && e.key === 'Tab' && !e.shiftKey && !e.target.closest('input, textarea')) {
      e.preventDefault();
      this._nextTab();
    }

    // Ctrl + Shift + Tab to go to previous tab
    if ((e.metaKey || e.ctrlKey) && e.key === 'Tab' && e.shiftKey && !e.target.closest('input, textarea')) {
      e.preventDefault();
      this._prevTab();
    }

    // Ctrl + 1-9 to switch to specific tab (1-indexed)
    if ((e.metaKey || e.ctrlKey) && !e.shiftKey && !e.altKey && !e.target.closest('input, textarea')) {
      const tabIndex = parseInt(e.key, 10);
      if (tabIndex >= 1 && tabIndex <= 9) {
        const set = this.getCurrentSet();
        if (set && set.views.length > 0) {
          const viewIndex = tabIndex === 9 ? set.views.length - 1 : Math.min(tabIndex - 1, set.views.length - 1);
          if (set.views[viewIndex]) {
            e.preventDefault();
            this._selectView(set.views[viewIndex].id);
          }
        }
      }
    }

    // ========== CREATE SHORTCUTS ==========

    // Ctrl + Shift + N to open "New" menu
    if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'N' && !e.target.closest('input, textarea')) {
      e.preventDefault();
      const dropdown = document.getElementById('new-action-dropdown');
      if (dropdown) {
        dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
      }
    }

    // Ctrl + I for import source
    if ((e.metaKey || e.ctrlKey) && e.key === 'i' && !e.shiftKey && !e.target.closest('input, textarea')) {
      e.preventDefault();
      this._showImportModal();
    }

    // Ctrl + Shift + S for new set (different from Ctrl + S which is export)
    if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'S' && !e.target.closest('input, textarea')) {
      e.preventDefault();
      this._showNewSetModal();
    }

    // Ctrl + Shift + V for new view
    if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'V' && !e.target.closest('input, textarea')) {
      e.preventDefault();
      this._showNewViewForCurrentSet();
    }

    // Ctrl + Shift + F for new field (note: Ctrl+F is filter)
    if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'F' && !e.target.closest('input, textarea')) {
      e.preventDefault();
      const btn = document.getElementById('btn-new-action');
      this._showAddFieldMenu(btn);
    }

    // ========== RECORD SHORTCUTS ==========

    // Cmd/Ctrl + N for new record (case-insensitive for cross-browser compatibility)
    if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'n' && !e.shiftKey && !e.target.closest('input, textarea')) {
      e.preventDefault();
      this.addRecord();
    }

    // Cmd/Ctrl + D for duplicate
    if ((e.metaKey || e.ctrlKey) && e.key === 'd' && !e.target.closest('input, textarea')) {
      if (this.selectedRecords.size > 0) {
        e.preventDefault();
        this._bulkDuplicate();
      }
    }

    // Cmd/Ctrl + A to select all (but not when inside any editable element)
    if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'a') {
      // Check if target is any kind of editable element
      const target = e.target;
      const tagName = target.tagName?.toUpperCase();
      const isEditable = tagName === 'INPUT' ||
                         tagName === 'TEXTAREA' ||
                         tagName === 'SELECT' ||
                         target.isContentEditable ||
                         target.closest('input, textarea, select, [contenteditable="true"]') ||
                         // Also check if any input/textarea has focus
                         document.activeElement?.tagName === 'INPUT' ||
                         document.activeElement?.tagName === 'TEXTAREA' ||
                         document.activeElement?.tagName === 'SELECT' ||
                         document.activeElement?.isContentEditable;
      // Only select all records if NOT in an editable element
      if (!isEditable) {
        e.preventDefault();
        this._selectAll();
      }
      // When in editable element, don't do anything - let browser handle Ctrl+A natively
    }

    // Cmd/Ctrl + F for filter
    if ((e.metaKey || e.ctrlKey) && e.key === 'f' && !e.target.closest('input, textarea')) {
      e.preventDefault();
      this._toggleFilterPanel();
    }

    // Cmd/Ctrl + S for export
    if ((e.metaKey || e.ctrlKey) && e.key === 's' && !e.target.closest('input, textarea')) {
      e.preventDefault();
      this._showNewExportModal();
    }

    // Cmd/Ctrl + / to focus search
    if ((e.metaKey || e.ctrlKey) && e.key === '/' && !e.target.closest('input, textarea')) {
      e.preventDefault();
      document.getElementById('global-search')?.focus();
    }

    // Delete selected records
    if ((e.key === 'Delete' || e.key === 'Backspace') && !e.target.closest('input, textarea')) {
      if (this.selectedRecords.size > 0) {
        e.preventDefault();
        this._bulkDelete();
      }
    }

    // Number keys for view TYPE switching (1-5) - only when not using Ctrl
    if (!e.target.closest('input, textarea') && !e.metaKey && !e.ctrlKey && !e.altKey) {
      const viewMap = { '1': 'table', '2': 'cards', '3': 'kanban', '4': 'calendar', '5': 'graph' };
      if (viewMap[e.key]) {
        e.preventDefault();
        this._switchViewType(viewMap[e.key]);
      }
    }
  }

  // --------------------------------------------------------------------------
  // Keyboard Shortcuts Modal
  // --------------------------------------------------------------------------

  _showKeyboardShortcuts() {
    const modal = document.getElementById('shortcuts-modal');
    if (modal) {
      modal.style.display = 'flex';
    }
  }

  _hideKeyboardShortcuts() {
    const modal = document.getElementById('shortcuts-modal');
    if (modal) {
      modal.style.display = 'none';
    }
  }

  // --------------------------------------------------------------------------
  // Tossed Items Panel (Deletion History)
  // --------------------------------------------------------------------------

  _showTossedPanel() {
    const panel = document.getElementById('tossed-panel');
    if (panel) {
      panel.style.display = 'flex';
      this._renderTossedPanel();
    }
  }

  _hideTossedPanel() {
    const panel = document.getElementById('tossed-panel');
    if (panel) {
      panel.style.display = 'none';
    }
  }

  _updateTossedBadge() {
    const badge = document.getElementById('tossed-count-badge');
    if (badge) {
      const count = this.tossedItems.length;
      if (count > 0) {
        badge.textContent = count;
        badge.style.display = 'inline-flex';
      } else {
        badge.style.display = 'none';
      }
    }
  }

  _renderTossedPanel() {
    const treeEl = document.getElementById('tossed-tree');
    const emptyEl = document.getElementById('tossed-empty');

    if (!treeEl || !emptyEl) return;

    // Update badge
    this._updateTossedBadge();

    if (this.tossedItems.length === 0) {
      treeEl.style.display = 'none';
      emptyEl.style.display = 'flex';
      return;
    }

    treeEl.style.display = 'flex';
    emptyEl.style.display = 'none';

    // Group items by type
    const grouped = {
      source: [],
      set: [],
      view: [],
      record: [],
      field: []
    };

    this.tossedItems.forEach((item, index) => {
      if (grouped[item.type]) {
        grouped[item.type].push({ ...item, originalIndex: index });
      }
    });

    // Category configurations
    const categories = [
      { type: 'source', label: 'Sources', icon: 'ph-file-csv', iconClass: 'source-icon' },
      { type: 'set', label: 'Sets', icon: 'ph-table', iconClass: 'set-icon' },
      { type: 'view', label: 'Views', icon: 'ph-eye', iconClass: 'view-icon' },
      { type: 'field', label: 'Fields (Columns)', icon: 'ph-columns', iconClass: 'field-icon' },
      { type: 'record', label: 'Records (Rows)', icon: 'ph-rows', iconClass: 'record-icon' }
    ];

    let html = '';

    categories.forEach(cat => {
      const items = grouped[cat.type];
      if (items.length === 0) return;

      html += `
        <div class="tossed-category" data-type="${cat.type}">
          <div class="tossed-category-header">
            <i class="ph ${cat.icon} category-icon"></i>
            <span>${cat.label}</span>
            <span class="category-count">${items.length}</span>
            <i class="ph ph-caret-down expand-icon"></i>
          </div>
          <div class="tossed-category-items">
      `;

      items.forEach(item => {
        const name = this._getTossedItemName(item);
        const meta = this._getTossedItemMeta(item);
        const timeAgo = this._formatTimeAgo(item.tossedAt);

        html += `
          <div class="tossed-item" data-index="${item.originalIndex}" data-type="${item.type}">
            <div class="tossed-item-icon ${cat.iconClass}">
              <i class="ph ${cat.icon}"></i>
            </div>
            <div class="tossed-item-content">
              <div class="tossed-item-name">${this._escapeHtml(name)}</div>
              <div class="tossed-item-meta">
                ${meta ? `<span>${this._escapeHtml(meta)}</span><span class="meta-separator">•</span>` : ''}
                <span>${timeAgo}</span>
              </div>
            </div>
            <div class="tossed-item-actions">
              <button class="tossed-item-action restore" title="Restore" data-action="restore">
                <i class="ph ph-arrow-counter-clockwise"></i>
              </button>
              <button class="tossed-item-action delete" title="Delete permanently" data-action="delete">
                <i class="ph ph-x"></i>
              </button>
            </div>
          </div>
        `;
      });

      html += `
          </div>
        </div>
      `;
    });

    treeEl.innerHTML = html;

    // Add event listeners
    treeEl.querySelectorAll('.tossed-category-header').forEach(header => {
      header.addEventListener('click', () => {
        header.parentElement.classList.toggle('collapsed');
      });
    });

    treeEl.querySelectorAll('.tossed-item-action').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const item = btn.closest('.tossed-item');
        const index = parseInt(item.dataset.index);
        const action = btn.dataset.action;

        if (action === 'restore') {
          this._restoreTossedItem(index);
        } else if (action === 'delete') {
          this._permanentlyDeleteTossedItem(index);
        }
      });
    });
  }

  _getTossedItemName(item) {
    switch (item.type) {
      case 'source':
        return item.source?.name || 'Unnamed Source';
      case 'set':
        return item.set?.name || 'Unnamed Set';
      case 'view':
        return item.view?.name || 'Unnamed View';
      case 'record':
        // Try to get the primary field value
        const set = this.sets.find(s => s.id === item.setId);
        if (set) {
          const primaryField = set.fields.find(f => f.isPrimary);
          if (primaryField && item.record?.values?.[primaryField.id]) {
            return item.record.values[primaryField.id];
          }
        }
        return 'Record';
      case 'field':
        return item.field?.name || 'Unnamed Field';
      default:
        return 'Unknown Item';
    }
  }

  _getTossedItemMeta(item) {
    switch (item.type) {
      case 'source':
        const sourceRecordCount = item.source?.records?.length || item.source?.recordCount || 0;
        const derivedCount = item.derivedSetIds?.length || 0;
        let meta = `${sourceRecordCount} records`;
        if (derivedCount > 0) {
          meta += `, ${derivedCount} derived set${derivedCount > 1 ? 's' : ''} (ghost)`;
        }
        return meta;
      case 'set':
        const recordCount = item.set?.records?.length || 0;
        const viewCount = item.set?.views?.length || 0;
        return `${recordCount} records, ${viewCount} views`;
      case 'view':
        const viewSet = this.sets.find(s => s.id === item.setId);
        return viewSet ? `from ${viewSet.name}` : null;
      case 'record':
        const recSet = this.sets.find(s => s.id === item.setId);
        return recSet ? `from ${recSet.name}` : null;
      case 'field':
        const fieldSet = this.sets.find(s => s.id === item.setId);
        const fieldType = item.field?.type || 'unknown';
        return fieldSet ? `${fieldType} field from ${fieldSet.name}` : fieldType;
      default:
        return null;
    }
  }

  _formatTimeAgo(dateStr) {
    if (!dateStr) return '';
    const date = new Date(dateStr);
    const now = new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);

    if (diffMins < 1) return 'just now';
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    if (diffDays < 7) return `${diffDays}d ago`;
    return date.toLocaleDateString();
  }

  _restoreTossedItem(index, options = {}) {
    if (index < 0 || index >= this.tossedItems.length) return;

    const item = this.tossedItems[index];

    // Get the item name before removing from array
    const itemName = this._getTossedItemName(item);

    // Remove from tossed items
    this.tossedItems.splice(index, 1);

    // Track if restore was successful
    let restored = false;

    // Restore based on type
    switch (item.type) {
      case 'source':
        // Re-add to sources array
        if (!this.sources) this.sources = [];
        this.sources.push(item.source);

        // Re-add to sourceStore if present
        if (this.sourceStore) {
          this.sourceStore.sources.set(item.source.id, item.source);
        }

        // Resurrect from ghost registry if available
        if (typeof getGhostRegistry === 'function') {
          const ghostRegistry = getGhostRegistry();
          if (ghostRegistry.isGhost(item.source.id)) {
            ghostRegistry.resurrect(item.source.id, 'user', { reason: 'User restored source from toss bin' });
          }
        }

        this._renderSidebar();
        this._renderFileExplorer?.();
        this._showToast(`Restored source "${item.source.name}"`, 'success');
        restored = true;
        break;

      case 'set':
        this.sets.push(item.set);
        this.currentSetId = item.set.id;
        this.currentViewId = item.set.views[0]?.id;
        if (this.currentSetId && this.currentViewId) {
          this.lastViewPerSet[this.currentSetId] = this.currentViewId;
        }
        this._renderTabBar();
        this._renderSetsNavFlat();
        this._renderSidebar();
        this._renderView();
        this._updateBreadcrumb();
        this._showToast(`Restored set "${item.set.name}"`, 'success');
        restored = true;
        break;

      case 'view':
        const viewSet = this.sets.find(s => s.id === item.setId);
        if (viewSet) {
          viewSet.views.push(item.view);
          this.currentViewId = item.view.id;
          if (this.currentSetId !== item.setId) {
            this.currentSetId = item.setId;
            this._renderSidebar();
          }
          this.lastViewPerSet[item.setId] = item.view.id;
          this._renderViewsNav();
          this._renderView();
          this._updateBreadcrumb();
          this._showToast(`Restored view "${item.view.name}"`, 'success');
          restored = true;
        } else {
          this._showToast('Original set no longer exists', 'warning');
        }
        break;

      case 'record':
        const recSet = this.sets.find(s => s.id === item.setId);
        if (recSet) {
          recSet.records.push(item.record);
          if (this.currentSetId !== item.setId) {
            this.currentSetId = item.setId;
            this._renderSidebar();
          }
          this._renderView();
          this._showToast('Restored record', 'success');
          restored = true;
        } else {
          this._showToast('Original set no longer exists', 'warning');
        }
        break;

      case 'field':
        const fieldSet = this.sets.find(s => s.id === item.setId);
        if (fieldSet) {
          fieldSet.fields.push(item.field);
          // Restore field values
          if (item.fieldValues) {
            Object.entries(item.fieldValues).forEach(([recordId, value]) => {
              const record = fieldSet.records.find(r => r.id === recordId);
              if (record) {
                record.values[item.field.id] = value;
              }
            });
          }
          if (this.currentSetId !== item.setId) {
            this.currentSetId = item.setId;
          }
          // Record field restore event for event stream
          this._recordFieldEvent(item.field.id, 'field.restored', {
            name: item.field.name,
            type: item.field.type
          });
          this._renderView();
          this._showToast(`Restored field "${item.field.name}"`, 'success');
          restored = true;
        } else {
          this._showToast('Original set no longer exists', 'warning');
        }
        break;
    }

    this._saveData();
    this._renderTossedPanel();

    // Record the restore activity (unless caller wants to handle it)
    if (restored && !options.skipActivityRecord) {
      this._recordActivity({
        action: 'restore',
        entityType: item.type,
        name: itemName,
        details: `Restored from toss bin`
      });
    }
  }

  _permanentlyDeleteTossedItem(index) {
    if (index < 0 || index >= this.tossedItems.length) return;

    const item = this.tossedItems[index];
    const name = this._getTossedItemName(item);

    if (confirm(`Remove "${name}" from toss bin? The item will persist as a ghost for provenance tracking.`)) {
      // Register as ghost before removing from toss bin (nothing is ever truly deleted)
      this._registerTossedItemAsGhost(item);

      this.tossedItems.splice(index, 1);
      this._saveData();
      this._renderTossedPanel();
      this._showToast(`Removed "${name}" from toss bin (persists as ghost)`, 'info');
    }
  }

  _clearAllTossedItems() {
    if (this.tossedItems.length === 0) {
      this._showToast('No items to clear', 'info');
      return;
    }

    if (confirm(`Clear all ${this.tossedItems.length} tossed items? Items will persist as ghosts for provenance tracking.`)) {
      // Register all items as ghosts before clearing
      this.tossedItems.forEach(item => {
        this._registerTossedItemAsGhost(item);
      });

      this.tossedItems = [];
      this._saveData();
      this._renderTossedPanel();
      this._showToast('Cleared toss bin (items persist as ghosts)', 'info');
    }
  }

  /**
   * Register a tossed item as a ghost in the ghost registry
   * This ensures items are never truly deleted - they persist for provenance tracking
   */
  _registerTossedItemAsGhost(item) {
    if (typeof getGhostRegistry !== 'function') return;

    const ghostRegistry = getGhostRegistry();
    let entityId, entityType, snapshot;

    switch (item.type) {
      case 'source':
        entityId = item.source?.id;
        entityType = 'source';
        snapshot = {
          type: 'source',
          payload: {
            name: item.source?.name,
            recordCount: item.source?.records?.length || item.source?.recordCount || 0
          }
        };
        break;
      case 'set':
        entityId = item.set?.id;
        entityType = 'set';
        snapshot = {
          type: 'set',
          payload: {
            name: item.set?.name,
            fieldCount: item.set?.fields?.length || 0,
            recordCount: item.set?.records?.length || 0
          }
        };
        break;
      case 'view':
        entityId = item.view?.id;
        entityType = 'view';
        snapshot = {
          type: 'view',
          payload: {
            name: item.view?.name,
            setId: item.setId
          }
        };
        break;
      case 'record':
        entityId = item.record?.id;
        entityType = 'record';
        snapshot = {
          type: 'record',
          payload: {
            setId: item.setId,
            values: item.record?.values
          }
        };
        break;
      case 'field':
        entityId = item.field?.id;
        entityType = 'field';
        snapshot = {
          type: 'field',
          payload: {
            name: item.field?.name,
            fieldType: item.field?.type,
            setId: item.setId
          }
        };
        break;
      default:
        return;
    }

    if (!entityId || ghostRegistry.isGhost(entityId)) return;

    const tombstoneEvent = {
      id: `tombstone_${Date.now().toString(36)}_${Math.random().toString(36).substr(2, 6)}`,
      timestamp: new Date().toISOString(),
      actor: 'user',
      payload: {
        action: 'tombstone',
        targetId: entityId,
        reason: 'Cleared from toss bin',
        targetSnapshot: snapshot
      },
      context: { workspace: 'default' }
    };

    ghostRegistry.registerGhost(entityId, tombstoneEvent, {
      entityType,
      workspace: 'default'
    });
  }

  // --------------------------------------------------------------------------
  // Activity Stream Panel
  // --------------------------------------------------------------------------

  /**
   * Record an activity in the activity log
   * @param {Object} activity - Activity object with action, type, name, details, and optional reverseData
   *
   * EO Operator Mapping:
   *   INS (⊕) - Assert existence: create
   *   DES (⊙) - Designate identity: rename
   *   SEG (⊘) - Scope visibility: filter, hide, archive
   *   CON (⊗) - Connect entities: link, relate
   *   SYN (≡) - Synthesize identity: duplicate, merge
   *   ALT (Δ) - Alternate world state: update, change
   *   SUP (∥) - Superpose interpretations: (not common in UI)
   *   REC (←) - Record grounding: import, export
   *   NUL (∅) - Assert meaningful absence: delete, toss
   */
  _recordActivity(activity) {
    // Map action to EO operator
    const operatorMap = {
      'create': 'INS',
      'update': 'ALT',
      'delete': 'NUL',
      'rename': 'DES',
      'duplicate': 'SYN',
      'restore': 'INS',
      'link': 'CON',
      'import': 'REC',
      'export': 'REC',
      'filter': 'SEG',
      'archive': 'SEG'
    };

    const operator = activity.operator || operatorMap[activity.action] || 'ALT';

    const activityEntry = {
      id: `act_${Date.now().toString(36)}_${Math.random().toString(36).substr(2, 6)}`,
      timestamp: new Date().toISOString(),
      op: operator,  // EO operator
      actor: 'user',
      target: activity.entityType,
      ...activity
    };

    this.activityLog.unshift(activityEntry);

    // Trim to max size
    if (this.activityLog.length > this.maxActivityLogSize) {
      this.activityLog = this.activityLog.slice(0, this.maxActivityLogSize);
    }

    // Save activity log
    this._saveData();
  }

  _showActivityPanel() {
    const panel = document.getElementById('activity-panel');
    if (panel) {
      panel.style.display = 'flex';
      this._renderActivityPanel();
    }
  }

  _hideActivityPanel() {
    const panel = document.getElementById('activity-panel');
    if (panel) {
      panel.style.display = 'none';
    }
  }

  _renderActivityPanel() {
    const tableBody = document.getElementById('activity-table-body');
    const tableContainer = document.getElementById('activity-table-container');
    const emptyEl = document.getElementById('activity-empty');
    const countEl = document.getElementById('activity-count');

    if (!tableBody) return;

    // Get filter values
    const typeFilter = document.getElementById('activity-filter-type')?.value || 'all';
    const actionFilter = document.getElementById('activity-filter-action')?.value || 'all';

    // Collect all activities from multiple sources
    const allActivities = this._collectAllActivities();

    // Filter activities
    let filtered = allActivities;
    if (typeFilter !== 'all') {
      filtered = filtered.filter(a => a.entityType === typeFilter);
    }
    if (actionFilter !== 'all') {
      filtered = filtered.filter(a => a.action === actionFilter);
    }

    // Update count
    if (countEl) {
      countEl.textContent = `${filtered.length} ${filtered.length === 1 ? 'activity' : 'activities'}`;
    }

    if (filtered.length === 0) {
      tableContainer.style.display = 'none';
      emptyEl.style.display = 'flex';
      return;
    }

    tableContainer.style.display = 'block';
    emptyEl.style.display = 'none';

    // Render table rows
    tableBody.innerHTML = filtered.slice(0, 100).map(activity => {
      const timeAgo = this._formatTimeAgo(activity.timestamp);
      const actionBadge = this._getActivityActionBadge(activity.action);
      const typeBadge = this._getActivityTypeBadge(activity.entityType);
      const canUndo = activity.canReverse && activity.reverseData;

      return `
        <tr data-activity-id="${activity.id}">
          <td class="activity-col-time">${timeAgo}</td>
          <td class="activity-col-action">${actionBadge}</td>
          <td class="activity-col-type">${typeBadge}</td>
          <td class="activity-col-name">
            <span class="activity-name" title="${this._escapeHtml(activity.name || '')}">${this._escapeHtml(activity.name || 'Untitled')}</span>
          </td>
          <td class="activity-col-details">
            <span class="activity-details" title="${this._escapeHtml(activity.details || '')}">${this._escapeHtml(activity.details || '')}</span>
          </td>
          <td class="activity-col-actions">
            ${canUndo ? `<button class="activity-undo-btn" data-activity-id="${activity.id}" title="Reverse this action">Undo</button>` : ''}
          </td>
        </tr>
      `;
    }).join('');

    // Add event listeners for undo buttons
    tableBody.querySelectorAll('.activity-undo-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const activityId = btn.dataset.activityId;
        this._reverseActivity(activityId);
      });
    });
  }

  /**
   * Collect all activities from multiple sources
   */
  _collectAllActivities() {
    const activities = [];

    // 1. Add tossed items as delete activities
    this.tossedItems.forEach(item => {
      const name = this._getTossedItemName(item);
      activities.push({
        id: `toss_${item.tossedAt}_${item.type}`,
        timestamp: item.tossedAt,
        action: 'delete',
        entityType: item.type,
        name: name,
        details: this._getTossedItemMeta(item),
        canReverse: true,
        reverseData: { type: 'restore_tossed', item }
      });
    });

    // 2. Add activities from activity log (recorded activities)
    this.activityLog.forEach(act => {
      activities.push({
        ...act,
        canReverse: !!act.reverseData
      });
    });

    // 3. Add field events from current set's event stream
    const set = this.getCurrentSet();
    if (set?.eventStream) {
      set.eventStream.forEach(event => {
        const actionMap = {
          'field.created': 'create',
          'field.deleted': 'delete',
          'field.restored': 'restore',
          'field.renamed': 'update',
          'field.type_changed': 'update',
          'field.description_changed': 'update',
          'field.definition_linked': 'update',
          'field.definition_unlinked': 'update',
          'field.duplicated': 'create'
        };
        const action = actionMap[event.type] || 'update';

        activities.push({
          id: event.id,
          timestamp: event.timestamp,
          action: action,
          entityType: 'field',
          name: event.target?.fieldName || event.changes?.name || 'Field',
          details: this._getFieldEventDetails(event),
          canReverse: false
        });
      });
    }

    // Sort by timestamp (newest first)
    activities.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

    return activities;
  }

  /**
   * Get history of changes for a specific set
   * Aggregates activities from multiple sources filtered by set
   * @param {string} setId - The set ID to get history for
   * @returns {Array} Array of activity objects sorted by timestamp (newest first)
   */
  _getSetHistory(setId) {
    const set = this.sets.find(s => s.id === setId);
    if (!set) return [];

    const activities = [];
    const setName = set.name;

    // 1. Add tossed items related to this set
    this.tossedItems.forEach(item => {
      // Check if this tossed item belongs to our set
      const belongsToSet =
        (item.type === 'set' && item.set?.id === setId) ||
        (item.type === 'view' && item.setId === setId) ||
        (item.type === 'record' && item.setId === setId) ||
        (item.type === 'field' && item.setId === setId);

      if (!belongsToSet) return;

      const name = this._getTossedItemName(item);
      activities.push({
        id: `toss_${item.tossedAt}_${item.type}`,
        timestamp: item.tossedAt,
        action: 'delete',
        entityType: item.type,
        name: name,
        details: this._getTossedItemMeta(item),
        op: 'NUL',
        canReverse: true,
        reverseData: { type: 'restore_tossed', item }
      });
    });

    // 2. Add activities from activity log that relate to this set
    this.activityLog.forEach(act => {
      const belongsToSet =
        // Direct set operations
        (act.entityType === 'set' && (
          act.name === setName ||
          act.reverseData?.setId === setId ||
          act.details?.includes(`"${setName}"`)
        )) ||
        // View/field/record operations with setId
        ((act.entityType === 'view' || act.entityType === 'record' || act.entityType === 'field') && (
          act.reverseData?.setId === setId ||
          act.details?.includes(`"${setName}"`) ||
          act.details?.includes(`set "${setName}"`)
        )) ||
        // Import operations mentioning the set
        (act.action === 'import' && act.details?.includes(setName));

      if (!belongsToSet) return;

      activities.push({
        ...act,
        canReverse: !!act.reverseData
      });
    });

    // 3. Add field events from set's event stream
    if (set.eventStream) {
      set.eventStream.forEach(event => {
        const actionMap = {
          'field.created': 'create',
          'field.deleted': 'delete',
          'field.restored': 'restore',
          'field.renamed': 'rename',
          'field.type_changed': 'update',
          'field.description_changed': 'update',
          'field.definition_linked': 'link',
          'field.definition_unlinked': 'update',
          'field.duplicated': 'create'
        };
        const action = actionMap[event.type] || 'update';

        activities.push({
          id: event.id,
          timestamp: event.timestamp,
          action: action,
          entityType: 'field',
          name: event.target?.fieldName || event.changes?.name || 'Field',
          details: this._getFieldEventDetails(event),
          op: this._getOperatorForAction(action),
          canReverse: false
        });
      });
    }

    // 4. Include set creation date as first event if available
    if (set.createdAt) {
      const existingCreation = activities.find(a =>
        a.entityType === 'set' && a.action === 'create' &&
        new Date(a.timestamp).getTime() === new Date(set.createdAt).getTime()
      );
      if (!existingCreation) {
        const provenance = set.datasetProvenance;
        let details = `${set.records?.length || 0} records, ${set.fields?.length || 0} fields`;
        if (provenance?.sourceType) {
          details = `From ${provenance.sourceType} import • ${details}`;
        }
        activities.push({
          id: `set_created_${setId}`,
          timestamp: set.createdAt,
          action: 'create',
          entityType: 'set',
          name: setName,
          details: details,
          op: 'INS',
          canReverse: false
        });
      }
    }

    // Sort by timestamp (newest first)
    activities.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

    return activities;
  }

  /**
   * Get EO operator symbol for an action
   */
  _getOperatorForAction(action) {
    const map = {
      'create': 'INS',
      'update': 'ALT',
      'delete': 'NUL',
      'rename': 'DES',
      'duplicate': 'SYN',
      'restore': 'INS',
      'link': 'CON',
      'import': 'REC',
      'export': 'REC'
    };
    return map[action] || 'ALT';
  }

  /**
   * Get EO operator symbol for display
   */
  _getOperatorSymbol(op) {
    const symbols = {
      'INS': '⊕',
      'DES': '⊙',
      'SEG': '⊘',
      'CON': '⊗',
      'SYN': '≡',
      'ALT': 'Δ',
      'SUP': '∥',
      'REC': '←',
      'NUL': '∅'
    };
    return symbols[op] || '•';
  }

  /**
   * Group activities by date for timeline display
   */
  _groupActivitiesByDate(activities) {
    const groups = {};
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const yesterday = new Date(today.getTime() - 86400000);

    activities.forEach(activity => {
      const date = new Date(activity.timestamp);
      const activityDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());

      let dateKey;
      if (activityDate.getTime() === today.getTime()) {
        dateKey = 'Today';
      } else if (activityDate.getTime() === yesterday.getTime()) {
        dateKey = 'Yesterday';
      } else {
        dateKey = activityDate.toLocaleDateString('en-US', {
          month: 'short',
          day: 'numeric',
          year: activityDate.getFullYear() !== now.getFullYear() ? 'numeric' : undefined
        });
      }

      if (!groups[dateKey]) {
        groups[dateKey] = {
          label: dateKey,
          date: activityDate,
          activities: []
        };
      }
      groups[dateKey].activities.push(activity);
    });

    // Convert to array and sort by date (newest first)
    return Object.values(groups).sort((a, b) => b.date - a.date);
  }

  /**
   * Render Set History section for the Overview panel
   */
  _renderSetHistorySection(setId) {
    const activities = this._getSetHistory(setId);
    const groupedActivities = this._groupActivitiesByDate(activities);

    if (activities.length === 0) {
      return `
        <div class="set-history-section">
          <div class="set-history-header">
            <h4><i class="ph ph-clock-counter-clockwise"></i> Set History</h4>
          </div>
          <div class="set-history-empty">
            <i class="ph ph-clock"></i>
            <span>No history recorded yet</span>
          </div>
        </div>
      `;
    }

    // Show only first 10 activities in overview, with option to view all
    const previewCount = 10;
    const totalCount = activities.length;
    const hasMore = totalCount > previewCount;

    let timelineHtml = '';
    let shownCount = 0;

    for (const group of groupedActivities) {
      if (shownCount >= previewCount) break;

      timelineHtml += `
        <div class="history-date-group">
          <div class="history-date-marker">
            <span class="history-date-dot"></span>
            <span class="history-date-label">${group.label}</span>
          </div>
          <div class="history-date-items">
      `;

      for (const activity of group.activities) {
        if (shownCount >= previewCount) break;

        const time = new Date(activity.timestamp).toLocaleTimeString('en-US', {
          hour: 'numeric',
          minute: '2-digit',
          hour12: true
        });
        const opSymbol = this._getOperatorSymbol(activity.op);
        const actionClass = activity.action || 'update';

        timelineHtml += `
          <div class="history-item" data-activity-id="${activity.id}">
            <span class="history-item-time">${time}</span>
            <span class="history-item-op ${actionClass}" title="${activity.op || ''}">${opSymbol}</span>
            <div class="history-item-content">
              <span class="history-item-action">${this._getHistoryActionText(activity)}</span>
              ${activity.details ? `<span class="history-item-details">${this._escapeHtml(activity.details)}</span>` : ''}
            </div>
          </div>
        `;
        shownCount++;
      }

      timelineHtml += `
          </div>
        </div>
      `;
    }

    return `
      <div class="set-history-section">
        <div class="set-history-header">
          <h4><i class="ph ph-clock-counter-clockwise"></i> Set History</h4>
          ${hasMore ? `<button class="set-history-view-all" data-set-id="${setId}">View All (${totalCount})</button>` : ''}
        </div>
        <div class="set-history-timeline">
          ${timelineHtml}
        </div>
      </div>
    `;
  }

  /**
   * Get human-readable action text for history item
   */
  _getHistoryActionText(activity) {
    const entityLabels = {
      'set': 'Set',
      'record': 'record',
      'field': 'field',
      'view': 'view',
      'source': 'source'
    };

    const actionVerbs = {
      'create': 'Added',
      'delete': 'Deleted',
      'update': 'Updated',
      'rename': 'Renamed',
      'restore': 'Restored',
      'link': 'Linked',
      'import': 'Imported',
      'export': 'Exported',
      'duplicate': 'Duplicated'
    };

    const verb = actionVerbs[activity.action] || 'Modified';
    const entity = entityLabels[activity.entityType] || activity.entityType;
    const name = activity.name ? `"${activity.name}"` : '';

    // Special case for set creation
    if (activity.entityType === 'set' && activity.action === 'create') {
      return `Set created`;
    }

    // Special case for bulk operations
    if (activity.details?.match(/^\d+ records/)) {
      return `${verb} ${activity.details.split(',')[0]}`;
    }

    return `${verb} ${entity} ${name}`.trim();
  }

  /**
   * Show full set history modal
   */
  _showSetHistoryModal(setId) {
    const set = this.sets.find(s => s.id === setId);
    if (!set) return;

    const activities = this._getSetHistory(setId);
    const groupedActivities = this._groupActivitiesByDate(activities);

    let timelineHtml = '';

    for (const group of groupedActivities) {
      timelineHtml += `
        <div class="history-date-group">
          <div class="history-date-marker">
            <span class="history-date-dot"></span>
            <span class="history-date-label">${group.label}</span>
          </div>
          <div class="history-date-items">
      `;

      for (const activity of group.activities) {
        const time = new Date(activity.timestamp).toLocaleTimeString('en-US', {
          hour: 'numeric',
          minute: '2-digit',
          hour12: true
        });
        const opSymbol = this._getOperatorSymbol(activity.op);
        const actionClass = activity.action || 'update';
        const canUndo = activity.canReverse && activity.reverseData;

        timelineHtml += `
          <div class="history-item history-item-full" data-activity-id="${activity.id}">
            <span class="history-item-time">${time}</span>
            <span class="history-item-op ${actionClass}" title="${activity.op || ''}">${opSymbol}</span>
            <div class="history-item-content">
              <span class="history-item-action">${this._getHistoryActionText(activity)}</span>
              ${activity.details ? `<span class="history-item-details">${this._escapeHtml(activity.details)}</span>` : ''}
            </div>
            ${canUndo ? `<button class="history-item-undo" data-activity-id="${activity.id}" title="Undo">
              <i class="ph ph-arrow-counter-clockwise"></i>
            </button>` : ''}
          </div>
        `;
      }

      timelineHtml += `
          </div>
        </div>
      `;
    }

    const modalContent = `
      <div class="set-history-modal">
        <div class="set-history-modal-header">
          <div class="set-history-modal-stats">
            <span><strong>${activities.length}</strong> changes tracked</span>
            ${set.createdAt ? `<span>Created ${this._formatTimeAgo(set.createdAt)}</span>` : ''}
          </div>
        </div>
        <div class="set-history-modal-timeline">
          ${activities.length > 0 ? timelineHtml : `
            <div class="set-history-empty">
              <i class="ph ph-clock"></i>
              <span>No history recorded yet</span>
            </div>
          `}
        </div>
      </div>
    `;

    this._showModal(`History: ${set.name}`, modalContent, null, {
      showCancel: false,
      confirmText: 'Close',
      width: '600px'
    });

    // Attach undo handlers
    setTimeout(() => {
      document.querySelectorAll('.history-item-undo').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const activityId = btn.dataset.activityId;
          this._reverseActivity(activityId);
          this._closeModal();
        });
      });
    }, 100);
  }

  _getFieldEventDetails(event) {
    if (!event.changes) return event.type.replace('field.', '');

    const parts = [];
    if (event.changes.name) {
      if (typeof event.changes.name === 'object') {
        parts.push(`renamed: "${event.changes.name.from}" → "${event.changes.name.to}"`);
      } else {
        parts.push(`name: ${event.changes.name}`);
      }
    }
    if (event.changes.type) {
      if (typeof event.changes.type === 'object') {
        parts.push(`type: ${event.changes.type.from} → ${event.changes.type.to}`);
      } else {
        parts.push(`type: ${event.changes.type}`);
      }
    }
    if (event.changes.description) {
      parts.push('description updated');
    }
    return parts.join(', ') || event.type.replace('field.', '');
  }

  _getActivityActionBadge(action) {
    const badges = {
      create: '<span class="activity-action-badge create"><i class="ph ph-plus"></i> Created</span>',
      update: '<span class="activity-action-badge update"><i class="ph ph-pencil-simple"></i> Updated</span>',
      delete: '<span class="activity-action-badge delete"><i class="ph ph-trash"></i> Deleted</span>',
      restore: '<span class="activity-action-badge restore"><i class="ph ph-arrow-counter-clockwise"></i> Restored</span>'
    };
    return badges[action] || `<span class="activity-action-badge">${action}</span>`;
  }

  _getActivityTypeBadge(entityType) {
    const icons = {
      source: 'ph-file-csv',
      set: 'ph-table',
      view: 'ph-eye',
      field: 'ph-columns',
      record: 'ph-rows',
      lens: 'ph-funnel'
    };
    const icon = icons[entityType] || 'ph-circle';
    return `<span class="activity-type-badge"><i class="ph ${icon}"></i> ${entityType}</span>`;
  }

  /**
   * Reverse an activity (undo it)
   */
  _reverseActivity(activityId) {
    // Find the activity
    const allActivities = this._collectAllActivities();
    const activity = allActivities.find(a => a.id === activityId);

    if (!activity || !activity.reverseData) {
      this._showToast('Cannot undo this action', 'warning');
      return;
    }

    const reverseData = activity.reverseData;

    switch (reverseData.type) {
      case 'restore_tossed':
        // Find and restore the tossed item
        const tossedIndex = this.tossedItems.findIndex(t => {
          if (reverseData.item.type === 'source') return t.source?.id === reverseData.item.source?.id;
          if (reverseData.item.type === 'set') return t.set?.id === reverseData.item.set?.id;
          if (reverseData.item.type === 'view') return t.view?.id === reverseData.item.view?.id;
          if (reverseData.item.type === 'field') return t.field?.id === reverseData.item.field?.id;
          if (reverseData.item.type === 'record') return t.record?.id === reverseData.item.record?.id;
          return false;
        });
        if (tossedIndex !== -1) {
          // _restoreTossedItem now records the restore activity automatically
          this._restoreTossedItem(tossedIndex);
        }
        break;

      case 'delete_record':
        // Re-delete a restored record
        if (reverseData.recordId) {
          this.deleteRecord(reverseData.recordId, true);
        }
        break;

      case 'create_record':
        // Delete a created record
        if (reverseData.recordId && reverseData.setId) {
          const set = this.sets.find(s => s.id === reverseData.setId);
          if (set) {
            const index = set.records.findIndex(r => r.id === reverseData.recordId);
            if (index !== -1) {
              set.records.splice(index, 1);
              this._saveData();
              this._renderView();
              this._showToast('Record removed', 'success');
            }
          }
        }
        break;

      case 'update_field':
        // Revert field update - can be either a record value update or a field property update
        if (reverseData.setId && reverseData.fieldId) {
          const set = this.sets.find(s => s.id === reverseData.setId);
          if (set) {
            // Check if this is a record value update (has recordId)
            if (reverseData.recordId) {
              const record = set.records.find(r => r.id === reverseData.recordId);
              if (record && reverseData.previousValue !== undefined) {
                record.values[reverseData.fieldId] = reverseData.previousValue;
                record.updatedAt = new Date().toISOString();
                this._saveData();
                this._renderView();
                this._showToast('Cell value reverted', 'success');
              }
            } else if (reverseData.property && reverseData.previousValue !== undefined) {
              // This is a field schema property update
              const field = set.fields.find(f => f.id === reverseData.fieldId);
              if (field) {
                field[reverseData.property] = reverseData.previousValue;
                this._saveData();
                this._renderView();
                this._showToast('Field reverted', 'success');
              }
            }
          }
        }
        break;

      default:
        this._showToast('Cannot undo this action type', 'warning');
        return;
    }

    this._renderActivityPanel();
  }

  // --------------------------------------------------------------------------
  // Sync Panel (Cloud API Configuration)
  // --------------------------------------------------------------------------

  _initSyncAPI() {
    // Initialize sync API if not already done
    if (!this.syncAPI && typeof initSyncAPI === 'function') {
      this.syncAPI = initSyncAPI(getEventStore());

      // Subscribe to sync status updates
      this.syncAPI.subscribe(({ event, status }) => {
        this._updateSyncStatusBadge(status);
        if (event === 'sync_completed') {
          this._renderSyncPanel();
        }
      });
    }
    return this.syncAPI;
  }

  _showSyncPanel() {
    this._initSyncAPI();

    // Use the new sync wizard for a step-by-step experience
    if (typeof EOSyncWizard !== 'undefined' && this.syncAPI) {
      const wizard = new EOSyncWizard(this.syncAPI);
      wizard.show();
      return;
    }

    // Fallback to old panel if wizard not available
    const panel = document.getElementById('sync-panel');
    if (panel) {
      panel.style.display = 'flex';
      this._renderSyncPanel();
    }

    // Add backdrop click to close
    const backdrop = document.createElement('div');
    backdrop.className = 'sync-panel-backdrop';
    backdrop.id = 'sync-panel-backdrop';
    backdrop.addEventListener('click', () => this._hideSyncPanel());
    document.body.appendChild(backdrop);
  }

  _hideSyncPanel() {
    const panel = document.getElementById('sync-panel');
    if (panel) {
      panel.style.display = 'none';
    }

    const backdrop = document.getElementById('sync-panel-backdrop');
    if (backdrop) {
      backdrop.remove();
    }
  }

  _renderSyncPanel() {
    const syncAPI = this._initSyncAPI();
    if (!syncAPI) return;

    const status = syncAPI.getStatus();

    // Populate form fields
    const endpointInput = document.getElementById('sync-endpoint');
    const tokenInput = document.getElementById('sync-auth-token');
    const workspaceInput = document.getElementById('sync-workspace-id');
    const enabledCheckbox = document.getElementById('sync-enabled');

    if (endpointInput) endpointInput.value = syncAPI.config.endpoint || '';
    if (tokenInput) tokenInput.value = syncAPI.config.authToken || '';
    if (workspaceInput) workspaceInput.value = syncAPI.config.workspaceId || 'default';
    if (enabledCheckbox) enabledCheckbox.checked = syncAPI.config.enabled || false;

    // Update status indicator
    this._updateSyncStatusIndicator(status);

    // Update last sync info
    this._updateSyncLastInfo(status);

    // Update sync now button
    this._updateSyncNowButton();

    // Show/hide error
    const errorEl = document.getElementById('sync-error');
    const errorMsgEl = document.getElementById('sync-error-message');
    if (errorEl && errorMsgEl) {
      if (status.lastError) {
        errorEl.style.display = 'flex';
        errorMsgEl.textContent = status.lastError;
      } else {
        errorEl.style.display = 'none';
      }
    }
  }

  _updateSyncStatusIndicator(status) {
    const indicator = document.getElementById('sync-status-indicator');
    if (!indicator) return;

    let icon, text, className;

    if (status.syncInProgress) {
      icon = 'ph-arrows-clockwise';
      text = 'Syncing...';
      className = 'syncing';
    } else if (status.lastError) {
      icon = 'ph-warning-circle';
      text = 'Sync error';
      className = 'error';
    } else if (status.configured) {
      icon = 'ph-cloud-check';
      text = 'Connected';
      className = 'configured';
    } else {
      icon = 'ph-cloud-slash';
      text = 'Not configured';
      className = 'not-configured';
    }

    indicator.innerHTML = `<i class="ph ${icon}"></i><span>${text}</span>`;
    indicator.className = `sync-status-indicator ${className}`;
  }

  _updateSyncLastInfo(status) {
    const infoEl = document.getElementById('sync-last-info');
    if (!infoEl) return;

    if (status.lastSync?.timestamp) {
      infoEl.style.display = 'block';

      const timeEl = document.getElementById('sync-last-time');
      const pushedEl = document.getElementById('sync-pushed-count');
      const pulledEl = document.getElementById('sync-pulled-count');
      const localEl = document.getElementById('sync-local-count');

      if (timeEl) timeEl.textContent = this._formatTimeAgo(status.lastSync.timestamp);
      if (pushedEl) pushedEl.textContent = status.lastSync.pushedCount || 0;
      if (pulledEl) pulledEl.textContent = status.lastSync.pulledCount || 0;
      if (localEl) localEl.textContent = status.localEventCount || 0;
    } else {
      infoEl.style.display = 'none';
    }
  }

  _updateSyncNowButton() {
    const syncNowBtn = document.getElementById('sync-now');
    const enabledCheckbox = document.getElementById('sync-enabled');
    const endpointInput = document.getElementById('sync-endpoint');
    const tokenInput = document.getElementById('sync-auth-token');

    if (syncNowBtn) {
      const hasEndpoint = endpointInput?.value?.trim();
      const hasToken = tokenInput?.value?.trim();
      const isEnabled = enabledCheckbox?.checked;

      syncNowBtn.disabled = !(hasEndpoint && hasToken && isEnabled);
    }
  }

  _updateSyncStatusBadge(status) {
    const badge = document.getElementById('sync-status-badge');
    if (!badge) return;

    let iconClass, badgeClass;

    if (status.syncInProgress) {
      iconClass = 'ph-arrows-clockwise';
      badgeClass = 'syncing';
    } else if (status.lastError) {
      iconClass = 'ph-x-circle';
      badgeClass = 'error';
    } else if (status.configured) {
      iconClass = 'ph-check-circle';
      badgeClass = 'synced';
    } else {
      iconClass = 'ph-cloud-slash';
      badgeClass = 'pending';
    }

    badge.innerHTML = `<i class="ph ${iconClass}"></i>`;
    badge.className = `sync-badge ${badgeClass}`;
  }

  _toggleSyncTokenVisibility() {
    const tokenInput = document.getElementById('sync-auth-token');
    const toggleBtn = document.getElementById('sync-token-toggle');

    if (tokenInput && toggleBtn) {
      if (tokenInput.type === 'password') {
        tokenInput.type = 'text';
        toggleBtn.innerHTML = '<i class="ph ph-eye-slash"></i>';
      } else {
        tokenInput.type = 'password';
        toggleBtn.innerHTML = '<i class="ph ph-eye"></i>';
      }
    }
  }

  _saveSyncConfig() {
    const syncAPI = this._initSyncAPI();
    if (!syncAPI) {
      this._showToast('Sync API not available', 'error');
      return;
    }

    const endpoint = document.getElementById('sync-endpoint')?.value?.trim();
    const authToken = document.getElementById('sync-auth-token')?.value?.trim();
    const workspaceId = document.getElementById('sync-workspace-id')?.value?.trim() || 'default';
    const enabled = document.getElementById('sync-enabled')?.checked || false;

    syncAPI.configure({
      endpoint,
      authToken,
      workspaceId,
      enabled
    });

    this._updateSyncStatusBadge(syncAPI.getStatus());
    this._showToast('Sync configuration saved', 'success');
    this._hideSyncPanel();
  }

  async _testSyncConnection() {
    const syncAPI = this._initSyncAPI();
    if (!syncAPI) {
      this._showToast('Sync API not available', 'error');
      return;
    }

    // Temporarily apply the current form values for testing
    const endpoint = document.getElementById('sync-endpoint')?.value?.trim();
    const authToken = document.getElementById('sync-auth-token')?.value?.trim();
    const workspaceId = document.getElementById('sync-workspace-id')?.value?.trim() || 'default';

    if (!endpoint || !authToken) {
      this._showToast('Please enter endpoint and auth token', 'warning');
      return;
    }

    // Save current config temporarily
    const originalConfig = { ...syncAPI.config };

    // Apply test config
    syncAPI.config.endpoint = endpoint;
    syncAPI.config.authToken = authToken;
    syncAPI.config.workspaceId = workspaceId;

    const testBtn = document.getElementById('sync-test-connection');
    if (testBtn) {
      testBtn.disabled = true;
      testBtn.innerHTML = '<i class="ph ph-spinner ph-spin"></i> Testing...';
    }

    try {
      const result = await syncAPI.testConnection();

      if (result.success) {
        this._showToast('Connection successful!', 'success');
      } else {
        this._showToast(`Connection failed: ${result.error}`, 'error');
      }
    } catch (error) {
      this._showToast(`Connection error: ${error.message}`, 'error');
    } finally {
      // Restore original config (user must click Save to persist)
      syncAPI.config = originalConfig;

      if (testBtn) {
        testBtn.disabled = false;
        testBtn.innerHTML = '<i class="ph ph-plugs"></i> Test Connection';
      }
    }
  }

  async _triggerSync() {
    const syncAPI = this._initSyncAPI();
    if (!syncAPI) {
      this._showToast('Sync API not available', 'error');
      return;
    }

    if (!syncAPI.isConfigured()) {
      this._showToast('Please configure and enable sync first', 'warning');
      return;
    }

    const syncNowBtn = document.getElementById('sync-now');
    if (syncNowBtn) {
      syncNowBtn.disabled = true;
      syncNowBtn.innerHTML = '<i class="ph ph-arrows-clockwise ph-spin"></i> Syncing...';
    }

    this._updateSyncStatusBadge({ syncInProgress: true });

    try {
      const result = await syncAPI.sync();

      if (result.success) {
        this._showToast(`Synced: ${result.pushed} pushed, ${result.applied} new events applied`, 'success');
      } else {
        const errorMsg = result.errors.length > 0 ? result.errors[0].error : 'Unknown error';
        this._showToast(`Sync failed: ${errorMsg}`, 'error');
      }

      // Refresh panel
      this._renderSyncPanel();
    } catch (error) {
      this._showToast(`Sync error: ${error.message}`, 'error');
    } finally {
      if (syncNowBtn) {
        syncNowBtn.disabled = false;
        syncNowBtn.innerHTML = '<i class="ph ph-arrows-clockwise"></i> Sync Now';
      }

      this._updateSyncStatusBadge(syncAPI.getStatus());
    }
  }

  // --------------------------------------------------------------------------
  // Bulk Operations
  // --------------------------------------------------------------------------

  _selectAll() {
    const set = this.getCurrentSet();
    if (!set) return;

    set.records.forEach(r => this.selectedRecords.add(r.id));
    this._renderTableView();
    this._updateBulkActionsToolbar();
  }

  _clearSelection() {
    this.selectedRecords.clear();
    this._renderView();  // Use _renderView() to handle any view type
    this._updateBulkActionsToolbar();
  }

  _updateBulkActionsToolbar() {
    const toolbar = document.getElementById('bulk-actions-toolbar');
    const countEl = document.getElementById('bulk-selected-count');

    if (!toolbar) return;

    // Only count records that exist in the current set
    const set = this.getCurrentSet();
    const currentSetRecordIds = new Set(set?.records?.map(r => r.id) || []);
    const validSelectedCount = [...this.selectedRecords].filter(id => currentSetRecordIds.has(id)).length;

    if (validSelectedCount > 0) {
      toolbar.style.display = 'flex';
      if (countEl) {
        countEl.textContent = `${validSelectedCount} selected`;
      }
    } else {
      toolbar.style.display = 'none';
      // Clean up any stale selections
      if (this.selectedRecords.size > 0 && validSelectedCount === 0) {
        this.selectedRecords.clear();
      }
    }
  }

  _bulkDuplicate() {
    if (this.selectedRecords.size === 0) return;

    const count = this.selectedRecords.size;
    this.selectedRecords.forEach(id => {
      this.duplicateRecord(id);
    });

    this._showToast(`Duplicated ${count} record${count !== 1 ? 's' : ''}`, 'success');
  }

  _bulkExport() {
    if (this.selectedRecords.size === 0) return;

    const set = this.getCurrentSet();
    if (!set) return;

    const selectedRecords = set.records.filter(r => this.selectedRecords.has(r.id));

    // Show export format selection dialog
    if (typeof showExportDialog === 'function') {
      showExportDialog({
        name: set.name,
        fields: set.fields,
        records: selectedRecords,
        allSets: this.sets, // For multi-tab Excel export option
        onExport: (result) => {
          this._showToast(
            `Exported ${result.recordCount} record${result.recordCount !== 1 ? 's' : ''} to ${result.format.toUpperCase()}`,
            'success'
          );
        }
      });
    } else {
      // Fallback to JSON export if dialog not available
      const exportData = {
        setName: set.name,
        fields: set.fields,
        records: selectedRecords,
        exportedAt: new Date().toISOString()
      };

      const json = JSON.stringify(exportData, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = `${set.name}_export_${new Date().toISOString().split('T')[0]}.json`;
      a.click();

      URL.revokeObjectURL(url);
      this._showToast(`Exported ${this.selectedRecords.size} record${this.selectedRecords.size !== 1 ? 's' : ''}`, 'success');
    }
  }

  _bulkDelete() {
    if (this.selectedRecords.size === 0) return;

    const count = this.selectedRecords.size;
    const idsToDelete = [...this.selectedRecords];
    idsToDelete.forEach(id => this.deleteRecord(id));

    this.selectedRecords.clear();
    this._updateBulkActionsToolbar();
    this._showToast(`Tossed ${count} record${count !== 1 ? 's' : ''}`, 'info');
  }

  // --------------------------------------------------------------------------
  // Toast Notifications
  // --------------------------------------------------------------------------

  _showToast(message, type = 'info', options = {}) {
    let container = document.querySelector('.toast-container');
    if (!container) {
      container = document.createElement('div');
      container.className = 'toast-container';
      document.body.appendChild(container);
    }

    const icons = {
      success: 'ph-check-circle',
      error: 'ph-x-circle',
      warning: 'ph-warning',
      info: 'ph-info'
    };

    const toast = document.createElement('div');
    toast.className = `toast ${type}${options.action ? ' has-action' : ''}`;

    let actionHtml = '';
    if (options.action) {
      actionHtml = `<button class="toast-action">${this._escapeHtml(options.action.label)}</button>`;
    }

    let progressHtml = '';
    if (options.countdown) {
      progressHtml = `<div class="toast-progress"><div class="toast-progress-bar"></div></div>`;
    }

    toast.innerHTML = `
      <i class="ph ${icons[type] || 'ph-info'} toast-icon"></i>
      <span class="toast-message">${this._escapeHtml(message)}</span>
      ${actionHtml}
      <button class="toast-close"><i class="ph ph-x"></i></button>
      ${progressHtml}
    `;

    container.appendChild(toast);

    // Action button handler
    if (options.action) {
      toast.querySelector('.toast-action').addEventListener('click', () => {
        options.action.callback();
        toast.classList.add('toast-out');
        setTimeout(() => toast.remove(), 300);
      });
    }

    // Start countdown animation if specified
    if (options.countdown) {
      const progressBar = toast.querySelector('.toast-progress-bar');
      progressBar.style.animation = `toast-countdown ${options.countdown}ms linear`;
    }

    toast.querySelector('.toast-close').addEventListener('click', () => {
      toast.classList.add('toast-out');
      setTimeout(() => toast.remove(), 300);
    });

    const duration = options.duration || (options.countdown ? options.countdown : 4000);
    setTimeout(() => {
      if (toast.parentElement) {
        toast.classList.add('toast-out');
        setTimeout(() => toast.remove(), 300);
      }
    }, duration);

    return toast;
  }

  // --------------------------------------------------------------------------
  // Loading Overlay
  // --------------------------------------------------------------------------

  /**
   * Show a loading overlay in the content area
   * @param {string} message - Loading message to display
   * @param {object} options - Options for the loading overlay
   * @param {boolean} options.showProgress - Whether to show a progress bar
   * @param {number} options.progress - Current progress percentage (0-100)
   */
  _showLoadingOverlay(message = 'Loading...', options = {}) {
    // Remove existing loading overlay if any
    this._hideLoadingOverlay();

    const overlay = document.createElement('div');
    overlay.className = 'loading-overlay';
    overlay.id = 'loading-overlay';

    let progressHtml = '';
    if (options.showProgress) {
      progressHtml = `
        <div class="loading-progress-container">
          <div class="loading-progress-bar" id="loading-progress-bar" style="width: ${options.progress || 0}%"></div>
        </div>
        <p class="loading-progress-text" id="loading-progress-text">${options.progressText || ''}</p>
      `;
    }

    overlay.innerHTML = `
      <div class="loading-content">
        <div class="loading-spinner">
          <i class="ph ph-spinner ph-spin"></i>
        </div>
        <p class="loading-text">${this._escapeHtml(message)}</p>
        ${progressHtml}
      </div>
    `;

    this.elements.contentArea?.appendChild(overlay);
    return overlay;
  }

  /**
   * Update the loading overlay progress
   * @param {number} progress - Progress percentage (0-100)
   * @param {string} text - Optional text to display
   */
  _updateLoadingProgress(progress, text = null) {
    const progressBar = document.getElementById('loading-progress-bar');
    const progressText = document.getElementById('loading-progress-text');

    if (progressBar) {
      progressBar.style.width = `${progress}%`;
    }
    if (progressText && text !== null) {
      progressText.textContent = text;
    }
  }

  /**
   * Hide the loading overlay
   */
  _hideLoadingOverlay() {
    const overlay = document.getElementById('loading-overlay');
    if (overlay) {
      overlay.remove();
    }
  }

  // --------------------------------------------------------------------------
  // Set Tag Selector (filter sets by tag in header)
  // --------------------------------------------------------------------------

  _toggleSetTagDropdown() {
    const dropdown = document.getElementById('set-tag-dropdown');
    if (dropdown) {
      const isVisible = dropdown.style.display !== 'none';
      if (!isVisible) {
        this._renderSetTagDropdown();
      }
      dropdown.style.display = isVisible ? 'none' : 'block';
    }
  }

  _hideSetTagDropdown() {
    const dropdown = document.getElementById('set-tag-dropdown');
    if (dropdown) {
      dropdown.style.display = 'none';
    }
  }

  _renderSetTagDropdown() {
    const dropdown = document.getElementById('set-tag-dropdown');
    if (!dropdown) return;

    // Collect all unique tags from sets
    const allTags = new Set();
    this.sets.forEach(set => {
      if (set.tags) {
        set.tags.forEach(tag => allTags.add(tag));
      }
    });

    const tagsArray = Array.from(allTags).sort();

    dropdown.innerHTML = `
      <div class="set-tag-option ${!this.currentSetTagFilter ? 'active' : ''}" data-tag="">
        <i class="ph ph-squares-four"></i>
        <span>All Sets</span>
      </div>
      ${tagsArray.map(tag => `
        <div class="set-tag-option ${this.currentSetTagFilter === tag ? 'active' : ''}" data-tag="${this._escapeHtml(tag)}">
          <i class="ph ph-tag"></i>
          <span>${this._escapeHtml(tag)}</span>
        </div>
      `).join('')}
    `;

    // Attach click handlers
    dropdown.querySelectorAll('.set-tag-option').forEach(option => {
      option.addEventListener('click', () => {
        this.currentSetTagFilter = option.dataset.tag || null;
        this._hideSetTagDropdown();
        this._updateSetTagLabel();
        this._renderSetsNavFlat();
      });
    });
  }

  _updateSetTagLabel() {
    const label = document.querySelector('.set-tag-label');
    if (label) {
      label.textContent = this.currentSetTagFilter || 'All Sets';
    }
  }

  // --------------------------------------------------------------------------
  // Advanced Filter Panel
  // --------------------------------------------------------------------------

  _toggleFilterPanel() {
    const panel = document.getElementById('filter-panel');
    if (!panel) return;

    if (panel.style.display === 'none') {
      this._showFilterPanel();
    } else {
      this._hideFilterPanel();
    }
  }

  _showFilterPanel() {
    const panel = document.getElementById('filter-panel');
    if (!panel) return;

    // Close other panels if open
    this._hideSortPanel();
    this._hideFieldsPanel();

    panel.style.display = 'block';

    // Initialize with one empty filter if none exist
    const filterGroups = document.getElementById('filter-groups');
    if (filterGroups && filterGroups.children.length === 0) {
      this._addFilterRow();
    }
  }

  _hideFilterPanel() {
    const panel = document.getElementById('filter-panel');
    if (panel) {
      panel.style.display = 'none';
    }
  }

  _addFilterRow() {
    const container = document.getElementById('filter-groups');
    if (!container) return;

    const set = this.getCurrentSet();
    const fields = set?.fields || [];

    const row = document.createElement('div');
    row.className = 'filter-row';
    row.innerHTML = `
      <select class="filter-field">
        <option value="">Select field...</option>
        ${fields.map(f => `<option value="${f.id}">${this._escapeHtml(f.name)}</option>`).join('')}
      </select>
      <select class="filter-operator">
        <option value="contains">contains</option>
        <option value="equals">equals</option>
        <option value="not_equals">does not equal</option>
        <option value="is_empty">is empty</option>
        <option value="is_not_empty">is not empty</option>
        <option value="greater_than">greater than</option>
        <option value="less_than">less than</option>
      </select>
      <input type="text" class="filter-value" placeholder="Value...">
      <button class="filter-remove-btn" title="Remove filter">
        <i class="ph ph-x"></i>
      </button>
    `;

    row.querySelector('.filter-remove-btn').addEventListener('click', () => row.remove());

    // Hide value input for is_empty/is_not_empty
    row.querySelector('.filter-operator').addEventListener('change', (e) => {
      const valueInput = row.querySelector('.filter-value');
      if (e.target.value === 'is_empty' || e.target.value === 'is_not_empty') {
        valueInput.style.display = 'none';
      } else {
        valueInput.style.display = 'block';
      }
    });

    container.appendChild(row);
  }

  _applyFilters() {
    const view = this.getCurrentView();
    if (!view) return;

    // Ensure view.config exists (defensive check for legacy data)
    if (!view.config) view.config = {};

    const rows = document.querySelectorAll('#filter-groups .filter-row');
    const logic = document.getElementById('filter-logic')?.value || 'and';

    view.config.filters = [];
    view.config.filterLogic = logic;

    rows.forEach(row => {
      const fieldId = row.querySelector('.filter-field')?.value;
      const operator = row.querySelector('.filter-operator')?.value;
      const value = row.querySelector('.filter-value')?.value;

      if (fieldId) {
        view.config.filters.push({ fieldId, operator, filterValue: value });
      }
    });

    this._hideFilterPanel();
    this._renderView();
    this._saveData();

    const count = view.config.filters.length;
    if (count > 0) {
      // Record activity for applying filters
      this._recordActivity({
        action: 'filter',
        entityType: 'view',
        name: view.name,
        details: `Applied ${count} filter${count !== 1 ? 's' : ''} to view "${view.name}"`,
        canReverse: false
      });
      this._showToast(`Applied ${count} filter${count !== 1 ? 's' : ''}`, 'info');
    }
  }

  _clearFilters() {
    const view = this.getCurrentView();
    if (view) {
      if (!view.config) view.config = {};
      const hadFilters = (view.config.filters?.length || 0) > 0;
      view.config.filters = [];
      view.config.filterLogic = 'and';

      if (hadFilters) {
        // Record activity for clearing filters
        this._recordActivity({
          action: 'filter',
          entityType: 'view',
          name: view.name,
          details: `Cleared all filters from view "${view.name}"`,
          canReverse: false
        });
      }
    }

    const container = document.getElementById('filter-groups');
    if (container) {
      container.innerHTML = '';
    }

    this._hideFilterPanel();
    this._renderView();
    this._saveData();
  }

  // --------------------------------------------------------------------------
  // Sort Panel
  // --------------------------------------------------------------------------

  _toggleSortPanel() {
    const panel = document.getElementById('sort-panel');
    if (!panel) return;

    if (panel.style.display === 'none') {
      this._showSortPanel();
    } else {
      this._hideSortPanel();
    }
  }

  _showSortPanel() {
    const panel = document.getElementById('sort-panel');
    if (!panel) return;

    // Close other panels if open
    this._hideFilterPanel();
    this._hideFieldsPanel();

    panel.style.display = 'block';

    // Initialize with one empty sort if none exist
    const sortRules = document.getElementById('sort-rules');
    if (sortRules && sortRules.children.length === 0) {
      this._addSortRow();
    }
  }

  _hideSortPanel() {
    const panel = document.getElementById('sort-panel');
    if (panel) {
      panel.style.display = 'none';
    }
  }

  _addSortRow() {
    const container = document.getElementById('sort-rules');
    if (!container) return;

    const set = this.getCurrentSet();
    const fields = set?.fields || [];

    const row = document.createElement('div');
    row.className = 'sort-row';
    row.innerHTML = `
      <select class="sort-field">
        <option value="">Select field...</option>
        ${fields.map(f => `<option value="${f.id}">${this._escapeHtml(f.name)}</option>`).join('')}
      </select>
      <select class="sort-direction">
        <option value="asc">Ascending (A-Z)</option>
        <option value="desc">Descending (Z-A)</option>
      </select>
      <button class="sort-remove-btn" title="Remove sort">
        <i class="ph ph-x"></i>
      </button>
    `;

    row.querySelector('.sort-remove-btn').addEventListener('click', () => row.remove());

    container.appendChild(row);
  }

  _applySorts() {
    const view = this.getCurrentView();
    if (!view) return;

    // Ensure view.config exists (defensive check for legacy data)
    if (!view.config) view.config = {};

    const rows = document.querySelectorAll('#sort-rules .sort-row');

    view.config.sorts = [];

    rows.forEach(row => {
      const fieldId = row.querySelector('.sort-field')?.value;
      const direction = row.querySelector('.sort-direction')?.value;

      if (fieldId) {
        view.config.sorts.push({ fieldId, direction });
      }
    });

    this._hideSortPanel();
    this._renderView();
    this._saveData();

    const count = view.config.sorts.length;
    if (count > 0) {
      // Record activity for applying sorts
      this._recordActivity({
        action: 'filter',
        entityType: 'view',
        name: view.name,
        details: `Applied ${count} sort${count !== 1 ? 's' : ''} to view "${view.name}"`,
        canReverse: false
      });
      this._showToast(`Applied ${count} sort${count !== 1 ? 's' : ''}`, 'info');
    }
  }

  _clearSorts() {
    const view = this.getCurrentView();
    if (view) {
      if (!view.config) view.config = {};
      const hadSorts = (view.config.sorts?.length || 0) > 0;
      view.config.sorts = [];

      if (hadSorts) {
        // Record activity for clearing sorts
        this._recordActivity({
          action: 'filter',
          entityType: 'view',
          name: view.name,
          details: `Cleared all sorts from view "${view.name}"`,
          canReverse: false
        });
      }
    }

    const container = document.getElementById('sort-rules');
    if (container) {
      container.innerHTML = '';
    }

    this._hideSortPanel();
    this._renderView();
    this._saveData();
  }

  // --------------------------------------------------------------------------
  // Fields Panel (Visibility & Reordering)
  // --------------------------------------------------------------------------

  _toggleFieldsPanel() {
    const panel = document.getElementById('fields-panel');
    if (!panel) return;

    if (panel.style.display === 'none') {
      this._showFieldsPanel();
    } else {
      this._hideFieldsPanel();
    }
  }

  _showFieldsPanel() {
    const panel = document.getElementById('fields-panel');
    if (!panel) return;

    // Close other panels if open
    this._hideFilterPanel();
    this._hideSortPanel();

    panel.style.display = 'block';
    this._renderFieldsList();
  }

  _hideFieldsPanel() {
    const panel = document.getElementById('fields-panel');
    if (panel) {
      panel.style.display = 'none';
    }
  }

  _renderFieldsList() {
    const container = document.getElementById('fields-list');
    if (!container) return;

    const set = this.getCurrentSet();
    const view = this.getCurrentView();
    if (!set) return;

    // Get all fields and determine their order
    let fields = [...set.fields];
    const hiddenFields = view?.config.hiddenFields || [];
    const fieldOrder = view?.config.fieldOrder || [];

    // Sort fields by the stored order, with unordered fields at the end
    if (fieldOrder.length > 0) {
      fields.sort((a, b) => {
        const aIndex = fieldOrder.indexOf(a.id);
        const bIndex = fieldOrder.indexOf(b.id);
        if (aIndex === -1 && bIndex === -1) return 0;
        if (aIndex === -1) return 1;
        if (bIndex === -1) return -1;
        return aIndex - bIndex;
      });
    }

    container.innerHTML = fields.map(field => {
      const isHidden = hiddenFields.includes(field.id);
      const isPrimary = field.isPrimary;

      return `
        <div class="field-item ${isHidden ? 'hidden-field' : ''}"
             data-field-id="${field.id}"
             draggable="true">
          <div class="field-item-drag-handle">
            <i class="ph ph-dots-six-vertical"></i>
          </div>
          <div class="field-item-icon">
            <i class="ph ${FieldTypeIcons[field.type] || 'ph-text-aa'}"></i>
          </div>
          <span class="field-item-name">${this._escapeHtml(field.name)}</span>
          ${isPrimary ? '<span class="field-item-primary-badge">Primary</span>' : ''}
          <button class="field-item-visibility-btn ${isHidden ? 'hidden' : 'visible'}"
                  data-field-id="${field.id}"
                  ${isPrimary ? 'disabled title="Primary field cannot be hidden"' : ''}>
            <i class="ph ${isHidden ? 'ph-eye-slash' : 'ph-eye'}"></i>
          </button>
        </div>
      `;
    }).join('');

    // Attach drag and drop handlers
    this._attachFieldsDragHandlers(container);

    // Attach visibility toggle handlers
    container.querySelectorAll('.field-item-visibility-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const fieldId = btn.dataset.fieldId;
        this._toggleFieldVisibility(fieldId);
      });
    });
  }

  _attachFieldsDragHandlers(container) {
    let draggedItem = null;

    container.querySelectorAll('.field-item').forEach(item => {
      item.addEventListener('dragstart', (e) => {
        draggedItem = item;
        item.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', item.dataset.fieldId);
      });

      item.addEventListener('dragend', () => {
        item.classList.remove('dragging');
        container.querySelectorAll('.field-item').forEach(i => i.classList.remove('drag-over'));
        draggedItem = null;

        // Save the new order
        this._saveFieldOrder();
      });

      item.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';

        if (item !== draggedItem) {
          item.classList.add('drag-over');
        }
      });

      item.addEventListener('dragleave', () => {
        item.classList.remove('drag-over');
      });

      item.addEventListener('drop', (e) => {
        e.preventDefault();
        item.classList.remove('drag-over');

        if (draggedItem && item !== draggedItem) {
          // Determine where to insert based on mouse position
          const rect = item.getBoundingClientRect();
          const midY = rect.top + rect.height / 2;

          if (e.clientY < midY) {
            container.insertBefore(draggedItem, item);
          } else {
            container.insertBefore(draggedItem, item.nextSibling);
          }
        }
      });
    });
  }

  _saveFieldOrder() {
    const view = this.getCurrentView();
    if (!view) return;

    const container = document.getElementById('fields-list');
    if (!container) return;

    // Get the new order from the DOM
    const fieldOrder = Array.from(container.querySelectorAll('.field-item'))
      .map(item => item.dataset.fieldId);

    view.config.fieldOrder = fieldOrder;
    this._saveData();
    this._renderView();
  }

  _toggleFieldVisibility(fieldId) {
    const view = this.getCurrentView();
    const set = this.getCurrentSet();
    if (!view || !set) return;

    // Don't allow hiding primary field
    const field = set.fields.find(f => f.id === fieldId);
    if (field?.isPrimary) {
      this._showToast('Cannot hide the primary field', 'warning');
      return;
    }

    if (!view.config.hiddenFields) {
      view.config.hiddenFields = [];
    }

    const index = view.config.hiddenFields.indexOf(fieldId);
    const isHiding = index === -1;
    if (isHiding) {
      view.config.hiddenFields.push(fieldId);
    } else {
      view.config.hiddenFields.splice(index, 1);
    }

    // Record activity for field visibility toggle
    this._recordActivity({
      action: 'filter',
      entityType: 'field',
      name: field?.name || 'Field',
      details: `${isHiding ? 'Hid' : 'Showed'} field "${field?.name || 'Unknown'}" in view "${view.name}"`,
      canReverse: false
    });

    this._saveData();
    this._renderFieldsList();
    this._renderView();
  }

  _showAllFields() {
    const view = this.getCurrentView();
    if (!view) return;

    const hadHiddenFields = (view.config.hiddenFields?.length || 0) > 0;
    view.config.hiddenFields = [];

    if (hadHiddenFields) {
      // Record activity for showing all fields
      this._recordActivity({
        action: 'filter',
        entityType: 'view',
        name: view.name,
        details: `Showed all fields in view "${view.name}"`,
        canReverse: false
      });
    }

    this._saveData();
    this._renderFieldsList();
    this._renderView();
    this._showToast('All fields visible', 'success');
  }

  _hideAllFields() {
    const view = this.getCurrentView();
    const set = this.getCurrentSet();
    if (!view || !set) return;

    // Hide all non-primary fields
    const fieldsToHide = set.fields.filter(f => !f.isPrimary);
    view.config.hiddenFields = fieldsToHide.map(f => f.id);

    // Record activity for hiding all fields
    this._recordActivity({
      action: 'filter',
      entityType: 'view',
      name: view.name,
      details: `Hid ${fieldsToHide.length} field${fieldsToHide.length !== 1 ? 's' : ''} in view "${view.name}"`,
      canReverse: false
    });

    this._saveData();
    this._renderFieldsList();
    this._renderView();
    this._showToast('Non-primary fields hidden', 'success');
  }

  /**
   * Render the Schema Meaning tab showing definition bindings
   * This is the MEANT side of the Schema (as opposed to Structure which is GIVEN)
   */
  _renderSchemaMeaningTab() {
    const container = document.getElementById('schema-meaning-list');
    if (!container) return;

    const set = this.getCurrentSet();
    if (!set) {
      container.innerHTML = '<div class="empty-state-small"><p>No set selected</p></div>';
      return;
    }

    const fields = set.fields || [];

    if (fields.length === 0) {
      container.innerHTML = '<div class="empty-state-small"><p>No fields in this set</p></div>';
      return;
    }

    container.innerHTML = fields.map(field => {
      // Find if field has a definition binding
      const binding = field.definitionBinding || field.semanticBinding;
      const definition = binding ? this.definitions?.find(d => d.id === binding.definitionId) : null;

      return `
        <div class="schema-meaning-field" data-field-id="${field.id}">
          <div class="field-header">
            <span class="field-name">${this._escapeHtml(field.name)}</span>
            ${definition ? `
              <span class="field-definition-link" title="Linked to ${this._escapeHtml(definition.name)}">
                <i class="ph ph-link"></i>
                ${this._escapeHtml(definition.name)}
              </span>
            ` : `
              <button class="btn btn-sm" onclick="getDataWorkbench()?._showDefinitionPicker('${field.id}')">
                <i class="ph ph-plus"></i>
                Add Meaning
              </button>
            `}
          </div>
          ${definition ? `
            <div class="field-explanation">
              ${definition.uri ? `<a href="${this._escapeHtml(definition.uri)}" target="_blank" title="View definition"><i class="ph ph-globe"></i> ${this._escapeHtml(definition.uri)}</a>` : ''}
              ${definition.description ? `<p>${this._escapeHtml(definition.description)}</p>` : '<p class="text-muted">No description</p>'}
            </div>
          ` : `
            <div class="field-explanation text-muted">
              <p>No semantic definition attached. This field's meaning is implicit.</p>
            </div>
          `}
        </div>
      `;
    }).join('');
  }

  // --------------------------------------------------------------------------
  // Global Search
  // --------------------------------------------------------------------------

  _handleSearch(query) {
    if (!query || query.length < 2) {
      this._hideSearchResults();
      this.currentSearchQuery = null;
      return;
    }

    this.currentSearchQuery = query;
    const results = [];
    const lowerQuery = query.toLowerCase();

    // Search across all sets and records
    this.sets.forEach(set => {
      // Search set name
      if (set.name.toLowerCase().includes(lowerQuery)) {
        results.push({ type: 'set', id: set.id, name: set.name, icon: 'ph-table', matchedField: null });
      }

      // Search records - check ALL fields, not just primary
      set.records.forEach(record => {
        const primaryField = set.fields.find(f => f.isPrimary) || set.fields[0];
        const primaryValue = record.values[primaryField?.id] || 'Untitled';
        let matchedField = null;
        let matchedValue = null;

        // Check each field for matches
        for (const field of set.fields) {
          const value = record.values[field.id];
          if (value && String(value).toLowerCase().includes(lowerQuery)) {
            matchedField = field;
            matchedValue = String(value);
            break;
          }
        }

        if (matchedField) {
          results.push({
            type: 'record',
            id: record.id,
            setId: set.id,
            name: primaryValue,
            setName: set.name,
            icon: 'ph-note',
            matchedField: matchedField.name,
            matchedValue: matchedValue,
            query: query
          });
        }
      });
    });

    this._renderSearchResults(results.slice(0, 15), query);
  }

  _highlightMatch(text, query) {
    if (!text || !query) return this._escapeHtml(text || '');

    const lowerText = text.toLowerCase();
    const lowerQuery = query.toLowerCase();
    const startIndex = lowerText.indexOf(lowerQuery);

    if (startIndex === -1) return this._escapeHtml(text);

    const before = text.substring(0, startIndex);
    const match = text.substring(startIndex, startIndex + query.length);
    const after = text.substring(startIndex + query.length);

    return `${this._escapeHtml(before)}<mark class="search-highlight">${this._escapeHtml(match)}</mark>${this._escapeHtml(after)}`;
  }

  _renderSearchResults(results, query) {
    let dropdown = document.querySelector('.search-results-dropdown');

    if (results.length === 0) {
      // Show "no results" message
      if (!dropdown) {
        dropdown = document.createElement('div');
        dropdown.className = 'search-results-dropdown';
        document.querySelector('.sidebar-search')?.appendChild(dropdown);
      }
      dropdown.innerHTML = `
        <div class="search-no-results">
          <i class="ph ph-magnifying-glass"></i>
          <span>No results found for "${this._escapeHtml(query)}"</span>
        </div>
      `;
      return;
    }

    if (!dropdown) {
      dropdown = document.createElement('div');
      dropdown.className = 'search-results-dropdown';
      document.querySelector('.sidebar-search')?.appendChild(dropdown);
    }

    dropdown.innerHTML = `
      <div class="search-results-header">
        <span>${results.length} result${results.length !== 1 ? 's' : ''}</span>
      </div>
      ${results.map(r => `
        <div class="search-result-item" data-type="${r.type}" data-id="${r.id}" data-set-id="${r.setId || ''}">
          <div class="search-result-icon">
            <i class="ph ${r.icon}"></i>
          </div>
          <div class="search-result-content">
            <span class="result-title">${this._highlightMatch(r.name, query)}</span>
            ${r.matchedField && r.matchedField !== 'Name' ? `
              <span class="result-context">
                <span class="result-field">${this._escapeHtml(r.matchedField)}:</span>
                ${this._highlightMatch(r.matchedValue?.substring(0, 50) + (r.matchedValue?.length > 50 ? '...' : ''), query)}
              </span>
            ` : ''}
            <span class="result-type">${r.type}${r.setName ? ` in ${this._escapeHtml(r.setName)}` : ''}</span>
          </div>
        </div>
      `).join('')}
    `;

    dropdown.querySelectorAll('.search-result-item').forEach(item => {
      item.addEventListener('click', () => {
        const type = item.dataset.type;
        if (type === 'set') {
          this._selectSet(item.dataset.id);
        } else if (type === 'record') {
          if (item.dataset.setId) {
            this._selectSet(item.dataset.setId);
          }
          // Scroll to and highlight the record in the grid
          setTimeout(() => {
            this._highlightRecordInGrid(item.dataset.id);
          }, 100);
          this._showRecordDetail(item.dataset.id);
        }
        this._hideSearchResults();
        document.getElementById('global-search').value = '';
      });
    });
  }

  _highlightRecordInGrid(recordId) {
    // Find and scroll to the record in the grid
    const row = document.querySelector(`tr[data-record-id="${recordId}"]`);
    if (row) {
      row.scrollIntoView({ behavior: 'smooth', block: 'center' });
      row.classList.add('search-highlight-row');
      setTimeout(() => {
        row.classList.remove('search-highlight-row');
      }, 2000);
    }
  }

  _showSearchResults() {
    const dropdown = document.querySelector('.search-results-dropdown');
    const searchWrapper = document.querySelector('.sidebar-search');
    if (searchWrapper) {
      searchWrapper.classList.add('focused');
    }
  }

  _hideSearchResults() {
    const dropdown = document.querySelector('.search-results-dropdown');
    if (dropdown) dropdown.remove();

    const searchWrapper = document.querySelector('.sidebar-search');
    if (searchWrapper) {
      searchWrapper.classList.remove('focused');
    }
  }

  _moveToNextCell(reverse = false) {
    // TODO: Implement cell navigation
  }

  // --------------------------------------------------------------------------
  // EO Integration
  // --------------------------------------------------------------------------

  _createEOEvent(action, data) {
    if (!this.eoApp) return;

    try {
      // Create a Given event for raw data changes
      // Using 'received' mode since this is user input data
      this.eoApp.recordGiven('received', data, { action });
    } catch (e) {
      console.error('Failed to create EO event:', e);
    }
  }

  // --------------------------------------------------------------------------
  // Utilities
  // --------------------------------------------------------------------------

  _escapeHtml(text) {
    if (text == null) return '';
    const div = document.createElement('div');
    div.textContent = String(text);
    return div.innerHTML;
  }

  // --------------------------------------------------------------------------
  // Link/Edge Data Utilities
  // --------------------------------------------------------------------------

  /**
   * Normalize link field value to the new format with edge data support.
   * Handles backward compatibility with old format (simple array of IDs).
   *
   * New format: [{recordId: "id1", edgeData: {...}}, {recordId: "id2", edgeData: {...}}]
   * Old format: ["id1", "id2"] or "id1" (single value)
   *
   * @param {*} value - The raw link field value
   * @returns {Array} Normalized array of link objects
   */
  _normalizeLinkValue(value) {
    if (!value) return [];

    // Single string value (legacy)
    if (typeof value === 'string') {
      return [{ recordId: value, edgeData: {} }];
    }

    // Array value
    if (Array.isArray(value)) {
      return value.map(item => {
        // New format: already an object with recordId
        if (item && typeof item === 'object' && item.recordId) {
          return {
            recordId: item.recordId,
            edgeData: item.edgeData || {}
          };
        }
        // Old format: just a string ID
        if (typeof item === 'string') {
          return { recordId: item, edgeData: {} };
        }
        // Unknown format, try to use as-is
        return { recordId: String(item), edgeData: {} };
      });
    }

    return [];
  }

  /**
   * Extract just the record IDs from a link value (for backwards compatibility)
   * @param {*} value - The raw link field value
   * @returns {Array} Array of record IDs
   */
  _extractLinkIds(value) {
    return this._normalizeLinkValue(value).map(link => link.recordId);
  }

  /**
   * Create a link value in the new format
   * @param {string} recordId - The linked record ID
   * @param {Object} edgeData - Optional edge data
   * @returns {Object} Link object
   */
  _createLinkObject(recordId, edgeData = {}) {
    return { recordId, edgeData };
  }

  /**
   * Get edge data for a specific link
   * @param {*} value - The raw link field value
   * @param {string} recordId - The target record ID
   * @returns {Object|null} Edge data or null if not found
   */
  _getEdgeData(value, recordId) {
    const links = this._normalizeLinkValue(value);
    const link = links.find(l => l.recordId === recordId);
    return link ? link.edgeData : null;
  }

  /**
   * Update edge data for a specific link
   * @param {*} value - The raw link field value
   * @param {string} recordId - The target record ID
   * @param {Object} newEdgeData - New edge data to merge
   * @returns {Array} Updated link value array
   */
  _updateEdgeData(value, recordId, newEdgeData) {
    const links = this._normalizeLinkValue(value);
    return links.map(link => {
      if (link.recordId === recordId) {
        return {
          ...link,
          edgeData: { ...link.edgeData, ...newEdgeData }
        };
      }
      return link;
    });
  }

  // --------------------------------------------------------------------------
  // Reciprocal Link Utilities
  // --------------------------------------------------------------------------

  /**
   * Find or create a reciprocal LINK field in the target set that points back to the source set.
   * @param {Object} sourceSet - The set containing the original link field
   * @param {Object} sourceField - The original link field
   * @param {Object} targetSet - The set to find/create the reciprocal field in
   * @returns {Object|null} The reciprocal field, or null if target set not found
   */
  _findOrCreateReciprocalField(sourceSet, sourceField, targetSet) {
    if (!targetSet || !sourceSet || !sourceField) return null;

    // Look for an existing LINK field in target set that points to source set
    let reciprocalField = targetSet.fields.find(f =>
      f.type === FieldTypes.LINK &&
      f.options?.linkedSetId === sourceSet.id
    );

    // If no reciprocal field exists, create one
    if (!reciprocalField) {
      const fieldId = 'field_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
      reciprocalField = {
        id: fieldId,
        name: sourceSet.name,
        type: FieldTypes.LINK,
        options: {
          linkedSetId: sourceSet.id,
          linkedViewId: null,
          linkedFieldId: null,
          allowMultiple: true, // Reciprocal links should allow multiple since many records can link to one
          enableEdgeData: sourceField.options?.enableEdgeData || false,
          edgeFields: sourceField.options?.edgeFields || []
        }
      };
      targetSet.fields.push(reciprocalField);
      targetSet.updatedAt = new Date().toISOString();
    }

    return reciprocalField;
  }

  /**
   * Update reciprocal links when a LINK field value changes.
   * When Set A links to Set B, this creates/updates the link from Set B back to Set A.
   * @param {string} sourceSetId - ID of the set containing the link field
   * @param {string} sourceRecordId - ID of the record being edited
   * @param {Object} field - The link field being updated
   * @param {*} oldValue - Previous value of the link field
   * @param {*} newValue - New value of the link field
   * @param {boolean} skipReciprocal - If true, don't trigger further reciprocal updates (prevents infinite loops)
   */
  _updateReciprocalLinks(sourceSetId, sourceRecordId, field, oldValue, newValue, skipReciprocal = false) {
    if (skipReciprocal) return;
    if (!field || field.type !== FieldTypes.LINK) return;

    const linkedSetId = field.options?.linkedSetId;
    if (!linkedSetId) return;

    const sourceSet = this.sets.find(s => s.id === sourceSetId);
    const targetSet = this.sets.find(s => s.id === linkedSetId);
    if (!sourceSet || !targetSet) return;

    // Normalize old and new values to arrays of link objects
    const oldLinks = this._normalizeLinkValue(oldValue);
    const newLinks = this._normalizeLinkValue(newValue);

    const oldIds = new Set(oldLinks.map(l => l.recordId));
    const newIds = new Set(newLinks.map(l => l.recordId));

    // Find added and removed links
    const addedLinks = newLinks.filter(l => !oldIds.has(l.recordId));
    const removedIds = [...oldIds].filter(id => !newIds.has(id));

    // Find or create the reciprocal field in the target set
    const reciprocalField = this._findOrCreateReciprocalField(sourceSet, field, targetSet);
    if (!reciprocalField) return;

    // Add reciprocal links for newly added links
    for (const addedLink of addedLinks) {
      const targetRecord = targetSet.records.find(r => r.id === addedLink.recordId);
      if (!targetRecord) continue;

      // Get current links in the reciprocal field
      const currentReciprocalLinks = this._normalizeLinkValue(targetRecord.values[reciprocalField.id]);
      const alreadyLinked = currentReciprocalLinks.some(l => l.recordId === sourceRecordId);

      if (!alreadyLinked) {
        // Add the reciprocal link with the same edge data
        const newReciprocalLink = this._createLinkObject(sourceRecordId, addedLink.edgeData);
        const updatedLinks = [...currentReciprocalLinks, newReciprocalLink];
        targetRecord.values[reciprocalField.id] = updatedLinks;
        targetRecord.updatedAt = new Date().toISOString();
      }
    }

    // Remove reciprocal links for removed links
    for (const removedId of removedIds) {
      const targetRecord = targetSet.records.find(r => r.id === removedId);
      if (!targetRecord) continue;

      // Get current links in the reciprocal field
      const currentReciprocalLinks = this._normalizeLinkValue(targetRecord.values[reciprocalField.id]);
      const updatedLinks = currentReciprocalLinks.filter(l => l.recordId !== sourceRecordId);

      if (updatedLinks.length !== currentReciprocalLinks.length) {
        targetRecord.values[reciprocalField.id] = updatedLinks.length > 0 ? updatedLinks : null;
        targetRecord.updatedAt = new Date().toISOString();
      }
    }
  }

  // --------------------------------------------------------------------------
  // Ghost/Haunt Utilities
  // --------------------------------------------------------------------------

  /**
   * Get haunt info for an entity if available
   * @param {string} entityId - The entity ID to check
   * @returns {Object|null} Haunt info or null if not haunted
   */
  _getHauntInfo(entityId) {
    if (typeof getGhostRegistry !== 'function') return null;
    const ghostRegistry = getGhostRegistry();
    return ghostRegistry.getHauntInfo(entityId);
  }

  /**
   * Render a haunt indicator badge
   * @param {string} entityId - The entity ID to check
   * @returns {string} HTML for haunt indicator or empty string
   */
  _renderHauntIndicator(entityId) {
    const hauntInfo = this._getHauntInfo(entityId);
    if (!hauntInfo || !hauntInfo.isHaunted) return '';

    const ghostNames = hauntInfo.ghosts.map(g => g.name || g.id).join(', ');
    return `
      <span class="haunt-indicator" title="Influenced by deleted data: ${this._escapeHtml(ghostNames)}">
        <i class="ph ph-ghost"></i>
        <span class="haunt-count">${hauntInfo.ghostCount}</span>
      </span>
    `;
  }

  /**
   * Get ghost summary for display
   * @returns {Object} Ghost statistics and recent ghosts
   */
  _getGhostSummary() {
    if (typeof getGhostRegistry !== 'function') return null;
    const ghostRegistry = getGhostRegistry();
    return ghostRegistry.getSummary();
  }

  /**
   * Show ghost/trash panel modal
   */
  _showGhostPanel() {
    if (typeof getGhostRegistry !== 'function') {
      this._showToast('Ghost registry not available', 'warning');
      return;
    }

    const ghostRegistry = getGhostRegistry();
    const ghosts = ghostRegistry.getAllGhosts({ status: ['active', 'dormant'] });
    const stats = ghostRegistry.getStats();

    const content = `
      <div class="ghost-panel">
        <div class="ghost-stats">
          <div class="stat-item">
            <span class="stat-value">${stats.totalGhosts}</span>
            <span class="stat-label">Total Ghosts</span>
          </div>
          <div class="stat-item">
            <span class="stat-value">${stats.activeGhosts}</span>
            <span class="stat-label">Active</span>
          </div>
          <div class="stat-item">
            <span class="stat-value">${stats.hauntsDetected}</span>
            <span class="stat-label">Haunts Detected</span>
          </div>
        </div>
        <div class="ghost-list">
          ${ghosts.length === 0 ? '<p class="empty-state">No deleted items</p>' : ''}
          ${ghosts.map(ghost => `
            <div class="ghost-item" data-ghost-id="${ghost.id}">
              <div class="ghost-info">
                <i class="ph ph-ghost ghost-icon"></i>
                <div class="ghost-details">
                  <span class="ghost-name">${this._escapeHtml(ghost.snapshot?.payload?.name || ghost.snapshot?.name || ghost.id)}</span>
                  <span class="ghost-meta">${ghost.entityType} - ${new Date(ghost.ghostedAt).toLocaleDateString()}</span>
                  <span class="ghost-reason">${this._escapeHtml(ghost.reason)}</span>
                </div>
              </div>
              <div class="ghost-actions">
                <button class="btn-icon" onclick="window.eoWorkbench._resurrectGhost('${ghost.id}')" title="Resurrect">
                  <i class="ph ph-arrow-counter-clockwise"></i>
                </button>
              </div>
            </div>
          `).join('')}
        </div>
      </div>
    `;

    this._showModal({
      title: 'Deleted Items (Ghosts)',
      icon: 'ph-ghost',
      content,
      size: 'medium'
    });
  }

  /**
   * Resurrect a ghost (restore deleted item)
   * @param {string} ghostId - The ghost ID to resurrect
   */
  _resurrectGhost(ghostId) {
    if (typeof getGhostRegistry !== 'function') return;

    const ghostRegistry = getGhostRegistry();
    const result = ghostRegistry.resurrect(ghostId, 'user', {
      reason: 'User requested restoration',
      clearHaunts: true
    });

    if (result.success) {
      // Restore the item based on its type
      const ghost = result.ghost;

      // Find in tossed items and restore using _restoreTossedItem
      // which handles all types and records activity
      const tossedIndex = this.tossedItems.findIndex(t => {
        if (t.type === 'set') return t.set?.id === ghostId;
        if (t.type === 'source') return t.source?.id === ghostId;
        if (t.type === 'view') return t.view?.id === ghostId;
        if (t.type === 'record') return t.record?.id === ghostId;
        if (t.type === 'field') return t.field?.id === ghostId;
        return false;
      });

      if (tossedIndex >= 0) {
        this._restoreTossedItem(tossedIndex);
      }

      this._showToast(`Resurrected "${ghost.snapshot?.payload?.name || ghost.id}"`, 'success');
      this._closeModal();
    } else {
      this._showToast(`Failed to resurrect: ${result.error}`, 'error');
    }
  }

  // --------------------------------------------------------------------------
  // Provenance Utilities
  // --------------------------------------------------------------------------

  /**
   * Extract the actual value from a provenance element.
   * Handles both old flat format (direct value) and new nested format ({ value: ... })
   */
  _getProvenanceValue(element) {
    if (element === null || element === undefined) return null;
    // New nested format: { value: "...", uploadContext: {...}, ... }
    if (typeof element === 'object' && 'value' in element) return element.value;
    // Old format or direct string/reference
    return element;
  }

  /**
   * Get provenance status for a record
   * @returns 'full' | 'partial' | 'none'
   */
  _getRecordProvenanceStatus(record, set) {
    // Check if provenance functions are available
    if (typeof getProvenanceStatus !== 'function') {
      return 'none';
    }

    // Resolve provenance (record + dataset inheritance)
    const datasetProv = set?.datasetProvenance?.provenance || null;
    const recordProv = record?.provenance || null;

    // Merge provenance (record takes precedence)
    const resolved = typeof mergeProvenance === 'function'
      ? mergeProvenance(datasetProv, recordProv)
      : (recordProv || datasetProv || null);

    return getProvenanceStatus(resolved);
  }

  /**
   * Get provenance indicator symbol
   */
  _getProvenanceIndicator(status) {
    switch (status) {
      case 'full': return '◉';
      case 'partial': return '◐';
      default: return '○';
    }
  }

  /**
   * Render provenance section for detail panel
   *
   * Detects whether to render:
   * - Source-level provenance (Identity/Space/Time) for raw sources
   * - Interpretation parameters (9-element) for sets
   */
  _renderProvenanceSection(record, set) {
    // Check if this is source-level (Identity/Space/Time) or interpretation-level (9-element)
    const datasetProv = set?.datasetProvenance?.provenance || {};

    // Detect Identity/Space/Time format by checking for identity_kind, boundary_type, or temporal_mode
    const isSourceProvenance = datasetProv.identity_kind || datasetProv.boundary_type || datasetProv.temporal_mode;

    if (isSourceProvenance) {
      return this._renderSourceProvenanceSection(record, set, datasetProv);
    }

    return this._renderInterpretationProvenanceSection(record, set, datasetProv);
  }

  /**
   * Render Source-level provenance (Identity/Space/Time)
   *
   * This is for GIVEN events (raw imported data).
   * Answers: "What exists?"
   */
  _renderSourceProvenanceSection(record, set, datasetProv) {
    const recordProv = record?.provenance || {};
    const mergedProv = { ...datasetProv, ...recordProv };

    // Define dimensions and their elements
    const dimensions = [
      {
        name: 'Identity',
        subtitle: 'What has been made into a thing?',
        icon: 'ph-fingerprint',
        color: 'var(--primary-500, #6366f1)',
        elements: [
          { key: 'identity_kind', label: 'Kind', hint: 'claim, observation, record, import' },
          { key: 'identity_scope', label: 'Scope', hint: 'atomic, composite, aggregate' },
          { key: 'designation_operator', label: 'Operator', hint: 'DES, INS, REC, GEN' },
          { key: 'designation_mechanism', label: 'Mechanism', hint: 'How identity was created' },
          { key: 'designation_time', label: 'Designated', hint: 'When identity stabilized' },
          { key: 'asserting_agent', label: 'Agent', hint: 'Who made this real' },
          { key: 'authority_class', label: 'Authority', hint: 'human, institution, pipeline' }
        ]
      },
      {
        name: 'Space',
        subtitle: 'Where are the boundaries?',
        icon: 'ph-frame-corners',
        color: 'var(--success-500, #22c55e)',
        elements: [
          { key: 'boundary_type', label: 'Type', hint: '+1 bounded, -1 unbounded' },
          { key: 'boundary_basis', label: 'Basis', hint: 'file, system, domain' },
          { key: 'container_id', label: 'Container', hint: 'Where this lives' },
          { key: 'container_stability', label: 'Stability', hint: 'immutable or mutable' },
          { key: 'containment_level', label: 'Level', hint: 'leaf, intermediate, root' },
          { key: 'jurisdiction_present', label: 'Jurisdiction', hint: 'Authority present?' }
        ]
      },
      {
        name: 'Time',
        subtitle: 'How does this persist?',
        icon: 'ph-clock-clockwise',
        color: 'var(--warning-500, #f59e0b)',
        elements: [
          { key: 'temporal_mode', label: 'Mode', hint: '-1 static, +1 dynamic, tau recursive' },
          { key: 'temporal_justification', label: 'Justification', hint: 'Why this mode' },
          { key: 'fixation_timestamp', label: 'Fixated', hint: 'When identity locked' },
          { key: 'fixation_event', label: 'Event', hint: 'What caused fixation' },
          { key: 'validity_window', label: 'Validity', hint: 'How long to trust' },
          { key: 'reassessment_required', label: 'Reassess', hint: 'Needs review?' }
        ]
      }
    ];

    // Calculate completeness
    const totalFields = dimensions.reduce((sum, d) => sum + d.elements.length, 0);
    const filledFields = dimensions.reduce((sum, d) =>
      sum + d.elements.filter(e => this._hasSourceProvenanceValue(mergedProv[e.key])).length, 0);
    const status = filledFields === 0 ? 'none' : filledFields === totalFields ? 'full' : 'partial';
    const indicator = this._getProvenanceIndicator(status);

    return `
      <div class="provenance-section source-provenance" style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border-primary);">
        <div class="provenance-header" style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
          <span class="prov-indicator prov-${status}" style="font-size: 14px;">${indicator}</span>
          <span style="font-weight: 500; font-size: 13px;">Source Provenance</span>
          <span style="font-size: 11px; color: var(--text-muted);">Identity/Space/Time</span>
        </div>

        ${dimensions.map(dim => `
          <div class="source-provenance-dimension" style="margin-bottom: 12px;">
            <div class="dimension-header" style="display: flex; align-items: center; gap: 6px; margin-bottom: 8px;">
              <i class="ph ${dim.icon}" style="color: ${dim.color}; font-size: 14px;"></i>
              <span style="font-size: 12px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-secondary);">
                ${dim.name}
              </span>
              <span style="font-size: 10px; color: var(--text-muted);">${dim.subtitle}</span>
            </div>
            <div style="padding-left: 20px; display: grid; gap: 4px;">
              ${dim.elements.map(el => {
                const value = mergedProv[el.key];
                const hasValue = this._hasSourceProvenanceValue(value);
                const displayValue = this._formatSourceProvenanceValue(el.key, value);

                return `
                  <div class="source-prov-field" style="display: flex; align-items: center; gap: 8px; padding: 2px 0;">
                    <span style="font-size: 11px; color: var(--text-muted); min-width: 80px;">${el.label}:</span>
                    <span style="font-size: 12px; color: ${hasValue ? 'var(--text-primary)' : 'var(--text-muted)'}; ${!hasValue ? 'font-style: italic; opacity: 0.6;' : ''}">
                      ${displayValue || '(not set)'}
                    </span>
                  </div>
                `;
              }).join('')}
            </div>
          </div>
        `).join('')}
      </div>
    `;
  }

  /**
   * Render record-level interpretation context
   *
   * RECORD-LEVEL PRINCIPLE: At the record level, interpretation is about
   * "this case, this moment, this understanding" - not abstract frameworks.
   *
   * Users think in situations, not ontologies. The UI answers:
   * - Who said this?
   * - What did they mean in this case?
   * - When and under what circumstances?
   */
  _renderInterpretationProvenanceSection(record, set, datasetProv) {
    const recordProv = record?.provenance || {};

    const status = this._getRecordProvenanceStatus(record, set);
    const indicator = this._getProvenanceIndicator(status);

    // Record-level sections with plain language (not ontology terms)
    // These read like case notes, which is exactly what a record is
    const sections = [
      {
        header: 'Who provided this information?',
        elements: [
          { key: 'agent', label: 'Who provided this?', icon: 'ph-user', hint: 'Person, team, or system', placeholder: 'Click to add' },
          { key: 'method', label: 'How was it recorded?', icon: 'ph-flask', hint: 'Observed, reported, calculated, inferred', placeholder: 'Click to add' },
          { key: 'source', label: 'What did it come from?', icon: 'ph-file-text', hint: 'Import, form, sync, manual entry', placeholder: 'From import', readonly: true }
        ]
      },
      {
        header: 'What does this represent in this case?',
        elements: [
          { key: 'term', label: 'What is this about?', icon: 'ph-bookmark', hint: 'e.g. homelessness, income, risk level', placeholder: 'Click to add' },
          { key: 'definition', label: 'How is that defined here?', icon: 'ph-book-open', hint: 'Shared or local definition', placeholder: 'Click to add' },
          { key: 'jurisdiction', label: 'Any rules or standards?', icon: 'ph-map-pin', hint: 'Program guideline, legal definition', placeholder: 'Click to add' }
        ]
      },
      {
        header: 'When and at what level was this true?',
        elements: [
          { key: 'scale', label: 'Who does this apply to?', icon: 'ph-arrows-out', hint: 'Individual, household, case, program', placeholder: 'Click to add' },
          { key: 'timeframe', label: 'When was this true?', icon: 'ph-calendar', hint: 'Date or time range', placeholder: 'Click to add' },
          { key: 'background', label: 'Anything else that matters?', icon: 'ph-info', hint: 'Context, assumptions, notes', placeholder: 'Click to add' }
        ]
      }
    ];

    return `
      <div class="provenance-section interpretation-provenance" style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border-primary);">
        <div class="provenance-header" style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
          <span class="prov-indicator prov-${status}" style="font-size: 14px;">${indicator}</span>
          <span style="font-weight: 500; font-size: 13px;">About this record</span>
          <span style="font-size: 11px; color: var(--text-muted);">
            ${status === 'full' ? '(complete)' : status === 'partial' ? '(partial)' : '(none)'}
          </span>
        </div>
        <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 12px;">
          Optional context that explains why this record looks the way it does.
        </div>

        ${sections.map(section => `
          <div class="interpretation-triad" style="margin-bottom: 12px;">
            <div style="font-size: 11px; font-weight: 500; color: var(--text-secondary); margin-bottom: 8px;">
              ${section.header}
            </div>
            <div style="display: grid; gap: 6px;">
              ${section.elements.map(el => {
                const value = recordProv[el.key] ?? datasetProv[el.key] ?? null;
                const inherited = !this._hasProvenanceValue(recordProv[el.key]) && this._hasProvenanceValue(datasetProv[el.key]);
                const isRef = this._isProvenanceRef(value);
                const displayValue = this._formatProvenanceValue(value);
                const hasValue = this._hasProvenanceValue(value);

                const isEditable = !el.readonly;
                const placeholderText = el.placeholder;

                return `
                  <div class="provenance-field" data-prov-key="${el.key}" data-record-id="${record.id}"
                       style="display: flex; align-items: flex-start; gap: 8px; padding: 4px 0;">
                    <i class="ph ${el.icon}" style="color: var(--text-muted); margin-top: 2px; flex-shrink: 0;"></i>
                    <div style="flex: 1; min-width: 0;">
                      <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 2px;">
                        ${el.label}
                        ${inherited ? '<span style="font-size: 10px; opacity: 0.7;">(inherited)</span>' : ''}
                      </div>
                      <div class="provenance-value ${isEditable ? 'editable' : ''} ${isRef ? 'is-ref' : ''}"
                           data-prov-key="${el.key}"
                           data-record-id="${record.id}"
                           title="${el.hint}"
                           style="font-size: 12px; color: ${hasValue ? 'var(--text-primary)' : 'var(--text-muted)'}; ${isEditable ? 'cursor: pointer;' : ''}">
                        ${displayValue || `<span style="opacity: 0.5;">${placeholderText}</span>`}
                      </div>
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
          </div>
        `).join('')}
      </div>
    `;
  }

  /**
   * Check if a source provenance value has content
   */
  _hasSourceProvenanceValue(value) {
    if (value === null || value === undefined) return false;
    if (typeof value === 'boolean') return true;
    if (typeof value === 'string') return value.length > 0;
    return true;
  }

  /**
   * Format source provenance value for display
   */
  _formatSourceProvenanceValue(key, value) {
    if (value === null || value === undefined) return '';

    // Format booleans
    if (typeof value === 'boolean') {
      return value ? 'Yes' : 'No';
    }

    // Format timestamps
    if (key.includes('timestamp') || key.includes('time') || key === 'designation_time') {
      try {
        const date = new Date(value);
        if (!isNaN(date.getTime())) {
          return date.toLocaleString();
        }
      } catch {
        // Fall through to string display
      }
    }

    // Format phase-space values
    const phaseLabels = {
      '+1': 'Bounded (+1)',
      '-1': 'Unbounded (-1)',
      'sqrt2': 'Fractal (\u221A2)',
      'tau': 'Recursive (\u03C4)'
    };
    if (phaseLabels[value]) {
      return phaseLabels[value];
    }

    return this._escapeHtml(String(value));
  }

  /**
   * Check if a provenance value has actual content (handles nested format and arrays)
   */
  _hasProvenanceValue(value) {
    if (value === null || value === undefined) {
      return false;
    }
    // Handle arrays
    if (Array.isArray(value)) {
      return value.length > 0;
    }
    // Extract from nested format
    if (typeof value === 'object' && 'value' in value && !('$ref' in value)) {
      const actualValue = value.value;
      if (Array.isArray(actualValue)) return actualValue.length > 0;
      return actualValue !== null && actualValue !== undefined;
    }
    return true;
  }

  /**
   * Check if provenance value is a record reference (handles nested format and arrays)
   * Returns true if ANY entry is a reference
   */
  _isProvenanceRef(value) {
    if (!value) return false;
    // Handle arrays - check if any entry is a ref
    if (Array.isArray(value)) {
      return value.some(v => v && typeof v === 'object' && '$ref' in v);
    }
    // Check nested format first
    if (typeof value === 'object' && 'value' in value && !('$ref' in value)) {
      const actualValue = value.value;
      if (Array.isArray(actualValue)) {
        return actualValue.some(v => v && typeof v === 'object' && '$ref' in v);
      }
      return actualValue && typeof actualValue === 'object' && '$ref' in actualValue;
    }
    // Direct reference check
    return typeof value === 'object' && '$ref' in value;
  }

  /**
   * Format provenance value for display
   */
  _formatProvenanceValue(value) {
    if (value === null || value === undefined) {
      return '';
    }

    // Extract actual value from nested format (handles both old flat and new nested format)
    // Nested format: { value: "actual_value", uploadContext: {...}, ... }
    let actualValue = value;
    if (typeof value === 'object' && 'value' in value && !('$ref' in value) && !Array.isArray(value)) {
      actualValue = value.value;
    }

    // Use getProvenanceValue helper if available for consistent extraction
    if (typeof getProvenanceValue === 'function') {
      actualValue = getProvenanceValue(value);
    }

    if (actualValue === null || actualValue === undefined) {
      return '';
    }

    // Handle arrays (multiple entries)
    if (Array.isArray(actualValue)) {
      if (actualValue.length === 0) return '';
      return `<div class="prov-multi-entries" style="display: flex; flex-wrap: wrap; gap: 4px;">
        ${actualValue.map((entry, idx) => {
          const formatted = this._formatSingleProvenanceEntry(entry);
          return `<span class="prov-entry" data-index="${idx}" style="display: inline-flex; align-items: center; gap: 2px; padding: 2px 6px; background: var(--bg-tertiary); border-radius: 4px; font-size: 11px;">${formatted}</span>`;
        }).join('')}
      </div>`;
    }

    return this._formatSingleProvenanceEntry(actualValue);
  }

  /**
   * Format a single provenance entry (used for both single values and array items)
   */
  _formatSingleProvenanceEntry(entry) {
    if (entry === null || entry === undefined) {
      return '';
    }

    // Record reference
    if (typeof entry === 'object' && '$ref' in entry) {
      const refId = entry.$ref;
      // Try to find the referenced record's name
      const refRecord = this._findRecordById(refId);
      const refName = refRecord ? this._getRecordPrimaryValue(refRecord) : refId.substring(0, 8);
      return `<span class="prov-ref"><i class="ph ph-arrow-right"></i> ${this._escapeHtml(refName)}</span>`;
    }

    // Handle objects with proper JSON rendering
    if (typeof entry === 'object') {
      return this._renderJsonKeyValue(entry);
    }

    return this._escapeHtml(String(entry));
  }

  /**
   * Find a record by ID across all sets
   */
  _findRecordById(recordId) {
    for (const set of this.sets) {
      const record = set.records.find(r => r.id === recordId);
      if (record) return record;
    }
    return null;
  }

  /**
   * Get primary field value for a record
   */
  _getRecordPrimaryValue(record) {
    const set = this.sets.find(s => s.id === record.setId);
    if (!set) return record.id;
    const primaryField = set.fields.find(f => f.isPrimary) || set.fields[0];
    return record.values[primaryField?.id] || record.id;
  }

  // --------------------------------------------------------------------------
  // SQL Derivation Provenance (EO-IR)
  // --------------------------------------------------------------------------

  /**
   * Get the full EO-IR provenance chain for a SQL-derived set
   * Returns the query event, set event, and source references
   */
  _getSQLProvenanceChain(set) {
    if (!set?.derivation?.queryEventId) {
      return null;
    }

    const eventStore = this._getOrCreateEventStore();
    const chain = {
      queryEvent: null,
      setEvent: null,
      sources: [],
      pipeline: set.derivation.pipeline || [],
      sql: set.derivation.sql
    };

    // Get query event
    if (set.derivation.queryEventId) {
      chain.queryEvent = eventStore.get(set.derivation.queryEventId);
    }

    // Get set event
    if (set.derivation.setEventId) {
      chain.setEvent = eventStore.get(set.derivation.setEventId);
    }

    // Get source references
    const sourceRefs = set.derivation.sourceRefs || [];
    for (const sourceId of sourceRefs) {
      const sourceSet = this.sets.find(s => s.id === sourceId || s.name === sourceId);
      if (sourceSet) {
        chain.sources.push({
          id: sourceSet.id,
          name: sourceSet.name,
          recordCount: sourceSet.records?.length || 0
        });
      }
    }

    return chain;
  }

  /**
   * Render SQL derivation provenance section in the set details panel
   */
  _renderSQLDerivationSection(set) {
    const derivation = set?.derivation;
    if (!derivation?.sql) {
      return '';
    }

    const chain = this._getSQLProvenanceChain(set);
    const strategyLabels = {
      'seg': 'Segmentation (Filter)',
      'con': 'Connection (Join)',
      'alt': 'Alteration (Transform)',
      'direct': 'Direct Import'
    };

    const strategyLabel = strategyLabels[derivation.strategy] || derivation.strategy;

    // Format the pipeline steps
    const pipelineHtml = (derivation.pipeline || []).map(step => {
      const params = Object.entries(step.params || {})
        .map(([k, v]) => `${k}=${JSON.stringify(v)}`)
        .join(', ');
      return `<div class="pipeline-step">
        <span class="pipeline-op">${step.op}</span>
        <span class="pipeline-params">${this._escapeHtml(params)}</span>
      </div>`;
    }).join('<div class="pipeline-arrow">↓</div>');

    // Format source references
    const sourcesHtml = (chain?.sources || []).map(src =>
      `<span class="source-ref">${this._escapeHtml(src.name)} (${src.recordCount} rows)</span>`
    ).join(', ');

    return `
      <div class="sql-derivation-section" style="margin-top: 16px; padding: 12px; background: var(--surface-secondary); border-radius: 8px; border: 1px solid var(--border-primary);">
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
          <i class="ph ph-database" style="color: var(--accent-primary);"></i>
          <span style="font-weight: 600; font-size: 13px;">SQL Derivation</span>
          <span class="derivation-strategy-badge" style="font-size: 10px; padding: 2px 6px; background: var(--accent-primary); color: white; border-radius: 4px;">
            ${strategyLabel}
          </span>
        </div>

        <div style="margin-bottom: 12px;">
          <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 4px;">SQL Query</div>
          <pre style="font-size: 11px; background: var(--surface-primary); padding: 8px; border-radius: 4px; overflow-x: auto; white-space: pre-wrap;">${this._escapeHtml(derivation.sql)}</pre>
        </div>

        ${sourcesHtml ? `
        <div style="margin-bottom: 12px;">
          <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 4px;">Source Sets</div>
          <div style="font-size: 12px;">${sourcesHtml}</div>
        </div>
        ` : ''}

        <div style="margin-bottom: 12px;">
          <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 4px;">EO-IR Pipeline</div>
          <div class="pipeline-view" style="font-size: 11px;">
            ${pipelineHtml || '<span style="color: var(--text-muted);">No pipeline steps</span>'}
          </div>
        </div>

        ${derivation.frame?.purpose ? `
        <div style="margin-bottom: 8px;">
          <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 4px;">Purpose</div>
          <div style="font-size: 12px;">${this._escapeHtml(derivation.frame.purpose)}</div>
        </div>
        ` : ''}

        ${derivation.frame?.caveats?.length ? `
        <div style="margin-bottom: 8px;">
          <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 4px;">Caveats</div>
          <ul style="font-size: 12px; margin: 0; padding-left: 16px;">
            ${derivation.frame.caveats.map(c => `<li>${this._escapeHtml(c)}</li>`).join('')}
          </ul>
        </div>
        ` : ''}

        <div style="display: flex; gap: 16px; font-size: 11px; color: var(--text-muted); margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border-secondary);">
          <span><i class="ph ph-rows"></i> ${derivation.stats?.outputRows || set.records?.length || 0} rows</span>
          <span><i class="ph ph-timer"></i> ${derivation.stats?.executionMs || 0}ms</span>
          <span><i class="ph ph-calendar"></i> ${derivation.derivedAt ? new Date(derivation.derivedAt).toLocaleDateString() : 'Unknown'}</span>
        </div>

        ${chain?.queryEventId || chain?.setEventId ? `
        <div style="font-size: 10px; color: var(--text-muted); margin-top: 8px;">
          <i class="ph ph-fingerprint"></i> Event IDs:
          ${derivation.queryEventId ? `<code>${derivation.queryEventId.substring(0, 12)}...</code>` : ''}
          ${derivation.setEventId ? `<code>${derivation.setEventId.substring(0, 12)}...</code>` : ''}
        </div>
        ` : ''}
      </div>
    `;
  }

  // --------------------------------------------------------------------------
  // History Section (Grounding: Lineage + History + Impact)
  // --------------------------------------------------------------------------

  /**
   * Get history events for a record from the Event Store
   */
  _getRecordHistory(recordId) {
    // Try to get events from the Event Store via eoApp
    const eventStore = this.eoApp?.eventStore;
    if (eventStore) {
      // Prefer getEntityHistory (sorted) over getByEntity
      if (typeof eventStore.getEntityHistory === 'function') {
        return eventStore.getEntityHistory(recordId);
      }
      // Fallback to getByEntity if getEntityHistory doesn't exist
      if (typeof eventStore.getByEntity === 'function') {
        const events = eventStore.getByEntity(recordId);
        // Sort by timestamp, newest first
        return events.sort((a, b) =>
          new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
        );
      }
    }

    // Fallback: check if global event store getter exists
    if (typeof window !== 'undefined') {
      const globalStore = window.eoEventStore || (window.getEventStore && window.getEventStore());
      if (globalStore) {
        if (typeof globalStore.getEntityHistory === 'function') {
          return globalStore.getEntityHistory(recordId);
        }
        if (typeof globalStore.getByEntity === 'function') {
          const events = globalStore.getByEntity(recordId);
          return events.sort((a, b) =>
            new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
          );
        }
      }
    }

    return [];
  }

  /**
   * Get history events for a specific field within a record
   */
  _getFieldHistory(recordId, fieldId) {
    const recordHistory = this._getRecordHistory(recordId);

    // Filter to events that affect this specific field
    return recordHistory.filter(event => {
      // Include creation events (they affect all fields)
      const action = event.payload?.action;
      if (action === 'record_created' || action === 'import' || action === 'create') {
        return true;
      }
      // Include field-specific changes
      return event.payload?.fieldId === fieldId;
    });
  }

  /**
   * Get count of field-specific history events (excludes record creation)
   * Used for efficient history indicator rendering
   */
  _getFieldHistoryChangeCount(recordId, fieldId) {
    const fieldHistory = this._getFieldHistory(recordId, fieldId);
    // Count only actual field changes, not creation events
    return fieldHistory.filter(event => {
      const action = event.payload?.action;
      return action === 'record_updated' || action === 'field_changed' || action === 'update';
    }).length;
  }

  /**
   * Check if a field has any history changes
   * Fast check for rendering indicators
   */
  _hasFieldHistoryChanges(recordId, fieldId) {
    return this._getFieldHistoryChangeCount(recordId, fieldId) > 0;
  }

  /**
   * Build a cache of field history counts for all fields in a record
   * Call once per record to avoid repeated event store queries
   */
  _buildRecordHistoryCache(recordId) {
    const recordHistory = this._getRecordHistory(recordId);
    const cache = {};

    // Count changes per field
    recordHistory.forEach(event => {
      const action = event.payload?.action;
      const fieldId = event.payload?.fieldId;

      if (fieldId && (action === 'record_updated' || action === 'field_changed' || action === 'update')) {
        cache[fieldId] = (cache[fieldId] || 0) + 1;
      }
    });

    return cache;
  }

  /**
   * Get the most recent changes for a field (for quick preview)
   * @param {string} recordId - The record ID
   * @param {string} fieldId - The field ID
   * @param {number} limit - Max number of changes to return
   * @returns {Array} Recent changes with oldValue, newValue, timestamp, actor
   */
  _getRecentFieldChanges(recordId, fieldId, limit = 3) {
    const fieldHistory = this._getFieldHistory(recordId, fieldId);

    return fieldHistory
      .filter(event => {
        const action = event.payload?.action;
        return action === 'record_updated' || action === 'field_changed' || action === 'update';
      })
      .slice(0, limit)
      .map(event => ({
        oldValue: event.payload?.previousValue ?? event.payload?.oldValue,
        newValue: event.payload?.newValue ?? event.payload?.value,
        timestamp: event.timestamp,
        actor: event.actor || 'system',
        eventId: event.id
      }));
  }

  /**
   * Restore a field to a previous value
   * Creates a new update event (never mutates history - Rule 3)
   */
  async _restoreFieldValue(recordId, fieldId, previousValue, sourceEventId) {
    try {
      const set = this.getCurrentSet();

      if (!set) {
        this._showToast('No set selected', 'error');
        return;
      }

      // Ensure records are loaded from IndexedDB if needed
      // Use undefined check specifically - empty array means already loaded (no records in IndexedDB)
      if (set._recordsInIndexedDB && set.records === undefined) {
        await this._ensureSetRecords(set);
      }

      const record = set?.records?.find(r => r.id === recordId);
      const field = set?.fields?.find(f => f.id === fieldId);

      if (!record) {
        this._showToast('Could not find record', 'error');
        return;
      }

      if (!field) {
        this._showToast('Could not find field', 'error');
        return;
      }

      const currentValue = record.values[fieldId];

      // Check if the values are actually different
      // Use JSON.stringify for deep comparison in case of complex values
      const currentStr = JSON.stringify(currentValue);
      const previousStr = JSON.stringify(previousValue);

      if (currentStr === previousStr) {
        this._showToast('Value is already set to this', 'info');
        this._hideFieldHistoryPopover();
        return;
      }

      // Update the value using existing method (which creates proper events)
      this._updateRecordValue(recordId, fieldId, previousValue);

      // Verify the update succeeded
      const updatedRecord = set.records.find(r => r.id === recordId);
      const newValue = updatedRecord?.values[fieldId];
      const newValueStr = JSON.stringify(newValue);

      if (newValueStr !== previousStr) {
        console.error('Restore verification failed:', { previousValue, newValue, currentValue });
        this._showToast('Restore may not have completed correctly', 'warning');
      } else {
        this._showToast('Restored to previous value', 'success');
      }

      // Re-render the cell
      const cell = document.querySelector(`tr[data-record-id="${recordId}"] td[data-field-id="${fieldId}"]`);
      if (cell) {
        cell.innerHTML = this._renderCellContent(field, previousValue);
      }

      // Also re-render if in detail panel view
      this._refreshDetailPanelField(recordId, fieldId);

      this._hideFieldHistoryPopover();
    } catch (err) {
      console.error('Error restoring field value:', err);
      this._showToast('Failed to restore value: ' + err.message, 'error');
    }
  }

  /**
   * Refresh a specific field in the detail panel if it's open
   */
  _refreshDetailPanelField(recordId, fieldId) {
    // Check if detail panel is showing this record
    const detailPanel = document.querySelector('.detail-panel');
    if (!detailPanel) return;

    const panelRecordId = detailPanel.dataset?.recordId;
    if (panelRecordId !== recordId) return;

    // Re-render the entire detail panel to reflect the change
    const set = this.getCurrentSet();
    const record = set?.records?.find(r => r.id === recordId);
    if (record) {
      this._showRecordDetail(recordId);
    }
  }

  /**
   * Render field history popover/tooltip
   * Shows change history for a specific field with agent, timestamps, and value changes
   */
  _renderFieldHistoryPopover(record, field, set) {
    const fieldHistory = this._getFieldHistory(record.id, field.id);
    const currentValue = record.values[field.id];
    const hasHistory = fieldHistory.length > 0;

    // Get field-level provenance if available
    const fieldProv = record.fieldProvenance?.[field.id];
    const recordProv = record.provenance;
    const datasetProv = set?.datasetProvenance?.provenance;

    // Determine provenance source for display
    let provenanceSource = 'dataset';
    let effectiveProv = datasetProv;
    if (fieldProv && Object.values(fieldProv).some(v => v !== null && v !== undefined)) {
      provenanceSource = 'field';
      effectiveProv = fieldProv;
    } else if (recordProv && Object.values(recordProv).some(v => v !== null && v !== undefined)) {
      provenanceSource = 'record';
      effectiveProv = recordProv;
    }

    // Helper to get provenance value - handles both simple and EO-style provenance
    const getProvValue = (prov, simpleKey, eoKey) => {
      if (!prov) return null;
      // Try simple key first (agent, method, source)
      if (prov[simpleKey]) {
        return typeof prov[simpleKey] === 'object' ? prov[simpleKey].value : prov[simpleKey];
      }
      // Fall back to EO-style key (asserting_agent, designation_mechanism, etc.)
      if (prov[eoKey]) {
        return typeof prov[eoKey] === 'object' ? prov[eoKey].value : prov[eoKey];
      }
      return null;
    };

    const provAgent = getProvValue(effectiveProv, 'agent', 'asserting_agent');
    const provMethod = getProvValue(effectiveProv, 'method', 'designation_mechanism');
    const provSource = getProvValue(effectiveProv, 'source', 'identity_kind');
    const hasProvenance = provAgent || provMethod || provSource;

    return `
      <div class="field-history-popover" data-field-id="${field.id}" data-record-id="${record.id}">
        <div class="field-history-header">
          <div class="field-history-title">
            <i class="ph ph-clock-counter-clockwise"></i>
            <span>History: ${this._escapeHtml(field.name)}</span>
          </div>
          <button class="field-history-close" title="Close">
            <i class="ph ph-x"></i>
          </button>
        </div>

        <div class="field-history-current">
          <div class="field-history-current-label">Current Value</div>
          <div class="field-history-current-value">
            ${currentValue !== null && currentValue !== undefined
              ? this._escapeHtml(this._formatFieldValueForDisplay(currentValue, field, 100))
              : '<span class="empty-value">Empty</span>'}
          </div>
        </div>

        <div class="field-history-provenance">
          <div class="field-history-section-label">
            <i class="ph ph-git-branch"></i>
            Provenance
            <span class="provenance-source-badge ${provenanceSource}">${provenanceSource}</span>
          </div>
          <div class="field-history-provenance-grid">
            ${provAgent ? `
              <div class="prov-item">
                <span class="prov-label">Agent</span>
                <span class="prov-value">${this._escapeHtml(provAgent)}</span>
              </div>
            ` : ''}
            ${provMethod ? `
              <div class="prov-item">
                <span class="prov-label">Method</span>
                <span class="prov-value">${this._escapeHtml(provMethod)}</span>
              </div>
            ` : ''}
            ${provSource ? `
              <div class="prov-item">
                <span class="prov-label">Source</span>
                <span class="prov-value">${this._escapeHtml(provSource)}</span>
              </div>
            ` : ''}
            ${!hasProvenance ? `
              <div class="prov-item empty">
                <span class="prov-value">No provenance set</span>
              </div>
            ` : ''}
          </div>
        </div>

        <div class="field-history-timeline">
          <div class="field-history-section-label">
            <i class="ph ph-list-bullets"></i>
            Change History
            <span class="history-count">${fieldHistory.length} event${fieldHistory.length !== 1 ? 's' : ''}</span>
          </div>

          ${hasHistory ? `
            <div class="field-history-events">
              ${fieldHistory.slice().reverse().map(event => this._renderFieldHistoryEvent(event, field, record.id, true)).join('')}
            </div>
          ` : `
            <div class="field-history-empty">
              <i class="ph ph-clock-afternoon"></i>
              <span>No changes tracked yet</span>
              <div class="field-history-empty-hint">
                Changes will appear here as you edit this field
              </div>
            </div>
          `}
        </div>

        <div class="field-history-footer">
          <button class="field-history-view-all-btn"
                  data-record-id="${record.id}"
                  data-field-id="${field.id}">
            <i class="ph ph-clock-counter-clockwise"></i>
            View Full Record History
          </button>
        </div>
      </div>
    `;
  }

  /**
   * Render a single field history event
   * @param {Object} event - The history event
   * @param {Object} field - The field object (or fieldId string for backwards compatibility)
   * @param {string} recordId - The record ID (for restore functionality)
   * @param {boolean} showRestore - Whether to show restore button
   */
  _renderFieldHistoryEvent(event, field, recordId = null, showRestore = true) {
    // Support both field object and fieldId string for backwards compatibility
    const fieldId = typeof field === 'string' ? field : field?.id;
    const fieldObj = typeof field === 'object' ? field : null;

    const action = event.payload?.action || 'unknown';
    const timestamp = event.timestamp ? new Date(event.timestamp) : null;
    const actor = event.actor || 'system';
    const previousValue = event.payload?.previousValue ?? event.payload?.oldValue;
    const newValue = event.payload?.newValue ?? event.payload?.value;

    // Format values for display (handles SELECT/MULTI_SELECT by looking up choice names)
    const formattedPrevValue = fieldObj ? this._formatFieldValueForDisplay(previousValue, fieldObj, 25) : this._truncate(String(previousValue ?? ''), 25);
    const formattedNewValue = fieldObj ? this._formatFieldValueForDisplay(newValue, fieldObj, 25) : this._truncate(String(newValue ?? ''), 25);
    const fullPrevValue = fieldObj ? this._formatFieldValueForDisplay(previousValue, fieldObj, 200) : String(previousValue ?? '');
    const fullNewValue = fieldObj ? this._formatFieldValueForDisplay(newValue, fieldObj, 200) : String(newValue ?? '');

    // Determine event type and styling
    let icon = 'ph-circle';
    let iconClass = '';
    let label = action;

    switch (action) {
      case 'record_created':
      case 'create':
      case 'import':
        icon = 'ph-plus-circle';
        iconClass = 'event-created';
        label = 'Created';
        break;
      case 'record_updated':
      case 'field_changed':
      case 'update':
        icon = 'ph-pencil-simple';
        iconClass = 'event-modified';
        label = 'Modified';
        break;
      case 'supersession':
        icon = 'ph-arrows-clockwise';
        iconClass = 'event-superseded';
        label = 'Superseded';
        break;
    }

    const isFieldSpecific = event.payload?.fieldId === fieldId;
    const canRestore = isFieldSpecific && previousValue !== undefined && showRestore && recordId;

    return `
      <div class="field-history-event ${iconClass} ${isFieldSpecific ? 'field-specific' : 'record-level'}">
        <div class="event-icon">
          <i class="ph ${icon}"></i>
        </div>
        <div class="event-content">
          <div class="event-header">
            <span class="event-label">${label}</span>
            <span class="event-time">${timestamp ? this._formatRelativeTime(timestamp) : ''}</span>
          </div>
          ${isFieldSpecific && (previousValue !== undefined || newValue !== undefined) ? `
            <div class="event-change">
              ${previousValue !== undefined ? `
                <span class="old-value" title="${this._escapeHtml(fullPrevValue)}">${this._escapeHtml(formattedPrevValue)}</span>
                <i class="ph ph-arrow-right"></i>
              ` : ''}
              <span class="new-value" title="${this._escapeHtml(fullNewValue)}">${this._escapeHtml(formattedNewValue)}</span>
            </div>
          ` : ''}
          <div class="event-footer">
            <div class="event-actor">
              <i class="ph ph-user"></i>
              ${this._formatActor(actor)}
            </div>
            ${canRestore ? `
              <button class="event-restore-btn"
                      data-record-id="${recordId}"
                      data-field-id="${fieldId}"
                      data-restore-value="${this._escapeHtml(JSON.stringify(previousValue))}"
                      data-event-id="${event.id}"
                      title="Restore to this value">
                <i class="ph ph-arrow-counter-clockwise"></i>
                Restore
              </button>
            ` : ''}
          </div>
        </div>
      </div>
    `;
  }

  /**
   * Show field history popover for a specific field
   */
  _showFieldHistoryPopover(recordId, fieldId, anchorEl) {
    // Remove any existing popover
    this._hideFieldHistoryPopover();

    const record = this._getRecordById(recordId);
    const set = this.getCurrentSet();
    const field = set?.fields?.find(f => f.id === fieldId);

    if (!record || !field) return;

    // Create popover element
    const popover = document.createElement('div');
    popover.className = 'field-history-popover-container';
    popover.innerHTML = this._renderFieldHistoryPopover(record, field, set);

    // Position relative to anchor
    document.body.appendChild(popover);

    const rect = anchorEl.getBoundingClientRect();
    const popoverRect = popover.getBoundingClientRect();

    // Position to the left of the anchor, or right if no space
    let left = rect.left - popoverRect.width - 8;
    if (left < 8) {
      left = rect.right + 8;
    }

    // Ensure it stays within viewport vertically
    let top = rect.top;
    if (top + popoverRect.height > window.innerHeight - 8) {
      top = window.innerHeight - popoverRect.height - 8;
    }
    if (top < 8) top = 8;

    popover.style.left = `${left}px`;
    popover.style.top = `${top}px`;

    // Add close handler
    popover.querySelector('.field-history-close')?.addEventListener('click', () => {
      this._hideFieldHistoryPopover();
    });

    // Add restore button handlers
    popover.querySelectorAll('.event-restore-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        e.preventDefault();

        try {
          const restoreRecordId = btn.dataset.recordId;
          const restoreFieldId = btn.dataset.fieldId;
          const restoreValueRaw = btn.dataset.restoreValue;
          const eventId = btn.dataset.eventId;

          // Validate required data
          if (!restoreRecordId || !restoreFieldId) {
            this._showToast('Missing record or field information', 'error');
            return;
          }

          // Parse the restore value with error handling
          let restoreValue;
          try {
            restoreValue = JSON.parse(restoreValueRaw);
          } catch (parseError) {
            console.error('Failed to parse restore value:', restoreValueRaw, parseError);
            this._showToast('Could not parse restore value', 'error');
            return;
          }

          // Show confirmation and restore
          if (confirm(`Restore field to previous value?\n\nThis will create a new change event (history is preserved).`)) {
            this._restoreFieldValue(restoreRecordId, restoreFieldId, restoreValue, eventId);
          }
        } catch (err) {
          console.error('Restore button click handler error:', err);
          this._showToast('Failed to restore value', 'error');
        }
      });
    });

    // Add "View Full History" button handler
    popover.querySelector('.field-history-view-all-btn')?.addEventListener('click', (e) => {
      e.stopPropagation();
      const popoverRecordId = e.target.closest('.field-history-view-all-btn').dataset.recordId;
      const popoverFieldId = e.target.closest('.field-history-view-all-btn').dataset.fieldId;
      this._hideFieldHistoryPopover();
      this._showRecordHistoryDrawer(popoverRecordId, popoverFieldId);
    });

    // Close on click outside
    setTimeout(() => {
      document.addEventListener('click', this._fieldHistoryOutsideClickHandler = (e) => {
        if (!popover.contains(e.target) && !anchorEl.contains(e.target)) {
          this._hideFieldHistoryPopover();
        }
      });
    }, 0);
  }

  /**
   * Hide field history popover
   */
  _hideFieldHistoryPopover() {
    const existing = document.querySelector('.field-history-popover-container');
    if (existing) {
      existing.remove();
    }
    if (this._fieldHistoryOutsideClickHandler) {
      document.removeEventListener('click', this._fieldHistoryOutsideClickHandler);
      this._fieldHistoryOutsideClickHandler = null;
    }
  }

  /**
   * Show record history drawer - full history view for a record
   */
  _showRecordHistoryDrawer(recordId, initialFieldFilter = null) {
    const record = this._getRecordById(recordId);
    const set = this.getCurrentSet();

    if (!record || !set) {
      this._showToast('Could not find record', 'error');
      return;
    }

    // Get primary field value for title
    const primaryField = set.fields?.find(f => f.isPrimary) || set.fields?.[0];
    const recordName = record.values?.[primaryField?.id] || recordId;

    // Get all history for this record
    const history = this._getRecordHistory(recordId);

    // Group by date
    const groupedHistory = this._groupHistoryByDate(history);

    // Get unique field IDs that have changes
    const fieldsWithChanges = [...new Set(
      history
        .filter(e => e.payload?.fieldId)
        .map(e => e.payload.fieldId)
    )];

    // Create drawer element
    const overlay = document.createElement('div');
    overlay.className = 'record-history-overlay';
    overlay.id = 'record-history-overlay';

    const drawer = document.createElement('div');
    drawer.className = 'record-history-drawer';
    drawer.id = 'record-history-drawer';
    drawer.innerHTML = `
      <div class="record-history-drawer-header">
        <div class="record-history-drawer-title">
          <i class="ph ph-clock-counter-clockwise"></i>
          <span>History: ${this._escapeHtml(this._truncate(String(recordName), 30))}</span>
        </div>
        <button class="record-history-drawer-close" id="close-record-history">
          <i class="ph ph-x"></i>
        </button>
      </div>

      <div class="record-history-drawer-filters">
        <button class="record-history-filter ${!initialFieldFilter ? 'active' : ''}" data-filter="all">
          <i class="ph ph-list"></i>
          All Changes
        </button>
        ${fieldsWithChanges.map(fieldId => {
          const field = set.fields?.find(f => f.id === fieldId);
          if (!field) return '';
          return `
            <button class="record-history-filter ${initialFieldFilter === fieldId ? 'active' : ''}"
                    data-filter="${fieldId}">
              ${this._escapeHtml(field.name)}
            </button>
          `;
        }).join('')}
      </div>

      <div class="record-history-drawer-content" id="record-history-content">
        ${this._renderRecordHistoryContent(groupedHistory, set, recordId, initialFieldFilter)}
      </div>
    `;

    document.body.appendChild(overlay);
    document.body.appendChild(drawer);

    // Trigger animation
    requestAnimationFrame(() => {
      overlay.classList.add('visible');
      drawer.classList.add('open');
    });

    // Close handlers
    const closeDrawer = () => {
      overlay.classList.remove('visible');
      drawer.classList.remove('open');
      setTimeout(() => {
        overlay.remove();
        drawer.remove();
      }, 300);
    };

    document.getElementById('close-record-history')?.addEventListener('click', closeDrawer);
    overlay.addEventListener('click', closeDrawer);

    // Filter handlers
    drawer.querySelectorAll('.record-history-filter').forEach(btn => {
      btn.addEventListener('click', () => {
        const filter = btn.dataset.filter;
        drawer.querySelectorAll('.record-history-filter').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');

        const filteredHistory = filter === 'all'
          ? history
          : history.filter(e => e.payload?.fieldId === filter ||
              e.payload?.action === 'record_created' ||
              e.payload?.action === 'import');

        const grouped = this._groupHistoryByDate(filteredHistory);
        const content = document.getElementById('record-history-content');
        if (content) {
          content.innerHTML = this._renderRecordHistoryContent(grouped, set, recordId, filter === 'all' ? null : filter);
        }
      });
    });

    // Escape key handler
    const escHandler = (e) => {
      if (e.key === 'Escape') {
        closeDrawer();
        document.removeEventListener('keydown', escHandler);
      }
    };
    document.addEventListener('keydown', escHandler);
  }

  /**
   * Group history events by date for display
   */
  _groupHistoryByDate(history) {
    const groups = {};
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);

    history.forEach(event => {
      const date = new Date(event.timestamp);
      date.setHours(0, 0, 0, 0);

      let dateKey;
      if (date.getTime() === today.getTime()) {
        dateKey = 'Today';
      } else if (date.getTime() === yesterday.getTime()) {
        dateKey = 'Yesterday';
      } else {
        dateKey = date.toLocaleDateString('en-US', {
          weekday: 'short',
          month: 'short',
          day: 'numeric',
          year: date.getFullYear() !== today.getFullYear() ? 'numeric' : undefined
        });
      }

      if (!groups[dateKey]) {
        groups[dateKey] = [];
      }
      groups[dateKey].push(event);
    });

    return groups;
  }

  /**
   * Render content for record history drawer
   */
  _renderRecordHistoryContent(groupedHistory, set, recordId, fieldFilter = null) {
    const dateKeys = Object.keys(groupedHistory);

    if (dateKeys.length === 0) {
      return `
        <div class="record-history-empty">
          <i class="ph ph-clock-afternoon"></i>
          <div class="record-history-empty-title">No changes recorded</div>
          <div class="record-history-empty-hint">
            Changes will appear here as you edit this record
          </div>
        </div>
      `;
    }

    return dateKeys.map(dateKey => `
      <div class="record-history-date-group">
        <div class="record-history-date-label">${dateKey}</div>
        ${groupedHistory[dateKey].map(event => this._renderRecordHistoryEvent(event, set, recordId)).join('')}
      </div>
    `).join('');
  }

  /**
   * Render a single event in the record history drawer
   */
  _renderRecordHistoryEvent(event, set, recordId) {
    const action = event.payload?.action || 'unknown';
    const timestamp = event.timestamp ? new Date(event.timestamp) : null;
    const actor = event.actor || 'system';
    const fieldId = event.payload?.fieldId;
    const field = fieldId ? set.fields?.find(f => f.id === fieldId) : null;
    const previousValue = event.payload?.previousValue ?? event.payload?.oldValue;
    const newValue = event.payload?.newValue ?? event.payload?.value;

    let iconClass = 'modified';
    let icon = 'ph-pencil-simple';
    let label = field?.name || 'Field';

    switch (action) {
      case 'record_created':
      case 'create':
      case 'import':
        iconClass = 'created';
        icon = 'ph-plus-circle';
        label = 'Record Created';
        break;
      case 'record_deleted':
        iconClass = 'deleted';
        icon = 'ph-trash';
        label = 'Record Deleted';
        break;
    }

    const timeStr = timestamp
      ? timestamp.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' })
      : '';

    return `
      <div class="record-history-event">
        <div class="record-history-event-icon ${iconClass}">
          <i class="ph ${icon}"></i>
        </div>
        <div class="record-history-event-content">
          <div class="record-history-event-header">
            <span class="record-history-event-field">${this._escapeHtml(label)}</span>
            <span class="record-history-event-time">${timeStr}</span>
          </div>
          ${previousValue !== undefined || newValue !== undefined ? `
            <div class="record-history-event-change">
              ${previousValue !== undefined ? `
                <span class="old-val" title="${this._escapeHtml(String(previousValue))}">${this._escapeHtml(this._truncate(previousValue, 20))}</span>
                <span class="arrow">→</span>
              ` : ''}
              <span class="new-val" title="${this._escapeHtml(String(newValue))}">${this._escapeHtml(this._truncate(newValue, 20))}</span>
            </div>
          ` : ''}
          <div class="record-history-event-actor">
            <i class="ph ph-user"></i>
            ${this._formatActor(actor)}
          </div>
        </div>
      </div>
    `;
  }

  /**
   * Render history section for detail panel
   *
   * RECORD-LEVEL PRINCIPLE: History tracks how understanding of this record evolved.
   * Data may be stable, but understanding can change.
   *
   * Shows: When understanding changed, who changed it, and why
   */
  _renderHistorySection(record) {
    const history = this._getRecordHistory(record.id);
    const hasHistory = history.length > 0;

    // Group events by type for display
    const creationEvents = history.filter(e =>
      e.payload?.action === 'record_created' ||
      e.payload?.action === 'import' ||
      e.payload?.action === 'create'
    );
    const modificationEvents = history.filter(e =>
      e.payload?.action === 'record_updated' ||
      e.payload?.action === 'field_changed' ||
      e.payload?.action === 'update'
    );
    const otherEvents = history.filter(e =>
      !creationEvents.includes(e) && !modificationEvents.includes(e)
    );

    return `
      <div class="history-section" style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border-primary);">
        <div class="history-header" style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
          <i class="ph ph-clock-counter-clockwise" style="font-size: 14px; color: var(--text-muted);"></i>
          <span style="font-weight: 500; font-size: 13px;">Changes to this record</span>
          <span style="font-size: 11px; color: var(--text-muted);">
            ${hasHistory ? `(${history.length} change${history.length !== 1 ? 's' : ''})` : ''}
          </span>
        </div>

        ${hasHistory ? `
          <div class="history-timeline" style="display: flex; flex-direction: column; gap: 8px; max-height: 300px; overflow-y: auto;">
            ${history.slice().reverse().map(event => this._renderHistoryEvent(event)).join('')}
          </div>
        ` : `
          <div style="font-size: 12px; color: var(--text-muted); padding: 8px 0;">
            <div style="margin-bottom: 8px; font-style: italic;">
              No changes recorded yet.
            </div>
            <div style="margin-top: 12px; padding: 8px; background: var(--bg-secondary); border-radius: 4px;">
              <div style="font-size: 11px; opacity: 0.7;">From timestamps:</div>
              <div style="margin-top: 4px;">
                <i class="ph ph-plus-circle" style="color: var(--success);"></i>
                Created ${this._formatRelativeTime(record.createdAt)}
              </div>
              ${record.updatedAt !== record.createdAt ? `
                <div style="margin-top: 2px;">
                  <i class="ph ph-pencil-simple" style="color: var(--primary);"></i>
                  Last updated ${this._formatRelativeTime(record.updatedAt)}
                </div>
              ` : ''}
            </div>
          </div>
        `}
      </div>
    `;
  }

  /**
   * Render a single history event
   */
  _renderHistoryEvent(event) {
    const action = event.payload?.action || 'unknown';
    const timestamp = event.timestamp ? new Date(event.timestamp) : null;
    const actor = event.actor || 'system';

    // Determine icon and color based on action
    let icon = 'ph-circle';
    let color = 'var(--text-muted)';
    let label = action;

    switch (action) {
      case 'record_created':
      case 'create':
      case 'import':
        icon = 'ph-plus-circle';
        color = 'var(--success)';
        label = 'Created';
        break;
      case 'record_updated':
      case 'field_changed':
      case 'update':
        icon = 'ph-pencil-simple';
        color = 'var(--primary)';
        label = 'Modified';
        break;
      case 'record_deleted':
      case 'delete':
        icon = 'ph-trash';
        color = 'var(--danger)';
        label = 'Deleted';
        break;
      case 'tombstone':
        icon = 'ph-prohibit';
        color = 'var(--warning)';
        label = 'Tombstoned';
        break;
      case 'supersession':
        icon = 'ph-arrows-clockwise';
        color = 'var(--info)';
        label = 'Superseded';
        break;
    }

    // Extract field change details if available
    const fieldId = event.payload?.fieldId;
    const previousValue = event.payload?.previousValue;
    const newValue = event.payload?.newValue || event.payload?.value;
    const hasFieldChange = fieldId && (previousValue !== undefined || newValue !== undefined);

    return `
      <div class="history-event" style="display: flex; gap: 8px; font-size: 12px; padding: 4px 0;">
        <i class="ph ${icon}" style="color: ${color}; margin-top: 2px; flex-shrink: 0;"></i>
        <div style="flex: 1; min-width: 0;">
          <div style="display: flex; justify-content: space-between; gap: 8px;">
            <span style="font-weight: 500;">${label}</span>
            <span style="color: var(--text-muted); font-size: 11px;">
              ${timestamp ? this._formatRelativeTime(timestamp) : ''}
            </span>
          </div>
          ${hasFieldChange ? `
            <div style="color: var(--text-secondary); font-size: 11px; margin-top: 2px;">
              ${fieldId}: ${previousValue !== undefined ? `"${this._truncate(previousValue, 20)}" → ` : ''}${newValue !== undefined ? `"${this._truncate(newValue, 20)}"` : ''}
            </div>
          ` : ''}
          <div style="color: var(--text-muted); font-size: 10px; margin-top: 2px;">
            by ${this._formatActor(actor)}
          </div>
        </div>
      </div>
    `;
  }

  /**
   * Format relative time (e.g., "2 hours ago")
   */
  _formatRelativeTime(date) {
    if (!date) return '';
    const d = date instanceof Date ? date : new Date(date);
    if (isNaN(d.getTime())) return '';
    const now = new Date();
    const diff = now - d;

    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);

    if (days > 7) return d.toLocaleDateString();
    if (days > 0) return `${days}d ago`;
    if (hours > 0) return `${hours}h ago`;
    if (minutes > 0) return `${minutes}m ago`;
    return 'just now';
  }

  /**
   * Format date safely, handling null/undefined/invalid dates
   */
  _formatDateSafe(date) {
    if (!date) return 'Unknown';
    const d = date instanceof Date ? date : new Date(date);
    if (isNaN(d.getTime())) return 'Unknown';
    return d.toLocaleString();
  }

  /**
   * Format actor for display
   */
  _formatActor(actor) {
    if (!actor) return 'unknown';
    if (actor.startsWith('user:')) return actor.substring(5);
    if (actor.startsWith('system:')) return actor.substring(7);
    return actor;
  }

  /**
   * Truncate string for display
   */
  _truncate(value, maxLen) {
    if (value === null || value === undefined) return 'null';
    const str = String(value);
    return str.length > maxLen ? str.substring(0, maxLen) + '…' : str;
  }

  /**
   * Render a nested value (object or array) for display in a table cell
   */
  _renderNestedValue(value, searchTerm = '', depth = 0) {
    if (value === null || value === undefined) {
      return '<span class="cell-empty">-</span>';
    }

    // Prevent infinite nesting - show JSON after max depth
    const MAX_DEPTH = 3;
    if (depth >= MAX_DEPTH) {
      return `<span class="nested-json-preview">${this._highlightText(JSON.stringify(value), searchTerm)}</span>`;
    }

    // Array of objects -> nested table
    if (Array.isArray(value)) {
      if (value.length === 0) {
        return '<span class="cell-empty">[]</span>';
      }

      // Array of primitives -> comma-separated badges
      if (value.every(item => typeof item !== 'object' || item === null)) {
        return this._renderPrimitiveArray(value, searchTerm);
      }

      // Array of objects -> nested table
      return this._renderNestedTable(value, depth, searchTerm);
    }

    // Single object -> key-value display
    if (typeof value === 'object') {
      return this._renderNestedObject(value, depth, searchTerm);
    }

    // Primitive value
    return this._highlightText(String(value), searchTerm);
  }

  /**
   * Render an array of primitive values as badges/chips
   */
  _renderPrimitiveArray(arr, searchTerm = '') {
    const items = arr.slice(0, 10); // Limit display
    const hasMore = arr.length > 10;

    let html = '<div class="nested-array-badges">';
    items.forEach(item => {
      html += `<span class="nested-badge">${this._highlightText(String(item), searchTerm)}</span>`;
    });
    if (hasMore) {
      html += `<span class="nested-badge nested-more">+${arr.length - 10} more</span>`;
    }
    html += '</div>';
    return html;
  }

  /**
   * Render an array of objects as a nested table
   */
  _renderNestedTable(arr, depth, searchTerm = '') {
    // Filter to only objects
    const objects = arr.filter(item => typeof item === 'object' && item !== null && !Array.isArray(item));

    if (objects.length === 0) {
      // Mixed array - show as JSON
      return `<span class="nested-json-preview">${this._highlightText(JSON.stringify(arr), searchTerm)}</span>`;
    }

    // Get all unique keys from all objects
    const keys = new Set();
    objects.forEach(obj => Object.keys(obj).forEach(k => keys.add(k)));
    const headers = Array.from(keys);

    // Limit columns for readability
    const displayHeaders = headers.slice(0, 6);
    const hasMoreCols = headers.length > 6;

    // Limit rows
    const displayRows = objects.slice(0, 5);
    const hasMoreRows = objects.length > 5;

    let html = '<div class="nested-table-container">';
    html += '<table class="nested-table">';

    // Header
    html += '<thead><tr>';
    displayHeaders.forEach(h => {
      html += `<th>${this._escapeHtml(h)}</th>`;
    });
    if (hasMoreCols) {
      html += '<th class="nested-more-col">...</th>';
    }
    html += '</tr></thead>';

    // Body
    html += '<tbody>';
    displayRows.forEach(obj => {
      html += '<tr>';
      displayHeaders.forEach(h => {
        const cellValue = obj[h];
        html += `<td>${this._renderNestedValue(cellValue, searchTerm, depth + 1)}</td>`;
      });
      if (hasMoreCols) {
        html += '<td class="nested-more-col">...</td>';
      }
      html += '</tr>';
    });

    if (hasMoreRows) {
      html += `<tr class="nested-more-row"><td colspan="${displayHeaders.length + (hasMoreCols ? 1 : 0)}">+${objects.length - 5} more rows</td></tr>`;
    }
    html += '</tbody></table>';
    html += '</div>';

    return html;
  }

  /**
   * Render a single object as key-value pairs
   */
  _renderNestedObject(obj, depth, searchTerm = '') {
    const keys = Object.keys(obj);

    if (keys.length === 0) {
      return '<span class="cell-empty">{}</span>';
    }

    // For small objects (1-2 keys), show inline
    if (keys.length <= 2 && keys.every(k => typeof obj[k] !== 'object')) {
      return '<span class="nested-object-inline">' +
        keys.map(k => `<span class="nested-kv"><span class="nested-key">${this._escapeHtml(k)}:</span> <span class="nested-val">${this._highlightText(String(obj[k]), searchTerm)}</span></span>`).join(' ') +
        '</span>';
    }

    // For larger objects, show as compact table
    const displayKeys = keys.slice(0, 4);
    const hasMore = keys.length > 4;

    let html = '<div class="nested-object-container">';
    html += '<div class="nested-object-grid">';
    displayKeys.forEach(k => {
      html += `<div class="nested-object-row">`;
      html += `<span class="nested-key">${this._escapeHtml(k)}</span>`;
      html += `<span class="nested-val">${this._renderNestedValue(obj[k], searchTerm, depth + 1)}</span>`;
      html += '</div>';
    });
    if (hasMore) {
      html += `<div class="nested-object-more">+${keys.length - 4} more fields</div>`;
    }
    html += '</div>';
    html += '</div>';

    return html;
  }

  /**
   * Render JSON field value as elegant key-value pairs
   * This is the default display for JSON field type
   */
  _renderJsonKeyValue(value, field, searchTerm = '') {
    // Handle string values - try to parse as JSON
    let data = value;
    if (typeof value === 'string') {
      try {
        data = JSON.parse(value);
      } catch (e) {
        // Not valid JSON, show as raw string
        return `<span class="cell-json-raw">${this._highlightText(value, searchTerm)}</span>`;
      }
    }

    // Null/undefined
    if (data === null || data === undefined) {
      return '<span class="cell-empty">-</span>';
    }

    // Primitives (number, boolean, string that wasn't JSON)
    if (typeof data !== 'object') {
      return this._renderJsonPrimitive(data, searchTerm);
    }

    // Arrays
    if (Array.isArray(data)) {
      if (data.length === 0) {
        return '<span class="cell-empty json-empty">[]</span>';
      }
      // For arrays, show count with preview
      const preview = data.slice(0, 3).map(item =>
        typeof item === 'object' ? '{...}' : String(item)
      ).join(', ');
      const hasMore = data.length > 3 ? ` +${data.length - 3}` : '';
      return `<span class="json-array-preview" title="${this._escapeHtml(JSON.stringify(data))}">[${this._highlightText(preview, searchTerm)}${hasMore}]</span>`;
    }

    // Objects - render as key-value pairs
    const keys = Object.keys(data);
    if (keys.length === 0) {
      return '<span class="cell-empty json-empty">{}</span>';
    }

    let html = '<div class="json-kv-container">';

    // Show up to 4 key-value pairs
    const displayKeys = keys.slice(0, 4);
    displayKeys.forEach(key => {
      const val = data[key];
      html += '<div class="json-kv-row">';
      html += `<span class="json-key">${this._escapeHtml(key)}</span>`;
      html += `<span class="json-val">${this._renderJsonPrimitive(val, searchTerm)}</span>`;
      html += '</div>';
    });

    if (keys.length > 4) {
      html += `<div class="json-kv-more">+${keys.length - 4} more</div>`;
    }

    html += '</div>';

    return html;
  }

  /**
   * Render a JSON primitive value with appropriate formatting
   */
  _renderJsonPrimitive(val, searchTerm = '') {
    if (val === null) {
      return '<span class="json-null">null</span>';
    }
    if (val === undefined) {
      return '<span class="json-undefined">undefined</span>';
    }
    if (typeof val === 'boolean') {
      return `<span class="json-bool"><i class="ph ${val ? 'ph-check-circle' : 'ph-x-circle'}"></i> ${val}</span>`;
    }
    if (typeof val === 'number') {
      return `<span class="json-number">${this._highlightText(String(val), searchTerm)}</span>`;
    }
    if (typeof val === 'string') {
      // Truncate long strings
      const display = val.length > 30 ? val.substring(0, 30) + '...' : val;
      return `<span class="json-string" title="${this._escapeHtml(val)}">${this._highlightText(display, searchTerm)}</span>`;
    }
    if (Array.isArray(val)) {
      return `<span class="json-array">[${val.length}]</span>`;
    }
    if (typeof val === 'object') {
      return `<span class="json-object">{${Object.keys(val).length}}</span>`;
    }
    return this._escapeHtml(String(val));
  }

  /**
   * Show modal with full nested data view
   */
  _showNestedDataModal(jsonString) {
    const data = JSON.parse(jsonString);

    // Create modal content
    const modalContent = document.createElement('div');
    modalContent.className = 'nested-data-modal';

    // Render full data recursively
    if (Array.isArray(data)) {
      modalContent.innerHTML = this._renderFullNestedTable(data);
    } else {
      modalContent.innerHTML = this._renderFullNestedObject(data);
    }

    // Show in modal
    const modal = document.getElementById('modal-overlay');
    const modalBody = modal.querySelector('.modal-body');
    const modalTitle = modal.querySelector('.modal-title');

    if (modal && modalBody && modalTitle) {
      modalTitle.textContent = 'Nested Data';
      modalBody.innerHTML = '';
      modalBody.appendChild(modalContent);
      modal.classList.add('active');
    }
  }

  /**
   * Render full nested table for modal view
   */
  _renderFullNestedTable(arr) {
    if (!Array.isArray(arr) || arr.length === 0) {
      return '<p class="cell-empty">No data</p>';
    }

    // Get all unique keys
    const keys = new Set();
    arr.forEach(item => {
      if (typeof item === 'object' && item !== null) {
        Object.keys(item).forEach(k => keys.add(k));
      }
    });
    const headers = Array.from(keys);

    let html = '<div class="nested-modal-table-wrapper">';
    html += '<table class="nested-modal-table">';

    // Header
    html += '<thead><tr>';
    headers.forEach(h => {
      html += `<th>${this._escapeHtml(h)}</th>`;
    });
    html += '</tr></thead>';

    // Body
    html += '<tbody>';
    arr.forEach((item, idx) => {
      if (typeof item === 'object' && item !== null && !Array.isArray(item)) {
        html += '<tr>';
        headers.forEach(h => {
          const cellValue = item[h];
          html += `<td>${this._renderModalCellValue(cellValue)}</td>`;
        });
        html += '</tr>';
      } else {
        html += `<tr><td colspan="${headers.length}">${this._renderModalCellValue(item)}</td></tr>`;
      }
    });
    html += '</tbody></table></div>';

    return html;
  }

  /**
   * Render full nested object for modal view
   */
  _renderFullNestedObject(obj) {
    if (typeof obj !== 'object' || obj === null) {
      return `<p>${this._escapeHtml(String(obj))}</p>`;
    }

    let html = '<div class="nested-modal-object">';
    Object.entries(obj).forEach(([key, value]) => {
      html += '<div class="nested-modal-field">';
      html += `<div class="nested-modal-key">${this._escapeHtml(key)}</div>`;
      html += `<div class="nested-modal-value">${this._renderModalCellValue(value)}</div>`;
      html += '</div>';
    });
    html += '</div>';

    return html;
  }

  /**
   * Render a cell value for modal display (recursive)
   */
  _renderModalCellValue(value) {
    if (value === null || value === undefined) {
      return '<span class="cell-empty">-</span>';
    }

    if (Array.isArray(value)) {
      if (value.length === 0) return '<span class="cell-empty">[]</span>';
      if (value.every(item => typeof item !== 'object' || item === null)) {
        return value.map(v => `<span class="nested-badge">${this._escapeHtml(String(v))}</span>`).join(' ');
      }
      return this._renderFullNestedTable(value);
    }

    if (typeof value === 'object') {
      return this._renderFullNestedObject(value);
    }

    return this._escapeHtml(String(value));
  }

  // --------------------------------------------------------------------------
  // Public API
  // --------------------------------------------------------------------------

  getSets() {
    return this.sets;
  }

  getRecords(setId = null) {
    const targetSetId = setId || this.currentSetId;
    const set = this.sets.find(s => s.id === targetSetId);
    return set?.records || [];
  }

  getFields(setId = null) {
    const targetSetId = setId || this.currentSetId;
    const set = this.sets.find(s => s.id === targetSetId);
    return set?.fields || [];
  }

  refresh() {
    this._renderView();
  }

  exportData() {
    return {
      sets: this.sets,
      exportedAt: new Date().toISOString()
    };
  }

  // ==========================================================================
  // PIPELINE MANAGEMENT METHODS
  // ==========================================================================

  /**
   * Initialize the pipeline manager
   */
  _initPipelineManager() {
    if (typeof PipelineManager !== 'undefined') {
      this.pipelineManager = new PipelineManager(this);
    }
  }

  /**
   * Toggle the pipeline panel open/closed
   */
  _togglePipelinePanel() {
    const panel = document.getElementById('pipeline-panel');
    if (!panel) return;

    // Close detail panel if open
    this._closeDetailPanel();

    if (panel.classList.contains('open')) {
      this._closePipelinePanel();
    } else {
      this._openPipelinePanel();
    }
  }

  /**
   * Open the pipeline panel
   */
  _openPipelinePanel() {
    const panel = document.getElementById('pipeline-panel');
    if (panel) {
      panel.classList.add('open');
      this._renderPipelinePanel();
    }
  }

  /**
   * Close the pipeline panel
   */
  _closePipelinePanel() {
    const panel = document.getElementById('pipeline-panel');
    if (panel) {
      panel.classList.remove('open');
    }
  }

  /**
   * Render the pipeline panel contents
   */
  _renderPipelinePanel() {
    const body = document.getElementById('pipeline-panel-body');
    if (!body) return;

    const set = this.getCurrentSet();
    if (!set) {
      body.innerHTML = `
        <div class="empty-state-small">
          <i class="ph ph-warning"></i>
          <p>Select a set to manage its pipeline</p>
        </div>
      `;
      return;
    }

    // Initialize pipeline if not exists
    if (!set.pipeline) {
      set.pipeline = {
        steps: [],
        history: [],
        lastExecutedAt: null
      };
    }

    // Render based on view mode
    if (this._pipelineViewMode === 'canvas') {
      this._renderPipelineCanvasView(body, set);
      return;
    }

    const steps = set.pipeline.steps || [];

    if (steps.length === 0) {
      body.innerHTML = `
        <div class="empty-state-small">
          <i class="ph ph-flow-arrow"></i>
          <p>No data flow steps yet</p>
          <p style="font-size: 11px; color: var(--text-muted); margin-top: 8px;">
            Add steps to merge sources, filter records, or transform data
          </p>
        </div>
      `;
      return;
    }

    // Render pipeline steps
    let html = '<div class="pipeline-steps">';

    steps.forEach((step, idx) => {
      const icon = (typeof PipelineStepIcons !== 'undefined' && PipelineStepIcons[step.type]) || 'ph-circle';
      const isDisabled = !step.enabled;
      const stats = step.lastExecution?.stats || {};

      html += `
        <div class="pipeline-step ${isDisabled ? 'disabled' : ''}" data-step-id="${step.id}" draggable="true">
          <div class="pipeline-step-header">
            <div class="pipeline-step-type ${step.type}">
              <i class="ph ${icon}"></i>
              <span>${this._formatStepType(step.type)}</span>
            </div>
            <div class="pipeline-step-actions">
              <button class="pipeline-step-action" data-action="toggle" title="${isDisabled ? 'Enable' : 'Disable'}">
                <i class="ph ${isDisabled ? 'ph-eye-slash' : 'ph-eye'}"></i>
              </button>
              <button class="pipeline-step-action" data-action="edit" title="Edit">
                <i class="ph ph-pencil"></i>
              </button>
              <button class="pipeline-step-action danger" data-action="delete" title="Delete">
                <i class="ph ph-trash"></i>
              </button>
            </div>
          </div>
          <div class="pipeline-step-content">
            ${this._renderStepSummary(step)}
          </div>
          ${Object.keys(stats).length > 0 ? `
            <div class="pipeline-step-stats">
              ${stats.added ? `<span class="pipeline-step-stat"><i class="ph ph-plus"></i> ${stats.added}</span>` : ''}
              ${stats.matched ? `<span class="pipeline-step-stat"><i class="ph ph-check"></i> ${stats.matched}</span>` : ''}
              ${stats.removed ? `<span class="pipeline-step-stat"><i class="ph ph-minus"></i> ${stats.removed}</span>` : ''}
            </div>
          ` : ''}
        </div>
        ${idx < steps.length - 1 ? '<div class="pipeline-connector"><i class="ph ph-arrow-down"></i></div>' : ''}
      `;
    });

    html += '</div>';

    // Add execution info
    if (set.pipeline.lastExecutedAt) {
      const lastRun = new Date(set.pipeline.lastExecutedAt);
      html += `
        <div style="margin-top: 16px; font-size: 11px; color: var(--text-muted);">
          <i class="ph ph-clock"></i>
          Last run: ${lastRun.toLocaleString()}
        </div>
      `;
    }

    body.innerHTML = html;

    // Add event listeners for step actions
    body.querySelectorAll('.pipeline-step-action').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const stepEl = btn.closest('.pipeline-step');
        const stepId = stepEl?.dataset.stepId;
        const action = btn.dataset.action;

        if (stepId && action) {
          this._handleStepAction(stepId, action);
        }
      });
    });

    // Add drag-and-drop for reordering
    this._initPipelineStepDragDrop();
  }

  /**
   * Render the pipeline canvas view (n8n-style visual flow builder)
   */
  _renderPipelineCanvasView(body, set) {
    // Set up container for the canvas
    body.innerHTML = `
      <div id="pipeline-canvas-container" style="width: 100%; height: 100%; min-height: 400px;"></div>
    `;

    // Destroy existing canvas if any
    if (this._pipelineCanvas) {
      this._pipelineCanvas.destroy();
    }

    // Create the canvas
    const container = document.getElementById('pipeline-canvas-container');
    if (!container || typeof PipelineCanvas === 'undefined') {
      body.innerHTML = `
        <div class="empty-state-small">
          <i class="ph ph-warning"></i>
          <p>Canvas view not available</p>
        </div>
      `;
      return;
    }

    this._pipelineCanvas = new PipelineCanvas(container, {
      onNodeSelect: (node) => {
        if (node) {
          this._showPipelineNodeInspector(node);
        }
      },
      onNodeChange: (action, node) => {
        this._syncCanvasToSteps(set);
      },
      onConnectionChange: (action, connection) => {
        this._syncCanvasToSteps(set);
      },
      onRun: () => {
        this._runPipeline();
      }
    });

    // Load existing pipeline steps into the canvas
    this._loadStepsIntoCanvas(set);
  }

  /**
   * Load pipeline steps into the canvas as nodes
   */
  _loadStepsIntoCanvas(set) {
    if (!this._pipelineCanvas) return;

    const steps = set.pipeline?.steps || [];
    const nodes = [];
    const connections = [];

    // Convert steps to nodes
    let x = 100;
    let y = 150;
    let prevNodeId = null;

    steps.forEach((step, idx) => {
      const nodeId = `step_${step.id}`;

      // Determine node type
      let nodeType = step.type;

      // Get metric (record count or description)
      let metric = null;
      if (step.lastExecution?.stats?.outputCount != null) {
        metric = `${step.lastExecution.stats.outputCount} records`;
      }

      // Get label
      let label = this._formatStepType(step.type);
      if (step.type === 'source' && step.config?.sourceId) {
        const source = this.sources?.find(s => s.id === step.config.sourceId);
        label = source?.name || source?.payload?.name || 'Source';
      } else if (step.type === 'filter' && step.config?.conditions?.length > 0) {
        label = `Filter (${step.config.conditions.length} conditions)`;
      }

      nodes.push({
        id: nodeId,
        type: nodeType,
        x,
        y,
        label,
        status: step.enabled ? 'idle' : 'stale',
        config: step.config,
        metric,
        stepId: step.id
      });

      // Create connection from previous step
      if (prevNodeId) {
        connections.push({
          id: `conn_${idx}`,
          from: prevNodeId,
          to: nodeId
        });
      }

      prevNodeId = nodeId;
      x += 280;

      // Wrap to next row after 3 nodes
      if ((idx + 1) % 3 === 0) {
        x = 100;
        y += 140;
      }
    });

    // Load into canvas
    this._pipelineCanvas.loadPipeline({ nodes, connections });
  }

  /**
   * Sync canvas nodes back to pipeline steps
   */
  _syncCanvasToSteps(set) {
    if (!this._pipelineCanvas) return;

    const canvasData = this._pipelineCanvas.getPipelineData();

    // Update step positions (for future persistence)
    canvasData.nodes.forEach(node => {
      if (node.stepId) {
        const step = set.pipeline?.steps?.find(s => s.id === node.stepId);
        if (step) {
          step._canvasPosition = { x: node.x, y: node.y };
        }
      }
    });

    this._saveData();
  }

  /**
   * Show inspector panel for a pipeline node
   */
  _showPipelineNodeInspector(node) {
    // For now, just log - could show a config panel
    console.log('Selected pipeline node:', node);
  }

  /**
   * Format step type for display
   */
  _formatStepType(type) {
    const names = {
      source: 'Source',
      merge: 'Merge',
      filter: 'Filter',
      transform: 'Transform',
      dedupe: 'Dedupe',
      rollup: 'Rollup',
      sort: 'Sort',
      link: 'Link'
    };
    return names[type] || type;
  }

  /**
   * Render a summary of what the step does
   */
  _renderStepSummary(step) {
    const config = step.config || {};

    switch (step.type) {
      case 'source': {
        const source = this.sources?.find(s => s.id === config.sourceId);
        const name = source?.name || source?.payload?.name || 'Unknown source';
        return `<div class="pipeline-step-summary"><span class="pipeline-step-tag">${this._escapeHtml(name)}</span></div>`;
      }

      case 'merge': {
        const source = this.sources?.find(s => s.id === config.sourceId);
        const name = source?.name || source?.payload?.name || 'Unknown source';
        const matchFields = config.matchFields?.map(f => typeof f === 'string' ? f : f.field).join(', ') || 'auto';
        return `
          <div class="pipeline-step-summary">
            <span class="pipeline-step-tag">${this._escapeHtml(name)}</span>
            <span class="pipeline-step-tag">on: ${matchFields}</span>
          </div>
        `;
      }

      case 'filter': {
        const conditions = config.conditions || [];
        const condStr = conditions.map(c => `${c.field} ${c.operator}`).join(', ');
        return `<div class="pipeline-step-summary"><span class="pipeline-step-tag">${condStr || 'No conditions'}</span></div>`;
      }

      case 'transform': {
        const transforms = config.transformations || [];
        return `<div class="pipeline-step-summary"><span class="pipeline-step-tag">${transforms.length} transformation(s)</span></div>`;
      }

      case 'dedupe': {
        const fields = config.matchFields?.join(', ') || 'all fields';
        return `<div class="pipeline-step-summary"><span class="pipeline-step-tag">on: ${fields}</span></div>`;
      }

      default:
        return step.note ? `<div class="pipeline-step-summary">${this._escapeHtml(step.note)}</div>` : '';
    }
  }

  /**
   * Handle step action (toggle, edit, delete)
   */
  _handleStepAction(stepId, action) {
    const set = this.getCurrentSet();
    if (!set?.pipeline) return;

    const step = set.pipeline.steps.find(s => s.id === stepId);
    if (!step) return;

    switch (action) {
      case 'toggle':
        step.enabled = !step.enabled;
        // Record activity for pipeline step toggle
        this._recordActivity({
          action: 'update',
          entityType: 'pipeline',
          name: `${this._formatStepType(step.type)} step`,
          details: `${step.enabled ? 'Enabled' : 'Disabled'} ${this._formatStepType(step.type)} step in "${set.name}"`,
          canReverse: false
        });
        this._saveData();
        this._renderPipelinePanel();
        this._showToast(`Step ${step.enabled ? 'enabled' : 'disabled'}`, 'info');
        break;

      case 'edit':
        this._showEditStepModal(step);
        break;

      case 'delete':
        const idx = set.pipeline.steps.findIndex(s => s.id === stepId);
        if (idx !== -1) {
          const stepType = this._formatStepType(step.type);
          set.pipeline.steps.splice(idx, 1);
          // Record activity for pipeline step deletion
          this._recordActivity({
            action: 'delete',
            entityType: 'pipeline',
            name: `${stepType} step`,
            details: `Removed ${stepType} step from pipeline in "${set.name}"`,
            canReverse: false
          });
          this._saveData();
          this._renderPipelinePanel();
          this._showToast('Step removed', 'info');
        }
        break;
    }
  }

  /**
   * Initialize drag and drop for pipeline steps
   */
  _initPipelineStepDragDrop() {
    const body = document.getElementById('pipeline-panel-body');
    if (!body) return;

    const steps = body.querySelectorAll('.pipeline-step');
    let draggedStep = null;

    steps.forEach(step => {
      step.addEventListener('dragstart', (e) => {
        draggedStep = step;
        step.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
      });

      step.addEventListener('dragend', () => {
        step.classList.remove('dragging');
        draggedStep = null;
      });

      step.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
      });

      step.addEventListener('drop', (e) => {
        e.preventDefault();
        if (!draggedStep || draggedStep === step) return;

        // Reorder steps
        const set = this.getCurrentSet();
        if (!set?.pipeline?.steps) return;

        const fromId = draggedStep.dataset.stepId;
        const toId = step.dataset.stepId;
        const fromIdx = set.pipeline.steps.findIndex(s => s.id === fromId);
        const toIdx = set.pipeline.steps.findIndex(s => s.id === toId);

        if (fromIdx !== -1 && toIdx !== -1) {
          const [moved] = set.pipeline.steps.splice(fromIdx, 1);
          set.pipeline.steps.splice(toIdx, 0, moved);
          this._saveData();
          this._renderPipelinePanel();
        }
      });
    });
  }

  /**
   * Show modal to add a new pipeline step
   */
  _showAddStepModal() {
    const set = this.getCurrentSet();
    if (!set) {
      this._showToast('Select a set first', 'warning');
      return;
    }

    const stepOptions = [
      { type: 'source', icon: 'ph-database', name: 'Source', desc: 'Pull records from a source' },
      { type: 'merge', icon: 'ph-git-merge', name: 'Merge', desc: 'Layer in data by matching key' },
      { type: 'filter', icon: 'ph-funnel', name: 'Filter', desc: 'Remove records by condition' },
      { type: 'transform', icon: 'ph-magic-wand', name: 'Transform', desc: 'Modify field values' },
      { type: 'dedupe', icon: 'ph-users-three', name: 'Dedupe', desc: 'Collapse duplicate records' },
      { type: 'sort', icon: 'ph-sort-ascending', name: 'Sort', desc: 'Order records' }
    ];

    const optionsHtml = stepOptions.map(opt => `
      <div class="pipeline-step-option" data-step-type="${opt.type}">
        <i class="ph ${opt.icon}"></i>
        <div class="pipeline-step-option-name">${opt.name}</div>
        <div class="pipeline-step-option-desc">${opt.desc}</div>
      </div>
    `).join('');

    this._showModal('Add Pipeline Step', `
      <p style="margin-bottom: 16px; color: var(--text-secondary);">
        Choose a step type to add to the pipeline:
      </p>
      <div class="pipeline-step-options">
        ${optionsHtml}
      </div>
    `);

    // Add click handlers for options
    setTimeout(() => {
      document.querySelectorAll('.pipeline-step-option').forEach(opt => {
        opt.addEventListener('click', () => {
          const type = opt.dataset.stepType;
          this._closeModal();
          this._showStepConfigModal(type);
        });
      });
    }, 100);
  }

  /**
   * Show configuration modal for a specific step type
   */
  _showStepConfigModal(type) {
    switch (type) {
      case 'source':
        this._showSourceStepConfig();
        break;
      case 'merge':
        this._showMergeStepConfig();
        break;
      case 'filter':
        this._showFilterStepConfig();
        break;
      case 'transform':
        this._showTransformStepConfig();
        break;
      case 'dedupe':
        this._showDedupeStepConfig();
        break;
      case 'sort':
        this._showSortStepConfig();
        break;
      default:
        this._showToast(`Unknown step type: ${type}`, 'error');
    }
  }

  /**
   * Show source step configuration
   */
  _showSourceStepConfig() {
    const sources = this.sources || [];

    if (sources.length === 0) {
      this._showToast('No sources available. Import a file first.', 'warning');
      return;
    }

    const sourcesHtml = sources.map(src => {
      const name = src.name || src.payload?.name || 'Unknown';
      const count = src.recordCount || src.records?.length || 0;
      return `<option value="${src.id}">${this._escapeHtml(name)} (${count} records)</option>`;
    }).join('');

    this._showModal('Add Source Step', `
      <div class="form-group">
        <label class="form-label">Select Source</label>
        <select class="form-select" id="step-source-id">
          ${sourcesHtml}
        </select>
      </div>
    `, () => {
      const sourceId = document.getElementById('step-source-id')?.value;
      if (!sourceId) return;

      this._addPipelineStep('source', { sourceId });
    }, { confirmText: 'Add Step' });
  }

  /**
   * Show merge step configuration
   */
  _showMergeStepConfig() {
    const sources = this.sources || [];
    const set = this.getCurrentSet();
    const fields = set?.fields || [];

    if (sources.length === 0) {
      this._showToast('No sources available. Import a file first.', 'warning');
      return;
    }

    const sourcesHtml = sources.map(src => {
      const name = src.name || src.payload?.name || 'Unknown';
      const count = src.recordCount || src.records?.length || 0;
      return `<option value="${src.id}">${this._escapeHtml(name)} (${count} records)</option>`;
    }).join('');

    const fieldsHtml = fields.map(f => `
      <option value="${f.id}">${this._escapeHtml(f.name)}</option>
    `).join('');

    const strategiesHtml = Object.entries(typeof MergeStrategyLabels !== 'undefined' ? MergeStrategyLabels : {
      keepFirst: 'Keep first',
      preferNonEmpty: 'Prefer non-empty',
      concat: 'Concatenate',
      keepLast: 'Keep last'
    }).map(([value, label]) => `<option value="${value}">${label}</option>`).join('');

    this._showModal('Add Merge Step', `
      <div class="form-group">
        <label class="form-label">Source to Merge</label>
        <select class="form-select" id="merge-source-id">
          ${sourcesHtml}
        </select>
      </div>
      <div class="form-group">
        <label class="form-label">Match on Field</label>
        <select class="form-select" id="merge-match-field">
          <option value="">Select field...</option>
          ${fieldsHtml}
        </select>
        <p class="form-hint">Records with the same value in this field will be merged</p>
      </div>
      <div class="form-group">
        <label class="form-label">Default Merge Strategy</label>
        <select class="form-select" id="merge-strategy">
          ${strategiesHtml}
        </select>
        <p class="form-hint">How to resolve conflicts when both records have values</p>
      </div>
      <div class="form-group">
        <label class="form-check">
          <input type="checkbox" id="merge-add-unmatched" checked>
          <span>Add unmatched records as new</span>
        </label>
      </div>
    `, () => {
      const sourceId = document.getElementById('merge-source-id')?.value;
      const matchField = document.getElementById('merge-match-field')?.value;
      const strategy = document.getElementById('merge-strategy')?.value;
      const addUnmatched = document.getElementById('merge-add-unmatched')?.checked;

      if (!sourceId) {
        this._showToast('Select a source', 'warning');
        return;
      }

      // Find the field name from the set
      const field = set.fields.find(f => f.id === matchField);
      const matchFieldName = field?.name || matchField;

      this._addPipelineStep('merge', {
        sourceId,
        matchFields: matchFieldName ? [matchFieldName] : [],
        defaultStrategy: strategy || 'preferNonEmpty',
        addUnmatched
      });
    }, { confirmText: 'Add Merge Step' });
  }

  /**
   * Show filter step configuration
   */
  _showFilterStepConfig() {
    const set = this.getCurrentSet();
    const fields = set?.fields || [];

    const fieldsHtml = fields.map(f => `
      <option value="${f.name}">${this._escapeHtml(f.name)}</option>
    `).join('');

    const operatorsHtml = [
      ['equals', 'Equals'],
      ['notEquals', 'Not equals'],
      ['contains', 'Contains'],
      ['notContains', 'Does not contain'],
      ['isEmpty', 'Is empty'],
      ['isNotEmpty', 'Is not empty'],
      ['greaterThan', 'Greater than'],
      ['lessThan', 'Less than']
    ].map(([value, label]) => `<option value="${value}">${label}</option>`).join('');

    this._showModal('Add Filter Step', `
      <div class="form-group">
        <label class="form-label">Filter Condition</label>
        <div style="display: flex; gap: 8px;">
          <select class="form-select" id="filter-field" style="flex: 1;">
            ${fieldsHtml}
          </select>
          <select class="form-select" id="filter-operator" style="flex: 1;">
            ${operatorsHtml}
          </select>
        </div>
      </div>
      <div class="form-group" id="filter-value-group">
        <label class="form-label">Value</label>
        <input type="text" class="form-input" id="filter-value" placeholder="Enter value...">
      </div>
      <div class="form-group">
        <label class="form-check">
          <input type="checkbox" id="filter-invert">
          <span>Invert (keep records that DON'T match)</span>
        </label>
      </div>
    `, () => {
      const field = document.getElementById('filter-field')?.value;
      const operator = document.getElementById('filter-operator')?.value;
      const value = document.getElementById('filter-value')?.value;
      const invert = document.getElementById('filter-invert')?.checked;

      if (!field || !operator) {
        this._showToast('Configure the filter condition', 'warning');
        return;
      }

      this._addPipelineStep('filter', {
        conditions: [{ field, operator, value }],
        logic: 'and',
        invert
      });
    }, { confirmText: 'Add Filter Step' });
  }

  /**
   * Show transform step configuration
   */
  _showTransformStepConfig() {
    const set = this.getCurrentSet();
    const fields = set?.fields || [];

    const fieldsHtml = fields.map(f => `
      <option value="${f.name}">${this._escapeHtml(f.name)}</option>
    `).join('');

    const operationsHtml = [
      ['uppercase', 'Uppercase'],
      ['lowercase', 'Lowercase'],
      ['trim', 'Trim whitespace'],
      ['replace', 'Find & Replace'],
      ['prefix', 'Add prefix'],
      ['suffix', 'Add suffix']
    ].map(([value, label]) => `<option value="${value}">${label}</option>`).join('');

    this._showModal('Add Transform Step', `
      <div class="form-group">
        <label class="form-label">Field to Transform</label>
        <select class="form-select" id="transform-field">
          ${fieldsHtml}
        </select>
      </div>
      <div class="form-group">
        <label class="form-label">Operation</label>
        <select class="form-select" id="transform-operation">
          ${operationsHtml}
        </select>
      </div>
      <div class="form-group" id="transform-params-group" style="display: none;">
        <label class="form-label" id="transform-param-label">Value</label>
        <input type="text" class="form-input" id="transform-param" placeholder="">
      </div>
    `, () => {
      const field = document.getElementById('transform-field')?.value;
      const operation = document.getElementById('transform-operation')?.value;
      const param = document.getElementById('transform-param')?.value;

      if (!field || !operation) {
        this._showToast('Configure the transformation', 'warning');
        return;
      }

      let params = {};
      if (operation === 'replace') {
        params = { find: param, replace: '' };
      } else if (operation === 'prefix') {
        params = { prefix: param };
      } else if (operation === 'suffix') {
        params = { suffix: param };
      }

      this._addPipelineStep('transform', {
        transformations: [{ field, operation, params }]
      });
    }, { confirmText: 'Add Transform Step' });

    // Show/hide params based on operation
    setTimeout(() => {
      const opSelect = document.getElementById('transform-operation');
      const paramsGroup = document.getElementById('transform-params-group');
      const paramLabel = document.getElementById('transform-param-label');

      opSelect?.addEventListener('change', () => {
        const op = opSelect.value;
        if (['replace', 'prefix', 'suffix'].includes(op)) {
          paramsGroup.style.display = 'block';
          if (op === 'replace') paramLabel.textContent = 'Find text';
          else if (op === 'prefix') paramLabel.textContent = 'Prefix';
          else if (op === 'suffix') paramLabel.textContent = 'Suffix';
        } else {
          paramsGroup.style.display = 'none';
        }
      });
    }, 100);
  }

  /**
   * Show dedupe step configuration
   */
  _showDedupeStepConfig() {
    const set = this.getCurrentSet();
    const fields = set?.fields || [];

    const fieldsHtml = fields.map(f => `
      <label class="form-check">
        <input type="checkbox" class="dedupe-field" value="${f.name}">
        <span>${this._escapeHtml(f.name)}</span>
      </label>
    `).join('');

    this._showModal('Add Dedupe Step', `
      <div class="form-group">
        <label class="form-label">Match on Fields</label>
        <p class="form-hint">Records matching on ALL selected fields will be merged</p>
        <div style="display: flex; flex-direction: column; gap: 4px; margin-top: 8px;">
          ${fieldsHtml}
        </div>
      </div>
    `, () => {
      const matchFields = Array.from(document.querySelectorAll('.dedupe-field:checked'))
        .map(cb => cb.value);

      if (matchFields.length === 0) {
        this._showToast('Select at least one field', 'warning');
        return;
      }

      this._addPipelineStep('dedupe', { matchFields });
    }, { confirmText: 'Add Dedupe Step' });
  }

  /**
   * Show sort step configuration
   */
  _showSortStepConfig() {
    const set = this.getCurrentSet();
    const fields = set?.fields || [];

    const fieldsHtml = fields.map(f => `
      <option value="${f.name}">${this._escapeHtml(f.name)}</option>
    `).join('');

    this._showModal('Add Sort Step', `
      <div class="form-group">
        <label class="form-label">Sort by Field</label>
        <select class="form-select" id="sort-field">
          ${fieldsHtml}
        </select>
      </div>
      <div class="form-group">
        <label class="form-label">Direction</label>
        <select class="form-select" id="sort-direction">
          <option value="asc">Ascending (A-Z, 0-9)</option>
          <option value="desc">Descending (Z-A, 9-0)</option>
        </select>
      </div>
    `, () => {
      const field = document.getElementById('sort-field')?.value;
      const direction = document.getElementById('sort-direction')?.value;

      if (!field) {
        this._showToast('Select a field', 'warning');
        return;
      }

      this._addPipelineStep('sort', {
        sorts: [{ field, direction }]
      });
    }, { confirmText: 'Add Sort Step' });
  }

  /**
   * Add a step to the current set's pipeline
   */
  _addPipelineStep(type, config) {
    const set = this.getCurrentSet();
    if (!set) return;

    // Initialize pipeline if needed
    if (!set.pipeline) {
      set.pipeline = { steps: [], history: [], lastExecutedAt: null };
    }

    // Create the step using factory functions if available
    let step;
    if (type === 'source' && typeof createSourceStep === 'function') {
      step = createSourceStep(config.sourceId, config);
    } else if (type === 'merge' && typeof createMergeStep === 'function') {
      step = createMergeStep(config.sourceId, config);
    } else if (type === 'filter' && typeof createFilterStep === 'function') {
      step = createFilterStep(config.conditions, config);
    } else if (type === 'dedupe' && typeof createDedupeStep === 'function') {
      step = createDedupeStep(config.matchFields, config);
    } else if (typeof createPipelineStep === 'function') {
      step = createPipelineStep(type, config);
    } else {
      // Fallback
      step = {
        id: `step_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 6)}`,
        type,
        config,
        enabled: true,
        createdAt: new Date().toISOString()
      };
    }

    set.pipeline.steps.push(step);

    // Record activity for pipeline step addition
    this._recordActivity({
      action: 'create',
      entityType: 'pipeline',
      name: `${this._formatStepType(type)} step`,
      details: `Added ${this._formatStepType(type)} step to pipeline in "${set.name}"`,
      canReverse: false
    });

    this._saveData();
    this._renderPipelinePanel();
    this._showToast(`${this._formatStepType(type)} step added`, 'success');
  }

  /**
   * Show edit modal for an existing step
   */
  _showEditStepModal(step) {
    // For now, just show step details - full edit can be added later
    this._showModal('Edit Step', `
      <div class="form-group">
        <label class="form-label">Step Type</label>
        <div class="form-static">${this._formatStepType(step.type)}</div>
      </div>
      <div class="form-group">
        <label class="form-label">Note</label>
        <input type="text" class="form-input" id="step-note" value="${this._escapeHtml(step.note || '')}" placeholder="Add a note...">
      </div>
      <div class="form-group">
        <label class="form-label">Configuration</label>
        <pre style="background: var(--bg-tertiary); padding: 12px; border-radius: var(--radius-sm); font-size: 11px; overflow: auto; max-height: 200px;">${JSON.stringify(step.config, null, 2)}</pre>
      </div>
    `, () => {
      const note = document.getElementById('step-note')?.value;
      step.note = note;
      step.updatedAt = new Date().toISOString();
      this._saveData();
      this._renderPipelinePanel();
      this._showToast('Step updated', 'success');
    });
  }

  /**
   * Run the pipeline for the current set
   */
  _runPipeline() {
    const set = this.getCurrentSet();
    if (!set) {
      this._showToast('No set selected', 'warning');
      return;
    }

    if (!set.pipeline?.steps?.length) {
      this._showToast('No pipeline steps to run', 'warning');
      return;
    }

    // Initialize pipeline manager if needed
    if (!this.pipelineManager && typeof PipelineManager !== 'undefined') {
      this.pipelineManager = new PipelineManager(this);
    }

    if (!this.pipelineManager) {
      this._showToast('Pipeline manager not available', 'error');
      return;
    }

    this._showToast('Running pipeline...', 'info');

    const result = this.pipelineManager.execute(set.id, {
      onProgress: (progress) => {
        console.log(`Pipeline step ${progress.step}/${progress.total}: ${progress.stepType}`);
      }
    });

    if (result.success) {
      this._showToast(`Pipeline complete: ${result.records.length} records`, 'success');
      this._saveData();
      this._renderPipelinePanel();
      this._renderView();
    } else {
      this._showToast(`Pipeline errors: ${result.errors.length}`, 'error');
      console.error('Pipeline errors:', result.errors);
    }
  }

  /**
   * Show pipeline execution history
   */
  _showPipelineHistory() {
    const set = this.getCurrentSet();
    if (!set?.pipeline?.history?.length) {
      this._showToast('No pipeline history', 'info');
      return;
    }

    const history = set.pipeline.history.slice(-10).reverse();

    const historyHtml = history.map(entry => `
      <div class="pipeline-history-entry">
        <div class="pipeline-history-time">
          ${new Date(entry.executedAt).toLocaleString()}
        </div>
        <div class="pipeline-history-stats">
          <span class="pipeline-history-stat">
            <i class="ph ph-rows"></i>
            ${entry.outputCount} records
          </span>
          ${entry.errors?.length > 0 ? `
            <span class="pipeline-history-stat" style="color: var(--error-color);">
              <i class="ph ph-warning"></i>
              ${entry.errors.length} errors
            </span>
          ` : ''}
        </div>
      </div>
    `).join('');

    this._showModal('Pipeline History', `
      <div class="pipeline-history">
        ${historyHtml}
      </div>
    `, null, { hideFooter: true });
  }
}

// ============================================================================
// Initialization
// ============================================================================

let _workbench = null;

async function initDataWorkbench(container = 'content-area', eoApp = null) {
  _workbench = new EODataWorkbench(container);
  // Wait for data to load from IndexedDB before rendering (EO: GIVEN before MEANT)
  await _workbench.init(eoApp);
  // Expose workbench instance globally for onclick handlers
  if (typeof window !== 'undefined') {
    window.eoWorkbench = _workbench;
  }
  // Hide loading state now that data is ready
  const loadingState = document.getElementById('app-loading-state');
  if (loadingState) {
    loadingState.classList.add('hidden');
  }
  return _workbench;
}

function getDataWorkbench() {
  return _workbench;
}

// Debug helper function to reset demo data
function resetDemoData() {
  console.log('[Debug] Clearing localStorage and reloading...');
  localStorage.removeItem('eo_lake_data');
  console.log('[Debug] LocalStorage cleared. Refreshing page to recreate demo data...');
  window.location.reload();
}

// Debug helper function to diagnose demo data issues
function debugDemoData() {
  const data = localStorage.getItem('eo_lake_data');
  if (!data) {
    console.log('[Debug] No data in localStorage');
    return;
  }

  const parsed = JSON.parse(data);
  const myDataSet = parsed.sets?.find(s => s.name === 'My Data');

  if (!myDataSet) {
    console.log('[Debug] No "My Data" set found');
    return;
  }

  console.log('[Debug] === DEMO DATA STRUCTURE ===');
  console.log('[Debug] Fields:');
  myDataSet.fields.forEach((f, i) => {
    console.log(`  [${i}] id: ${f.id}, name: ${f.name}, type: ${f.type}`);
    if (f.options?.choices) {
      console.log(`      choices: ${f.options.choices.map(c => `${c.name}(${c.id})`).join(', ')}`);
    }
  });

  console.log('[Debug] Records (first 2):');
  myDataSet.records.slice(0, 2).forEach((r, i) => {
    console.log(`  Record ${i + 1}:`);
    Object.entries(r.values).forEach(([fieldId, value]) => {
      const field = myDataSet.fields.find(f => f.id === fieldId);
      console.log(`    ${field?.name || 'UNKNOWN'} (${fieldId}): ${JSON.stringify(value)}`);
    });
  });

  // Check for field ID mismatches
  console.log('[Debug] Field ID consistency check:');
  const fieldIds = new Set(myDataSet.fields.map(f => f.id));
  const recordKeys = new Set();
  myDataSet.records.forEach(r => {
    Object.keys(r.values).forEach(k => recordKeys.add(k));
  });

  const unmatchedFieldIds = [...fieldIds].filter(id => !recordKeys.has(id));
  const unmatchedRecordKeys = [...recordKeys].filter(id => !fieldIds.has(id));

  if (unmatchedFieldIds.length > 0) {
    console.warn('[Debug] Field IDs with no record values:', unmatchedFieldIds);
  }
  if (unmatchedRecordKeys.length > 0) {
    console.warn('[Debug] Record keys with no matching field:', unmatchedRecordKeys);
  }

  return { set: myDataSet, fieldIds, recordKeys, unmatchedFieldIds, unmatchedRecordKeys };
}

// Global exports
if (typeof window !== 'undefined') {
  window.debugDemoData = debugDemoData;
  window.resetDemoData = resetDemoData;
  window.FieldTypes = FieldTypes;
  window.createSet = createSet;
  window.createField = createField;
  window.createView = createView;
  window.createRecord = createRecord;
  // Table rendering utilities (TABLE RULES enforcement)
  window.ensureValidField = ensureValidField;
  window.ensureValidFields = ensureValidFields;
  window.ensureRecordValues = ensureRecordValues;
  // TABLE RULE 5: Field ID consistency validation and repair
  window.validateFieldIdConsistency = validateFieldIdConsistency;
  window.repairFieldIdConsistency = repairFieldIdConsistency;
  window.FIELD_MIN_WIDTH = FIELD_MIN_WIDTH;
  window.FIELD_DEFAULT_WIDTH = FIELD_DEFAULT_WIDTH;
  window.EODataWorkbench = EODataWorkbench;
  window.initDataWorkbench = initDataWorkbench;
  window.getDataWorkbench = getDataWorkbench;
}

// Module exports
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    FieldTypes,
    createSet,
    createField,
    createView,
    createRecord,
    ensureValidField,
    ensureValidFields,
    ensureRecordValues,
    FIELD_MIN_WIDTH,
    FIELD_DEFAULT_WIDTH,
    EODataWorkbench,
    initDataWorkbench,
    getDataWorkbench
  };
}
